#!/usr/bin/python3 -i
#
# Copyright (c) 2015-2023 The Khronos Group Inc.
# Copyright (c) 2015-2023 Valve Corporation
# Copyright (c) 2015-2023 LunarG, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys,os
from generator import *
from common_codegen import *
from generators.base_generator import BaseGenerator

#
# BestPracticesOutputGenerator(errFile, warnFile, diagFile)
class BestPracticesOutputGenerator(BaseGenerator):
    def __init__(self,
                 errFile = sys.stderr,
                 warnFile = sys.stderr,
                 diagFile = sys.stdout):
        BaseGenerator.__init__(self, errFile, warnFile, diagFile)
        # Commands which are not autogenerated but still intercepted
        self.no_autogen_list = [
            'vkEnumerateInstanceVersion',
            'vkCreateValidationCacheEXT',
            'vkDestroyValidationCacheEXT',
            'vkMergeValidationCachesEXT',
            'vkGetValidationCacheDataEXT',
            ]
        # Commands that require an extra parameter for state sharing between validate/record steps
        self.extra_parameter_list = [
            "vkCreateShaderModule",
            "vkCreateGraphicsPipelines",
            "vkCreateComputePipelines",
            "vkAllocateDescriptorSets",
            "vkCreateRayTracingPipelinesNV",
            "vkCreateRayTracingPipelinesKHR",
            ]
        # Commands that have a manually written post-call-record step which needs to be called from the autogen'd fcn
        self.manual_postcallrecord_list = [
            'vkAllocateDescriptorSets',
            'vkQueuePresentKHR',
            'vkQueueBindSparse',
            'vkCreateGraphicsPipelines',
            'vkGetPhysicalDeviceSurfaceCapabilitiesKHR',
            'vkGetPhysicalDeviceSurfaceCapabilities2KHR',
            'vkGetPhysicalDeviceSurfaceCapabilities2EXT',
            'vkGetPhysicalDeviceSurfacePresentModesKHR',
            'vkGetPhysicalDeviceSurfaceFormatsKHR',
            'vkGetPhysicalDeviceSurfaceFormats2KHR',
            'vkGetPhysicalDeviceDisplayPlanePropertiesKHR',
            'vkGetSwapchainImagesKHR',
            # AMD tracked
            'vkCreateComputePipelines',
            'vkCmdPipelineBarrier',
            'vkQueueSubmit',
            ]

        self.extension_info = dict()
    #
    # Separate content for validation source and header files
    def otwrite(self, dest, formatstring):
        if 'best_practices.h' in self.filename and (dest == 'hdr' or dest == 'both'):
            write(formatstring, file=self.outFile)
        elif 'best_practices.cpp' in self.filename and (dest == 'cpp' or dest == 'both'):
            write(formatstring, file=self.outFile)

    #
    # Now that the data is all collected and complete, generate and output the object validation routines
    def endFile(self):
        # File Comment
        file_comment = '// *** THIS FILE IS GENERATED - DO NOT EDIT ***\n'
        file_comment += '// See {} for modifications\n'.format(os.path.basename(__file__))
        self.otwrite('both', file_comment)
        # Copyright Statement
        copyright = ''
        copyright += '\n'
        copyright += '/***************************************************************************\n'
        copyright += ' *\n'
        copyright += ' * Copyright (c) 2015-2023 The Khronos Group Inc.\n'
        copyright += ' * Copyright (c) 2015-2023 Valve Corporation\n'
        copyright += ' * Copyright (c) 2015-2023 LunarG, Inc.\n'
        copyright += ' *\n'
        copyright += ' * Licensed under the Apache License, Version 2.0 (the "License");\n'
        copyright += ' * you may not use this file except in compliance with the License.\n'
        copyright += ' * You may obtain a copy of the License at\n'
        copyright += ' *\n'
        copyright += ' *     http://www.apache.org/licenses/LICENSE-2.0\n'
        copyright += ' *\n'
        copyright += ' * Unless required by applicable law or agreed to in writing, software\n'
        copyright += ' * distributed under the License is distributed on an "AS IS" BASIS,\n'
        copyright += ' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n'
        copyright += ' * See the License for the specific language governing permissions and\n'
        copyright += ' * limitations under the License.\n'
        copyright += ' ****************************************************************************/\n'
        self.otwrite('both', copyright)
        self.newline()
        self.otwrite('cpp', '#include "chassis.h"')
        self.otwrite('cpp', '#include "best_practices/best_practices_validation.h"')

        self.BuildExtensionInfo()
        self.FunctionDeclaration()
        self.newline()
        # Actually write the interface to the output file.
        if (self.emit):
            self.newline()

            # Output data structure containing extension deprecation data
            ext_deprecation_data = 'const vvl::unordered_map<std::string, DeprecationData>  deprecated_extensions = {\n'
            for ext in sorted(self.extension_info):
                ext_data = self.extension_info[ext]
                reason = ext_data[0]
                target = ext_data[1]
                if reason is not None:
                    ext_deprecation_data += '    {"%s", {kExt%s, "%s"}},\n' % (ext, reason, target)
            ext_deprecation_data += '};\n'
            self.otwrite('hdr', ext_deprecation_data)

            # Output data structure containing extension special use data
            ext_specialuse_data = 'const vvl::unordered_map<std::string, std::string> special_use_extensions = {\n'
            for ext in sorted(self.extension_info):
                spec_use_data = self.extension_info[ext]
                special_uses = spec_use_data[2]
                if special_uses is not None:
                    special_uses = special_uses.replace(',', ', ')
                    ext_specialuse_data += '    {"%s", "%s"},\n' % (ext, special_uses)
            ext_specialuse_data += '};\n'
            self.otwrite('hdr', ext_specialuse_data)

        BaseGenerator.endFile(self)
    #
    # Processing point at beginning of each extension definition
    def BuildExtensionInfo(self):
        for feature in self.vk.features:
            reason = None
            target = None
            if feature.promotedTo is not None:
                reason = 'Promoted'
                target = feature.promotedTo
            elif feature.obsoletedBy is not None:
                reason = 'Obsoleted'
                target = feature.obsoletedBy
            elif feature.deprecatedBy is not None:
                reason = 'Deprecated'
                target = feature.deprecatedBy

            if reason is not None or feature.specialUse is not None:
                self.extension_info[feature.name] = [reason, target, feature.specialUse]

    #
    # command info needed to create, destroy, and validate objects
    def FunctionDeclaration(self):
        for name, command in self.vk.commands.items():
            intercept = ''
            if name in self.no_autogen_list:
                intercept += '// Skipping %s for autogen as it has a manually created custom function or ignored.\n' % name
                self.otwrite('cpp', intercept)
                continue
            pre_decl = command.cPrototype[:-1]
            pre_decl = pre_decl.split("VKAPI_CALL ")[1]
            pre_decl = pre_decl.replace(')', ',\n    VkResult                                    result)')
            if name in self.extra_parameter_list:
                pre_decl = pre_decl.replace(')', ',\n    void*                                       state_data)')
            pre_decl = pre_decl.replace(')', ') {\n')
            pre_decl = 'void BestPractices::PostCallRecord' + pre_decl[2:]
            type = command.cPrototype.split(' ')[1]
            if type == 'VkResult':
                success_codes = command.successcodes
                success_codes.remove('VK_SUCCESS') if 'VK_SUCCESS' in success_codes else None
                error_codes = command.errorcodes if command.errorcodes is not None else []
                # This function only returns VK_SUCCESS
                if len(error_codes) == 0 and len(success_codes) == 0:
                    continue
                if command.feature.protect is not None:
                    self.otwrite('both', '#ifdef %s\n' % command.feature.protect)
                func_decl = pre_decl.replace(' {',' override;\n');
                func_decl = func_decl.replace('BestPractices::', '')
                self.otwrite('hdr', func_decl)
                intercept += pre_decl
                params_text = ''
                for param in command.params:
                    params_text += '%s, ' % param.name
                params_text = params_text + 'result, '
                if name in self.extra_parameter_list:
                    params_text += 'state_data, '
                params_text = params_text[:-2] + ');\n'
                intercept += '    ValidationStateTracker::PostCallRecord'+name[2:] + '(' + params_text
                if name in self.manual_postcallrecord_list:
                    intercept += '    ManualPostCallRecord'+name[2:] + '(' + params_text

                if len(success_codes) > 0:
                    success_codes = ','.join(success_codes)
                    intercept +=  '    if (result > VK_SUCCESS) {\n'
                    intercept += f'        LogPositiveSuccessCode("{name}", result); // {success_codes}\n'
                    intercept +=  '        return;\n'
                    intercept +=  '    }\n'

                if len(error_codes) > 0:
                    error_codes = ','.join(error_codes)
                    intercept +=  '    if (result < VK_SUCCESS) {\n'
                    intercept += f'        LogErrorCode("{name}", result); // {error_codes}\n'
                    intercept +=  '    }\n'

                intercept += '}\n'
                self.otwrite('cpp', intercept)
                if command.feature.protect is not None:
                    self.otwrite('both', '#endif // %s\n' % command.feature.protect)
