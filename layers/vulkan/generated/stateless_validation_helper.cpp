// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See stateless_validation_helper_generator.py for modifications

/***************************************************************************
*
* Copyright (c) 2015-2023 The Khronos Group Inc.
* Copyright (c) 2015-2023 Valve Corporation
* Copyright (c) 2015-2023 LunarG, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
****************************************************************************/

// NOLINTBEGIN

#include "chassis.h"

#include "stateless/stateless_validation.h"
#include "enum_flag_bits.h"

#include <vulkan/layer/vk_layer_settings_ext.h>

bool StatelessValidation::ValidatePnextStructContents(const Location& loc, const ParameterName &parameter_name,
                                                      const VkBaseOutStructure* header, const char *pnext_vuid,
                                                      bool is_physdev_api, bool is_const_param) const {
    bool skip = false;
    switch(header->sType) {

        // Validation code for VkShaderModuleCreateInfo structure members
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: { // Covers VUID-VkShaderModuleCreateInfo-sType-sType
            if (is_const_param) {
                VkShaderModuleCreateInfo *structure = (VkShaderModuleCreateInfo *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

                skip |= ValidateArray(loc, "codeSize / 4", "pCode", structure->codeSize / 4, &structure->pCode, true, true, kVUIDUndefined, "VUID-VkShaderModuleCreateInfo-pCode-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceSubgroupProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: { // Covers VUID-VkPhysicalDeviceSubgroupProperties-sType-sType
            if (api_version < VK_API_VERSION_1_1) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES) which was added in VK_API_VERSION_1_1 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
        } break;

        // Validation code for VkPhysicalDevice16BitStorageFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: { // Covers VUID-VkPhysicalDevice16BitStorageFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_16BIT_STORAGE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_16bit_storage))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES), but its parent extension "
                               "VK_KHR_16bit_storage has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDevice16BitStorageFeatures *structure = (VkPhysicalDevice16BitStorageFeatures *) header;
                skip |= ValidateBool32(loc, "storageBuffer16BitAccess", structure->storageBuffer16BitAccess);

                skip |= ValidateBool32(loc, "uniformAndStorageBuffer16BitAccess", structure->uniformAndStorageBuffer16BitAccess);

                skip |= ValidateBool32(loc, "storagePushConstant16", structure->storagePushConstant16);

                skip |= ValidateBool32(loc, "storageInputOutput16", structure->storageInputOutput16);
            }
        } break;

        // Validation code for VkMemoryDedicatedRequirements structure members
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: { // Covers VUID-VkMemoryDedicatedRequirements-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dedicated_allocation))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS), but its parent extension "
                               "VK_KHR_dedicated_allocation has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkMemoryDedicatedAllocateInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: { // Covers VUID-VkMemoryDedicatedAllocateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dedicated_allocation))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO), but its parent extension "
                               "VK_KHR_dedicated_allocation has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkMemoryAllocateFlagsInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: { // Covers VUID-VkMemoryAllocateFlagsInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkMemoryAllocateFlagsInfo *structure = (VkMemoryAllocateFlagsInfo *) header;
                skip |= ValidateFlags(loc, "flags", "VkMemoryAllocateFlagBits", AllVkMemoryAllocateFlagBits, structure->flags, kOptionalFlags, "VUID-VkMemoryAllocateFlagsInfo-flags-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupRenderPassBeginInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: { // Covers VUID-VkDeviceGroupRenderPassBeginInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkDeviceGroupRenderPassBeginInfo *structure = (VkDeviceGroupRenderPassBeginInfo *) header;
                skip |= ValidateArray(loc, "deviceRenderAreaCount", "pDeviceRenderAreas", structure->deviceRenderAreaCount, &structure->pDeviceRenderAreas, false, true, kVUIDUndefined, "VUID-VkDeviceGroupRenderPassBeginInfo-pDeviceRenderAreas-parameter");

                if (structure->pDeviceRenderAreas != nullptr)
                {
                    for (uint32_t deviceRenderAreaIndex = 0; deviceRenderAreaIndex < structure->deviceRenderAreaCount; ++deviceRenderAreaIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkDeviceGroupCommandBufferBeginInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: { // Covers VUID-VkDeviceGroupCommandBufferBeginInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkDeviceGroupSubmitInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: { // Covers VUID-VkDeviceGroupSubmitInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkDeviceGroupSubmitInfo *structure = (VkDeviceGroupSubmitInfo *) header;
                skip |= ValidateArray(loc, "waitSemaphoreCount", "pWaitSemaphoreDeviceIndices", structure->waitSemaphoreCount, &structure->pWaitSemaphoreDeviceIndices, false, true, kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-parameter");

                skip |= ValidateArray(loc, "commandBufferCount", "pCommandBufferDeviceMasks", structure->commandBufferCount, &structure->pCommandBufferDeviceMasks, false, true, kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-parameter");

                skip |= ValidateArray(loc, "signalSemaphoreCount", "pSignalSemaphoreDeviceIndices", structure->signalSemaphoreCount, &structure->pSignalSemaphoreDeviceIndices, false, true, kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pSignalSemaphoreDeviceIndices-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupBindSparseInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: { // Covers VUID-VkDeviceGroupBindSparseInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkBindBufferMemoryDeviceGroupInfo structure members
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: { // Covers VUID-VkBindBufferMemoryDeviceGroupInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkBindBufferMemoryDeviceGroupInfo *structure = (VkBindBufferMemoryDeviceGroupInfo *) header;
                skip |= ValidateArray(loc, "deviceIndexCount", "pDeviceIndices", structure->deviceIndexCount, &structure->pDeviceIndices, false, true, kVUIDUndefined, "VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-parameter");
            }
        } break;

        // Validation code for VkBindImageMemoryDeviceGroupInfo structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: { // Covers VUID-VkBindImageMemoryDeviceGroupInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEVICE_GROUP_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO), but its parent extension "
                               "VK_KHR_device_group has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkBindImageMemoryDeviceGroupInfo *structure = (VkBindImageMemoryDeviceGroupInfo *) header;
                skip |= ValidateArray(loc, "deviceIndexCount", "pDeviceIndices", structure->deviceIndexCount, &structure->pDeviceIndices, false, true, kVUIDUndefined, "VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-parameter");

                skip |= ValidateArray(loc, "splitInstanceBindRegionCount", "pSplitInstanceBindRegions", structure->splitInstanceBindRegionCount, &structure->pSplitInstanceBindRegions, false, true, kVUIDUndefined, "VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-parameter");

                if (structure->pSplitInstanceBindRegions != nullptr)
                {
                    for (uint32_t splitInstanceBindRegionIndex = 0; splitInstanceBindRegionIndex < structure->splitInstanceBindRegionCount; ++splitInstanceBindRegionIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkDeviceGroupDeviceCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: { // Covers VUID-VkDeviceGroupDeviceCreateInfo-sType-sType
            if (is_const_param) {
                if (!instance_extensions.vk_khr_device_group_creation) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO), but its parent extension "
                               "VK_KHR_device_group_creation has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkDeviceGroupDeviceCreateInfo *structure = (VkDeviceGroupDeviceCreateInfo *) header;
                skip |= ValidateArray(loc, "physicalDeviceCount", "pPhysicalDevices", structure->physicalDeviceCount, &structure->pPhysicalDevices, false, true, kVUIDUndefined, "VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceFeatures2 structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: { // Covers VUID-VkPhysicalDeviceFeatures2-sType-sType
            if (is_const_param) {
                if (!instance_extensions.vk_khr_get_physical_device_properties2) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2), but its parent extension "
                               "VK_KHR_get_physical_device_properties2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceFeatures2 *structure = (VkPhysicalDeviceFeatures2 *) header;
                skip |= ValidateBool32(loc, "features.robustBufferAccess", structure->features.robustBufferAccess);

                skip |= ValidateBool32(loc, "features.fullDrawIndexUint32", structure->features.fullDrawIndexUint32);

                skip |= ValidateBool32(loc, "features.imageCubeArray", structure->features.imageCubeArray);

                skip |= ValidateBool32(loc, "features.independentBlend", structure->features.independentBlend);

                skip |= ValidateBool32(loc, "features.geometryShader", structure->features.geometryShader);

                skip |= ValidateBool32(loc, "features.tessellationShader", structure->features.tessellationShader);

                skip |= ValidateBool32(loc, "features.sampleRateShading", structure->features.sampleRateShading);

                skip |= ValidateBool32(loc, "features.dualSrcBlend", structure->features.dualSrcBlend);

                skip |= ValidateBool32(loc, "features.logicOp", structure->features.logicOp);

                skip |= ValidateBool32(loc, "features.multiDrawIndirect", structure->features.multiDrawIndirect);

                skip |= ValidateBool32(loc, "features.drawIndirectFirstInstance", structure->features.drawIndirectFirstInstance);

                skip |= ValidateBool32(loc, "features.depthClamp", structure->features.depthClamp);

                skip |= ValidateBool32(loc, "features.depthBiasClamp", structure->features.depthBiasClamp);

                skip |= ValidateBool32(loc, "features.fillModeNonSolid", structure->features.fillModeNonSolid);

                skip |= ValidateBool32(loc, "features.depthBounds", structure->features.depthBounds);

                skip |= ValidateBool32(loc, "features.wideLines", structure->features.wideLines);

                skip |= ValidateBool32(loc, "features.largePoints", structure->features.largePoints);

                skip |= ValidateBool32(loc, "features.alphaToOne", structure->features.alphaToOne);

                skip |= ValidateBool32(loc, "features.multiViewport", structure->features.multiViewport);

                skip |= ValidateBool32(loc, "features.samplerAnisotropy", structure->features.samplerAnisotropy);

                skip |= ValidateBool32(loc, "features.textureCompressionETC2", structure->features.textureCompressionETC2);

                skip |= ValidateBool32(loc, "features.textureCompressionASTC_LDR", structure->features.textureCompressionASTC_LDR);

                skip |= ValidateBool32(loc, "features.textureCompressionBC", structure->features.textureCompressionBC);

                skip |= ValidateBool32(loc, "features.occlusionQueryPrecise", structure->features.occlusionQueryPrecise);

                skip |= ValidateBool32(loc, "features.pipelineStatisticsQuery", structure->features.pipelineStatisticsQuery);

                skip |= ValidateBool32(loc, "features.vertexPipelineStoresAndAtomics", structure->features.vertexPipelineStoresAndAtomics);

                skip |= ValidateBool32(loc, "features.fragmentStoresAndAtomics", structure->features.fragmentStoresAndAtomics);

                skip |= ValidateBool32(loc, "features.shaderTessellationAndGeometryPointSize", structure->features.shaderTessellationAndGeometryPointSize);

                skip |= ValidateBool32(loc, "features.shaderImageGatherExtended", structure->features.shaderImageGatherExtended);

                skip |= ValidateBool32(loc, "features.shaderStorageImageExtendedFormats", structure->features.shaderStorageImageExtendedFormats);

                skip |= ValidateBool32(loc, "features.shaderStorageImageMultisample", structure->features.shaderStorageImageMultisample);

                skip |= ValidateBool32(loc, "features.shaderStorageImageReadWithoutFormat", structure->features.shaderStorageImageReadWithoutFormat);

                skip |= ValidateBool32(loc, "features.shaderStorageImageWriteWithoutFormat", structure->features.shaderStorageImageWriteWithoutFormat);

                skip |= ValidateBool32(loc, "features.shaderUniformBufferArrayDynamicIndexing", structure->features.shaderUniformBufferArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "features.shaderSampledImageArrayDynamicIndexing", structure->features.shaderSampledImageArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "features.shaderStorageBufferArrayDynamicIndexing", structure->features.shaderStorageBufferArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "features.shaderStorageImageArrayDynamicIndexing", structure->features.shaderStorageImageArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "features.shaderClipDistance", structure->features.shaderClipDistance);

                skip |= ValidateBool32(loc, "features.shaderCullDistance", structure->features.shaderCullDistance);

                skip |= ValidateBool32(loc, "features.shaderFloat64", structure->features.shaderFloat64);

                skip |= ValidateBool32(loc, "features.shaderInt64", structure->features.shaderInt64);

                skip |= ValidateBool32(loc, "features.shaderInt16", structure->features.shaderInt16);

                skip |= ValidateBool32(loc, "features.shaderResourceResidency", structure->features.shaderResourceResidency);

                skip |= ValidateBool32(loc, "features.shaderResourceMinLod", structure->features.shaderResourceMinLod);

                skip |= ValidateBool32(loc, "features.sparseBinding", structure->features.sparseBinding);

                skip |= ValidateBool32(loc, "features.sparseResidencyBuffer", structure->features.sparseResidencyBuffer);

                skip |= ValidateBool32(loc, "features.sparseResidencyImage2D", structure->features.sparseResidencyImage2D);

                skip |= ValidateBool32(loc, "features.sparseResidencyImage3D", structure->features.sparseResidencyImage3D);

                skip |= ValidateBool32(loc, "features.sparseResidency2Samples", structure->features.sparseResidency2Samples);

                skip |= ValidateBool32(loc, "features.sparseResidency4Samples", structure->features.sparseResidency4Samples);

                skip |= ValidateBool32(loc, "features.sparseResidency8Samples", structure->features.sparseResidency8Samples);

                skip |= ValidateBool32(loc, "features.sparseResidency16Samples", structure->features.sparseResidency16Samples);

                skip |= ValidateBool32(loc, "features.sparseResidencyAliased", structure->features.sparseResidencyAliased);

                skip |= ValidateBool32(loc, "features.variableMultisampleRate", structure->features.variableMultisampleRate);

                skip |= ValidateBool32(loc, "features.inheritedQueries", structure->features.inheritedQueries);
            }
        } break;

        // Validation code for VkPhysicalDevicePointClippingProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: { // Covers VUID-VkPhysicalDevicePointClippingProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES), but its parent extension "
                               "VK_KHR_maintenance2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkRenderPassInputAttachmentAspectCreateInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: { // Covers VUID-VkRenderPassInputAttachmentAspectCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO), but its parent extension "
                               "VK_KHR_maintenance2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkRenderPassInputAttachmentAspectCreateInfo *structure = (VkRenderPassInputAttachmentAspectCreateInfo *) header;
                skip |= ValidateArray(loc, "aspectReferenceCount", "pAspectReferences", structure->aspectReferenceCount, &structure->pAspectReferences, true, true, "VUID-VkRenderPassInputAttachmentAspectCreateInfo-aspectReferenceCount-arraylength", "VUID-VkRenderPassInputAttachmentAspectCreateInfo-pAspectReferences-parameter");

                if (structure->pAspectReferences != nullptr)
                {
                    for (uint32_t aspectReferenceIndex = 0; aspectReferenceIndex < structure->aspectReferenceCount; ++aspectReferenceIndex)
                    {
                        skip |= ValidateFlags(loc, ParameterName("pAspectReferences[%i].aspectMask", ParameterName::IndexVector{ aspectReferenceIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, structure->pAspectReferences[aspectReferenceIndex].aspectMask, kRequiredFlags, "VUID-VkInputAttachmentAspectReference-aspectMask-parameter", "VUID-VkInputAttachmentAspectReference-aspectMask-requiredbitmask");
                    }
                }
            }
        } break;

        // Validation code for VkImageViewUsageCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: { // Covers VUID-VkImageViewUsageCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO), but its parent extension "
                               "VK_KHR_maintenance2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkImageViewUsageCreateInfo *structure = (VkImageViewUsageCreateInfo *) header;
                skip |= ValidateFlags(loc, "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, structure->usage, kRequiredFlags, "VUID-VkImageViewUsageCreateInfo-usage-parameter", "VUID-VkImageViewUsageCreateInfo-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkPipelineTessellationDomainOriginStateCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: { // Covers VUID-VkPipelineTessellationDomainOriginStateCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO), but its parent extension "
                               "VK_KHR_maintenance2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPipelineTessellationDomainOriginStateCreateInfo *structure = (VkPipelineTessellationDomainOriginStateCreateInfo *) header;
                skip |= ValidateRangedEnum(loc, "domainOrigin", "VkTessellationDomainOrigin", structure->domainOrigin, "VUID-VkPipelineTessellationDomainOriginStateCreateInfo-domainOrigin-parameter");
            }
        } break;

        // Validation code for VkRenderPassMultiviewCreateInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: { // Covers VUID-VkRenderPassMultiviewCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MULTIVIEW_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_multiview))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO), but its parent extension "
                               "VK_KHR_multiview has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkRenderPassMultiviewCreateInfo *structure = (VkRenderPassMultiviewCreateInfo *) header;
                skip |= ValidateArray(loc, "subpassCount", "pViewMasks", structure->subpassCount, &structure->pViewMasks, false, true, kVUIDUndefined, "VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-parameter");

                skip |= ValidateArray(loc, "dependencyCount", "pViewOffsets", structure->dependencyCount, &structure->pViewOffsets, false, true, kVUIDUndefined, "VUID-VkRenderPassMultiviewCreateInfo-pViewOffsets-parameter");

                skip |= ValidateArray(loc, "correlationMaskCount", "pCorrelationMasks", structure->correlationMaskCount, &structure->pCorrelationMasks, false, true, kVUIDUndefined, "VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: { // Covers VUID-VkPhysicalDeviceMultiviewFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MULTIVIEW_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_multiview))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES), but its parent extension "
                               "VK_KHR_multiview has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceMultiviewFeatures *structure = (VkPhysicalDeviceMultiviewFeatures *) header;
                skip |= ValidateBool32(loc, "multiview", structure->multiview);

                skip |= ValidateBool32(loc, "multiviewGeometryShader", structure->multiviewGeometryShader);

                skip |= ValidateBool32(loc, "multiviewTessellationShader", structure->multiviewTessellationShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: { // Covers VUID-VkPhysicalDeviceMultiviewProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MULTIVIEW_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_multiview))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES), but its parent extension "
                               "VK_KHR_multiview has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceVariablePointersFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: { // Covers VUID-VkPhysicalDeviceVariablePointersFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_variable_pointers))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES), but its parent extension "
                               "VK_KHR_variable_pointers has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceVariablePointersFeatures *structure = (VkPhysicalDeviceVariablePointersFeatures *) header;
                skip |= ValidateBool32(loc, "variablePointersStorageBuffer", structure->variablePointersStorageBuffer);

                skip |= ValidateBool32(loc, "variablePointers", structure->variablePointers);
            }
        } break;

        // Validation code for VkPhysicalDeviceProtectedMemoryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: { // Covers VUID-VkPhysicalDeviceProtectedMemoryFeatures-sType-sType
            if (api_version < VK_API_VERSION_1_1) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES) which was added in VK_API_VERSION_1_1 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
            if (is_const_param) {
                VkPhysicalDeviceProtectedMemoryFeatures *structure = (VkPhysicalDeviceProtectedMemoryFeatures *) header;
                skip |= ValidateBool32(loc, "protectedMemory", structure->protectedMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceProtectedMemoryProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: { // Covers VUID-VkPhysicalDeviceProtectedMemoryProperties-sType-sType
            if (api_version < VK_API_VERSION_1_1) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES) which was added in VK_API_VERSION_1_1 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
        } break;

        // Validation code for VkProtectedSubmitInfo structure members
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: { // Covers VUID-VkProtectedSubmitInfo-sType-sType
            if (api_version < VK_API_VERSION_1_1) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO) which was added in VK_API_VERSION_1_1 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
            if (is_const_param) {
                VkProtectedSubmitInfo *structure = (VkProtectedSubmitInfo *) header;
                skip |= ValidateBool32(loc, "protectedSubmit", structure->protectedSubmit);
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionInfo structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: { // Covers VUID-VkSamplerYcbcrConversionInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO), but its parent extension "
                               "VK_KHR_sampler_ycbcr_conversion has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkSamplerYcbcrConversionInfo *structure = (VkSamplerYcbcrConversionInfo *) header;
                skip |= ValidateRequiredHandle(loc, "conversion", structure->conversion);
            }
        } break;

        // Validation code for VkBindImagePlaneMemoryInfo structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: { // Covers VUID-VkBindImagePlaneMemoryInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO), but its parent extension "
                               "VK_KHR_sampler_ycbcr_conversion has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkBindImagePlaneMemoryInfo *structure = (VkBindImagePlaneMemoryInfo *) header;
                skip |= ValidateFlags(loc, "planeAspect", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, structure->planeAspect, kRequiredSingleBit, "VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter", "VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter");
            }
        } break;

        // Validation code for VkImagePlaneMemoryRequirementsInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: { // Covers VUID-VkImagePlaneMemoryRequirementsInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO), but its parent extension "
                               "VK_KHR_sampler_ycbcr_conversion has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkImagePlaneMemoryRequirementsInfo *structure = (VkImagePlaneMemoryRequirementsInfo *) header;
                skip |= ValidateFlags(loc, "planeAspect", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, structure->planeAspect, kRequiredSingleBit, "VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter", "VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceSamplerYcbcrConversionFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: { // Covers VUID-VkPhysicalDeviceSamplerYcbcrConversionFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES), but its parent extension "
                               "VK_KHR_sampler_ycbcr_conversion has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceSamplerYcbcrConversionFeatures *structure = (VkPhysicalDeviceSamplerYcbcrConversionFeatures *) header;
                skip |= ValidateBool32(loc, "samplerYcbcrConversion", structure->samplerYcbcrConversion);
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionImageFormatProperties structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: { // Covers VUID-VkSamplerYcbcrConversionImageFormatProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES), but its parent extension "
                               "VK_KHR_sampler_ycbcr_conversion has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceExternalImageFormatInfo structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: { // Covers VUID-VkPhysicalDeviceExternalImageFormatInfo-sType-sType
            if (is_const_param) {
                if (!instance_extensions.vk_khr_external_memory_capabilities) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO), but its parent extension "
                               "VK_KHR_external_memory_capabilities has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceExternalImageFormatInfo *structure = (VkPhysicalDeviceExternalImageFormatInfo *) header;
                skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit, "VUID-VkPhysicalDeviceExternalImageFormatInfo-handleType-parameter");
            }
        } break;

        // Validation code for VkExternalImageFormatProperties structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: { // Covers VUID-VkExternalImageFormatProperties-sType-sType
            if (is_const_param) {
                if (!instance_extensions.vk_khr_external_memory_capabilities) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES), but its parent extension "
                               "VK_KHR_external_memory_capabilities has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceIDProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: { // Covers VUID-VkPhysicalDeviceIDProperties-sType-sType
            if (is_const_param) {
                if (!instance_extensions.vk_khr_external_fence_capabilities) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES), but its parent extension "
                               "VK_KHR_external_fence_capabilities has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkExternalMemoryImageCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: { // Covers VUID-VkExternalMemoryImageCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_memory))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO), but its parent extension "
                               "VK_KHR_external_memory has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkExternalMemoryImageCreateInfo *structure = (VkExternalMemoryImageCreateInfo *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, "VUID-VkExternalMemoryImageCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExternalMemoryBufferCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: { // Covers VUID-VkExternalMemoryBufferCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_memory))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO), but its parent extension "
                               "VK_KHR_external_memory has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkExternalMemoryBufferCreateInfo *structure = (VkExternalMemoryBufferCreateInfo *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, "VUID-VkExternalMemoryBufferCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportMemoryAllocateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: { // Covers VUID-VkExportMemoryAllocateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_memory))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO), but its parent extension "
                               "VK_KHR_external_memory has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkExportMemoryAllocateInfo *structure = (VkExportMemoryAllocateInfo *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, "VUID-VkExportMemoryAllocateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportFenceCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: { // Covers VUID-VkExportFenceCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_fence))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO), but its parent extension "
                               "VK_KHR_external_fence has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkExportFenceCreateInfo *structure = (VkExportFenceCreateInfo *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalFenceHandleTypeFlagBits", AllVkExternalFenceHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, "VUID-VkExportFenceCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportSemaphoreCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: { // Covers VUID-VkExportSemaphoreCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_semaphore))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO), but its parent extension "
                               "VK_KHR_external_semaphore has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkExportSemaphoreCreateInfo *structure = (VkExportSemaphoreCreateInfo *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, "VUID-VkExportSemaphoreCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance3Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: { // Covers VUID-VkPhysicalDeviceMaintenance3Properties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_3_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance3))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES), but its parent extension "
                               "VK_KHR_maintenance3 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderDrawParametersFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderDrawParametersFeatures-sType-sType
            if (api_version < VK_API_VERSION_1_1) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES) which was added in VK_API_VERSION_1_1 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
            if (is_const_param) {
                VkPhysicalDeviceShaderDrawParametersFeatures *structure = (VkPhysicalDeviceShaderDrawParametersFeatures *) header;
                skip |= ValidateBool32(loc, "shaderDrawParameters", structure->shaderDrawParameters);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan11Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: { // Covers VUID-VkPhysicalDeviceVulkan11Features-sType-sType
            if (api_version < VK_API_VERSION_1_2) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES) which was added in VK_API_VERSION_1_2 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
            if (is_const_param) {
                VkPhysicalDeviceVulkan11Features *structure = (VkPhysicalDeviceVulkan11Features *) header;
                skip |= ValidateBool32(loc, "storageBuffer16BitAccess", structure->storageBuffer16BitAccess);

                skip |= ValidateBool32(loc, "uniformAndStorageBuffer16BitAccess", structure->uniformAndStorageBuffer16BitAccess);

                skip |= ValidateBool32(loc, "storagePushConstant16", structure->storagePushConstant16);

                skip |= ValidateBool32(loc, "storageInputOutput16", structure->storageInputOutput16);

                skip |= ValidateBool32(loc, "multiview", structure->multiview);

                skip |= ValidateBool32(loc, "multiviewGeometryShader", structure->multiviewGeometryShader);

                skip |= ValidateBool32(loc, "multiviewTessellationShader", structure->multiviewTessellationShader);

                skip |= ValidateBool32(loc, "variablePointersStorageBuffer", structure->variablePointersStorageBuffer);

                skip |= ValidateBool32(loc, "variablePointers", structure->variablePointers);

                skip |= ValidateBool32(loc, "protectedMemory", structure->protectedMemory);

                skip |= ValidateBool32(loc, "samplerYcbcrConversion", structure->samplerYcbcrConversion);

                skip |= ValidateBool32(loc, "shaderDrawParameters", structure->shaderDrawParameters);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan11Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: { // Covers VUID-VkPhysicalDeviceVulkan11Properties-sType-sType
            if (api_version < VK_API_VERSION_1_2) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES) which was added in VK_API_VERSION_1_2 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan12Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: { // Covers VUID-VkPhysicalDeviceVulkan12Features-sType-sType
            if (api_version < VK_API_VERSION_1_2) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES) which was added in VK_API_VERSION_1_2 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
            if (is_const_param) {
                VkPhysicalDeviceVulkan12Features *structure = (VkPhysicalDeviceVulkan12Features *) header;
                skip |= ValidateBool32(loc, "samplerMirrorClampToEdge", structure->samplerMirrorClampToEdge);

                skip |= ValidateBool32(loc, "drawIndirectCount", structure->drawIndirectCount);

                skip |= ValidateBool32(loc, "storageBuffer8BitAccess", structure->storageBuffer8BitAccess);

                skip |= ValidateBool32(loc, "uniformAndStorageBuffer8BitAccess", structure->uniformAndStorageBuffer8BitAccess);

                skip |= ValidateBool32(loc, "storagePushConstant8", structure->storagePushConstant8);

                skip |= ValidateBool32(loc, "shaderBufferInt64Atomics", structure->shaderBufferInt64Atomics);

                skip |= ValidateBool32(loc, "shaderSharedInt64Atomics", structure->shaderSharedInt64Atomics);

                skip |= ValidateBool32(loc, "shaderFloat16", structure->shaderFloat16);

                skip |= ValidateBool32(loc, "shaderInt8", structure->shaderInt8);

                skip |= ValidateBool32(loc, "descriptorIndexing", structure->descriptorIndexing);

                skip |= ValidateBool32(loc, "shaderInputAttachmentArrayDynamicIndexing", structure->shaderInputAttachmentArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "shaderUniformTexelBufferArrayDynamicIndexing", structure->shaderUniformTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "shaderStorageTexelBufferArrayDynamicIndexing", structure->shaderStorageTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "shaderUniformBufferArrayNonUniformIndexing", structure->shaderUniformBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderSampledImageArrayNonUniformIndexing", structure->shaderSampledImageArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderStorageBufferArrayNonUniformIndexing", structure->shaderStorageBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderStorageImageArrayNonUniformIndexing", structure->shaderStorageImageArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderInputAttachmentArrayNonUniformIndexing", structure->shaderInputAttachmentArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderUniformTexelBufferArrayNonUniformIndexing", structure->shaderUniformTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderStorageTexelBufferArrayNonUniformIndexing", structure->shaderStorageTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "descriptorBindingUniformBufferUpdateAfterBind", structure->descriptorBindingUniformBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingSampledImageUpdateAfterBind", structure->descriptorBindingSampledImageUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingStorageImageUpdateAfterBind", structure->descriptorBindingStorageImageUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingStorageBufferUpdateAfterBind", structure->descriptorBindingStorageBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingUniformTexelBufferUpdateAfterBind", structure->descriptorBindingUniformTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingStorageTexelBufferUpdateAfterBind", structure->descriptorBindingStorageTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingUpdateUnusedWhilePending", structure->descriptorBindingUpdateUnusedWhilePending);

                skip |= ValidateBool32(loc, "descriptorBindingPartiallyBound", structure->descriptorBindingPartiallyBound);

                skip |= ValidateBool32(loc, "descriptorBindingVariableDescriptorCount", structure->descriptorBindingVariableDescriptorCount);

                skip |= ValidateBool32(loc, "runtimeDescriptorArray", structure->runtimeDescriptorArray);

                skip |= ValidateBool32(loc, "samplerFilterMinmax", structure->samplerFilterMinmax);

                skip |= ValidateBool32(loc, "scalarBlockLayout", structure->scalarBlockLayout);

                skip |= ValidateBool32(loc, "imagelessFramebuffer", structure->imagelessFramebuffer);

                skip |= ValidateBool32(loc, "uniformBufferStandardLayout", structure->uniformBufferStandardLayout);

                skip |= ValidateBool32(loc, "shaderSubgroupExtendedTypes", structure->shaderSubgroupExtendedTypes);

                skip |= ValidateBool32(loc, "separateDepthStencilLayouts", structure->separateDepthStencilLayouts);

                skip |= ValidateBool32(loc, "hostQueryReset", structure->hostQueryReset);

                skip |= ValidateBool32(loc, "timelineSemaphore", structure->timelineSemaphore);

                skip |= ValidateBool32(loc, "bufferDeviceAddress", structure->bufferDeviceAddress);

                skip |= ValidateBool32(loc, "bufferDeviceAddressCaptureReplay", structure->bufferDeviceAddressCaptureReplay);

                skip |= ValidateBool32(loc, "bufferDeviceAddressMultiDevice", structure->bufferDeviceAddressMultiDevice);

                skip |= ValidateBool32(loc, "vulkanMemoryModel", structure->vulkanMemoryModel);

                skip |= ValidateBool32(loc, "vulkanMemoryModelDeviceScope", structure->vulkanMemoryModelDeviceScope);

                skip |= ValidateBool32(loc, "vulkanMemoryModelAvailabilityVisibilityChains", structure->vulkanMemoryModelAvailabilityVisibilityChains);

                skip |= ValidateBool32(loc, "shaderOutputViewportIndex", structure->shaderOutputViewportIndex);

                skip |= ValidateBool32(loc, "shaderOutputLayer", structure->shaderOutputLayer);

                skip |= ValidateBool32(loc, "subgroupBroadcastDynamicId", structure->subgroupBroadcastDynamicId);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan12Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: { // Covers VUID-VkPhysicalDeviceVulkan12Properties-sType-sType
            if (api_version < VK_API_VERSION_1_2) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES) which was added in VK_API_VERSION_1_2 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
        } break;

        // Validation code for VkImageFormatListCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: { // Covers VUID-VkImageFormatListCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_image_format_list))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO), but its parent extension "
                               "VK_KHR_image_format_list has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkImageFormatListCreateInfo *structure = (VkImageFormatListCreateInfo *) header;
                skip |= ValidateRangedEnumArray(loc, "viewFormatCount", "pViewFormats", "VkFormat", structure->viewFormatCount, structure->pViewFormats, false, true);
            }
        } break;

        // Validation code for VkPhysicalDevice8BitStorageFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: { // Covers VUID-VkPhysicalDevice8BitStorageFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_8BIT_STORAGE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_8bit_storage))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES), but its parent extension "
                               "VK_KHR_8bit_storage has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDevice8BitStorageFeatures *structure = (VkPhysicalDevice8BitStorageFeatures *) header;
                skip |= ValidateBool32(loc, "storageBuffer8BitAccess", structure->storageBuffer8BitAccess);

                skip |= ValidateBool32(loc, "uniformAndStorageBuffer8BitAccess", structure->uniformAndStorageBuffer8BitAccess);

                skip |= ValidateBool32(loc, "storagePushConstant8", structure->storagePushConstant8);
            }
        } break;

        // Validation code for VkPhysicalDeviceDriverProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: { // Covers VUID-VkPhysicalDeviceDriverProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_driver_properties))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES), but its parent extension "
                               "VK_KHR_driver_properties has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicInt64Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderAtomicInt64Features-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_atomic_int64))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES), but its parent extension "
                               "VK_KHR_shader_atomic_int64 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceShaderAtomicInt64Features *structure = (VkPhysicalDeviceShaderAtomicInt64Features *) header;
                skip |= ValidateBool32(loc, "shaderBufferInt64Atomics", structure->shaderBufferInt64Atomics);

                skip |= ValidateBool32(loc, "shaderSharedInt64Atomics", structure->shaderSharedInt64Atomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderFloat16Int8Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderFloat16Int8Features-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_float16_int8))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES), but its parent extension "
                               "VK_KHR_shader_float16_int8 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceShaderFloat16Int8Features *structure = (VkPhysicalDeviceShaderFloat16Int8Features *) header;
                skip |= ValidateBool32(loc, "shaderFloat16", structure->shaderFloat16);

                skip |= ValidateBool32(loc, "shaderInt8", structure->shaderInt8);
            }
        } break;

        // Validation code for VkPhysicalDeviceFloatControlsProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: { // Covers VUID-VkPhysicalDeviceFloatControlsProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_float_controls))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES), but its parent extension "
                               "VK_KHR_shader_float_controls has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkDescriptorSetLayoutBindingFlagsCreateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: { // Covers VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO), but its parent extension "
                               "VK_EXT_descriptor_indexing has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkDescriptorSetLayoutBindingFlagsCreateInfo *structure = (VkDescriptorSetLayoutBindingFlagsCreateInfo *) header;
                skip |= ValidateFlagsArray(loc, "bindingCount", "pBindingFlags", "VkDescriptorBindingFlagBits", AllVkDescriptorBindingFlagBits, structure->bindingCount, structure->pBindingFlags, false, "VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorIndexingFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: { // Covers VUID-VkPhysicalDeviceDescriptorIndexingFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES), but its parent extension "
                               "VK_EXT_descriptor_indexing has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceDescriptorIndexingFeatures *structure = (VkPhysicalDeviceDescriptorIndexingFeatures *) header;
                skip |= ValidateBool32(loc, "shaderInputAttachmentArrayDynamicIndexing", structure->shaderInputAttachmentArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "shaderUniformTexelBufferArrayDynamicIndexing", structure->shaderUniformTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "shaderStorageTexelBufferArrayDynamicIndexing", structure->shaderStorageTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(loc, "shaderUniformBufferArrayNonUniformIndexing", structure->shaderUniformBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderSampledImageArrayNonUniformIndexing", structure->shaderSampledImageArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderStorageBufferArrayNonUniformIndexing", structure->shaderStorageBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderStorageImageArrayNonUniformIndexing", structure->shaderStorageImageArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderInputAttachmentArrayNonUniformIndexing", structure->shaderInputAttachmentArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderUniformTexelBufferArrayNonUniformIndexing", structure->shaderUniformTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "shaderStorageTexelBufferArrayNonUniformIndexing", structure->shaderStorageTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(loc, "descriptorBindingUniformBufferUpdateAfterBind", structure->descriptorBindingUniformBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingSampledImageUpdateAfterBind", structure->descriptorBindingSampledImageUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingStorageImageUpdateAfterBind", structure->descriptorBindingStorageImageUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingStorageBufferUpdateAfterBind", structure->descriptorBindingStorageBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingUniformTexelBufferUpdateAfterBind", structure->descriptorBindingUniformTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingStorageTexelBufferUpdateAfterBind", structure->descriptorBindingStorageTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(loc, "descriptorBindingUpdateUnusedWhilePending", structure->descriptorBindingUpdateUnusedWhilePending);

                skip |= ValidateBool32(loc, "descriptorBindingPartiallyBound", structure->descriptorBindingPartiallyBound);

                skip |= ValidateBool32(loc, "descriptorBindingVariableDescriptorCount", structure->descriptorBindingVariableDescriptorCount);

                skip |= ValidateBool32(loc, "runtimeDescriptorArray", structure->runtimeDescriptorArray);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorIndexingProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: { // Covers VUID-VkPhysicalDeviceDescriptorIndexingProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES), but its parent extension "
                               "VK_EXT_descriptor_indexing has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkDescriptorSetVariableDescriptorCountAllocateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: { // Covers VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO), but its parent extension "
                               "VK_EXT_descriptor_indexing has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkDescriptorSetVariableDescriptorCountAllocateInfo *structure = (VkDescriptorSetVariableDescriptorCountAllocateInfo *) header;
                skip |= ValidateArray(loc, "descriptorSetCount", "pDescriptorCounts", structure->descriptorSetCount, &structure->pDescriptorCounts, false, true, kVUIDUndefined, "VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetVariableDescriptorCountLayoutSupport structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: { // Covers VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT), but its parent extension "
                               "VK_EXT_descriptor_indexing has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkSubpassDescriptionDepthStencilResolve structure members
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: { // Covers VUID-VkSubpassDescriptionDepthStencilResolve-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_depth_stencil_resolve))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE), but its parent extension "
                               "VK_KHR_depth_stencil_resolve has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkSubpassDescriptionDepthStencilResolve *structure = (VkSubpassDescriptionDepthStencilResolve *) header;
                skip |= ValidateStructType(loc, "pDepthStencilResolveAttachment", "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", structure->pDepthStencilResolveAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, "VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-parameter", "VUID-VkAttachmentReference2-sType-sType");

                if (structure->pDepthStencilResolveAttachment != nullptr)
                {
                    skip |= ValidateRangedEnum(loc, "pDepthStencilResolveAttachment->layout", "VkImageLayout", structure->pDepthStencilResolveAttachment->layout, "VUID-VkAttachmentReference2-layout-parameter");
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthStencilResolveProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: { // Covers VUID-VkPhysicalDeviceDepthStencilResolveProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_depth_stencil_resolve))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES), but its parent extension "
                               "VK_KHR_depth_stencil_resolve has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceScalarBlockLayoutFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: { // Covers VUID-VkPhysicalDeviceScalarBlockLayoutFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_scalar_block_layout))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES), but its parent extension "
                               "VK_EXT_scalar_block_layout has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceScalarBlockLayoutFeatures *structure = (VkPhysicalDeviceScalarBlockLayoutFeatures *) header;
                skip |= ValidateBool32(loc, "scalarBlockLayout", structure->scalarBlockLayout);
            }
        } break;

        // Validation code for VkImageStencilUsageCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: { // Covers VUID-VkImageStencilUsageCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_separate_stencil_usage))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO), but its parent extension "
                               "VK_EXT_separate_stencil_usage has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkImageStencilUsageCreateInfo *structure = (VkImageStencilUsageCreateInfo *) header;
                skip |= ValidateFlags(loc, "stencilUsage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, structure->stencilUsage, kRequiredFlags, "VUID-VkImageStencilUsageCreateInfo-stencilUsage-parameter", "VUID-VkImageStencilUsageCreateInfo-stencilUsage-requiredbitmask");
            }
        } break;

        // Validation code for VkSamplerReductionModeCreateInfo structure members
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: { // Covers VUID-VkSamplerReductionModeCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_sampler_filter_minmax))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO), but its parent extension "
                               "VK_EXT_sampler_filter_minmax has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkSamplerReductionModeCreateInfo *structure = (VkSamplerReductionModeCreateInfo *) header;
                skip |= ValidateRangedEnum(loc, "reductionMode", "VkSamplerReductionMode", structure->reductionMode, "VUID-VkSamplerReductionModeCreateInfo-reductionMode-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceSamplerFilterMinmaxProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: { // Covers VUID-VkPhysicalDeviceSamplerFilterMinmaxProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_sampler_filter_minmax))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES), but its parent extension "
                               "VK_EXT_sampler_filter_minmax has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkanMemoryModelFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: { // Covers VUID-VkPhysicalDeviceVulkanMemoryModelFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_vulkan_memory_model))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES), but its parent extension "
                               "VK_KHR_vulkan_memory_model has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceVulkanMemoryModelFeatures *structure = (VkPhysicalDeviceVulkanMemoryModelFeatures *) header;
                skip |= ValidateBool32(loc, "vulkanMemoryModel", structure->vulkanMemoryModel);

                skip |= ValidateBool32(loc, "vulkanMemoryModelDeviceScope", structure->vulkanMemoryModelDeviceScope);

                skip |= ValidateBool32(loc, "vulkanMemoryModelAvailabilityVisibilityChains", structure->vulkanMemoryModelAvailabilityVisibilityChains);
            }
        } break;

        // Validation code for VkPhysicalDeviceImagelessFramebufferFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: { // Covers VUID-VkPhysicalDeviceImagelessFramebufferFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES), but its parent extension "
                               "VK_KHR_imageless_framebuffer has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceImagelessFramebufferFeatures *structure = (VkPhysicalDeviceImagelessFramebufferFeatures *) header;
                skip |= ValidateBool32(loc, "imagelessFramebuffer", structure->imagelessFramebuffer);
            }
        } break;

        // Validation code for VkFramebufferAttachmentsCreateInfo structure members
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: { // Covers VUID-VkFramebufferAttachmentsCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO), but its parent extension "
                               "VK_KHR_imageless_framebuffer has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkFramebufferAttachmentsCreateInfo *structure = (VkFramebufferAttachmentsCreateInfo *) header;
                skip |= ValidateStructTypeArray(loc, "attachmentImageInfoCount", "pAttachmentImageInfos", "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO", structure->attachmentImageInfoCount, structure->pAttachmentImageInfos, VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO, false, true, "VUID-VkFramebufferAttachmentImageInfo-sType-sType", "VUID-VkFramebufferAttachmentsCreateInfo-pAttachmentImageInfos-parameter", kVUIDUndefined);

                if (structure->pAttachmentImageInfos != nullptr)
                {
                    for (uint32_t attachmentImageInfoIndex = 0; attachmentImageInfoIndex < structure->attachmentImageInfoCount; ++attachmentImageInfoIndex)
                    {
                        skip |= ValidateFlags(loc, ParameterName("pAttachmentImageInfos[%i].flags", ParameterName::IndexVector{ attachmentImageInfoIndex }), "VkImageCreateFlagBits", AllVkImageCreateFlagBits, structure->pAttachmentImageInfos[attachmentImageInfoIndex].flags, kOptionalFlags, "VUID-VkFramebufferAttachmentImageInfo-flags-parameter");

                        skip |= ValidateFlags(loc, ParameterName("pAttachmentImageInfos[%i].usage", ParameterName::IndexVector{ attachmentImageInfoIndex }), "VkImageUsageFlagBits", AllVkImageUsageFlagBits, structure->pAttachmentImageInfos[attachmentImageInfoIndex].usage, kRequiredFlags, "VUID-VkFramebufferAttachmentImageInfo-usage-parameter", "VUID-VkFramebufferAttachmentImageInfo-usage-requiredbitmask");

                        skip |= ValidateRangedEnumArray(loc, ParameterName("pAttachmentImageInfos[%i].viewFormatCount", ParameterName::IndexVector{ attachmentImageInfoIndex }), ParameterName("pAttachmentImageInfos[%i].pViewFormats", ParameterName::IndexVector{ attachmentImageInfoIndex }), "VkFormat", structure->pAttachmentImageInfos[attachmentImageInfoIndex].viewFormatCount, structure->pAttachmentImageInfos[attachmentImageInfoIndex].pViewFormats, false, true);
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassAttachmentBeginInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: { // Covers VUID-VkRenderPassAttachmentBeginInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO), but its parent extension "
                               "VK_KHR_imageless_framebuffer has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkRenderPassAttachmentBeginInfo *structure = (VkRenderPassAttachmentBeginInfo *) header;
                skip |= ValidateArray(loc, "attachmentCount", "pAttachments", structure->attachmentCount, &structure->pAttachments, false, true, kVUIDUndefined, "VUID-VkRenderPassAttachmentBeginInfo-pAttachments-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: { // Covers VUID-VkPhysicalDeviceUniformBufferStandardLayoutFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_uniform_buffer_standard_layout))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES), but its parent extension "
                               "VK_KHR_uniform_buffer_standard_layout has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceUniformBufferStandardLayoutFeatures *structure = (VkPhysicalDeviceUniformBufferStandardLayoutFeatures *) header;
                skip |= ValidateBool32(loc, "uniformBufferStandardLayout", structure->uniformBufferStandardLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_subgroup_extended_types))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES), but its parent extension "
                               "VK_KHR_shader_subgroup_extended_types has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: { // Covers VUID-VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES), but its parent extension "
                               "VK_KHR_separate_depth_stencil_layouts has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *structure = (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *) header;
                skip |= ValidateBool32(loc, "separateDepthStencilLayouts", structure->separateDepthStencilLayouts);
            }
        } break;

        // Validation code for VkAttachmentReferenceStencilLayout structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: { // Covers VUID-VkAttachmentReferenceStencilLayout-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT), but its parent extension "
                               "VK_KHR_separate_depth_stencil_layouts has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkAttachmentReferenceStencilLayout *structure = (VkAttachmentReferenceStencilLayout *) header;
                skip |= ValidateRangedEnum(loc, "stencilLayout", "VkImageLayout", structure->stencilLayout, "VUID-VkAttachmentReferenceStencilLayout-stencilLayout-parameter");
            }
        } break;

        // Validation code for VkAttachmentDescriptionStencilLayout structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: { // Covers VUID-VkAttachmentDescriptionStencilLayout-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT), but its parent extension "
                               "VK_KHR_separate_depth_stencil_layouts has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkAttachmentDescriptionStencilLayout *structure = (VkAttachmentDescriptionStencilLayout *) header;
                skip |= ValidateRangedEnum(loc, "stencilInitialLayout", "VkImageLayout", structure->stencilInitialLayout, "VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-parameter");

                skip |= ValidateRangedEnum(loc, "stencilFinalLayout", "VkImageLayout", structure->stencilFinalLayout, "VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceHostQueryResetFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: { // Covers VUID-VkPhysicalDeviceHostQueryResetFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_host_query_reset))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES), but its parent extension "
                               "VK_EXT_host_query_reset has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceHostQueryResetFeatures *structure = (VkPhysicalDeviceHostQueryResetFeatures *) header;
                skip |= ValidateBool32(loc, "hostQueryReset", structure->hostQueryReset);
            }
        } break;

        // Validation code for VkPhysicalDeviceTimelineSemaphoreFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: { // Covers VUID-VkPhysicalDeviceTimelineSemaphoreFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES), but its parent extension "
                               "VK_KHR_timeline_semaphore has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceTimelineSemaphoreFeatures *structure = (VkPhysicalDeviceTimelineSemaphoreFeatures *) header;
                skip |= ValidateBool32(loc, "timelineSemaphore", structure->timelineSemaphore);
            }
        } break;

        // Validation code for VkPhysicalDeviceTimelineSemaphoreProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: { // Covers VUID-VkPhysicalDeviceTimelineSemaphoreProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES), but its parent extension "
                               "VK_KHR_timeline_semaphore has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkSemaphoreTypeCreateInfo structure members
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: { // Covers VUID-VkSemaphoreTypeCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO), but its parent extension "
                               "VK_KHR_timeline_semaphore has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkSemaphoreTypeCreateInfo *structure = (VkSemaphoreTypeCreateInfo *) header;
                skip |= ValidateRangedEnum(loc, "semaphoreType", "VkSemaphoreType", structure->semaphoreType, "VUID-VkSemaphoreTypeCreateInfo-semaphoreType-parameter");
            }
        } break;

        // Validation code for VkTimelineSemaphoreSubmitInfo structure members
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: { // Covers VUID-VkTimelineSemaphoreSubmitInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO), but its parent extension "
                               "VK_KHR_timeline_semaphore has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceBufferDeviceAddressFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: { // Covers VUID-VkPhysicalDeviceBufferDeviceAddressFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_buffer_device_address))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES), but its parent extension "
                               "VK_KHR_buffer_device_address has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceBufferDeviceAddressFeatures *structure = (VkPhysicalDeviceBufferDeviceAddressFeatures *) header;
                skip |= ValidateBool32(loc, "bufferDeviceAddress", structure->bufferDeviceAddress);

                skip |= ValidateBool32(loc, "bufferDeviceAddressCaptureReplay", structure->bufferDeviceAddressCaptureReplay);

                skip |= ValidateBool32(loc, "bufferDeviceAddressMultiDevice", structure->bufferDeviceAddressMultiDevice);
            }
        } break;

        // Validation code for VkBufferOpaqueCaptureAddressCreateInfo structure members
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: { // Covers VUID-VkBufferOpaqueCaptureAddressCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_buffer_device_address))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO), but its parent extension "
                               "VK_KHR_buffer_device_address has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkMemoryOpaqueCaptureAddressAllocateInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: { // Covers VUID-VkMemoryOpaqueCaptureAddressAllocateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_buffer_device_address))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO), but its parent extension "
                               "VK_KHR_buffer_device_address has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan13Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: { // Covers VUID-VkPhysicalDeviceVulkan13Features-sType-sType
            if (api_version < VK_API_VERSION_1_3) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES) which was added in VK_API_VERSION_1_3 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
            if (is_const_param) {
                VkPhysicalDeviceVulkan13Features *structure = (VkPhysicalDeviceVulkan13Features *) header;
                skip |= ValidateBool32(loc, "robustImageAccess", structure->robustImageAccess);

                skip |= ValidateBool32(loc, "inlineUniformBlock", structure->inlineUniformBlock);

                skip |= ValidateBool32(loc, "descriptorBindingInlineUniformBlockUpdateAfterBind", structure->descriptorBindingInlineUniformBlockUpdateAfterBind);

                skip |= ValidateBool32(loc, "pipelineCreationCacheControl", structure->pipelineCreationCacheControl);

                skip |= ValidateBool32(loc, "privateData", structure->privateData);

                skip |= ValidateBool32(loc, "shaderDemoteToHelperInvocation", structure->shaderDemoteToHelperInvocation);

                skip |= ValidateBool32(loc, "shaderTerminateInvocation", structure->shaderTerminateInvocation);

                skip |= ValidateBool32(loc, "subgroupSizeControl", structure->subgroupSizeControl);

                skip |= ValidateBool32(loc, "computeFullSubgroups", structure->computeFullSubgroups);

                skip |= ValidateBool32(loc, "synchronization2", structure->synchronization2);

                skip |= ValidateBool32(loc, "textureCompressionASTC_HDR", structure->textureCompressionASTC_HDR);

                skip |= ValidateBool32(loc, "shaderZeroInitializeWorkgroupMemory", structure->shaderZeroInitializeWorkgroupMemory);

                skip |= ValidateBool32(loc, "dynamicRendering", structure->dynamicRendering);

                skip |= ValidateBool32(loc, "shaderIntegerDotProduct", structure->shaderIntegerDotProduct);

                skip |= ValidateBool32(loc, "maintenance4", structure->maintenance4);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan13Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: { // Covers VUID-VkPhysicalDeviceVulkan13Properties-sType-sType
            if (api_version < VK_API_VERSION_1_3) {
                skip |= LogError(
                           pnext_vuid, instance, loc,
                           "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES) which was added in VK_API_VERSION_1_3 but the "
                           "current effective API version is %s.",
                           parameter_name.get_name().c_str(), StringAPIVersion(api_version).c_str());
            }
        } break;

        // Validation code for VkPipelineCreationFeedbackCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: { // Covers VUID-VkPipelineCreationFeedbackCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_pipeline_creation_feedback))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO), but its parent extension "
                               "VK_EXT_pipeline_creation_feedback has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPipelineCreationFeedbackCreateInfo *structure = (VkPipelineCreationFeedbackCreateInfo *) header;
                skip |= ValidateRequiredPointer(loc, "pPipelineCreationFeedback", structure->pPipelineCreationFeedback, "VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineCreationFeedback-parameter");

                if (structure->pPipelineCreationFeedback != nullptr)
                {
                }

                skip |= ValidateArray(loc, "pipelineStageCreationFeedbackCount", "pPipelineStageCreationFeedbacks", structure->pipelineStageCreationFeedbackCount, &structure->pPipelineStageCreationFeedbacks, false, true, kVUIDUndefined, "VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineStageCreationFeedbacks-parameter");

                if (structure->pPipelineStageCreationFeedbacks != nullptr)
                {
                    for (uint32_t pipelineStageCreationFeedbackIndex = 0; pipelineStageCreationFeedbackIndex < structure->pipelineStageCreationFeedbackCount; ++pipelineStageCreationFeedbackIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderTerminateInvocationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderTerminateInvocationFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_terminate_invocation))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES), but its parent extension "
                               "VK_KHR_shader_terminate_invocation has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceShaderTerminateInvocationFeatures *structure = (VkPhysicalDeviceShaderTerminateInvocationFeatures *) header;
                skip |= ValidateBool32(loc, "shaderTerminateInvocation", structure->shaderTerminateInvocation);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_shader_demote_to_helper_invocation))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES), but its parent extension "
                               "VK_EXT_shader_demote_to_helper_invocation has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *structure = (VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *) header;
                skip |= ValidateBool32(loc, "shaderDemoteToHelperInvocation", structure->shaderDemoteToHelperInvocation);
            }
        } break;

        // Validation code for VkPhysicalDevicePrivateDataFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: { // Covers VUID-VkPhysicalDevicePrivateDataFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_PRIVATE_DATA_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_private_data))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES), but its parent extension "
                               "VK_EXT_private_data has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDevicePrivateDataFeatures *structure = (VkPhysicalDevicePrivateDataFeatures *) header;
                skip |= ValidateBool32(loc, "privateData", structure->privateData);
            }
        } break;

        // Validation code for VkDevicePrivateDataCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: { // Covers VUID-VkDevicePrivateDataCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_PRIVATE_DATA_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_private_data))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO), but its parent extension "
                               "VK_EXT_private_data has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineCreationCacheControlFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: { // Covers VUID-VkPhysicalDevicePipelineCreationCacheControlFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_pipeline_creation_cache_control))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES), but its parent extension "
                               "VK_EXT_pipeline_creation_cache_control has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDevicePipelineCreationCacheControlFeatures *structure = (VkPhysicalDevicePipelineCreationCacheControlFeatures *) header;
                skip |= ValidateBool32(loc, "pipelineCreationCacheControl", structure->pipelineCreationCacheControl);
            }
        } break;

        // Validation code for VkMemoryBarrier2 structure members
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: { // Covers VUID-VkMemoryBarrier2-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_synchronization2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_BARRIER_2), but its parent extension "
                               "VK_KHR_synchronization2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkMemoryBarrier2 *structure = (VkMemoryBarrier2 *) header;
                skip |= ValidateFlags(loc, "srcStageMask", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, structure->srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, "srcAccessMask", "VkAccessFlagBits2", AllVkAccessFlagBits2, structure->srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, "dstStageMask", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, structure->dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, "dstAccessMask", "VkAccessFlagBits2", AllVkAccessFlagBits2, structure->dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceSynchronization2Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: { // Covers VUID-VkPhysicalDeviceSynchronization2Features-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_synchronization2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES), but its parent extension "
                               "VK_KHR_synchronization2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceSynchronization2Features *structure = (VkPhysicalDeviceSynchronization2Features *) header;
                skip |= ValidateBool32(loc, "synchronization2", structure->synchronization2);
            }
        } break;

        // Validation code for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: { // Covers VUID-VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_zero_initialize_workgroup_memory))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES), but its parent extension "
                               "VK_KHR_zero_initialize_workgroup_memory has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *structure = (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *) header;
                skip |= ValidateBool32(loc, "shaderZeroInitializeWorkgroupMemory", structure->shaderZeroInitializeWorkgroupMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageRobustnessFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: { // Covers VUID-VkPhysicalDeviceImageRobustnessFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_image_robustness))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES), but its parent extension "
                               "VK_EXT_image_robustness has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceImageRobustnessFeatures *structure = (VkPhysicalDeviceImageRobustnessFeatures *) header;
                skip |= ValidateBool32(loc, "robustImageAccess", structure->robustImageAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubgroupSizeControlFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: { // Covers VUID-VkPhysicalDeviceSubgroupSizeControlFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_subgroup_size_control))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES), but its parent extension "
                               "VK_EXT_subgroup_size_control has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceSubgroupSizeControlFeatures *structure = (VkPhysicalDeviceSubgroupSizeControlFeatures *) header;
                skip |= ValidateBool32(loc, "subgroupSizeControl", structure->subgroupSizeControl);

                skip |= ValidateBool32(loc, "computeFullSubgroups", structure->computeFullSubgroups);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubgroupSizeControlProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: { // Covers VUID-VkPhysicalDeviceSubgroupSizeControlProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_subgroup_size_control))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES), but its parent extension "
                               "VK_EXT_subgroup_size_control has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: { // Covers VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_subgroup_size_control))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO), but its parent extension "
                               "VK_EXT_subgroup_size_control has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceInlineUniformBlockFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: { // Covers VUID-VkPhysicalDeviceInlineUniformBlockFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES), but its parent extension "
                               "VK_EXT_inline_uniform_block has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceInlineUniformBlockFeatures *structure = (VkPhysicalDeviceInlineUniformBlockFeatures *) header;
                skip |= ValidateBool32(loc, "inlineUniformBlock", structure->inlineUniformBlock);

                skip |= ValidateBool32(loc, "descriptorBindingInlineUniformBlockUpdateAfterBind", structure->descriptorBindingInlineUniformBlockUpdateAfterBind);
            }
        } break;

        // Validation code for VkPhysicalDeviceInlineUniformBlockProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: { // Covers VUID-VkPhysicalDeviceInlineUniformBlockProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES), but its parent extension "
                               "VK_EXT_inline_uniform_block has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkWriteDescriptorSetInlineUniformBlock structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: { // Covers VUID-VkWriteDescriptorSetInlineUniformBlock-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK), but its parent extension "
                               "VK_EXT_inline_uniform_block has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkWriteDescriptorSetInlineUniformBlock *structure = (VkWriteDescriptorSetInlineUniformBlock *) header;
                skip |= ValidateArray(loc, "dataSize", "pData", structure->dataSize, &structure->pData, true, true, "VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-arraylength", "VUID-VkWriteDescriptorSetInlineUniformBlock-pData-parameter");
            }
        } break;

        // Validation code for VkDescriptorPoolInlineUniformBlockCreateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: { // Covers VUID-VkDescriptorPoolInlineUniformBlockCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO), but its parent extension "
                               "VK_EXT_inline_uniform_block has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceTextureCompressionASTCHDRFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: { // Covers VUID-VkPhysicalDeviceTextureCompressionASTCHDRFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_texture_compression_astc_hdr))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES), but its parent extension "
                               "VK_EXT_texture_compression_astc_hdr has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceTextureCompressionASTCHDRFeatures *structure = (VkPhysicalDeviceTextureCompressionASTCHDRFeatures *) header;
                skip |= ValidateBool32(loc, "textureCompressionASTC_HDR", structure->textureCompressionASTC_HDR);
            }
        } break;

        // Validation code for VkPipelineRenderingCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: { // Covers VUID-VkPipelineRenderingCreateInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO), but its parent extension "
                               "VK_KHR_dynamic_rendering has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: { // Covers VUID-VkPhysicalDeviceDynamicRenderingFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES), but its parent extension "
                               "VK_KHR_dynamic_rendering has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceDynamicRenderingFeatures *structure = (VkPhysicalDeviceDynamicRenderingFeatures *) header;
                skip |= ValidateBool32(loc, "dynamicRendering", structure->dynamicRendering);
            }
        } break;

        // Validation code for VkCommandBufferInheritanceRenderingInfo structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: { // Covers VUID-VkCommandBufferInheritanceRenderingInfo-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO), but its parent extension "
                               "VK_KHR_dynamic_rendering has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkCommandBufferInheritanceRenderingInfo *structure = (VkCommandBufferInheritanceRenderingInfo *) header;
                skip |= ValidateFlags(loc, "flags", "VkRenderingFlagBits", AllVkRenderingFlagBits, structure->flags, kOptionalFlags, "VUID-VkCommandBufferInheritanceRenderingInfo-flags-parameter");

                skip |= ValidateRangedEnumArray(loc, "colorAttachmentCount", "pColorAttachmentFormats", "VkFormat", structure->colorAttachmentCount, structure->pColorAttachmentFormats, false, true);

                skip |= ValidateRangedEnum(loc, "depthAttachmentFormat", "VkFormat", structure->depthAttachmentFormat, "VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-parameter");

                skip |= ValidateRangedEnum(loc, "stencilAttachmentFormat", "VkFormat", structure->stencilAttachmentFormat, "VUID-VkCommandBufferInheritanceRenderingInfo-stencilAttachmentFormat-parameter");

                skip |= ValidateFlags(loc, "rasterizationSamples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, structure->rasterizationSamples, kOptionalSingleBit, "VUID-VkCommandBufferInheritanceRenderingInfo-rasterizationSamples-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerDotProductFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: { // Covers VUID-VkPhysicalDeviceShaderIntegerDotProductFeatures-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_integer_dot_product))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES), but its parent extension "
                               "VK_KHR_shader_integer_dot_product has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceShaderIntegerDotProductFeatures *structure = (VkPhysicalDeviceShaderIntegerDotProductFeatures *) header;
                skip |= ValidateBool32(loc, "shaderIntegerDotProduct", structure->shaderIntegerDotProduct);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerDotProductProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: { // Covers VUID-VkPhysicalDeviceShaderIntegerDotProductProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_integer_dot_product))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES), but its parent extension "
                               "VK_KHR_shader_integer_dot_product has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceTexelBufferAlignmentProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: { // Covers VUID-VkPhysicalDeviceTexelBufferAlignmentProperties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_texel_buffer_alignment))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES), but its parent extension "
                               "VK_EXT_texel_buffer_alignment has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkFormatProperties3 structure members
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: { // Covers VUID-VkFormatProperties3-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_format_feature_flags2))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3), but its parent extension "
                               "VK_KHR_format_feature_flags2 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance4Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: { // Covers VUID-VkPhysicalDeviceMaintenance4Features-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_4_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance4))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES), but its parent extension "
                               "VK_KHR_maintenance4 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
            if (is_const_param) {
                VkPhysicalDeviceMaintenance4Features *structure = (VkPhysicalDeviceMaintenance4Features *) header;
                skip |= ValidateBool32(loc, "maintenance4", structure->maintenance4);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance4Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: { // Covers VUID-VkPhysicalDeviceMaintenance4Properties-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_MAINTENANCE_4_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance4))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES), but its parent extension "
                               "VK_KHR_maintenance4 has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // No Validation code for VkImageSwapchainCreateInfoKHR structure members  -- Covers VUID-VkImageSwapchainCreateInfoKHR-sType-sType

        // Validation code for VkBindImageMemorySwapchainInfoKHR structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: { // Covers VUID-VkBindImageMemorySwapchainInfoKHR-sType-sType
            if (is_const_param) {
                VkBindImageMemorySwapchainInfoKHR *structure = (VkBindImageMemorySwapchainInfoKHR *) header;
                skip |= ValidateRequiredHandle(loc, "swapchain", structure->swapchain);
            }
        } break;

        // Validation code for VkDeviceGroupPresentInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: { // Covers VUID-VkDeviceGroupPresentInfoKHR-sType-sType
            if (is_const_param) {
                VkDeviceGroupPresentInfoKHR *structure = (VkDeviceGroupPresentInfoKHR *) header;
                skip |= ValidateArray(loc, "swapchainCount", "pDeviceMasks", structure->swapchainCount, &structure->pDeviceMasks, false, true, kVUIDUndefined, "VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter");

                skip |= ValidateFlags(loc, "mode", "VkDeviceGroupPresentModeFlagBitsKHR", AllVkDeviceGroupPresentModeFlagBitsKHR, structure->mode, kRequiredSingleBit, "VUID-VkDeviceGroupPresentInfoKHR-mode-parameter", "VUID-VkDeviceGroupPresentInfoKHR-mode-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupSwapchainCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: { // Covers VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkDeviceGroupSwapchainCreateInfoKHR *structure = (VkDeviceGroupSwapchainCreateInfoKHR *) header;
                skip |= ValidateFlags(loc, "modes", "VkDeviceGroupPresentModeFlagBitsKHR", AllVkDeviceGroupPresentModeFlagBitsKHR, structure->modes, kRequiredFlags, "VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter", "VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask");
            }
        } break;

        // Validation code for VkDisplayPresentInfoKHR structure members
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: { // Covers VUID-VkDisplayPresentInfoKHR-sType-sType
            if (is_const_param) {
                VkDisplayPresentInfoKHR *structure = (VkDisplayPresentInfoKHR *) header;
                skip |= ValidateBool32(loc, "persistent", structure->persistent);
            }
        } break;

        // No Validation code for VkQueueFamilyQueryResultStatusPropertiesKHR structure members  -- Covers VUID-VkQueueFamilyQueryResultStatusPropertiesKHR-sType-sType

        // No Validation code for VkQueueFamilyVideoPropertiesKHR structure members  -- Covers VUID-VkQueueFamilyVideoPropertiesKHR-sType-sType

        // Validation code for VkVideoProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: { // Covers VUID-VkVideoProfileInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoProfileInfoKHR *structure = (VkVideoProfileInfoKHR *) header;
                skip |= ValidateFlags(loc, "videoCodecOperation", "VkVideoCodecOperationFlagBitsKHR", AllVkVideoCodecOperationFlagBitsKHR, structure->videoCodecOperation, kRequiredSingleBit, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

                skip |= ValidateFlags(loc, "chromaSubsampling", "VkVideoChromaSubsamplingFlagBitsKHR", AllVkVideoChromaSubsamplingFlagBitsKHR, structure->chromaSubsampling, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter", "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

                skip |= ValidateFlags(loc, "lumaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, structure->lumaBitDepth, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

                skip |= ValidateFlags(loc, "chromaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, structure->chromaBitDepth, kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
            }
        } break;

        // Validation code for VkVideoProfileListInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: { // Covers VUID-VkVideoProfileListInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoProfileListInfoKHR *structure = (VkVideoProfileListInfoKHR *) header;
                skip |= ValidateStructTypeArray(loc, "profileCount", "pProfiles", "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR", structure->profileCount, structure->pProfiles, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, false, true, "VUID-VkVideoProfileInfoKHR-sType-sType", "VUID-VkVideoProfileListInfoKHR-pProfiles-parameter", kVUIDUndefined);

                if (structure->pProfiles != nullptr)
                {
                    for (uint32_t profileIndex = 0; profileIndex < structure->profileCount; ++profileIndex)
                    {
                        skip |= ValidateFlags(loc, ParameterName("pProfiles[%i].videoCodecOperation", ParameterName::IndexVector{ profileIndex }), "VkVideoCodecOperationFlagBitsKHR", AllVkVideoCodecOperationFlagBitsKHR, structure->pProfiles[profileIndex].videoCodecOperation, kRequiredSingleBit, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

                        skip |= ValidateFlags(loc, ParameterName("pProfiles[%i].chromaSubsampling", ParameterName::IndexVector{ profileIndex }), "VkVideoChromaSubsamplingFlagBitsKHR", AllVkVideoChromaSubsamplingFlagBitsKHR, structure->pProfiles[profileIndex].chromaSubsampling, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter", "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

                        skip |= ValidateFlags(loc, ParameterName("pProfiles[%i].lumaBitDepth", ParameterName::IndexVector{ profileIndex }), "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, structure->pProfiles[profileIndex].lumaBitDepth, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

                        skip |= ValidateFlags(loc, ParameterName("pProfiles[%i].chromaBitDepth", ParameterName::IndexVector{ profileIndex }), "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, structure->pProfiles[profileIndex].chromaBitDepth, kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
                    }
                }
            }
        } break;

        // No Validation code for VkVideoDecodeCapabilitiesKHR structure members  -- Covers VUID-VkVideoDecodeCapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeUsageInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: { // Covers VUID-VkVideoDecodeUsageInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeUsageInfoKHR *structure = (VkVideoDecodeUsageInfoKHR *) header;
                skip |= ValidateFlags(loc, "videoUsageHints", "VkVideoDecodeUsageFlagBitsKHR", AllVkVideoDecodeUsageFlagBitsKHR, structure->videoUsageHints, kOptionalFlags, "VUID-VkVideoDecodeUsageInfoKHR-videoUsageHints-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: { // Covers VUID-VkVideoDecodeH264ProfileInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH264ProfileInfoKHR *structure = (VkVideoDecodeH264ProfileInfoKHR *) header;
                skip |= ValidateFlags(loc, "pictureLayout", "VkVideoDecodeH264PictureLayoutFlagBitsKHR", AllVkVideoDecodeH264PictureLayoutFlagBitsKHR, structure->pictureLayout, kOptionalSingleBit, "VUID-VkVideoDecodeH264ProfileInfoKHR-pictureLayout-parameter");
            }
        } break;

        // No Validation code for VkVideoDecodeH264CapabilitiesKHR structure members  -- Covers VUID-VkVideoDecodeH264CapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeH264SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: { // Covers VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH264SessionParametersAddInfoKHR *structure = (VkVideoDecodeH264SessionParametersAddInfoKHR *) header;
                skip |= ValidateArray(loc, "stdSPSCount", "pStdSPSs", structure->stdSPSCount, &structure->pStdSPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdSPSs-parameter");

                skip |= ValidateArray(loc, "stdPPSCount", "pStdPPSs", structure->stdPPSCount, &structure->pStdPPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdPPSs-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: { // Covers VUID-VkVideoDecodeH264SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH264SessionParametersCreateInfoKHR *structure = (VkVideoDecodeH264SessionParametersCreateInfoKHR *) header;
                skip |= ValidateStructType(loc, "pParametersAddInfo", "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR", structure->pParametersAddInfo, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, false, "VUID-VkVideoDecodeH264SessionParametersCreateInfoKHR-pParametersAddInfo-parameter", "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr)
                {
                    skip |= ValidateArray(loc, "pParametersAddInfo->stdSPSCount", "pParametersAddInfo->pStdSPSs", structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdSPSs-parameter");

                    skip |= ValidateArray(loc, "pParametersAddInfo->stdPPSCount", "pParametersAddInfo->pStdPPSs", structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdPPSs-parameter");
                }
            }
        } break;

        // Validation code for VkVideoDecodeH264PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: { // Covers VUID-VkVideoDecodeH264PictureInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH264PictureInfoKHR *structure = (VkVideoDecodeH264PictureInfoKHR *) header;
                skip |= ValidateRequiredPointer(loc, "pStdPictureInfo", structure->pStdPictureInfo, "VUID-VkVideoDecodeH264PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateArray(loc, "sliceCount", "pSliceOffsets", structure->sliceCount, &structure->pSliceOffsets, true, true, "VUID-VkVideoDecodeH264PictureInfoKHR-sliceCount-arraylength", "VUID-VkVideoDecodeH264PictureInfoKHR-pSliceOffsets-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: { // Covers VUID-VkVideoDecodeH264DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH264DpbSlotInfoKHR *structure = (VkVideoDecodeH264DpbSlotInfoKHR *) header;
                skip |= ValidateRequiredPointer(loc, "pStdReferenceInfo", structure->pStdReferenceInfo, "VUID-VkVideoDecodeH264DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkRenderingFragmentShadingRateAttachmentInfoKHR structure members
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: { // Covers VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-sType-sType
            if (is_const_param) {
                VkRenderingFragmentShadingRateAttachmentInfoKHR *structure = (VkRenderingFragmentShadingRateAttachmentInfoKHR *) header;
                skip |= ValidateRangedEnum(loc, "imageLayout", "VkImageLayout", structure->imageLayout, "VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageLayout-parameter");

            }
        } break;

        // Validation code for VkRenderingFragmentDensityMapAttachmentInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: { // Covers VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-sType-sType
            if (is_const_param) {
                VkRenderingFragmentDensityMapAttachmentInfoEXT *structure = (VkRenderingFragmentDensityMapAttachmentInfoEXT *) header;
                skip |= ValidateRequiredHandle(loc, "imageView", structure->imageView);

                skip |= ValidateRangedEnum(loc, "imageLayout", "VkImageLayout", structure->imageLayout, "VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageLayout-parameter");
            }
        } break;

        // Validation code for VkAttachmentSampleCountInfoAMD structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: { // Covers VUID-VkAttachmentSampleCountInfoAMD-sType-sType
            if (is_const_param) {
                if ((is_physdev_api && !SupportedByPdev(physical_device, VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME)) || (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                        skip |= LogError(
                               pnext_vuid, instance, loc,
                               "Includes a pNext pointer (%s) to a VkStructureType (VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD), but its parent extension "
                               "VK_KHR_dynamic_rendering has not been enabled.",
                               parameter_name.get_name().c_str());
                }
            }
        } break;

        // Validation code for VkMultiviewPerViewAttributesInfoNVX structure members
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: { // Covers VUID-VkMultiviewPerViewAttributesInfoNVX-sType-sType
            if (is_const_param) {
                VkMultiviewPerViewAttributesInfoNVX *structure = (VkMultiviewPerViewAttributesInfoNVX *) header;
                skip |= ValidateBool32(loc, "perViewAttributes", structure->perViewAttributes);

                skip |= ValidateBool32(loc, "perViewAttributesPositionXOnly", structure->perViewAttributesPositionXOnly);
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryWin32HandleInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: { // Covers VUID-VkImportMemoryWin32HandleInfoKHR-sType-sType
            if (is_const_param) {
                VkImportMemoryWin32HandleInfoKHR *structure = (VkImportMemoryWin32HandleInfoKHR *) header;
                skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit, "VUID-VkImportMemoryWin32HandleInfoKHR-handleType-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkExportMemoryWin32HandleInfoKHR structure members  -- Covers VUID-VkExportMemoryWin32HandleInfoKHR-sType-sType
#endif // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryFdInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: { // Covers VUID-VkImportMemoryFdInfoKHR-sType-sType
            if (is_const_param) {
                VkImportMemoryFdInfoKHR *structure = (VkImportMemoryFdInfoKHR *) header;
                skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit, "VUID-VkImportMemoryFdInfoKHR-handleType-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkWin32KeyedMutexAcquireReleaseInfoKHR structure members
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: { // Covers VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-sType-sType
            if (is_const_param) {
                VkWin32KeyedMutexAcquireReleaseInfoKHR *structure = (VkWin32KeyedMutexAcquireReleaseInfoKHR *) header;
                skip |= ValidateArray(loc, "acquireCount", "pAcquireSyncs", structure->acquireCount, &structure->pAcquireSyncs, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-parameter");

                skip |= ValidateArray(loc, "acquireCount", "pAcquireKeys", structure->acquireCount, &structure->pAcquireKeys, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireKeys-parameter");

                skip |= ValidateArray(loc, "acquireCount", "pAcquireTimeouts", structure->acquireCount, &structure->pAcquireTimeouts, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireTimeouts-parameter");

                skip |= ValidateArray(loc, "releaseCount", "pReleaseSyncs", structure->releaseCount, &structure->pReleaseSyncs, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseSyncs-parameter");

                skip |= ValidateArray(loc, "releaseCount", "pReleaseKeys", structure->releaseCount, &structure->pReleaseKeys, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseKeys-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkExportSemaphoreWin32HandleInfoKHR structure members  -- Covers VUID-VkExportSemaphoreWin32HandleInfoKHR-sType-sType
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkD3D12FenceSubmitInfoKHR structure members  -- Covers VUID-VkD3D12FenceSubmitInfoKHR-sType-sType
#endif // VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkPhysicalDevicePushDescriptorPropertiesKHR structure members  -- Covers VUID-VkPhysicalDevicePushDescriptorPropertiesKHR-sType-sType

        // Validation code for VkPresentRegionsKHR structure members
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: { // Covers VUID-VkPresentRegionsKHR-sType-sType
            if (is_const_param) {
                VkPresentRegionsKHR *structure = (VkPresentRegionsKHR *) header;
                skip |= ValidateArray(loc, "swapchainCount", "pRegions", structure->swapchainCount, &structure->pRegions, true, false, "VUID-VkPresentRegionsKHR-swapchainCount-arraylength", "VUID-VkPresentRegionsKHR-pRegions-parameter");

                if (structure->pRegions != nullptr)
                {
                    for (uint32_t swapchainIndex = 0; swapchainIndex < structure->swapchainCount; ++swapchainIndex)
                    {
                        if (structure->pRegions[swapchainIndex].pRectangles != nullptr)
                        {
                            for (uint32_t rectangleIndex = 0; rectangleIndex < structure->pRegions[swapchainIndex].rectangleCount; ++rectangleIndex)
                            {
                            }
                        }
                    }
                }
            }
        } break;

        // No Validation code for VkSharedPresentSurfaceCapabilitiesKHR structure members  -- Covers VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkExportFenceWin32HandleInfoKHR structure members  -- Covers VUID-VkExportFenceWin32HandleInfoKHR-sType-sType
#endif // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkPhysicalDevicePerformanceQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: { // Covers VUID-VkPhysicalDevicePerformanceQueryFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePerformanceQueryFeaturesKHR *structure = (VkPhysicalDevicePerformanceQueryFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "performanceCounterQueryPools", structure->performanceCounterQueryPools);

                skip |= ValidateBool32(loc, "performanceCounterMultipleQueryPools", structure->performanceCounterMultipleQueryPools);
            }
        } break;

        // No Validation code for VkPhysicalDevicePerformanceQueryPropertiesKHR structure members  -- Covers VUID-VkPhysicalDevicePerformanceQueryPropertiesKHR-sType-sType

        // Validation code for VkQueryPoolPerformanceCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: { // Covers VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkQueryPoolPerformanceCreateInfoKHR *structure = (VkQueryPoolPerformanceCreateInfoKHR *) header;
                skip |= ValidateArray(loc, "counterIndexCount", "pCounterIndices", structure->counterIndexCount, &structure->pCounterIndices, true, true, "VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength", "VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter");
            }
        } break;

        // No Validation code for VkPerformanceQuerySubmitInfoKHR structure members  -- Covers VUID-VkPerformanceQuerySubmitInfoKHR-sType-sType
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDevicePortabilitySubsetFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: { // Covers VUID-VkPhysicalDevicePortabilitySubsetFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePortabilitySubsetFeaturesKHR *structure = (VkPhysicalDevicePortabilitySubsetFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "constantAlphaColorBlendFactors", structure->constantAlphaColorBlendFactors);

                skip |= ValidateBool32(loc, "events", structure->events);

                skip |= ValidateBool32(loc, "imageViewFormatReinterpretation", structure->imageViewFormatReinterpretation);

                skip |= ValidateBool32(loc, "imageViewFormatSwizzle", structure->imageViewFormatSwizzle);

                skip |= ValidateBool32(loc, "imageView2DOn3DImage", structure->imageView2DOn3DImage);

                skip |= ValidateBool32(loc, "multisampleArrayImage", structure->multisampleArrayImage);

                skip |= ValidateBool32(loc, "mutableComparisonSamplers", structure->mutableComparisonSamplers);

                skip |= ValidateBool32(loc, "pointPolygons", structure->pointPolygons);

                skip |= ValidateBool32(loc, "samplerMipLodBias", structure->samplerMipLodBias);

                skip |= ValidateBool32(loc, "separateStencilMaskRef", structure->separateStencilMaskRef);

                skip |= ValidateBool32(loc, "shaderSampleRateInterpolationFunctions", structure->shaderSampleRateInterpolationFunctions);

                skip |= ValidateBool32(loc, "tessellationIsolines", structure->tessellationIsolines);

                skip |= ValidateBool32(loc, "tessellationPointMode", structure->tessellationPointMode);

                skip |= ValidateBool32(loc, "triangleFans", structure->triangleFans);

                skip |= ValidateBool32(loc, "vertexAttributeAccessBeyondStride", structure->vertexAttributeAccessBeyondStride);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDevicePortabilitySubsetPropertiesKHR structure members  -- Covers VUID-VkPhysicalDevicePortabilitySubsetPropertiesKHR-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceShaderClockFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceShaderClockFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderClockFeaturesKHR *structure = (VkPhysicalDeviceShaderClockFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "shaderSubgroupClock", structure->shaderSubgroupClock);

                skip |= ValidateBool32(loc, "shaderDeviceClock", structure->shaderDeviceClock);
            }
        } break;

        // No Validation code for VkVideoDecodeH265ProfileInfoKHR structure members  -- Covers VUID-VkVideoDecodeH265ProfileInfoKHR-sType-sType

        // No Validation code for VkVideoDecodeH265CapabilitiesKHR structure members  -- Covers VUID-VkVideoDecodeH265CapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeH265SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: { // Covers VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH265SessionParametersAddInfoKHR *structure = (VkVideoDecodeH265SessionParametersAddInfoKHR *) header;
                skip |= ValidateArray(loc, "stdVPSCount", "pStdVPSs", structure->stdVPSCount, &structure->pStdVPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdVPSs-parameter");

                skip |= ValidateArray(loc, "stdSPSCount", "pStdSPSs", structure->stdSPSCount, &structure->pStdSPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdSPSs-parameter");

                skip |= ValidateArray(loc, "stdPPSCount", "pStdPPSs", structure->stdPPSCount, &structure->pStdPPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdPPSs-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH265SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: { // Covers VUID-VkVideoDecodeH265SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH265SessionParametersCreateInfoKHR *structure = (VkVideoDecodeH265SessionParametersCreateInfoKHR *) header;
                skip |= ValidateStructType(loc, "pParametersAddInfo", "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR", structure->pParametersAddInfo, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, false, "VUID-VkVideoDecodeH265SessionParametersCreateInfoKHR-pParametersAddInfo-parameter", "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr)
                {
                    skip |= ValidateArray(loc, "pParametersAddInfo->stdVPSCount", "pParametersAddInfo->pStdVPSs", structure->pParametersAddInfo->stdVPSCount, &structure->pParametersAddInfo->pStdVPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdVPSs-parameter");

                    skip |= ValidateArray(loc, "pParametersAddInfo->stdSPSCount", "pParametersAddInfo->pStdSPSs", structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdSPSs-parameter");

                    skip |= ValidateArray(loc, "pParametersAddInfo->stdPPSCount", "pParametersAddInfo->pStdPPSs", structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, false, true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdPPSs-parameter");
                }
            }
        } break;

        // Validation code for VkVideoDecodeH265PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: { // Covers VUID-VkVideoDecodeH265PictureInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH265PictureInfoKHR *structure = (VkVideoDecodeH265PictureInfoKHR *) header;
                skip |= ValidateRequiredPointer(loc, "pStdPictureInfo", structure->pStdPictureInfo, "VUID-VkVideoDecodeH265PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateArray(loc, "sliceSegmentCount", "pSliceSegmentOffsets", structure->sliceSegmentCount, &structure->pSliceSegmentOffsets, true, true, "VUID-VkVideoDecodeH265PictureInfoKHR-sliceSegmentCount-arraylength", "VUID-VkVideoDecodeH265PictureInfoKHR-pSliceSegmentOffsets-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH265DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: { // Covers VUID-VkVideoDecodeH265DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoDecodeH265DpbSlotInfoKHR *structure = (VkVideoDecodeH265DpbSlotInfoKHR *) header;
                skip |= ValidateRequiredPointer(loc, "pStdReferenceInfo", structure->pStdReferenceInfo, "VUID-VkVideoDecodeH265DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkDeviceQueueGlobalPriorityCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: { // Covers VUID-VkDeviceQueueGlobalPriorityCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkDeviceQueueGlobalPriorityCreateInfoKHR *structure = (VkDeviceQueueGlobalPriorityCreateInfoKHR *) header;
                skip |= ValidateRangedEnum(loc, "globalPriority", "VkQueueGlobalPriorityKHR", structure->globalPriority, "VUID-VkDeviceQueueGlobalPriorityCreateInfoKHR-globalPriority-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *structure = (VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "globalPriorityQuery", structure->globalPriorityQuery);
            }
        } break;

        // No Validation code for VkQueueFamilyGlobalPriorityPropertiesKHR structure members  -- Covers VUID-VkQueueFamilyGlobalPriorityPropertiesKHR-sType-sType

        // Validation code for VkFragmentShadingRateAttachmentInfoKHR structure members
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: { // Covers VUID-VkFragmentShadingRateAttachmentInfoKHR-sType-sType
            if (is_const_param) {
                VkFragmentShadingRateAttachmentInfoKHR *structure = (VkFragmentShadingRateAttachmentInfoKHR *) header;
                skip |= ValidateStructType(loc, "pFragmentShadingRateAttachment", "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", structure->pFragmentShadingRateAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, "VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-parameter", "VUID-VkAttachmentReference2-sType-sType");

                if (structure->pFragmentShadingRateAttachment != nullptr)
                {
                    skip |= ValidateRangedEnum(loc, "pFragmentShadingRateAttachment->layout", "VkImageLayout", structure->pFragmentShadingRateAttachment->layout, "VUID-VkAttachmentReference2-layout-parameter");
                }

            }
        } break;

        // No Validation code for VkPipelineFragmentShadingRateStateCreateInfoKHR structure members  -- Covers VUID-VkPipelineFragmentShadingRateStateCreateInfoKHR-sType-sType

        // Validation code for VkPhysicalDeviceFragmentShadingRateFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceFragmentShadingRateFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentShadingRateFeaturesKHR *structure = (VkPhysicalDeviceFragmentShadingRateFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "pipelineFragmentShadingRate", structure->pipelineFragmentShadingRate);

                skip |= ValidateBool32(loc, "primitiveFragmentShadingRate", structure->primitiveFragmentShadingRate);

                skip |= ValidateBool32(loc, "attachmentFragmentShadingRate", structure->attachmentFragmentShadingRate);
            }
        } break;

        // No Validation code for VkPhysicalDeviceFragmentShadingRatePropertiesKHR structure members  -- Covers VUID-VkPhysicalDeviceFragmentShadingRatePropertiesKHR-sType-sType

        // Validation code for VkSurfaceProtectedCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: { // Covers VUID-VkSurfaceProtectedCapabilitiesKHR-sType-sType
            if (is_const_param) {
                VkSurfaceProtectedCapabilitiesKHR *structure = (VkSurfaceProtectedCapabilitiesKHR *) header;
                skip |= ValidateBool32(loc, "supportsProtected", structure->supportsProtected);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentWaitFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: { // Covers VUID-VkPhysicalDevicePresentWaitFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePresentWaitFeaturesKHR *structure = (VkPhysicalDevicePresentWaitFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "presentWait", structure->presentWait);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: { // Covers VUID-VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *structure = (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "pipelineExecutableInfo", structure->pipelineExecutableInfo);
            }
        } break;

        // Validation code for VkPipelineLibraryCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: { // Covers VUID-VkPipelineLibraryCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkPipelineLibraryCreateInfoKHR *structure = (VkPipelineLibraryCreateInfoKHR *) header;
                skip |= ValidateArray(loc, "libraryCount", "pLibraries", structure->libraryCount, &structure->pLibraries, false, true, kVUIDUndefined, "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }
        } break;

        // Validation code for VkPresentIdKHR structure members
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR: { // Covers VUID-VkPresentIdKHR-sType-sType
            if (is_const_param) {
                VkPresentIdKHR *structure = (VkPresentIdKHR *) header;
                skip |= ValidateArray(loc, "swapchainCount", "pPresentIds", structure->swapchainCount, &structure->pPresentIds, true, false, "VUID-VkPresentIdKHR-swapchainCount-arraylength", "VUID-VkPresentIdKHR-pPresentIds-parameter");
            }
        } break;

        // Validation code for VkPhysicalDevicePresentIdFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: { // Covers VUID-VkPhysicalDevicePresentIdFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePresentIdFeaturesKHR *structure = (VkPhysicalDevicePresentIdFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "presentId", structure->presentId);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeCapabilitiesKHR structure members  -- Covers VUID-VkVideoEncodeCapabilitiesKHR-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR: { // Covers VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-sType-sType
            if (is_const_param) {
                VkQueryPoolVideoEncodeFeedbackCreateInfoKHR *structure = (VkQueryPoolVideoEncodeFeedbackCreateInfoKHR *) header;
                skip |= ValidateFlags(loc, "encodeFeedbackFlags", "VkVideoEncodeFeedbackFlagBitsKHR", AllVkVideoEncodeFeedbackFlagBitsKHR, structure->encodeFeedbackFlags, kRequiredFlags, "VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-encodeFeedbackFlags-parameter", "VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-encodeFeedbackFlags-requiredbitmask");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeUsageInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: { // Covers VUID-VkVideoEncodeUsageInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoEncodeUsageInfoKHR *structure = (VkVideoEncodeUsageInfoKHR *) header;
                skip |= ValidateFlags(loc, "videoUsageHints", "VkVideoEncodeUsageFlagBitsKHR", AllVkVideoEncodeUsageFlagBitsKHR, structure->videoUsageHints, kOptionalFlags, "VUID-VkVideoEncodeUsageInfoKHR-videoUsageHints-parameter");

                skip |= ValidateFlags(loc, "videoContentHints", "VkVideoEncodeContentFlagBitsKHR", AllVkVideoEncodeContentFlagBitsKHR, structure->videoContentHints, kOptionalFlags, "VUID-VkVideoEncodeUsageInfoKHR-videoContentHints-parameter");

                skip |= ValidateRangedEnum(loc, "tuningMode", "VkVideoEncodeTuningModeKHR", structure->tuningMode, "VUID-VkVideoEncodeUsageInfoKHR-tuningMode-parameter");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeRateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: { // Covers VUID-VkVideoEncodeRateControlInfoKHR-sType-sType
            if (is_const_param) {
                VkVideoEncodeRateControlInfoKHR *structure = (VkVideoEncodeRateControlInfoKHR *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkVideoEncodeRateControlInfoKHR-flags-zerobitmask");

                skip |= ValidateFlags(loc, "rateControlMode", "VkVideoEncodeRateControlModeFlagBitsKHR", AllVkVideoEncodeRateControlModeFlagBitsKHR, structure->rateControlMode, kOptionalSingleBit, "VUID-VkVideoEncodeRateControlInfoKHR-rateControlMode-parameter");

                skip |= ValidateStructTypeArray(loc, "layerCount", "pLayers", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR", structure->layerCount, structure->pLayers, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR, false, true, "VUID-VkVideoEncodeRateControlLayerInfoKHR-sType-sType", "VUID-VkVideoEncodeRateControlInfoKHR-pLayers-parameter", kVUIDUndefined);

                if (structure->pLayers != nullptr)
                {
                    for (uint32_t layerIndex = 0; layerIndex < structure->layerCount; ++layerIndex)
                    {
                    }
                }
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeQualityLevelInfoKHR structure members  -- Covers VUID-VkVideoEncodeQualityLevelInfoKHR-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkQueueFamilyCheckpointProperties2NV structure members  -- Covers VUID-VkQueueFamilyCheckpointProperties2NV-sType-sType

        // Validation code for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *structure = (VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "fragmentShaderBarycentric", structure->fragmentShaderBarycentric);
            }
        } break;

        // No Validation code for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR structure members  -- Covers VUID-VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR-sType-sType

        // Validation code for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *structure = (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "shaderSubgroupUniformControlFlow", structure->shaderSubgroupUniformControlFlow);
            }
        } break;

        // Validation code for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *structure = (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "workgroupMemoryExplicitLayout", structure->workgroupMemoryExplicitLayout);

                skip |= ValidateBool32(loc, "workgroupMemoryExplicitLayoutScalarBlockLayout", structure->workgroupMemoryExplicitLayoutScalarBlockLayout);

                skip |= ValidateBool32(loc, "workgroupMemoryExplicitLayout8BitAccess", structure->workgroupMemoryExplicitLayout8BitAccess);

                skip |= ValidateBool32(loc, "workgroupMemoryExplicitLayout16BitAccess", structure->workgroupMemoryExplicitLayout16BitAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *structure = (VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *) header;
                skip |= ValidateBool32(loc, "rayTracingMaintenance1", structure->rayTracingMaintenance1);

                skip |= ValidateBool32(loc, "rayTracingPipelineTraceRaysIndirect2", structure->rayTracingPipelineTraceRaysIndirect2);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance5FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceMaintenance5FeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMaintenance5FeaturesKHR *structure = (VkPhysicalDeviceMaintenance5FeaturesKHR *) header;
                skip |= ValidateBool32(loc, "maintenance5", structure->maintenance5);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMaintenance5PropertiesKHR structure members  -- Covers VUID-VkPhysicalDeviceMaintenance5PropertiesKHR-sType-sType

        // Validation code for VkPipelineCreateFlags2CreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR: { // Covers VUID-VkPipelineCreateFlags2CreateInfoKHR-sType-sType
            if (is_const_param) {
                VkPipelineCreateFlags2CreateInfoKHR *structure = (VkPipelineCreateFlags2CreateInfoKHR *) header;
                skip |= ValidateFlags(loc, "flags", "VkPipelineCreateFlagBits2KHR", AllVkPipelineCreateFlagBits2KHR, structure->flags, kRequiredFlags, "VUID-VkPipelineCreateFlags2CreateInfoKHR-flags-parameter", "VUID-VkPipelineCreateFlags2CreateInfoKHR-flags-requiredbitmask");
            }
        } break;

        // Validation code for VkBufferUsageFlags2CreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR: { // Covers VUID-VkBufferUsageFlags2CreateInfoKHR-sType-sType
            if (is_const_param) {
                VkBufferUsageFlags2CreateInfoKHR *structure = (VkBufferUsageFlags2CreateInfoKHR *) header;
                skip |= ValidateFlags(loc, "usage", "VkBufferUsageFlagBits2KHR", AllVkBufferUsageFlagBits2KHR, structure->usage, kRequiredFlags, "VUID-VkBufferUsageFlags2CreateInfoKHR-usage-parameter", "VUID-VkBufferUsageFlags2CreateInfoKHR-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *structure = (VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "rayTracingPositionFetch", structure->rayTracingPositionFetch);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrixFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceCooperativeMatrixFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCooperativeMatrixFeaturesKHR *structure = (VkPhysicalDeviceCooperativeMatrixFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "cooperativeMatrix", structure->cooperativeMatrix);

                skip |= ValidateBool32(loc, "cooperativeMatrixRobustBufferAccess", structure->cooperativeMatrixRobustBufferAccess);
            }
        } break;

        // No Validation code for VkPhysicalDeviceCooperativeMatrixPropertiesKHR structure members  -- Covers VUID-VkPhysicalDeviceCooperativeMatrixPropertiesKHR-sType-sType

        // Validation code for VkDebugReportCallbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: { // Covers VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkDebugReportCallbackCreateInfoEXT *structure = (VkDebugReportCallbackCreateInfoEXT *) header;
                skip |= ValidateFlags(loc, "flags", "VkDebugReportFlagBitsEXT", AllVkDebugReportFlagBitsEXT, structure->flags, kOptionalFlags, "VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter");

                skip |= ValidateRequiredPointer(loc, "pfnCallback", reinterpret_cast<const void*>(structure->pfnCallback), "VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter");
            }
        } break;

        // Validation code for VkPipelineRasterizationStateRasterizationOrderAMD structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: { // Covers VUID-VkPipelineRasterizationStateRasterizationOrderAMD-sType-sType
            if (is_const_param) {
                VkPipelineRasterizationStateRasterizationOrderAMD *structure = (VkPipelineRasterizationStateRasterizationOrderAMD *) header;
                skip |= ValidateRangedEnum(loc, "rasterizationOrder", "VkRasterizationOrderAMD", structure->rasterizationOrder, "VUID-VkPipelineRasterizationStateRasterizationOrderAMD-rasterizationOrder-parameter");
            }
        } break;

        // Validation code for VkDedicatedAllocationImageCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: { // Covers VUID-VkDedicatedAllocationImageCreateInfoNV-sType-sType
            if (is_const_param) {
                VkDedicatedAllocationImageCreateInfoNV *structure = (VkDedicatedAllocationImageCreateInfoNV *) header;
                skip |= ValidateBool32(loc, "dedicatedAllocation", structure->dedicatedAllocation);
            }
        } break;

        // Validation code for VkDedicatedAllocationBufferCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: { // Covers VUID-VkDedicatedAllocationBufferCreateInfoNV-sType-sType
            if (is_const_param) {
                VkDedicatedAllocationBufferCreateInfoNV *structure = (VkDedicatedAllocationBufferCreateInfoNV *) header;
                skip |= ValidateBool32(loc, "dedicatedAllocation", structure->dedicatedAllocation);
            }
        } break;

        // No Validation code for VkDedicatedAllocationMemoryAllocateInfoNV structure members  -- Covers VUID-VkDedicatedAllocationMemoryAllocateInfoNV-sType-sType

        // Validation code for VkPhysicalDeviceTransformFeedbackFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceTransformFeedbackFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceTransformFeedbackFeaturesEXT *structure = (VkPhysicalDeviceTransformFeedbackFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "transformFeedback", structure->transformFeedback);

                skip |= ValidateBool32(loc, "geometryStreams", structure->geometryStreams);
            }
        } break;

        // No Validation code for VkPhysicalDeviceTransformFeedbackPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceTransformFeedbackPropertiesEXT-sType-sType

        // Validation code for VkPipelineRasterizationStateStreamCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: { // Covers VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineRasterizationStateStreamCreateInfoEXT *structure = (VkPipelineRasterizationStateStreamCreateInfoEXT *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-flags-zerobitmask");
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH264CapabilitiesEXT structure members  -- Covers VUID-VkVideoEncodeH264CapabilitiesEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH264QualityLevelPropertiesEXT structure members  -- Covers VUID-VkVideoEncodeH264QualityLevelPropertiesEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264SessionCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT: { // Covers VUID-VkVideoEncodeH264SessionCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264SessionCreateInfoEXT *structure = (VkVideoEncodeH264SessionCreateInfoEXT *) header;
                skip |= ValidateBool32(loc, "useMaxLevelIdc", structure->useMaxLevelIdc);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264SessionParametersAddInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT: { // Covers VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264SessionParametersAddInfoEXT *structure = (VkVideoEncodeH264SessionParametersAddInfoEXT *) header;
                skip |= ValidateArray(loc, "stdSPSCount", "pStdSPSs", structure->stdSPSCount, &structure->pStdSPSs, true, false, "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdSPSCount-arraylength", "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-pStdSPSs-parameter");

                skip |= ValidateArray(loc, "stdPPSCount", "pStdPPSs", structure->stdPPSCount, &structure->pStdPPSs, true, false, "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdPPSCount-arraylength", "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-pStdPPSs-parameter");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264SessionParametersCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT: { // Covers VUID-VkVideoEncodeH264SessionParametersCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264SessionParametersCreateInfoEXT *structure = (VkVideoEncodeH264SessionParametersCreateInfoEXT *) header;
                skip |= ValidateStructType(loc, "pParametersAddInfo", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT", structure->pParametersAddInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT, false, "VUID-VkVideoEncodeH264SessionParametersCreateInfoEXT-pParametersAddInfo-parameter", "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-sType-sType");

                if (structure->pParametersAddInfo != nullptr)
                {
                    skip |= ValidateArray(loc, "pParametersAddInfo->stdSPSCount", "pParametersAddInfo->pStdSPSs", structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, true, false, "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdSPSCount-arraylength", "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-pStdSPSs-parameter");

                    skip |= ValidateArray(loc, "pParametersAddInfo->stdPPSCount", "pParametersAddInfo->pStdPPSs", structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, true, false, "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdPPSCount-arraylength", "VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-pStdPPSs-parameter");
                }
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264SessionParametersGetInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT: { // Covers VUID-VkVideoEncodeH264SessionParametersGetInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264SessionParametersGetInfoEXT *structure = (VkVideoEncodeH264SessionParametersGetInfoEXT *) header;
                skip |= ValidateBool32(loc, "writeStdSPS", structure->writeStdSPS);

                skip |= ValidateBool32(loc, "writeStdPPS", structure->writeStdPPS);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH264SessionParametersFeedbackInfoEXT structure members  -- Covers VUID-VkVideoEncodeH264SessionParametersFeedbackInfoEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264PictureInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT: { // Covers VUID-VkVideoEncodeH264PictureInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264PictureInfoEXT *structure = (VkVideoEncodeH264PictureInfoEXT *) header;
                skip |= ValidateStructTypeArray(loc, "naluSliceEntryCount", "pNaluSliceEntries", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT", structure->naluSliceEntryCount, structure->pNaluSliceEntries, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT, true, true, "VUID-VkVideoEncodeH264NaluSliceInfoEXT-sType-sType", "VUID-VkVideoEncodeH264PictureInfoEXT-pNaluSliceEntries-parameter", "VUID-VkVideoEncodeH264PictureInfoEXT-naluSliceEntryCount-arraylength");

                if (structure->pNaluSliceEntries != nullptr)
                {
                    for (uint32_t naluSliceEntryIndex = 0; naluSliceEntryIndex < structure->naluSliceEntryCount; ++naluSliceEntryIndex)
                    {
                        skip |= ValidateRequiredPointer(loc, ParameterName("pNaluSliceEntries[%i].pStdSliceHeader", ParameterName::IndexVector{ naluSliceEntryIndex }), structure->pNaluSliceEntries[naluSliceEntryIndex].pStdSliceHeader, "VUID-VkVideoEncodeH264NaluSliceInfoEXT-pStdSliceHeader-parameter");
                    }
                }

                skip |= ValidateRequiredPointer(loc, "pStdPictureInfo", structure->pStdPictureInfo, "VUID-VkVideoEncodeH264PictureInfoEXT-pStdPictureInfo-parameter");

                skip |= ValidateBool32(loc, "generatePrefixNalu", structure->generatePrefixNalu);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264DpbSlotInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT: { // Covers VUID-VkVideoEncodeH264DpbSlotInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264DpbSlotInfoEXT *structure = (VkVideoEncodeH264DpbSlotInfoEXT *) header;
                skip |= ValidateRequiredPointer(loc, "pStdReferenceInfo", structure->pStdReferenceInfo, "VUID-VkVideoEncodeH264DpbSlotInfoEXT-pStdReferenceInfo-parameter");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH264ProfileInfoEXT structure members  -- Covers VUID-VkVideoEncodeH264ProfileInfoEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264RateControlInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT: { // Covers VUID-VkVideoEncodeH264RateControlInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264RateControlInfoEXT *structure = (VkVideoEncodeH264RateControlInfoEXT *) header;
                skip |= ValidateFlags(loc, "flags", "VkVideoEncodeH264RateControlFlagBitsEXT", AllVkVideoEncodeH264RateControlFlagBitsEXT, structure->flags, kRequiredFlags, "VUID-VkVideoEncodeH264RateControlInfoEXT-flags-parameter", "VUID-VkVideoEncodeH264RateControlInfoEXT-flags-requiredbitmask");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264RateControlLayerInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT: { // Covers VUID-VkVideoEncodeH264RateControlLayerInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264RateControlLayerInfoEXT *structure = (VkVideoEncodeH264RateControlLayerInfoEXT *) header;
                skip |= ValidateBool32(loc, "useMinQp", structure->useMinQp);

                skip |= ValidateBool32(loc, "useMaxQp", structure->useMaxQp);

                skip |= ValidateBool32(loc, "useMaxFrameSize", structure->useMaxFrameSize);

            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH264GopRemainingFrameInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT: { // Covers VUID-VkVideoEncodeH264GopRemainingFrameInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH264GopRemainingFrameInfoEXT *structure = (VkVideoEncodeH264GopRemainingFrameInfoEXT *) header;
                skip |= ValidateBool32(loc, "useGopRemainingFrames", structure->useGopRemainingFrames);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH265CapabilitiesEXT structure members  -- Covers VUID-VkVideoEncodeH265CapabilitiesEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265SessionCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT: { // Covers VUID-VkVideoEncodeH265SessionCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265SessionCreateInfoEXT *structure = (VkVideoEncodeH265SessionCreateInfoEXT *) header;
                skip |= ValidateBool32(loc, "useMaxLevelIdc", structure->useMaxLevelIdc);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH265QualityLevelPropertiesEXT structure members  -- Covers VUID-VkVideoEncodeH265QualityLevelPropertiesEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265SessionParametersAddInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT: { // Covers VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265SessionParametersAddInfoEXT *structure = (VkVideoEncodeH265SessionParametersAddInfoEXT *) header;
                skip |= ValidateArray(loc, "stdVPSCount", "pStdVPSs", structure->stdVPSCount, &structure->pStdVPSs, true, false, "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdVPSCount-arraylength", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdVPSs-parameter");

                skip |= ValidateArray(loc, "stdSPSCount", "pStdSPSs", structure->stdSPSCount, &structure->pStdSPSs, true, false, "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdSPSCount-arraylength", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdSPSs-parameter");

                skip |= ValidateArray(loc, "stdPPSCount", "pStdPPSs", structure->stdPPSCount, &structure->pStdPPSs, true, false, "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdPPSCount-arraylength", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdPPSs-parameter");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265SessionParametersCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT: { // Covers VUID-VkVideoEncodeH265SessionParametersCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265SessionParametersCreateInfoEXT *structure = (VkVideoEncodeH265SessionParametersCreateInfoEXT *) header;
                skip |= ValidateStructType(loc, "pParametersAddInfo", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT", structure->pParametersAddInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT, false, "VUID-VkVideoEncodeH265SessionParametersCreateInfoEXT-pParametersAddInfo-parameter", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-sType-sType");

                if (structure->pParametersAddInfo != nullptr)
                {
                    skip |= ValidateArray(loc, "pParametersAddInfo->stdVPSCount", "pParametersAddInfo->pStdVPSs", structure->pParametersAddInfo->stdVPSCount, &structure->pParametersAddInfo->pStdVPSs, true, false, "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdVPSCount-arraylength", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdVPSs-parameter");

                    skip |= ValidateArray(loc, "pParametersAddInfo->stdSPSCount", "pParametersAddInfo->pStdSPSs", structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, true, false, "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdSPSCount-arraylength", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdSPSs-parameter");

                    skip |= ValidateArray(loc, "pParametersAddInfo->stdPPSCount", "pParametersAddInfo->pStdPPSs", structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, true, false, "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdPPSCount-arraylength", "VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdPPSs-parameter");
                }
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265SessionParametersGetInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT: { // Covers VUID-VkVideoEncodeH265SessionParametersGetInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265SessionParametersGetInfoEXT *structure = (VkVideoEncodeH265SessionParametersGetInfoEXT *) header;
                skip |= ValidateBool32(loc, "writeStdVPS", structure->writeStdVPS);

                skip |= ValidateBool32(loc, "writeStdSPS", structure->writeStdSPS);

                skip |= ValidateBool32(loc, "writeStdPPS", structure->writeStdPPS);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH265SessionParametersFeedbackInfoEXT structure members  -- Covers VUID-VkVideoEncodeH265SessionParametersFeedbackInfoEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265PictureInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT: { // Covers VUID-VkVideoEncodeH265PictureInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265PictureInfoEXT *structure = (VkVideoEncodeH265PictureInfoEXT *) header;
                skip |= ValidateStructTypeArray(loc, "naluSliceSegmentEntryCount", "pNaluSliceSegmentEntries", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT", structure->naluSliceSegmentEntryCount, structure->pNaluSliceSegmentEntries, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT, true, true, "VUID-VkVideoEncodeH265NaluSliceSegmentInfoEXT-sType-sType", "VUID-VkVideoEncodeH265PictureInfoEXT-pNaluSliceSegmentEntries-parameter", "VUID-VkVideoEncodeH265PictureInfoEXT-naluSliceSegmentEntryCount-arraylength");

                if (structure->pNaluSliceSegmentEntries != nullptr)
                {
                    for (uint32_t naluSliceSegmentEntryIndex = 0; naluSliceSegmentEntryIndex < structure->naluSliceSegmentEntryCount; ++naluSliceSegmentEntryIndex)
                    {
                        skip |= ValidateRequiredPointer(loc, ParameterName("pNaluSliceSegmentEntries[%i].pStdSliceSegmentHeader", ParameterName::IndexVector{ naluSliceSegmentEntryIndex }), structure->pNaluSliceSegmentEntries[naluSliceSegmentEntryIndex].pStdSliceSegmentHeader, "VUID-VkVideoEncodeH265NaluSliceSegmentInfoEXT-pStdSliceSegmentHeader-parameter");
                    }
                }

                skip |= ValidateRequiredPointer(loc, "pStdPictureInfo", structure->pStdPictureInfo, "VUID-VkVideoEncodeH265PictureInfoEXT-pStdPictureInfo-parameter");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265DpbSlotInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT: { // Covers VUID-VkVideoEncodeH265DpbSlotInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265DpbSlotInfoEXT *structure = (VkVideoEncodeH265DpbSlotInfoEXT *) header;
                skip |= ValidateRequiredPointer(loc, "pStdReferenceInfo", structure->pStdReferenceInfo, "VUID-VkVideoEncodeH265DpbSlotInfoEXT-pStdReferenceInfo-parameter");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkVideoEncodeH265ProfileInfoEXT structure members  -- Covers VUID-VkVideoEncodeH265ProfileInfoEXT-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265RateControlInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT: { // Covers VUID-VkVideoEncodeH265RateControlInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265RateControlInfoEXT *structure = (VkVideoEncodeH265RateControlInfoEXT *) header;
                skip |= ValidateFlags(loc, "flags", "VkVideoEncodeH265RateControlFlagBitsEXT", AllVkVideoEncodeH265RateControlFlagBitsEXT, structure->flags, kRequiredFlags, "VUID-VkVideoEncodeH265RateControlInfoEXT-flags-parameter", "VUID-VkVideoEncodeH265RateControlInfoEXT-flags-requiredbitmask");
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265RateControlLayerInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT: { // Covers VUID-VkVideoEncodeH265RateControlLayerInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265RateControlLayerInfoEXT *structure = (VkVideoEncodeH265RateControlLayerInfoEXT *) header;
                skip |= ValidateBool32(loc, "useMinQp", structure->useMinQp);

                skip |= ValidateBool32(loc, "useMaxQp", structure->useMaxQp);

                skip |= ValidateBool32(loc, "useMaxFrameSize", structure->useMaxFrameSize);

            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkVideoEncodeH265GopRemainingFrameInfoEXT structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT: { // Covers VUID-VkVideoEncodeH265GopRemainingFrameInfoEXT-sType-sType
            if (is_const_param) {
                VkVideoEncodeH265GopRemainingFrameInfoEXT *structure = (VkVideoEncodeH265GopRemainingFrameInfoEXT *) header;
                skip |= ValidateBool32(loc, "useGopRemainingFrames", structure->useGopRemainingFrames);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkTextureLODGatherFormatPropertiesAMD structure members  -- Covers VUID-VkTextureLODGatherFormatPropertiesAMD-sType-sType

        // Validation code for VkPhysicalDeviceCornerSampledImageFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceCornerSampledImageFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCornerSampledImageFeaturesNV *structure = (VkPhysicalDeviceCornerSampledImageFeaturesNV *) header;
                skip |= ValidateBool32(loc, "cornerSampledImage", structure->cornerSampledImage);
            }
        } break;

        // Validation code for VkExternalMemoryImageCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: { // Covers VUID-VkExternalMemoryImageCreateInfoNV-sType-sType
            if (is_const_param) {
                VkExternalMemoryImageCreateInfoNV *structure = (VkExternalMemoryImageCreateInfoNV *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleTypes, kOptionalFlags, "VUID-VkExternalMemoryImageCreateInfoNV-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportMemoryAllocateInfoNV structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: { // Covers VUID-VkExportMemoryAllocateInfoNV-sType-sType
            if (is_const_param) {
                VkExportMemoryAllocateInfoNV *structure = (VkExportMemoryAllocateInfoNV *) header;
                skip |= ValidateFlags(loc, "handleTypes", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleTypes, kOptionalFlags, "VUID-VkExportMemoryAllocateInfoNV-handleTypes-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryWin32HandleInfoNV structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: { // Covers VUID-VkImportMemoryWin32HandleInfoNV-sType-sType
            if (is_const_param) {
                VkImportMemoryWin32HandleInfoNV *structure = (VkImportMemoryWin32HandleInfoNV *) header;
                skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleType, kOptionalFlags, "VUID-VkImportMemoryWin32HandleInfoNV-handleType-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkExportMemoryWin32HandleInfoNV structure members  -- Covers VUID-VkExportMemoryWin32HandleInfoNV-sType-sType
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkWin32KeyedMutexAcquireReleaseInfoNV structure members
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: { // Covers VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-sType-sType
            if (is_const_param) {
                VkWin32KeyedMutexAcquireReleaseInfoNV *structure = (VkWin32KeyedMutexAcquireReleaseInfoNV *) header;
                skip |= ValidateArray(loc, "acquireCount", "pAcquireSyncs", structure->acquireCount, &structure->pAcquireSyncs, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireSyncs-parameter");

                skip |= ValidateArray(loc, "acquireCount", "pAcquireKeys", structure->acquireCount, &structure->pAcquireKeys, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireKeys-parameter");

                skip |= ValidateArray(loc, "acquireCount", "pAcquireTimeoutMilliseconds", structure->acquireCount, &structure->pAcquireTimeoutMilliseconds, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireTimeoutMilliseconds-parameter");

                skip |= ValidateArray(loc, "releaseCount", "pReleaseSyncs", structure->releaseCount, &structure->pReleaseSyncs, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseSyncs-parameter");

                skip |= ValidateArray(loc, "releaseCount", "pReleaseKeys", structure->releaseCount, &structure->pReleaseKeys, false, true, kVUIDUndefined, "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseKeys-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkValidationFlagsEXT structure members
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: { // Covers VUID-VkValidationFlagsEXT-sType-sType
            if (is_const_param) {
                VkValidationFlagsEXT *structure = (VkValidationFlagsEXT *) header;
                skip |= ValidateRangedEnumArray(loc, "disabledValidationCheckCount", "pDisabledValidationChecks", "VkValidationCheckEXT", structure->disabledValidationCheckCount, structure->pDisabledValidationChecks, true, true);
            }
        } break;

        // Validation code for VkImageViewASTCDecodeModeEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: { // Covers VUID-VkImageViewASTCDecodeModeEXT-sType-sType
            if (is_const_param) {
                VkImageViewASTCDecodeModeEXT *structure = (VkImageViewASTCDecodeModeEXT *) header;
                skip |= ValidateRangedEnum(loc, "decodeMode", "VkFormat", structure->decodeMode, "VUID-VkImageViewASTCDecodeModeEXT-decodeMode-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceASTCDecodeFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceASTCDecodeFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceASTCDecodeFeaturesEXT *structure = (VkPhysicalDeviceASTCDecodeFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "decodeModeSharedExponent", structure->decodeModeSharedExponent);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineRobustnessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePipelineRobustnessFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePipelineRobustnessFeaturesEXT *structure = (VkPhysicalDevicePipelineRobustnessFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "pipelineRobustness", structure->pipelineRobustness);
            }
        } break;

        // No Validation code for VkPhysicalDevicePipelineRobustnessPropertiesEXT structure members  -- Covers VUID-VkPhysicalDevicePipelineRobustnessPropertiesEXT-sType-sType

        // Validation code for VkPipelineRobustnessCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: { // Covers VUID-VkPipelineRobustnessCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineRobustnessCreateInfoEXT *structure = (VkPipelineRobustnessCreateInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "storageBuffers", "VkPipelineRobustnessBufferBehaviorEXT", structure->storageBuffers, "VUID-VkPipelineRobustnessCreateInfoEXT-storageBuffers-parameter");

                skip |= ValidateRangedEnum(loc, "uniformBuffers", "VkPipelineRobustnessBufferBehaviorEXT", structure->uniformBuffers, "VUID-VkPipelineRobustnessCreateInfoEXT-uniformBuffers-parameter");

                skip |= ValidateRangedEnum(loc, "vertexInputs", "VkPipelineRobustnessBufferBehaviorEXT", structure->vertexInputs, "VUID-VkPipelineRobustnessCreateInfoEXT-vertexInputs-parameter");

                skip |= ValidateRangedEnum(loc, "images", "VkPipelineRobustnessImageBehaviorEXT", structure->images, "VUID-VkPipelineRobustnessCreateInfoEXT-images-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceConditionalRenderingFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceConditionalRenderingFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceConditionalRenderingFeaturesEXT *structure = (VkPhysicalDeviceConditionalRenderingFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "conditionalRendering", structure->conditionalRendering);

                skip |= ValidateBool32(loc, "inheritedConditionalRendering", structure->inheritedConditionalRendering);
            }
        } break;

        // Validation code for VkCommandBufferInheritanceConditionalRenderingInfoEXT structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: { // Covers VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-sType-sType
            if (is_const_param) {
                VkCommandBufferInheritanceConditionalRenderingInfoEXT *structure = (VkCommandBufferInheritanceConditionalRenderingInfoEXT *) header;
                skip |= ValidateBool32(loc, "conditionalRenderingEnable", structure->conditionalRenderingEnable);
            }
        } break;

        // Validation code for VkPipelineViewportWScalingStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineViewportWScalingStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineViewportWScalingStateCreateInfoNV *structure = (VkPipelineViewportWScalingStateCreateInfoNV *) header;
                skip |= ValidateBool32(loc, "viewportWScalingEnable", structure->viewportWScalingEnable);

                skip |= ValidateArray(loc, "viewportCount", "", structure->viewportCount, &structure->pViewportWScalings, true, false, "VUID-VkPipelineViewportWScalingStateCreateInfoNV-viewportCount-arraylength", kVUIDUndefined);
            }
        } break;

        // Validation code for VkSwapchainCounterCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: { // Covers VUID-VkSwapchainCounterCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkSwapchainCounterCreateInfoEXT *structure = (VkSwapchainCounterCreateInfoEXT *) header;
                skip |= ValidateFlags(loc, "surfaceCounters", "VkSurfaceCounterFlagBitsEXT", AllVkSurfaceCounterFlagBitsEXT, structure->surfaceCounters, kOptionalFlags, "VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter");
            }
        } break;

        // Validation code for VkPresentTimesInfoGOOGLE structure members
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: { // Covers VUID-VkPresentTimesInfoGOOGLE-sType-sType
            if (is_const_param) {
                VkPresentTimesInfoGOOGLE *structure = (VkPresentTimesInfoGOOGLE *) header;
                skip |= ValidateArray(loc, "swapchainCount", "pTimes", structure->swapchainCount, &structure->pTimes, true, false, "VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength", "VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter");

                if (structure->pTimes != nullptr)
                {
                    for (uint32_t swapchainIndex = 0; swapchainIndex < structure->swapchainCount; ++swapchainIndex)
                    {
                    }
                }
            }
        } break;

        // No Validation code for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure members  -- Covers VUID-VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX-sType-sType

        // Validation code for VkPipelineViewportSwizzleStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineViewportSwizzleStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineViewportSwizzleStateCreateInfoNV *structure = (VkPipelineViewportSwizzleStateCreateInfoNV *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateArray(loc, "viewportCount", "pViewportSwizzles", structure->viewportCount, &structure->pViewportSwizzles, true, true, "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-arraylength", "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-pViewportSwizzles-parameter");

                if (structure->pViewportSwizzles != nullptr)
                {
                    for (uint32_t viewportIndex = 0; viewportIndex < structure->viewportCount; ++viewportIndex)
                    {
                        skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].x", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", structure->pViewportSwizzles[viewportIndex].x, "VUID-VkViewportSwizzleNV-x-parameter");

                        skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].y", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", structure->pViewportSwizzles[viewportIndex].y, "VUID-VkViewportSwizzleNV-y-parameter");

                        skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].z", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", structure->pViewportSwizzles[viewportIndex].z, "VUID-VkViewportSwizzleNV-z-parameter");

                        skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].w", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", structure->pViewportSwizzles[viewportIndex].w, "VUID-VkViewportSwizzleNV-w-parameter");
                    }
                }
            }
        } break;

        // No Validation code for VkPhysicalDeviceDiscardRectanglePropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceDiscardRectanglePropertiesEXT-sType-sType

        // Validation code for VkPipelineDiscardRectangleStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineDiscardRectangleStateCreateInfoEXT *structure = (VkPipelineDiscardRectangleStateCreateInfoEXT *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRangedEnum(loc, "discardRectangleMode", "VkDiscardRectangleModeEXT", structure->discardRectangleMode, "VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleMode-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceConservativeRasterizationPropertiesEXT-sType-sType

        // Validation code for VkPipelineRasterizationConservativeStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineRasterizationConservativeStateCreateInfoEXT *structure = (VkPipelineRasterizationConservativeStateCreateInfoEXT *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRangedEnum(loc, "conservativeRasterizationMode", "VkConservativeRasterizationModeEXT", structure->conservativeRasterizationMode, "VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-conservativeRasterizationMode-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClipEnableFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDepthClipEnableFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDepthClipEnableFeaturesEXT *structure = (VkPhysicalDeviceDepthClipEnableFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "depthClipEnable", structure->depthClipEnable);
            }
        } break;

        // Validation code for VkPipelineRasterizationDepthClipStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineRasterizationDepthClipStateCreateInfoEXT *structure = (VkPipelineRasterizationDepthClipStateCreateInfoEXT *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateBool32(loc, "depthClipEnable", structure->depthClipEnable);
            }
        } break;

        // Validation code for VkDebugUtilsObjectNameInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: { // Covers VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType
            if (is_const_param) {
                VkDebugUtilsObjectNameInfoEXT *structure = (VkDebugUtilsObjectNameInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "objectType", "VkObjectType", structure->objectType, "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter");
            }
        } break;

        // Validation code for VkDebugUtilsMessengerCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: { // Covers VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkDebugUtilsMessengerCreateInfoEXT *structure = (VkDebugUtilsMessengerCreateInfoEXT *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateFlags(loc, "messageSeverity", "VkDebugUtilsMessageSeverityFlagBitsEXT", AllVkDebugUtilsMessageSeverityFlagBitsEXT, structure->messageSeverity, kRequiredFlags, "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter", "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask");

                skip |= ValidateFlags(loc, "messageType", "VkDebugUtilsMessageTypeFlagBitsEXT", AllVkDebugUtilsMessageTypeFlagBitsEXT, structure->messageType, kRequiredFlags, "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter", "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask");

                skip |= ValidateRequiredPointer(loc, "pfnUserCallback", reinterpret_cast<const void*>(structure->pfnUserCallback), "VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkAndroidHardwareBufferUsageANDROID structure members  -- Covers VUID-VkAndroidHardwareBufferUsageANDROID-sType-sType
#endif // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkAndroidHardwareBufferFormatPropertiesANDROID structure members  -- Covers VUID-VkAndroidHardwareBufferFormatPropertiesANDROID-sType-sType
#endif // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkImportAndroidHardwareBufferInfoANDROID structure members
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: { // Covers VUID-VkImportAndroidHardwareBufferInfoANDROID-sType-sType
            if (is_const_param) {
                VkImportAndroidHardwareBufferInfoANDROID *structure = (VkImportAndroidHardwareBufferInfoANDROID *) header;
                skip |= ValidateRequiredPointer(loc, "buffer", structure->buffer, "VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkExternalFormatANDROID structure members  -- Covers VUID-VkExternalFormatANDROID-sType-sType
#endif // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkAndroidHardwareBufferFormatProperties2ANDROID structure members  -- Covers VUID-VkAndroidHardwareBufferFormatProperties2ANDROID-sType-sType
#endif // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceShaderEnqueueFeaturesAMDX structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX: { // Covers VUID-VkPhysicalDeviceShaderEnqueueFeaturesAMDX-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderEnqueueFeaturesAMDX *structure = (VkPhysicalDeviceShaderEnqueueFeaturesAMDX *) header;
                skip |= ValidateBool32(loc, "shaderEnqueue", structure->shaderEnqueue);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceShaderEnqueuePropertiesAMDX structure members  -- Covers VUID-VkPhysicalDeviceShaderEnqueuePropertiesAMDX-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPipelineShaderStageNodeCreateInfoAMDX structure members  -- Covers VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkSampleLocationsInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: { // Covers VUID-VkSampleLocationsInfoEXT-sType-sType
            if (is_const_param) {
                VkSampleLocationsInfoEXT *structure = (VkSampleLocationsInfoEXT *) header;
                skip |= ValidateArray(loc, "sampleLocationsCount", "pSampleLocations", structure->sampleLocationsCount, &structure->pSampleLocations, false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                if (structure->pSampleLocations != nullptr)
                {
                    for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < structure->sampleLocationsCount; ++sampleLocationsIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassSampleLocationsBeginInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: { // Covers VUID-VkRenderPassSampleLocationsBeginInfoEXT-sType-sType
            if (is_const_param) {
                VkRenderPassSampleLocationsBeginInfoEXT *structure = (VkRenderPassSampleLocationsBeginInfoEXT *) header;
                skip |= ValidateArray(loc, "attachmentInitialSampleLocationsCount", "pAttachmentInitialSampleLocations", structure->attachmentInitialSampleLocationsCount, &structure->pAttachmentInitialSampleLocations, false, true, kVUIDUndefined, "VUID-VkRenderPassSampleLocationsBeginInfoEXT-pAttachmentInitialSampleLocations-parameter");

                if (structure->pAttachmentInitialSampleLocations != nullptr)
                {
                    for (uint32_t attachmentInitialSampleLocationsIndex = 0; attachmentInitialSampleLocationsIndex < structure->attachmentInitialSampleLocationsCount; ++attachmentInitialSampleLocationsIndex)
                    {
                        skip |= ValidateStructType(loc, ParameterName("pAttachmentInitialSampleLocations[%i].sampleLocationsInfo", ParameterName::IndexVector{ attachmentInitialSampleLocationsIndex }), "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", &(structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex].sampleLocationsInfo), VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-sType-sType");

                        skip |= ValidateArray(loc, ParameterName("pAttachmentInitialSampleLocations[%i].sampleLocationsInfo.sampleLocationsCount", ParameterName::IndexVector{ attachmentInitialSampleLocationsIndex }), ParameterName("pAttachmentInitialSampleLocations[%i].sampleLocationsInfo.pSampleLocations", ParameterName::IndexVector{ attachmentInitialSampleLocationsIndex }), structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex].sampleLocationsInfo.sampleLocationsCount, &structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex].sampleLocationsInfo.pSampleLocations, false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                        if (structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex].sampleLocationsInfo.pSampleLocations != nullptr)
                        {
                            for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex].sampleLocationsInfo.sampleLocationsCount; ++sampleLocationsIndex)
                            {
                            }
                        }
                    }
                }

                skip |= ValidateArray(loc, "postSubpassSampleLocationsCount", "pPostSubpassSampleLocations", structure->postSubpassSampleLocationsCount, &structure->pPostSubpassSampleLocations, false, true, kVUIDUndefined, "VUID-VkRenderPassSampleLocationsBeginInfoEXT-pPostSubpassSampleLocations-parameter");

                if (structure->pPostSubpassSampleLocations != nullptr)
                {
                    for (uint32_t postSubpassSampleLocationsIndex = 0; postSubpassSampleLocationsIndex < structure->postSubpassSampleLocationsCount; ++postSubpassSampleLocationsIndex)
                    {
                        skip |= ValidateStructType(loc, ParameterName("pPostSubpassSampleLocations[%i].sampleLocationsInfo", ParameterName::IndexVector{ postSubpassSampleLocationsIndex }), "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", &(structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo), VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-sType-sType");

                        skip |= ValidateArray(loc, ParameterName("pPostSubpassSampleLocations[%i].sampleLocationsInfo.sampleLocationsCount", ParameterName::IndexVector{ postSubpassSampleLocationsIndex }), ParameterName("pPostSubpassSampleLocations[%i].sampleLocationsInfo.pSampleLocations", ParameterName::IndexVector{ postSubpassSampleLocationsIndex }), structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo.sampleLocationsCount, &structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo.pSampleLocations, false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                        if (structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo.pSampleLocations != nullptr)
                        {
                            for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo.sampleLocationsCount; ++sampleLocationsIndex)
                            {
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkPipelineSampleLocationsStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineSampleLocationsStateCreateInfoEXT *structure = (VkPipelineSampleLocationsStateCreateInfoEXT *) header;
                skip |= ValidateBool32(loc, "sampleLocationsEnable", structure->sampleLocationsEnable);

                skip |= ValidateStructType(loc, "sampleLocationsInfo", "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", &(structure->sampleLocationsInfo), VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-sType-sType");

                skip |= ValidateArray(loc, "sampleLocationsInfo.sampleLocationsCount", "sampleLocationsInfo.pSampleLocations", structure->sampleLocationsInfo.sampleLocationsCount, &structure->sampleLocationsInfo.pSampleLocations, false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                if (structure->sampleLocationsInfo.pSampleLocations != nullptr)
                {
                    for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < structure->sampleLocationsInfo.sampleLocationsCount; ++sampleLocationsIndex)
                    {
                    }
                }
            }
        } break;

        // No Validation code for VkPhysicalDeviceSampleLocationsPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceSampleLocationsPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *structure = (VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "advancedBlendCoherentOperations", structure->advancedBlendCoherentOperations);
            }
        } break;

        // No Validation code for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT-sType-sType

        // Validation code for VkPipelineColorBlendAdvancedStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineColorBlendAdvancedStateCreateInfoEXT *structure = (VkPipelineColorBlendAdvancedStateCreateInfoEXT *) header;
                skip |= ValidateBool32(loc, "srcPremultiplied", structure->srcPremultiplied);

                skip |= ValidateBool32(loc, "dstPremultiplied", structure->dstPremultiplied);

                skip |= ValidateRangedEnum(loc, "blendOverlap", "VkBlendOverlapEXT", structure->blendOverlap, "VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-parameter");
            }
        } break;

        // Validation code for VkPipelineCoverageToColorStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineCoverageToColorStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineCoverageToColorStateCreateInfoNV *structure = (VkPipelineCoverageToColorStateCreateInfoNV *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineCoverageToColorStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateBool32(loc, "coverageToColorEnable", structure->coverageToColorEnable);
            }
        } break;

        // Validation code for VkPipelineCoverageModulationStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineCoverageModulationStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineCoverageModulationStateCreateInfoNV *structure = (VkPipelineCoverageModulationStateCreateInfoNV *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineCoverageModulationStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateRangedEnum(loc, "coverageModulationMode", "VkCoverageModulationModeNV", structure->coverageModulationMode, "VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationMode-parameter");

                skip |= ValidateBool32(loc, "coverageModulationTableEnable", structure->coverageModulationTableEnable);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceShaderSMBuiltinsPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceShaderSMBuiltinsFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *structure = (VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *) header;
                skip |= ValidateBool32(loc, "shaderSMBuiltins", structure->shaderSMBuiltins);
            }
        } break;

        // No Validation code for VkDrmFormatModifierPropertiesListEXT structure members  -- Covers VUID-VkDrmFormatModifierPropertiesListEXT-sType-sType

        // Validation code for VkPhysicalDeviceImageDrmFormatModifierInfoEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: { // Covers VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageDrmFormatModifierInfoEXT *structure = (VkPhysicalDeviceImageDrmFormatModifierInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "sharingMode", "VkSharingMode", structure->sharingMode, "VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-parameter");
            }
        } break;

        // Validation code for VkImageDrmFormatModifierListCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: { // Covers VUID-VkImageDrmFormatModifierListCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkImageDrmFormatModifierListCreateInfoEXT *structure = (VkImageDrmFormatModifierListCreateInfoEXT *) header;
                skip |= ValidateArray(loc, "drmFormatModifierCount", "pDrmFormatModifiers", structure->drmFormatModifierCount, &structure->pDrmFormatModifiers, true, true, "VUID-VkImageDrmFormatModifierListCreateInfoEXT-drmFormatModifierCount-arraylength", "VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-parameter");
            }
        } break;

        // Validation code for VkImageDrmFormatModifierExplicitCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: { // Covers VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkImageDrmFormatModifierExplicitCreateInfoEXT *structure = (VkImageDrmFormatModifierExplicitCreateInfoEXT *) header;
                skip |= ValidateArray(loc, "drmFormatModifierPlaneCount", "pPlaneLayouts", structure->drmFormatModifierPlaneCount, &structure->pPlaneLayouts, true, true, "VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifierPlaneCount-arraylength", "VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-pPlaneLayouts-parameter");

                if (structure->pPlaneLayouts != nullptr)
                {
                    for (uint32_t drmFormatModifierPlaneIndex = 0; drmFormatModifierPlaneIndex < structure->drmFormatModifierPlaneCount; ++drmFormatModifierPlaneIndex)
                    {
                    }
                }
            }
        } break;

        // No Validation code for VkDrmFormatModifierPropertiesList2EXT structure members  -- Covers VUID-VkDrmFormatModifierPropertiesList2EXT-sType-sType

        // Validation code for VkShaderModuleValidationCacheCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: { // Covers VUID-VkShaderModuleValidationCacheCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkShaderModuleValidationCacheCreateInfoEXT *structure = (VkShaderModuleValidationCacheCreateInfoEXT *) header;
                skip |= ValidateRequiredHandle(loc, "validationCache", structure->validationCache);
            }
        } break;

        // Validation code for VkPipelineViewportShadingRateImageStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineViewportShadingRateImageStateCreateInfoNV *structure = (VkPipelineViewportShadingRateImageStateCreateInfoNV *) header;
                skip |= ValidateBool32(loc, "shadingRateImageEnable", structure->shadingRateImageEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceShadingRateImageFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceShadingRateImageFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShadingRateImageFeaturesNV *structure = (VkPhysicalDeviceShadingRateImageFeaturesNV *) header;
                skip |= ValidateBool32(loc, "shadingRateImage", structure->shadingRateImage);

                skip |= ValidateBool32(loc, "shadingRateCoarseSampleOrder", structure->shadingRateCoarseSampleOrder);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShadingRateImagePropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceShadingRateImagePropertiesNV-sType-sType

        // Validation code for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *structure = (VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *) header;
                skip |= ValidateRangedEnum(loc, "sampleOrderType", "VkCoarseSampleOrderTypeNV", structure->sampleOrderType, "VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-parameter");

                skip |= ValidateArray(loc, "customSampleOrderCount", "pCustomSampleOrders", structure->customSampleOrderCount, &structure->pCustomSampleOrders, false, true, kVUIDUndefined, "VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-parameter");

                if (structure->pCustomSampleOrders != nullptr)
                {
                    for (uint32_t customSampleOrderIndex = 0; customSampleOrderIndex < structure->customSampleOrderCount; ++customSampleOrderIndex)
                    {
                        skip |= ValidateRangedEnum(loc, ParameterName("pCustomSampleOrders[%i].shadingRate", ParameterName::IndexVector{ customSampleOrderIndex }), "VkShadingRatePaletteEntryNV", structure->pCustomSampleOrders[customSampleOrderIndex].shadingRate, "VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter");

                        skip |= ValidateArray(loc, ParameterName("pCustomSampleOrders[%i].sampleLocationCount", ParameterName::IndexVector{ customSampleOrderIndex }), ParameterName("pCustomSampleOrders[%i].pSampleLocations", ParameterName::IndexVector{ customSampleOrderIndex }), structure->pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount, &structure->pCustomSampleOrders[customSampleOrderIndex].pSampleLocations, true, true, "VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength", "VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter");

                        if (structure->pCustomSampleOrders[customSampleOrderIndex].pSampleLocations != nullptr)
                        {
                            for (uint32_t sampleLocationIndex = 0; sampleLocationIndex < structure->pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount; ++sampleLocationIndex)
                            {
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkWriteDescriptorSetAccelerationStructureNV structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: { // Covers VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType
            if (is_const_param) {
                VkWriteDescriptorSetAccelerationStructureNV *structure = (VkWriteDescriptorSetAccelerationStructureNV *) header;
                skip |= ValidateArray(loc, "accelerationStructureCount", "pAccelerationStructures", structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false, "VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength", "VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceRayTracingPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceRayTracingPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *structure = (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *) header;
                skip |= ValidateBool32(loc, "representativeFragmentTest", structure->representativeFragmentTest);
            }
        } break;

        // Validation code for VkPipelineRepresentativeFragmentTestStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineRepresentativeFragmentTestStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineRepresentativeFragmentTestStateCreateInfoNV *structure = (VkPipelineRepresentativeFragmentTestStateCreateInfoNV *) header;
                skip |= ValidateBool32(loc, "representativeFragmentTestEnable", structure->representativeFragmentTestEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageViewImageFormatInfoEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: { // Covers VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageViewImageFormatInfoEXT *structure = (VkPhysicalDeviceImageViewImageFormatInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "imageViewType", "VkImageViewType", structure->imageViewType, "VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-imageViewType-parameter");
            }
        } break;

        // No Validation code for VkFilterCubicImageViewImageFormatPropertiesEXT structure members  -- Covers VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-sType-sType

        // Validation code for VkImportMemoryHostPointerInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: { // Covers VUID-VkImportMemoryHostPointerInfoEXT-sType-sType
            if (is_const_param) {
                VkImportMemoryHostPointerInfoEXT *structure = (VkImportMemoryHostPointerInfoEXT *) header;
                skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kRequiredSingleBit, "VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter", "VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter");

                skip |= ValidateRequiredPointer(loc, "pHostPointer", structure->pHostPointer, "VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceExternalMemoryHostPropertiesEXT-sType-sType

        // Validation code for VkPipelineCompilerControlCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: { // Covers VUID-VkPipelineCompilerControlCreateInfoAMD-sType-sType
            if (is_const_param) {
                VkPipelineCompilerControlCreateInfoAMD *structure = (VkPipelineCompilerControlCreateInfoAMD *) header;
                skip |= ValidateReservedFlags(loc, "compilerControlFlags", structure->compilerControlFlags, "VUID-VkPipelineCompilerControlCreateInfoAMD-compilerControlFlags-zerobitmask");
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderCorePropertiesAMD structure members  -- Covers VUID-VkPhysicalDeviceShaderCorePropertiesAMD-sType-sType

        // Validation code for VkDeviceMemoryOverallocationCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: { // Covers VUID-VkDeviceMemoryOverallocationCreateInfoAMD-sType-sType
            if (is_const_param) {
                VkDeviceMemoryOverallocationCreateInfoAMD *structure = (VkDeviceMemoryOverallocationCreateInfoAMD *) header;
                skip |= ValidateRangedEnum(loc, "overallocationBehavior", "VkMemoryOverallocationBehaviorAMD", structure->overallocationBehavior, "VUID-VkDeviceMemoryOverallocationCreateInfoAMD-overallocationBehavior-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT-sType-sType

        // Validation code for VkPipelineVertexInputDivisorStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineVertexInputDivisorStateCreateInfoEXT *structure = (VkPipelineVertexInputDivisorStateCreateInfoEXT *) header;
                skip |= ValidateArray(loc, "vertexBindingDivisorCount", "pVertexBindingDivisors", structure->vertexBindingDivisorCount, &structure->pVertexBindingDivisors, true, true, "VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-vertexBindingDivisorCount-arraylength", "VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-pVertexBindingDivisors-parameter");

                if (structure->pVertexBindingDivisors != nullptr)
                {
                    for (uint32_t vertexBindingDivisorIndex = 0; vertexBindingDivisorIndex < structure->vertexBindingDivisorCount; ++vertexBindingDivisorIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *structure = (VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "vertexAttributeInstanceRateDivisor", structure->vertexAttributeInstanceRateDivisor);

                skip |= ValidateBool32(loc, "vertexAttributeInstanceRateZeroDivisor", structure->vertexAttributeInstanceRateZeroDivisor);
            }
        } break;
#ifdef VK_USE_PLATFORM_GGP

        // No Validation code for VkPresentFrameTokenGGP structure members  -- Covers VUID-VkPresentFrameTokenGGP-sType-sType
#endif // VK_USE_PLATFORM_GGP

        // Validation code for VkPhysicalDeviceComputeShaderDerivativesFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceComputeShaderDerivativesFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *structure = (VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *) header;
                skip |= ValidateBool32(loc, "computeDerivativeGroupQuads", structure->computeDerivativeGroupQuads);

                skip |= ValidateBool32(loc, "computeDerivativeGroupLinear", structure->computeDerivativeGroupLinear);
            }
        } break;

        // Validation code for VkPhysicalDeviceMeshShaderFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceMeshShaderFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMeshShaderFeaturesNV *structure = (VkPhysicalDeviceMeshShaderFeaturesNV *) header;
                skip |= ValidateBool32(loc, "taskShader", structure->taskShader);

                skip |= ValidateBool32(loc, "meshShader", structure->meshShader);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMeshShaderPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceMeshShaderPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceShaderImageFootprintFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceShaderImageFootprintFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderImageFootprintFeaturesNV *structure = (VkPhysicalDeviceShaderImageFootprintFeaturesNV *) header;
                skip |= ValidateBool32(loc, "imageFootprint", structure->imageFootprint);
            }
        } break;

        // No Validation code for VkPipelineViewportExclusiveScissorStateCreateInfoNV structure members  -- Covers VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-sType-sType

        // Validation code for VkPhysicalDeviceExclusiveScissorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceExclusiveScissorFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExclusiveScissorFeaturesNV *structure = (VkPhysicalDeviceExclusiveScissorFeaturesNV *) header;
                skip |= ValidateBool32(loc, "exclusiveScissor", structure->exclusiveScissor);
            }
        } break;

        // No Validation code for VkQueueFamilyCheckpointPropertiesNV structure members  -- Covers VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: { // Covers VUID-VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *structure = (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *) header;
                skip |= ValidateBool32(loc, "shaderIntegerFunctions2", structure->shaderIntegerFunctions2);
            }
        } break;

        // Validation code for VkQueryPoolPerformanceQueryCreateInfoINTEL structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: { // Covers VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-sType-sType
            if (is_const_param) {
                VkQueryPoolPerformanceQueryCreateInfoINTEL *structure = (VkQueryPoolPerformanceQueryCreateInfoINTEL *) header;
                skip |= ValidateRangedEnum(loc, "performanceCountersSampling", "VkQueryPoolSamplingModeINTEL", structure->performanceCountersSampling, "VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-performanceCountersSampling-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDevicePCIBusInfoPropertiesEXT structure members  -- Covers VUID-VkPhysicalDevicePCIBusInfoPropertiesEXT-sType-sType

        // No Validation code for VkDisplayNativeHdrSurfaceCapabilitiesAMD structure members  -- Covers VUID-VkDisplayNativeHdrSurfaceCapabilitiesAMD-sType-sType

        // Validation code for VkSwapchainDisplayNativeHdrCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: { // Covers VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-sType-sType
            if (is_const_param) {
                VkSwapchainDisplayNativeHdrCreateInfoAMD *structure = (VkSwapchainDisplayNativeHdrCreateInfoAMD *) header;
                skip |= ValidateBool32(loc, "localDimmingEnable", structure->localDimmingEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceFragmentDensityMapFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentDensityMapFeaturesEXT *structure = (VkPhysicalDeviceFragmentDensityMapFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "fragmentDensityMap", structure->fragmentDensityMap);

                skip |= ValidateBool32(loc, "fragmentDensityMapDynamic", structure->fragmentDensityMapDynamic);

                skip |= ValidateBool32(loc, "fragmentDensityMapNonSubsampledImages", structure->fragmentDensityMapNonSubsampledImages);
            }
        } break;

        // No Validation code for VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceFragmentDensityMapPropertiesEXT-sType-sType

        // Validation code for VkRenderPassFragmentDensityMapCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: { // Covers VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkRenderPassFragmentDensityMapCreateInfoEXT *structure = (VkRenderPassFragmentDensityMapCreateInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "fragmentDensityMapAttachment.layout", "VkImageLayout", structure->fragmentDensityMapAttachment.layout, "VUID-VkAttachmentReference-layout-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderCoreProperties2AMD structure members  -- Covers VUID-VkPhysicalDeviceShaderCoreProperties2AMD-sType-sType

        // Validation code for VkPhysicalDeviceCoherentMemoryFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: { // Covers VUID-VkPhysicalDeviceCoherentMemoryFeaturesAMD-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCoherentMemoryFeaturesAMD *structure = (VkPhysicalDeviceCoherentMemoryFeaturesAMD *) header;
                skip |= ValidateBool32(loc, "deviceCoherentMemory", structure->deviceCoherentMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *structure = (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "shaderImageInt64Atomics", structure->shaderImageInt64Atomics);

                skip |= ValidateBool32(loc, "sparseImageInt64Atomics", structure->sparseImageInt64Atomics);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMemoryBudgetPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceMemoryBudgetPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceMemoryPriorityFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceMemoryPriorityFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMemoryPriorityFeaturesEXT *structure = (VkPhysicalDeviceMemoryPriorityFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "memoryPriority", structure->memoryPriority);
            }
        } break;

        // No Validation code for VkMemoryPriorityAllocateInfoEXT structure members  -- Covers VUID-VkMemoryPriorityAllocateInfoEXT-sType-sType

        // Validation code for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *structure = (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *) header;
                skip |= ValidateBool32(loc, "dedicatedAllocationImageAliasing", structure->dedicatedAllocationImageAliasing);
            }
        } break;

        // Validation code for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceBufferDeviceAddressFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *structure = (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "bufferDeviceAddress", structure->bufferDeviceAddress);

                skip |= ValidateBool32(loc, "bufferDeviceAddressCaptureReplay", structure->bufferDeviceAddressCaptureReplay);

                skip |= ValidateBool32(loc, "bufferDeviceAddressMultiDevice", structure->bufferDeviceAddressMultiDevice);
            }
        } break;

        // No Validation code for VkBufferDeviceAddressCreateInfoEXT structure members  -- Covers VUID-VkBufferDeviceAddressCreateInfoEXT-sType-sType

        // Validation code for VkValidationFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: { // Covers VUID-VkValidationFeaturesEXT-sType-sType
            if (is_const_param) {
                VkValidationFeaturesEXT *structure = (VkValidationFeaturesEXT *) header;
                skip |= ValidateRangedEnumArray(loc, "enabledValidationFeatureCount", "pEnabledValidationFeatures", "VkValidationFeatureEnableEXT", structure->enabledValidationFeatureCount, structure->pEnabledValidationFeatures, false, true);

                skip |= ValidateRangedEnumArray(loc, "disabledValidationFeatureCount", "pDisabledValidationFeatures", "VkValidationFeatureDisableEXT", structure->disabledValidationFeatureCount, structure->pDisabledValidationFeatures, false, true);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrixFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceCooperativeMatrixFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCooperativeMatrixFeaturesNV *structure = (VkPhysicalDeviceCooperativeMatrixFeaturesNV *) header;
                skip |= ValidateBool32(loc, "cooperativeMatrix", structure->cooperativeMatrix);

                skip |= ValidateBool32(loc, "cooperativeMatrixRobustBufferAccess", structure->cooperativeMatrixRobustBufferAccess);
            }
        } break;

        // No Validation code for VkPhysicalDeviceCooperativeMatrixPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceCooperativeMatrixPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceCoverageReductionModeFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceCoverageReductionModeFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCoverageReductionModeFeaturesNV *structure = (VkPhysicalDeviceCoverageReductionModeFeaturesNV *) header;
                skip |= ValidateBool32(loc, "coverageReductionMode", structure->coverageReductionMode);
            }
        } break;

        // Validation code for VkPipelineCoverageReductionStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: { // Covers VUID-VkPipelineCoverageReductionStateCreateInfoNV-sType-sType
            if (is_const_param) {
                VkPipelineCoverageReductionStateCreateInfoNV *structure = (VkPipelineCoverageReductionStateCreateInfoNV *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkPipelineCoverageReductionStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateRangedEnum(loc, "coverageReductionMode", "VkCoverageReductionModeNV", structure->coverageReductionMode, "VUID-VkPipelineCoverageReductionStateCreateInfoNV-coverageReductionMode-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *structure = (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "fragmentShaderSampleInterlock", structure->fragmentShaderSampleInterlock);

                skip |= ValidateBool32(loc, "fragmentShaderPixelInterlock", structure->fragmentShaderPixelInterlock);

                skip |= ValidateBool32(loc, "fragmentShaderShadingRateInterlock", structure->fragmentShaderShadingRateInterlock);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceYcbcrImageArraysFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *structure = (VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "ycbcrImageArrays", structure->ycbcrImageArrays);
            }
        } break;

        // Validation code for VkPhysicalDeviceProvokingVertexFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceProvokingVertexFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceProvokingVertexFeaturesEXT *structure = (VkPhysicalDeviceProvokingVertexFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "provokingVertexLast", structure->provokingVertexLast);

                skip |= ValidateBool32(loc, "transformFeedbackPreservesProvokingVertex", structure->transformFeedbackPreservesProvokingVertex);
            }
        } break;

        // No Validation code for VkPhysicalDeviceProvokingVertexPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceProvokingVertexPropertiesEXT-sType-sType

        // Validation code for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *structure = (VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "provokingVertexMode", "VkProvokingVertexModeEXT", structure->provokingVertexMode, "VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-provokingVertexMode-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkSurfaceFullScreenExclusiveInfoEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: { // Covers VUID-VkSurfaceFullScreenExclusiveInfoEXT-sType-sType
            if (is_const_param) {
                VkSurfaceFullScreenExclusiveInfoEXT *structure = (VkSurfaceFullScreenExclusiveInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "fullScreenExclusive", "VkFullScreenExclusiveEXT", structure->fullScreenExclusive, "VUID-VkSurfaceFullScreenExclusiveInfoEXT-fullScreenExclusive-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkSurfaceCapabilitiesFullScreenExclusiveEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: { // Covers VUID-VkSurfaceCapabilitiesFullScreenExclusiveEXT-sType-sType
            if (is_const_param) {
                VkSurfaceCapabilitiesFullScreenExclusiveEXT *structure = (VkSurfaceCapabilitiesFullScreenExclusiveEXT *) header;
                skip |= ValidateBool32(loc, "fullScreenExclusiveSupported", structure->fullScreenExclusiveSupported);
            }
        } break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkSurfaceFullScreenExclusiveWin32InfoEXT structure members  -- Covers VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-sType-sType
#endif // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkPhysicalDeviceLineRasterizationFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceLineRasterizationFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceLineRasterizationFeaturesEXT *structure = (VkPhysicalDeviceLineRasterizationFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "rectangularLines", structure->rectangularLines);

                skip |= ValidateBool32(loc, "bresenhamLines", structure->bresenhamLines);

                skip |= ValidateBool32(loc, "smoothLines", structure->smoothLines);

                skip |= ValidateBool32(loc, "stippledRectangularLines", structure->stippledRectangularLines);

                skip |= ValidateBool32(loc, "stippledBresenhamLines", structure->stippledBresenhamLines);

                skip |= ValidateBool32(loc, "stippledSmoothLines", structure->stippledSmoothLines);
            }
        } break;

        // No Validation code for VkPhysicalDeviceLineRasterizationPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceLineRasterizationPropertiesEXT-sType-sType

        // Validation code for VkPipelineRasterizationLineStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineRasterizationLineStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineRasterizationLineStateCreateInfoEXT *structure = (VkPipelineRasterizationLineStateCreateInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "lineRasterizationMode", "VkLineRasterizationModeEXT", structure->lineRasterizationMode, "VUID-VkPipelineRasterizationLineStateCreateInfoEXT-lineRasterizationMode-parameter");

                skip |= ValidateBool32(loc, "stippledLineEnable", structure->stippledLineEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceShaderAtomicFloatFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *structure = (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "shaderBufferFloat32Atomics", structure->shaderBufferFloat32Atomics);

                skip |= ValidateBool32(loc, "shaderBufferFloat32AtomicAdd", structure->shaderBufferFloat32AtomicAdd);

                skip |= ValidateBool32(loc, "shaderBufferFloat64Atomics", structure->shaderBufferFloat64Atomics);

                skip |= ValidateBool32(loc, "shaderBufferFloat64AtomicAdd", structure->shaderBufferFloat64AtomicAdd);

                skip |= ValidateBool32(loc, "shaderSharedFloat32Atomics", structure->shaderSharedFloat32Atomics);

                skip |= ValidateBool32(loc, "shaderSharedFloat32AtomicAdd", structure->shaderSharedFloat32AtomicAdd);

                skip |= ValidateBool32(loc, "shaderSharedFloat64Atomics", structure->shaderSharedFloat64Atomics);

                skip |= ValidateBool32(loc, "shaderSharedFloat64AtomicAdd", structure->shaderSharedFloat64AtomicAdd);

                skip |= ValidateBool32(loc, "shaderImageFloat32Atomics", structure->shaderImageFloat32Atomics);

                skip |= ValidateBool32(loc, "shaderImageFloat32AtomicAdd", structure->shaderImageFloat32AtomicAdd);

                skip |= ValidateBool32(loc, "sparseImageFloat32Atomics", structure->sparseImageFloat32Atomics);

                skip |= ValidateBool32(loc, "sparseImageFloat32AtomicAdd", structure->sparseImageFloat32AtomicAdd);
            }
        } break;

        // Validation code for VkPhysicalDeviceIndexTypeUint8FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceIndexTypeUint8FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceIndexTypeUint8FeaturesEXT *structure = (VkPhysicalDeviceIndexTypeUint8FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "indexTypeUint8", structure->indexTypeUint8);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceExtendedDynamicStateFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *structure = (VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "extendedDynamicState", structure->extendedDynamicState);
            }
        } break;

        // Validation code for VkPhysicalDeviceHostImageCopyFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceHostImageCopyFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceHostImageCopyFeaturesEXT *structure = (VkPhysicalDeviceHostImageCopyFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "hostImageCopy", structure->hostImageCopy);
            }
        } break;

        // Validation code for VkPhysicalDeviceHostImageCopyPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT: { // Covers VUID-VkPhysicalDeviceHostImageCopyPropertiesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceHostImageCopyPropertiesEXT *structure = (VkPhysicalDeviceHostImageCopyPropertiesEXT *) header;
                skip |= ValidateBool32(loc, "identicalMemoryTypeRequirements", structure->identicalMemoryTypeRequirements);
            }
        } break;

        // No Validation code for VkSubresourceHostMemcpySizeEXT structure members  -- Covers VUID-VkSubresourceHostMemcpySizeEXT-sType-sType

        // No Validation code for VkHostImageCopyDevicePerformanceQueryEXT structure members  -- Covers VUID-VkHostImageCopyDevicePerformanceQueryEXT-sType-sType

        // Validation code for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *structure = (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "shaderBufferFloat16Atomics", structure->shaderBufferFloat16Atomics);

                skip |= ValidateBool32(loc, "shaderBufferFloat16AtomicAdd", structure->shaderBufferFloat16AtomicAdd);

                skip |= ValidateBool32(loc, "shaderBufferFloat16AtomicMinMax", structure->shaderBufferFloat16AtomicMinMax);

                skip |= ValidateBool32(loc, "shaderBufferFloat32AtomicMinMax", structure->shaderBufferFloat32AtomicMinMax);

                skip |= ValidateBool32(loc, "shaderBufferFloat64AtomicMinMax", structure->shaderBufferFloat64AtomicMinMax);

                skip |= ValidateBool32(loc, "shaderSharedFloat16Atomics", structure->shaderSharedFloat16Atomics);

                skip |= ValidateBool32(loc, "shaderSharedFloat16AtomicAdd", structure->shaderSharedFloat16AtomicAdd);

                skip |= ValidateBool32(loc, "shaderSharedFloat16AtomicMinMax", structure->shaderSharedFloat16AtomicMinMax);

                skip |= ValidateBool32(loc, "shaderSharedFloat32AtomicMinMax", structure->shaderSharedFloat32AtomicMinMax);

                skip |= ValidateBool32(loc, "shaderSharedFloat64AtomicMinMax", structure->shaderSharedFloat64AtomicMinMax);

                skip |= ValidateBool32(loc, "shaderImageFloat32AtomicMinMax", structure->shaderImageFloat32AtomicMinMax);

                skip |= ValidateBool32(loc, "sparseImageFloat32AtomicMinMax", structure->sparseImageFloat32AtomicMinMax);
            }
        } break;

        // Validation code for VkSurfacePresentModeEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: { // Covers VUID-VkSurfacePresentModeEXT-sType-sType
            if (is_const_param) {
                VkSurfacePresentModeEXT *structure = (VkSurfacePresentModeEXT *) header;
                skip |= ValidateRangedEnum(loc, "presentMode", "VkPresentModeKHR", structure->presentMode, "VUID-VkSurfacePresentModeEXT-presentMode-parameter");
            }
        } break;

        // Validation code for VkSurfacePresentScalingCapabilitiesEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: { // Covers VUID-VkSurfacePresentScalingCapabilitiesEXT-sType-sType
            if (is_const_param) {
                VkSurfacePresentScalingCapabilitiesEXT *structure = (VkSurfacePresentScalingCapabilitiesEXT *) header;
                skip |= ValidateFlags(loc, "supportedPresentScaling", "VkPresentScalingFlagBitsEXT", AllVkPresentScalingFlagBitsEXT, structure->supportedPresentScaling, kOptionalFlags, "VUID-VkSurfacePresentScalingCapabilitiesEXT-supportedPresentScaling-parameter");

                skip |= ValidateFlags(loc, "supportedPresentGravityX", "VkPresentGravityFlagBitsEXT", AllVkPresentGravityFlagBitsEXT, structure->supportedPresentGravityX, kOptionalFlags, "VUID-VkSurfacePresentScalingCapabilitiesEXT-supportedPresentGravityX-parameter");

                skip |= ValidateFlags(loc, "supportedPresentGravityY", "VkPresentGravityFlagBitsEXT", AllVkPresentGravityFlagBitsEXT, structure->supportedPresentGravityY, kOptionalFlags, "VUID-VkSurfacePresentScalingCapabilitiesEXT-supportedPresentGravityY-parameter");

            }
        } break;

        // No Validation code for VkSurfacePresentModeCompatibilityEXT structure members  -- Covers VUID-VkSurfacePresentModeCompatibilityEXT-sType-sType

        // Validation code for VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *structure = (VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "swapchainMaintenance1", structure->swapchainMaintenance1);
            }
        } break;

        // Validation code for VkSwapchainPresentFenceInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: { // Covers VUID-VkSwapchainPresentFenceInfoEXT-sType-sType
            if (is_const_param) {
                VkSwapchainPresentFenceInfoEXT *structure = (VkSwapchainPresentFenceInfoEXT *) header;
                skip |= ValidateHandleArray(loc, "swapchainCount", "pFences", structure->swapchainCount, structure->pFences, true, true, kVUIDUndefined);
            }
        } break;

        // Validation code for VkSwapchainPresentModesCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: { // Covers VUID-VkSwapchainPresentModesCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkSwapchainPresentModesCreateInfoEXT *structure = (VkSwapchainPresentModesCreateInfoEXT *) header;
                skip |= ValidateRangedEnumArray(loc, "presentModeCount", "pPresentModes", "VkPresentModeKHR", structure->presentModeCount, structure->pPresentModes, true, true);
            }
        } break;

        // Validation code for VkSwapchainPresentModeInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: { // Covers VUID-VkSwapchainPresentModeInfoEXT-sType-sType
            if (is_const_param) {
                VkSwapchainPresentModeInfoEXT *structure = (VkSwapchainPresentModeInfoEXT *) header;
                skip |= ValidateRangedEnumArray(loc, "swapchainCount", "pPresentModes", "VkPresentModeKHR", structure->swapchainCount, structure->pPresentModes, true, true);
            }
        } break;

        // Validation code for VkSwapchainPresentScalingCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: { // Covers VUID-VkSwapchainPresentScalingCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkSwapchainPresentScalingCreateInfoEXT *structure = (VkSwapchainPresentScalingCreateInfoEXT *) header;
                skip |= ValidateFlags(loc, "scalingBehavior", "VkPresentScalingFlagBitsEXT", AllVkPresentScalingFlagBitsEXT, structure->scalingBehavior, kOptionalFlags, "VUID-VkSwapchainPresentScalingCreateInfoEXT-scalingBehavior-parameter");

                skip |= ValidateFlags(loc, "presentGravityX", "VkPresentGravityFlagBitsEXT", AllVkPresentGravityFlagBitsEXT, structure->presentGravityX, kOptionalFlags, "VUID-VkSwapchainPresentScalingCreateInfoEXT-presentGravityX-parameter");

                skip |= ValidateFlags(loc, "presentGravityY", "VkPresentGravityFlagBitsEXT", AllVkPresentGravityFlagBitsEXT, structure->presentGravityY, kOptionalFlags, "VUID-VkSwapchainPresentScalingCreateInfoEXT-presentGravityY-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *structure = (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *) header;
                skip |= ValidateBool32(loc, "deviceGeneratedCommands", structure->deviceGeneratedCommands);
            }
        } break;

        // Validation code for VkGraphicsPipelineShaderGroupsCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: { // Covers VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-sType-sType
            if (is_const_param) {
                VkGraphicsPipelineShaderGroupsCreateInfoNV *structure = (VkGraphicsPipelineShaderGroupsCreateInfoNV *) header;
                skip |= ValidateStructTypeArray(loc, "groupCount", "pGroups", "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV", structure->groupCount, structure->pGroups, VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV, false, true, "VUID-VkGraphicsShaderGroupCreateInfoNV-sType-sType", "VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-parameter", kVUIDUndefined);

                if (structure->pGroups != nullptr)
                {
                    for (uint32_t groupIndex = 0; groupIndex < structure->groupCount; ++groupIndex)
                    {
                        skip |= ValidateStructTypeArray(loc, ParameterName("pGroups[%i].stageCount", ParameterName::IndexVector{ groupIndex }), ParameterName("pGroups[%i].pStages", ParameterName::IndexVector{ groupIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", structure->pGroups[groupIndex].stageCount, structure->pGroups[groupIndex].pStages, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true, "VUID-VkPipelineShaderStageCreateInfo-sType-sType", "VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-parameter", "VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-arraylength");

                        if (structure->pGroups[groupIndex].pStages != nullptr)
                        {
                            for (uint32_t stageIndex = 0; stageIndex < structure->pGroups[groupIndex].stageCount; ++stageIndex)
                            {
                                skip |= ValidateFlags(loc, ParameterName("pGroups[%i].pStages[%i].flags", ParameterName::IndexVector{ groupIndex, stageIndex }), "VkPipelineShaderStageCreateFlagBits", AllVkPipelineShaderStageCreateFlagBits, structure->pGroups[groupIndex].pStages[stageIndex].flags, kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                                skip |= ValidateFlags(loc, ParameterName("pGroups[%i].pStages[%i].stage", ParameterName::IndexVector{ groupIndex, stageIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, structure->pGroups[groupIndex].pStages[stageIndex].stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                                skip |= ValidateRequiredPointer(loc, ParameterName("pGroups[%i].pStages[%i].pName", ParameterName::IndexVector{ groupIndex, stageIndex }), structure->pGroups[groupIndex].pStages[stageIndex].pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                                if (structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo != nullptr)
                                {
                                    skip |= ValidateArray(loc, ParameterName("pGroups[%i].pStages[%i].pSpecializationInfo->mapEntryCount", ParameterName::IndexVector{ groupIndex, stageIndex }), ParameterName("pGroups[%i].pStages[%i].pSpecializationInfo->pMapEntries", ParameterName::IndexVector{ groupIndex, stageIndex }), structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount, &structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                                    if (structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr)
                                    {
                                        for (uint32_t mapEntryIndex = 0; mapEntryIndex < structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                                        {
                                        }
                                    }

                                    skip |= ValidateArray(loc, ParameterName("pGroups[%i].pStages[%i].pSpecializationInfo->dataSize", ParameterName::IndexVector{ groupIndex, stageIndex }), ParameterName("pGroups[%i].pStages[%i].pSpecializationInfo->pData", ParameterName::IndexVector{ groupIndex, stageIndex }), structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->dataSize, &structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                                }
                            }
                        }
                    }
                }

                skip |= ValidateArray(loc, "pipelineCount", "pPipelines", structure->pipelineCount, &structure->pPipelines, false, true, kVUIDUndefined, "VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceInheritedViewportScissorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceInheritedViewportScissorFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceInheritedViewportScissorFeaturesNV *structure = (VkPhysicalDeviceInheritedViewportScissorFeaturesNV *) header;
                skip |= ValidateBool32(loc, "inheritedViewportScissor2D", structure->inheritedViewportScissor2D);
            }
        } break;

        // Validation code for VkCommandBufferInheritanceViewportScissorInfoNV structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: { // Covers VUID-VkCommandBufferInheritanceViewportScissorInfoNV-sType-sType
            if (is_const_param) {
                VkCommandBufferInheritanceViewportScissorInfoNV *structure = (VkCommandBufferInheritanceViewportScissorInfoNV *) header;
                skip |= ValidateBool32(loc, "viewportScissor2D", structure->viewportScissor2D);
            }
        } break;

        // Validation code for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *structure = (VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "texelBufferAlignment", structure->texelBufferAlignment);
            }
        } break;

        // No Validation code for VkRenderPassTransformBeginInfoQCOM structure members  -- Covers VUID-VkRenderPassTransformBeginInfoQCOM-sType-sType

        // No Validation code for VkCommandBufferInheritanceRenderPassTransformInfoQCOM structure members  -- Covers VUID-VkCommandBufferInheritanceRenderPassTransformInfoQCOM-sType-sType

        // Validation code for VkPhysicalDeviceDepthBiasControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDepthBiasControlFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDepthBiasControlFeaturesEXT *structure = (VkPhysicalDeviceDepthBiasControlFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "depthBiasControl", structure->depthBiasControl);

                skip |= ValidateBool32(loc, "leastRepresentableValueForceUnormRepresentation", structure->leastRepresentableValueForceUnormRepresentation);

                skip |= ValidateBool32(loc, "floatRepresentation", structure->floatRepresentation);

                skip |= ValidateBool32(loc, "depthBiasExact", structure->depthBiasExact);
            }
        } break;

        // Validation code for VkDepthBiasRepresentationInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT: { // Covers VUID-VkDepthBiasRepresentationInfoEXT-sType-sType
            if (is_const_param) {
                VkDepthBiasRepresentationInfoEXT *structure = (VkDepthBiasRepresentationInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "depthBiasRepresentation", "VkDepthBiasRepresentationEXT", structure->depthBiasRepresentation, "VUID-VkDepthBiasRepresentationInfoEXT-depthBiasRepresentation-parameter");

                skip |= ValidateBool32(loc, "depthBiasExact", structure->depthBiasExact);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDeviceMemoryReportFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *structure = (VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "deviceMemoryReport", structure->deviceMemoryReport);
            }
        } break;

        // Validation code for VkDeviceDeviceMemoryReportCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: { // Covers VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkDeviceDeviceMemoryReportCreateInfoEXT *structure = (VkDeviceDeviceMemoryReportCreateInfoEXT *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRequiredPointer(loc, "pfnUserCallback", reinterpret_cast<const void*>(structure->pfnUserCallback), "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pfnUserCallback-parameter");

                skip |= ValidateRequiredPointer(loc, "pUserData", structure->pUserData, "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pUserData-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceRobustness2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceRobustness2FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRobustness2FeaturesEXT *structure = (VkPhysicalDeviceRobustness2FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "robustBufferAccess2", structure->robustBufferAccess2);

                skip |= ValidateBool32(loc, "robustImageAccess2", structure->robustImageAccess2);

                skip |= ValidateBool32(loc, "nullDescriptor", structure->nullDescriptor);
            }
        } break;

        // No Validation code for VkPhysicalDeviceRobustness2PropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceRobustness2PropertiesEXT-sType-sType

        // Validation code for VkSamplerCustomBorderColorCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: { // Covers VUID-VkSamplerCustomBorderColorCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkSamplerCustomBorderColorCreateInfoEXT *structure = (VkSamplerCustomBorderColorCreateInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "format", "VkFormat", structure->format, "VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceCustomBorderColorPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceCustomBorderColorPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceCustomBorderColorFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceCustomBorderColorFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCustomBorderColorFeaturesEXT *structure = (VkPhysicalDeviceCustomBorderColorFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "customBorderColors", structure->customBorderColors);

                skip |= ValidateBool32(loc, "customBorderColorWithoutFormat", structure->customBorderColorWithoutFormat);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentBarrierFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: { // Covers VUID-VkPhysicalDevicePresentBarrierFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePresentBarrierFeaturesNV *structure = (VkPhysicalDevicePresentBarrierFeaturesNV *) header;
                skip |= ValidateBool32(loc, "presentBarrier", structure->presentBarrier);
            }
        } break;

        // Validation code for VkSurfaceCapabilitiesPresentBarrierNV structure members
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV: { // Covers VUID-VkSurfaceCapabilitiesPresentBarrierNV-sType-sType
            if (is_const_param) {
                VkSurfaceCapabilitiesPresentBarrierNV *structure = (VkSurfaceCapabilitiesPresentBarrierNV *) header;
                skip |= ValidateBool32(loc, "presentBarrierSupported", structure->presentBarrierSupported);
            }
        } break;

        // Validation code for VkSwapchainPresentBarrierCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: { // Covers VUID-VkSwapchainPresentBarrierCreateInfoNV-sType-sType
            if (is_const_param) {
                VkSwapchainPresentBarrierCreateInfoNV *structure = (VkSwapchainPresentBarrierCreateInfoNV *) header;
                skip |= ValidateBool32(loc, "presentBarrierEnable", structure->presentBarrierEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceDiagnosticsConfigFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDiagnosticsConfigFeaturesNV *structure = (VkPhysicalDeviceDiagnosticsConfigFeaturesNV *) header;
                skip |= ValidateBool32(loc, "diagnosticsConfig", structure->diagnosticsConfig);
            }
        } break;

        // Validation code for VkDeviceDiagnosticsConfigCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: { // Covers VUID-VkDeviceDiagnosticsConfigCreateInfoNV-sType-sType
            if (is_const_param) {
                VkDeviceDiagnosticsConfigCreateInfoNV *structure = (VkDeviceDiagnosticsConfigCreateInfoNV *) header;
                skip |= ValidateFlags(loc, "flags", "VkDeviceDiagnosticsConfigFlagBitsNV", AllVkDeviceDiagnosticsConfigFlagBitsNV, structure->flags, kOptionalFlags, "VUID-VkDeviceDiagnosticsConfigCreateInfoNV-flags-parameter");
            }
        } break;

        // Validation code for VkQueryLowLatencySupportNV structure members
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: { // Covers VUID-VkQueryLowLatencySupportNV-sType-sType
            if (is_const_param) {
                VkQueryLowLatencySupportNV *structure = (VkQueryLowLatencySupportNV *) header;
                skip |= ValidateRequiredPointer(loc, "pQueriedLowLatencyData", structure->pQueriedLowLatencyData, "VUID-VkQueryLowLatencySupportNV-pQueriedLowLatencyData-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalObjectCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: { // Covers VUID-VkExportMetalObjectCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkExportMetalObjectCreateInfoEXT *structure = (VkExportMetalObjectCreateInfoEXT *) header;
                skip |= ValidateFlags(loc, "exportObjectType", "VkExportMetalObjectTypeFlagBitsEXT", AllVkExportMetalObjectTypeFlagBitsEXT, structure->exportObjectType, kOptionalSingleBit, "VUID-VkExportMetalObjectCreateInfoEXT-exportObjectType-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // No Validation code for VkExportMetalDeviceInfoEXT structure members  -- Covers VUID-VkExportMetalDeviceInfoEXT-sType-sType
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalCommandQueueInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: { // Covers VUID-VkExportMetalCommandQueueInfoEXT-sType-sType
            if (is_const_param) {
                VkExportMetalCommandQueueInfoEXT *structure = (VkExportMetalCommandQueueInfoEXT *) header;
                skip |= ValidateRequiredHandle(loc, "queue", structure->queue);
            }
        } break;
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalBufferInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: { // Covers VUID-VkExportMetalBufferInfoEXT-sType-sType
            if (is_const_param) {
                VkExportMetalBufferInfoEXT *structure = (VkExportMetalBufferInfoEXT *) header;
                skip |= ValidateRequiredHandle(loc, "memory", structure->memory);
            }
        } break;
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // No Validation code for VkImportMetalBufferInfoEXT structure members  -- Covers VUID-VkImportMetalBufferInfoEXT-sType-sType
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalTextureInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: { // Covers VUID-VkExportMetalTextureInfoEXT-sType-sType
            if (is_const_param) {
                VkExportMetalTextureInfoEXT *structure = (VkExportMetalTextureInfoEXT *) header;
                skip |= ValidateFlags(loc, "plane", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, structure->plane, kRequiredSingleBit, "VUID-VkExportMetalTextureInfoEXT-plane-parameter", "VUID-VkExportMetalTextureInfoEXT-plane-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkImportMetalTextureInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: { // Covers VUID-VkImportMetalTextureInfoEXT-sType-sType
            if (is_const_param) {
                VkImportMetalTextureInfoEXT *structure = (VkImportMetalTextureInfoEXT *) header;
                skip |= ValidateFlags(loc, "plane", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, structure->plane, kRequiredSingleBit, "VUID-VkImportMetalTextureInfoEXT-plane-parameter", "VUID-VkImportMetalTextureInfoEXT-plane-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalIOSurfaceInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: { // Covers VUID-VkExportMetalIOSurfaceInfoEXT-sType-sType
            if (is_const_param) {
                VkExportMetalIOSurfaceInfoEXT *structure = (VkExportMetalIOSurfaceInfoEXT *) header;
                skip |= ValidateRequiredHandle(loc, "image", structure->image);
            }
        } break;
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // No Validation code for VkImportMetalIOSurfaceInfoEXT structure members  -- Covers VUID-VkImportMetalIOSurfaceInfoEXT-sType-sType
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // No Validation code for VkExportMetalSharedEventInfoEXT structure members  -- Covers VUID-VkExportMetalSharedEventInfoEXT-sType-sType
#endif // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT

        // No Validation code for VkImportMetalSharedEventInfoEXT structure members  -- Covers VUID-VkImportMetalSharedEventInfoEXT-sType-sType
#endif // VK_USE_PLATFORM_METAL_EXT

        // No Validation code for VkPhysicalDeviceDescriptorBufferPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceDescriptorBufferPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceDescriptorBufferFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDescriptorBufferFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDescriptorBufferFeaturesEXT *structure = (VkPhysicalDeviceDescriptorBufferFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "descriptorBuffer", structure->descriptorBuffer);

                skip |= ValidateBool32(loc, "descriptorBufferCaptureReplay", structure->descriptorBufferCaptureReplay);

                skip |= ValidateBool32(loc, "descriptorBufferImageLayoutIgnored", structure->descriptorBufferImageLayoutIgnored);

                skip |= ValidateBool32(loc, "descriptorBufferPushDescriptors", structure->descriptorBufferPushDescriptors);
            }
        } break;

        // Validation code for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT: { // Covers VUID-VkDescriptorBufferBindingPushDescriptorBufferHandleEXT-sType-sType
            if (is_const_param) {
                VkDescriptorBufferBindingPushDescriptorBufferHandleEXT *structure = (VkDescriptorBufferBindingPushDescriptorBufferHandleEXT *) header;
                skip |= ValidateRequiredHandle(loc, "buffer", structure->buffer);
            }
        } break;

        // Validation code for VkOpaqueCaptureDescriptorDataCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: { // Covers VUID-VkOpaqueCaptureDescriptorDataCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkOpaqueCaptureDescriptorDataCreateInfoEXT *structure = (VkOpaqueCaptureDescriptorDataCreateInfoEXT *) header;
                skip |= ValidateRequiredPointer(loc, "opaqueCaptureDescriptorData", structure->opaqueCaptureDescriptorData, "VUID-VkOpaqueCaptureDescriptorDataCreateInfoEXT-opaqueCaptureDescriptorData-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *structure = (VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "graphicsPipelineLibrary", structure->graphicsPipelineLibrary);
            }
        } break;

        // Validation code for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: { // Covers VUID-VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *structure = (VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *) header;
                skip |= ValidateBool32(loc, "graphicsPipelineLibraryFastLinking", structure->graphicsPipelineLibraryFastLinking);

                skip |= ValidateBool32(loc, "graphicsPipelineLibraryIndependentInterpolationDecoration", structure->graphicsPipelineLibraryIndependentInterpolationDecoration);
            }
        } break;

        // Validation code for VkGraphicsPipelineLibraryCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: { // Covers VUID-VkGraphicsPipelineLibraryCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkGraphicsPipelineLibraryCreateInfoEXT *structure = (VkGraphicsPipelineLibraryCreateInfoEXT *) header;
                skip |= ValidateFlags(loc, "flags", "VkGraphicsPipelineLibraryFlagBitsEXT", AllVkGraphicsPipelineLibraryFlagBitsEXT, structure->flags, kRequiredFlags, "VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-parameter", "VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-requiredbitmask");
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: { // Covers VUID-VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *structure = (VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *) header;
                skip |= ValidateBool32(loc, "shaderEarlyAndLateFragmentTests", structure->shaderEarlyAndLateFragmentTests);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *structure = (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *) header;
                skip |= ValidateBool32(loc, "fragmentShadingRateEnums", structure->fragmentShadingRateEnums);

                skip |= ValidateBool32(loc, "supersampleFragmentShadingRates", structure->supersampleFragmentShadingRates);

                skip |= ValidateBool32(loc, "noInvocationFragmentShadingRates", structure->noInvocationFragmentShadingRates);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: { // Covers VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *structure = (VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *) header;
                skip |= ValidateFlags(loc, "maxFragmentShadingRateInvocationCount", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, structure->maxFragmentShadingRateInvocationCount, kRequiredSingleBit, "VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-maxFragmentShadingRateInvocationCount-parameter", "VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-maxFragmentShadingRateInvocationCount-parameter");
            }
        } break;

        // No Validation code for VkPipelineFragmentShadingRateEnumStateCreateInfoNV structure members  -- Covers VUID-VkPipelineFragmentShadingRateEnumStateCreateInfoNV-sType-sType

        // No Validation code for VkAccelerationStructureGeometryMotionTrianglesDataNV structure members  -- Covers VUID-VkAccelerationStructureGeometryMotionTrianglesDataNV-sType-sType

        // Validation code for VkAccelerationStructureMotionInfoNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: { // Covers VUID-VkAccelerationStructureMotionInfoNV-sType-sType
            if (is_const_param) {
                VkAccelerationStructureMotionInfoNV *structure = (VkAccelerationStructureMotionInfoNV *) header;
                skip |= ValidateReservedFlags(loc, "flags", structure->flags, "VUID-VkAccelerationStructureMotionInfoNV-flags-zerobitmask");
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceRayTracingMotionBlurFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *structure = (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *) header;
                skip |= ValidateBool32(loc, "rayTracingMotionBlur", structure->rayTracingMotionBlur);

                skip |= ValidateBool32(loc, "rayTracingMotionBlurPipelineTraceRaysIndirect", structure->rayTracingMotionBlurPipelineTraceRaysIndirect);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *structure = (VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "ycbcr2plane444Formats", structure->ycbcr2plane444Formats);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceFragmentDensityMap2FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *structure = (VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "fragmentDensityMapDeferred", structure->fragmentDensityMapDeferred);
            }
        } break;

        // No Validation code for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceFragmentDensityMap2PropertiesEXT-sType-sType

        // No Validation code for VkCopyCommandTransformInfoQCOM structure members  -- Covers VUID-VkCopyCommandTransformInfoQCOM-sType-sType

        // Validation code for VkPhysicalDeviceImageCompressionControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceImageCompressionControlFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageCompressionControlFeaturesEXT *structure = (VkPhysicalDeviceImageCompressionControlFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "imageCompressionControl", structure->imageCompressionControl);
            }
        } break;

        // No Validation code for VkImageCompressionControlEXT structure members  -- Covers VUID-VkImageCompressionControlEXT-sType-sType

        // No Validation code for VkImageCompressionPropertiesEXT structure members  -- Covers VUID-VkImageCompressionPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *structure = (VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "attachmentFeedbackLoopLayout", structure->attachmentFeedbackLoopLayout);
            }
        } break;

        // Validation code for VkPhysicalDevice4444FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: { // Covers VUID-VkPhysicalDevice4444FormatsFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevice4444FormatsFeaturesEXT *structure = (VkPhysicalDevice4444FormatsFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "formatA4R4G4B4", structure->formatA4R4G4B4);

                skip |= ValidateBool32(loc, "formatA4B4G4R4", structure->formatA4B4G4R4);
            }
        } break;

        // Validation code for VkPhysicalDeviceFaultFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceFaultFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFaultFeaturesEXT *structure = (VkPhysicalDeviceFaultFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "deviceFault", structure->deviceFault);

                skip |= ValidateBool32(loc, "deviceFaultVendorBinary", structure->deviceFaultVendorBinary);
            }
        } break;

        // Validation code for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *structure = (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "rasterizationOrderColorAttachmentAccess", structure->rasterizationOrderColorAttachmentAccess);

                skip |= ValidateBool32(loc, "rasterizationOrderDepthAttachmentAccess", structure->rasterizationOrderDepthAttachmentAccess);

                skip |= ValidateBool32(loc, "rasterizationOrderStencilAttachmentAccess", structure->rasterizationOrderStencilAttachmentAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *structure = (VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "formatRgba10x6WithoutYCbCrSampler", structure->formatRgba10x6WithoutYCbCrSampler);
            }
        } break;

        // Validation code for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *structure = (VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "mutableDescriptorType", structure->mutableDescriptorType);
            }
        } break;

        // Validation code for VkMutableDescriptorTypeCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: { // Covers VUID-VkMutableDescriptorTypeCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkMutableDescriptorTypeCreateInfoEXT *structure = (VkMutableDescriptorTypeCreateInfoEXT *) header;
                skip |= ValidateArray(loc, "mutableDescriptorTypeListCount", "pMutableDescriptorTypeLists", structure->mutableDescriptorTypeListCount, &structure->pMutableDescriptorTypeLists, false, true, kVUIDUndefined, "VUID-VkMutableDescriptorTypeCreateInfoEXT-pMutableDescriptorTypeLists-parameter");

                if (structure->pMutableDescriptorTypeLists != nullptr)
                {
                    for (uint32_t mutableDescriptorTypeListIndex = 0; mutableDescriptorTypeListIndex < structure->mutableDescriptorTypeListCount; ++mutableDescriptorTypeListIndex)
                    {
                        skip |= ValidateRangedEnumArray(loc, ParameterName("pMutableDescriptorTypeLists[%i].descriptorTypeCount", ParameterName::IndexVector{ mutableDescriptorTypeListIndex }), ParameterName("pMutableDescriptorTypeLists[%i].pDescriptorTypes", ParameterName::IndexVector{ mutableDescriptorTypeListIndex }), "VkDescriptorType", structure->pMutableDescriptorTypeLists[mutableDescriptorTypeListIndex].descriptorTypeCount, structure->pMutableDescriptorTypeLists[mutableDescriptorTypeListIndex].pDescriptorTypes, false, true);
                    }
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *structure = (VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "vertexInputDynamicState", structure->vertexInputDynamicState);
            }
        } break;

        // No Validation code for VkPhysicalDeviceDrmPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceDrmPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceAddressBindingReportFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceAddressBindingReportFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceAddressBindingReportFeaturesEXT *structure = (VkPhysicalDeviceAddressBindingReportFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "reportAddressBinding", structure->reportAddressBinding);
            }
        } break;

        // Validation code for VkDeviceAddressBindingCallbackDataEXT structure members
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: { // Covers VUID-VkDeviceAddressBindingCallbackDataEXT-sType-sType
            if (is_const_param) {
                VkDeviceAddressBindingCallbackDataEXT *structure = (VkDeviceAddressBindingCallbackDataEXT *) header;
                skip |= ValidateFlags(loc, "flags", "VkDeviceAddressBindingFlagBitsEXT", AllVkDeviceAddressBindingFlagBitsEXT, structure->flags, kOptionalFlags, "VUID-VkDeviceAddressBindingCallbackDataEXT-flags-parameter");

                skip |= ValidateRangedEnum(loc, "bindingType", "VkDeviceAddressBindingTypeEXT", structure->bindingType, "VUID-VkDeviceAddressBindingCallbackDataEXT-bindingType-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClipControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDepthClipControlFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDepthClipControlFeaturesEXT *structure = (VkPhysicalDeviceDepthClipControlFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "depthClipControl", structure->depthClipControl);
            }
        } break;

        // Validation code for VkPipelineViewportDepthClipControlCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: { // Covers VUID-VkPipelineViewportDepthClipControlCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineViewportDepthClipControlCreateInfoEXT *structure = (VkPipelineViewportDepthClipControlCreateInfoEXT *) header;
                skip |= ValidateBool32(loc, "negativeOneToOne", structure->negativeOneToOne);
            }
        } break;

        // Validation code for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *structure = (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "primitiveTopologyListRestart", structure->primitiveTopologyListRestart);

                skip |= ValidateBool32(loc, "primitiveTopologyPatchListRestart", structure->primitiveTopologyPatchListRestart);
            }
        } break;
#ifdef VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkImportMemoryZirconHandleInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: { // Covers VUID-VkImportMemoryZirconHandleInfoFUCHSIA-sType-sType
            if (is_const_param) {
                VkImportMemoryZirconHandleInfoFUCHSIA *structure = (VkImportMemoryZirconHandleInfoFUCHSIA *) header;
                skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit, "VUID-VkImportMemoryZirconHandleInfoFUCHSIA-handleType-parameter");
            }
        } break;
#endif // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkImportMemoryBufferCollectionFUCHSIA structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: { // Covers VUID-VkImportMemoryBufferCollectionFUCHSIA-sType-sType
            if (is_const_param) {
                VkImportMemoryBufferCollectionFUCHSIA *structure = (VkImportMemoryBufferCollectionFUCHSIA *) header;
                skip |= ValidateRequiredHandle(loc, "collection", structure->collection);
            }
        } break;
#endif // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkBufferCollectionImageCreateInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: { // Covers VUID-VkBufferCollectionImageCreateInfoFUCHSIA-sType-sType
            if (is_const_param) {
                VkBufferCollectionImageCreateInfoFUCHSIA *structure = (VkBufferCollectionImageCreateInfoFUCHSIA *) header;
                skip |= ValidateRequiredHandle(loc, "collection", structure->collection);
            }
        } break;
#endif // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkBufferCollectionBufferCreateInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: { // Covers VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-sType-sType
            if (is_const_param) {
                VkBufferCollectionBufferCreateInfoFUCHSIA *structure = (VkBufferCollectionBufferCreateInfoFUCHSIA *) header;
                skip |= ValidateRequiredHandle(loc, "collection", structure->collection);
            }
        } break;
#endif // VK_USE_PLATFORM_FUCHSIA

        // No Validation code for VkSubpassShadingPipelineCreateInfoHUAWEI structure members  -- Covers VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-sType-sType

        // Validation code for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: { // Covers VUID-VkPhysicalDeviceSubpassShadingFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *structure = (VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *) header;
                skip |= ValidateBool32(loc, "subpassShading", structure->subpassShading);
            }
        } break;

        // No Validation code for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI structure members  -- Covers VUID-VkPhysicalDeviceSubpassShadingPropertiesHUAWEI-sType-sType

        // Validation code for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: { // Covers VUID-VkPhysicalDeviceInvocationMaskFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *structure = (VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *) header;
                skip |= ValidateBool32(loc, "invocationMask", structure->invocationMask);
            }
        } break;

        // Validation code for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceExternalMemoryRDMAFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExternalMemoryRDMAFeaturesNV *structure = (VkPhysicalDeviceExternalMemoryRDMAFeaturesNV *) header;
                skip |= ValidateBool32(loc, "externalMemoryRDMA", structure->externalMemoryRDMA);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelinePropertiesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePipelinePropertiesFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePipelinePropertiesFeaturesEXT *structure = (VkPhysicalDevicePipelinePropertiesFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "pipelinePropertiesIdentifier", structure->pipelinePropertiesIdentifier);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *structure = (VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "multisampledRenderToSingleSampled", structure->multisampledRenderToSingleSampled);
            }
        } break;

        // No Validation code for VkSubpassResolvePerformanceQueryEXT structure members  -- Covers VUID-VkSubpassResolvePerformanceQueryEXT-sType-sType

        // Validation code for VkMultisampledRenderToSingleSampledInfoEXT structure members
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: { // Covers VUID-VkMultisampledRenderToSingleSampledInfoEXT-sType-sType
            if (is_const_param) {
                VkMultisampledRenderToSingleSampledInfoEXT *structure = (VkMultisampledRenderToSingleSampledInfoEXT *) header;
                skip |= ValidateBool32(loc, "multisampledRenderToSingleSampledEnable", structure->multisampledRenderToSingleSampledEnable);

                skip |= ValidateFlags(loc, "rasterizationSamples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, structure->rasterizationSamples, kRequiredSingleBit, "VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter", "VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceExtendedDynamicState2FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *structure = (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "extendedDynamicState2", structure->extendedDynamicState2);

                skip |= ValidateBool32(loc, "extendedDynamicState2LogicOp", structure->extendedDynamicState2LogicOp);

                skip |= ValidateBool32(loc, "extendedDynamicState2PatchControlPoints", structure->extendedDynamicState2PatchControlPoints);
            }
        } break;

        // Validation code for VkPhysicalDeviceColorWriteEnableFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceColorWriteEnableFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceColorWriteEnableFeaturesEXT *structure = (VkPhysicalDeviceColorWriteEnableFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "colorWriteEnable", structure->colorWriteEnable);
            }
        } break;

        // Validation code for VkPipelineColorWriteCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: { // Covers VUID-VkPipelineColorWriteCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineColorWriteCreateInfoEXT *structure = (VkPipelineColorWriteCreateInfoEXT *) header;
                skip |= ValidateBool32Array(loc, "attachmentCount", "pColorWriteEnables", structure->attachmentCount, structure->pColorWriteEnables, false, true);
            }
        } break;

        // Validation code for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *structure = (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "primitivesGeneratedQuery", structure->primitivesGeneratedQuery);

                skip |= ValidateBool32(loc, "primitivesGeneratedQueryWithRasterizerDiscard", structure->primitivesGeneratedQueryWithRasterizerDiscard);

                skip |= ValidateBool32(loc, "primitivesGeneratedQueryWithNonZeroStreams", structure->primitivesGeneratedQueryWithNonZeroStreams);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageViewMinLodFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceImageViewMinLodFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageViewMinLodFeaturesEXT *structure = (VkPhysicalDeviceImageViewMinLodFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "minLod", structure->minLod);
            }
        } break;

        // No Validation code for VkImageViewMinLodCreateInfoEXT structure members  -- Covers VUID-VkImageViewMinLodCreateInfoEXT-sType-sType

        // Validation code for VkPhysicalDeviceMultiDrawFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceMultiDrawFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMultiDrawFeaturesEXT *structure = (VkPhysicalDeviceMultiDrawFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "multiDraw", structure->multiDraw);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMultiDrawPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceMultiDrawPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceImage2DViewOf3DFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *structure = (VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "image2DViewOf3D", structure->image2DViewOf3D);

                skip |= ValidateBool32(loc, "sampler2DViewOf3D", structure->sampler2DViewOf3D);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderTileImageFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceShaderTileImageFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderTileImageFeaturesEXT *structure = (VkPhysicalDeviceShaderTileImageFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "shaderTileImageColorReadAccess", structure->shaderTileImageColorReadAccess);

                skip |= ValidateBool32(loc, "shaderTileImageDepthReadAccess", structure->shaderTileImageDepthReadAccess);

                skip |= ValidateBool32(loc, "shaderTileImageStencilReadAccess", structure->shaderTileImageStencilReadAccess);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderTileImagePropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceShaderTileImagePropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceOpacityMicromapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceOpacityMicromapFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceOpacityMicromapFeaturesEXT *structure = (VkPhysicalDeviceOpacityMicromapFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "micromap", structure->micromap);

                skip |= ValidateBool32(loc, "micromapCaptureReplay", structure->micromapCaptureReplay);

                skip |= ValidateBool32(loc, "micromapHostCommands", structure->micromapHostCommands);
            }
        } break;

        // No Validation code for VkPhysicalDeviceOpacityMicromapPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceOpacityMicromapPropertiesEXT-sType-sType

        // Validation code for VkAccelerationStructureTrianglesOpacityMicromapEXT structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: { // Covers VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-sType-sType
            if (is_const_param) {
                VkAccelerationStructureTrianglesOpacityMicromapEXT *structure = (VkAccelerationStructureTrianglesOpacityMicromapEXT *) header;
                skip |= ValidateRangedEnum(loc, "indexType", "VkIndexType", structure->indexType, "VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-parameter");

                if (structure->pUsageCounts != nullptr)
                {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex)
                    {
                    }
                }

                if (structure->ppUsageCounts != nullptr)
                {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex)
                    {
                    }
                }
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceDisplacementMicromapFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceDisplacementMicromapFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDisplacementMicromapFeaturesNV *structure = (VkPhysicalDeviceDisplacementMicromapFeaturesNV *) header;
                skip |= ValidateBool32(loc, "displacementMicromap", structure->displacementMicromap);
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceDisplacementMicromapPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceDisplacementMicromapPropertiesNV-sType-sType
#endif // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkAccelerationStructureTrianglesDisplacementMicromapNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV: { // Covers VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-sType-sType
            if (is_const_param) {
                VkAccelerationStructureTrianglesDisplacementMicromapNV *structure = (VkAccelerationStructureTrianglesDisplacementMicromapNV *) header;
                skip |= ValidateRangedEnum(loc, "displacementBiasAndScaleFormat", "VkFormat", structure->displacementBiasAndScaleFormat, "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementBiasAndScaleFormat-parameter");

                skip |= ValidateRangedEnum(loc, "displacementVectorFormat", "VkFormat", structure->displacementVectorFormat, "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementVectorFormat-parameter");

                skip |= ValidateRangedEnum(loc, "indexType", "VkIndexType", structure->indexType, "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-indexType-parameter");

                if (structure->pUsageCounts != nullptr)
                {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex)
                    {
                    }
                }

                if (structure->ppUsageCounts != nullptr)
                {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex)
                    {
                    }
                }
            }
        } break;
#endif // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI: { // Covers VUID-VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *structure = (VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *) header;
                skip |= ValidateBool32(loc, "clustercullingShader", structure->clustercullingShader);

                skip |= ValidateBool32(loc, "multiviewClusterCullingShader", structure->multiviewClusterCullingShader);
            }
        } break;

        // No Validation code for VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI structure members  -- Covers VUID-VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI-sType-sType

        // Validation code for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceBorderColorSwizzleFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *structure = (VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "borderColorSwizzle", structure->borderColorSwizzle);

                skip |= ValidateBool32(loc, "borderColorSwizzleFromImage", structure->borderColorSwizzleFromImage);
            }
        } break;

        // Validation code for VkSamplerBorderColorComponentMappingCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: { // Covers VUID-VkSamplerBorderColorComponentMappingCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkSamplerBorderColorComponentMappingCreateInfoEXT *structure = (VkSamplerBorderColorComponentMappingCreateInfoEXT *) header;
                skip |= ValidateRangedEnum(loc, "components.r", "VkComponentSwizzle", structure->components.r, "VUID-VkComponentMapping-r-parameter");

                skip |= ValidateRangedEnum(loc, "components.g", "VkComponentSwizzle", structure->components.g, "VUID-VkComponentMapping-g-parameter");

                skip |= ValidateRangedEnum(loc, "components.b", "VkComponentSwizzle", structure->components.b, "VUID-VkComponentMapping-b-parameter");

                skip |= ValidateRangedEnum(loc, "components.a", "VkComponentSwizzle", structure->components.a, "VUID-VkComponentMapping-a-parameter");

                skip |= ValidateBool32(loc, "srgb", structure->srgb);
            }
        } break;

        // Validation code for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *structure = (VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "pageableDeviceLocalMemory", structure->pageableDeviceLocalMemory);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderCorePropertiesARM structure members  -- Covers VUID-VkPhysicalDeviceShaderCorePropertiesARM-sType-sType

        // Validation code for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *structure = (VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "imageSlicedViewOf3D", structure->imageSlicedViewOf3D);
            }
        } break;

        // No Validation code for VkImageViewSlicedCreateInfoEXT structure members  -- Covers VUID-VkImageViewSlicedCreateInfoEXT-sType-sType

        // Validation code for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: { // Covers VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *structure = (VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *) header;
                skip |= ValidateBool32(loc, "descriptorSetHostMapping", structure->descriptorSetHostMapping);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClampZeroOneFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDepthClampZeroOneFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *structure = (VkPhysicalDeviceDepthClampZeroOneFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "depthClampZeroOne", structure->depthClampZeroOne);
            }
        } break;

        // Validation code for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *structure = (VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "nonSeamlessCubeMap", structure->nonSeamlessCubeMap);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *structure = (VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "fragmentDensityMapOffset", structure->fragmentDensityMapOffset);
            }
        } break;

        // No Validation code for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM structure members  -- Covers VUID-VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM-sType-sType

        // Validation code for VkSubpassFragmentDensityMapOffsetEndInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: { // Covers VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-sType-sType
            if (is_const_param) {
                VkSubpassFragmentDensityMapOffsetEndInfoQCOM *structure = (VkSubpassFragmentDensityMapOffsetEndInfoQCOM *) header;
                skip |= ValidateArray(loc, "fragmentDensityOffsetCount", "pFragmentDensityOffsets", structure->fragmentDensityOffsetCount, &structure->pFragmentDensityOffsets, false, true, kVUIDUndefined, "VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pFragmentDensityOffsets-parameter");

                if (structure->pFragmentDensityOffsets != nullptr)
                {
                    for (uint32_t fragmentDensityOffsetIndex = 0; fragmentDensityOffsetIndex < structure->fragmentDensityOffsetCount; ++fragmentDensityOffsetIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceCopyMemoryIndirectFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceCopyMemoryIndirectFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *structure = (VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *) header;
                skip |= ValidateBool32(loc, "indirectCopy", structure->indirectCopy);
            }
        } break;

        // No Validation code for VkPhysicalDeviceCopyMemoryIndirectPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceCopyMemoryIndirectPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceMemoryDecompressionFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceMemoryDecompressionFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMemoryDecompressionFeaturesNV *structure = (VkPhysicalDeviceMemoryDecompressionFeaturesNV *) header;
                skip |= ValidateBool32(loc, "memoryDecompression", structure->memoryDecompression);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMemoryDecompressionPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceMemoryDecompressionPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *structure = (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *) header;
                skip |= ValidateBool32(loc, "deviceGeneratedCompute", structure->deviceGeneratedCompute);

                skip |= ValidateBool32(loc, "deviceGeneratedComputePipelines", structure->deviceGeneratedComputePipelines);

                skip |= ValidateBool32(loc, "deviceGeneratedComputeCaptureReplay", structure->deviceGeneratedComputeCaptureReplay);
            }
        } break;

        // Validation code for VkPhysicalDeviceLinearColorAttachmentFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceLinearColorAttachmentFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceLinearColorAttachmentFeaturesNV *structure = (VkPhysicalDeviceLinearColorAttachmentFeaturesNV *) header;
                skip |= ValidateBool32(loc, "linearColorAttachment", structure->linearColorAttachment);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *structure = (VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "imageCompressionControlSwapchain", structure->imageCompressionControlSwapchain);
            }
        } break;

        // No Validation code for VkImageViewSampleWeightCreateInfoQCOM structure members  -- Covers VUID-VkImageViewSampleWeightCreateInfoQCOM-sType-sType

        // Validation code for VkPhysicalDeviceImageProcessingFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceImageProcessingFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageProcessingFeaturesQCOM *structure = (VkPhysicalDeviceImageProcessingFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "textureSampleWeighted", structure->textureSampleWeighted);

                skip |= ValidateBool32(loc, "textureBoxFilter", structure->textureBoxFilter);

                skip |= ValidateBool32(loc, "textureBlockMatch", structure->textureBlockMatch);
            }
        } break;

        // No Validation code for VkPhysicalDeviceImageProcessingPropertiesQCOM structure members  -- Covers VUID-VkPhysicalDeviceImageProcessingPropertiesQCOM-sType-sType

        // Validation code for VkExternalMemoryAcquireUnmodifiedEXT structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT: { // Covers VUID-VkExternalMemoryAcquireUnmodifiedEXT-sType-sType
            if (is_const_param) {
                VkExternalMemoryAcquireUnmodifiedEXT *structure = (VkExternalMemoryAcquireUnmodifiedEXT *) header;
                skip |= ValidateBool32(loc, "acquireUnmodifiedMemory", structure->acquireUnmodifiedMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceExtendedDynamicState3FeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *structure = (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *) header;
                skip |= ValidateBool32(loc, "extendedDynamicState3TessellationDomainOrigin", structure->extendedDynamicState3TessellationDomainOrigin);

                skip |= ValidateBool32(loc, "extendedDynamicState3DepthClampEnable", structure->extendedDynamicState3DepthClampEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3PolygonMode", structure->extendedDynamicState3PolygonMode);

                skip |= ValidateBool32(loc, "extendedDynamicState3RasterizationSamples", structure->extendedDynamicState3RasterizationSamples);

                skip |= ValidateBool32(loc, "extendedDynamicState3SampleMask", structure->extendedDynamicState3SampleMask);

                skip |= ValidateBool32(loc, "extendedDynamicState3AlphaToCoverageEnable", structure->extendedDynamicState3AlphaToCoverageEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3AlphaToOneEnable", structure->extendedDynamicState3AlphaToOneEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3LogicOpEnable", structure->extendedDynamicState3LogicOpEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3ColorBlendEnable", structure->extendedDynamicState3ColorBlendEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3ColorBlendEquation", structure->extendedDynamicState3ColorBlendEquation);

                skip |= ValidateBool32(loc, "extendedDynamicState3ColorWriteMask", structure->extendedDynamicState3ColorWriteMask);

                skip |= ValidateBool32(loc, "extendedDynamicState3RasterizationStream", structure->extendedDynamicState3RasterizationStream);

                skip |= ValidateBool32(loc, "extendedDynamicState3ConservativeRasterizationMode", structure->extendedDynamicState3ConservativeRasterizationMode);

                skip |= ValidateBool32(loc, "extendedDynamicState3ExtraPrimitiveOverestimationSize", structure->extendedDynamicState3ExtraPrimitiveOverestimationSize);

                skip |= ValidateBool32(loc, "extendedDynamicState3DepthClipEnable", structure->extendedDynamicState3DepthClipEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3SampleLocationsEnable", structure->extendedDynamicState3SampleLocationsEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3ColorBlendAdvanced", structure->extendedDynamicState3ColorBlendAdvanced);

                skip |= ValidateBool32(loc, "extendedDynamicState3ProvokingVertexMode", structure->extendedDynamicState3ProvokingVertexMode);

                skip |= ValidateBool32(loc, "extendedDynamicState3LineRasterizationMode", structure->extendedDynamicState3LineRasterizationMode);

                skip |= ValidateBool32(loc, "extendedDynamicState3LineStippleEnable", structure->extendedDynamicState3LineStippleEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3DepthClipNegativeOneToOne", structure->extendedDynamicState3DepthClipNegativeOneToOne);

                skip |= ValidateBool32(loc, "extendedDynamicState3ViewportWScalingEnable", structure->extendedDynamicState3ViewportWScalingEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3ViewportSwizzle", structure->extendedDynamicState3ViewportSwizzle);

                skip |= ValidateBool32(loc, "extendedDynamicState3CoverageToColorEnable", structure->extendedDynamicState3CoverageToColorEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3CoverageToColorLocation", structure->extendedDynamicState3CoverageToColorLocation);

                skip |= ValidateBool32(loc, "extendedDynamicState3CoverageModulationMode", structure->extendedDynamicState3CoverageModulationMode);

                skip |= ValidateBool32(loc, "extendedDynamicState3CoverageModulationTableEnable", structure->extendedDynamicState3CoverageModulationTableEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3CoverageModulationTable", structure->extendedDynamicState3CoverageModulationTable);

                skip |= ValidateBool32(loc, "extendedDynamicState3CoverageReductionMode", structure->extendedDynamicState3CoverageReductionMode);

                skip |= ValidateBool32(loc, "extendedDynamicState3RepresentativeFragmentTestEnable", structure->extendedDynamicState3RepresentativeFragmentTestEnable);

                skip |= ValidateBool32(loc, "extendedDynamicState3ShadingRateImageEnable", structure->extendedDynamicState3ShadingRateImageEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT: { // Covers VUID-VkPhysicalDeviceExtendedDynamicState3PropertiesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *structure = (VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *) header;
                skip |= ValidateBool32(loc, "dynamicPrimitiveTopologyUnrestricted", structure->dynamicPrimitiveTopologyUnrestricted);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *structure = (VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "subpassMergeFeedback", structure->subpassMergeFeedback);
            }
        } break;

        // Validation code for VkRenderPassCreationControlEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: { // Covers VUID-VkRenderPassCreationControlEXT-sType-sType
            if (is_const_param) {
                VkRenderPassCreationControlEXT *structure = (VkRenderPassCreationControlEXT *) header;
                skip |= ValidateBool32(loc, "disallowMerging", structure->disallowMerging);
            }
        } break;

        // Validation code for VkRenderPassCreationFeedbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: { // Covers VUID-VkRenderPassCreationFeedbackCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkRenderPassCreationFeedbackCreateInfoEXT *structure = (VkRenderPassCreationFeedbackCreateInfoEXT *) header;
                skip |= ValidateRequiredPointer(loc, "pRenderPassFeedback", structure->pRenderPassFeedback, "VUID-VkRenderPassCreationFeedbackCreateInfoEXT-pRenderPassFeedback-parameter");

                if (structure->pRenderPassFeedback != nullptr)
                {
                }
            }
        } break;

        // Validation code for VkRenderPassSubpassFeedbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: { // Covers VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkRenderPassSubpassFeedbackCreateInfoEXT *structure = (VkRenderPassSubpassFeedbackCreateInfoEXT *) header;
                skip |= ValidateRequiredPointer(loc, "pSubpassFeedback", structure->pSubpassFeedback, "VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-pSubpassFeedback-parameter");

                if (structure->pSubpassFeedback != nullptr)
                {
                }
            }
        } break;

        // Validation code for VkDirectDriverLoadingListLUNARG structure members
        case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG: { // Covers VUID-VkDirectDriverLoadingListLUNARG-sType-sType
            if (is_const_param) {
                VkDirectDriverLoadingListLUNARG *structure = (VkDirectDriverLoadingListLUNARG *) header;
                skip |= ValidateRangedEnum(loc, "mode", "VkDirectDriverLoadingModeLUNARG", structure->mode, "VUID-VkDirectDriverLoadingListLUNARG-mode-parameter");

                skip |= ValidateStructTypeArray(loc, "driverCount", "pDrivers", "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG", structure->driverCount, structure->pDrivers, VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG, true, true, "VUID-VkDirectDriverLoadingInfoLUNARG-sType-sType", "VUID-VkDirectDriverLoadingListLUNARG-pDrivers-parameter", "VUID-VkDirectDriverLoadingListLUNARG-driverCount-arraylength");

                if (structure->pDrivers != nullptr)
                {
                    for (uint32_t driverIndex = 0; driverIndex < structure->driverCount; ++driverIndex)
                    {
                        skip |= ValidateReservedFlags(loc, ParameterName("pDrivers[%i].flags", ParameterName::IndexVector{ driverIndex }), structure->pDrivers[driverIndex].flags, "VUID-VkDirectDriverLoadingInfoLUNARG-flags-zerobitmask");
                    }
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *structure = (VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "shaderModuleIdentifier", structure->shaderModuleIdentifier);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT-sType-sType

        // Validation code for VkPipelineShaderStageModuleIdentifierCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT: { // Covers VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-sType-sType
            if (is_const_param) {
                VkPipelineShaderStageModuleIdentifierCreateInfoEXT *structure = (VkPipelineShaderStageModuleIdentifierCreateInfoEXT *) header;
                skip |= ValidateArray(loc, "identifierSize", "pIdentifier", structure->identifierSize, &structure->pIdentifier, false, true, kVUIDUndefined, "VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pIdentifier-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceOpticalFlowFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceOpticalFlowFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceOpticalFlowFeaturesNV *structure = (VkPhysicalDeviceOpticalFlowFeaturesNV *) header;
                skip |= ValidateBool32(loc, "opticalFlow", structure->opticalFlow);
            }
        } break;

        // No Validation code for VkPhysicalDeviceOpticalFlowPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceOpticalFlowPropertiesNV-sType-sType

        // Validation code for VkOpticalFlowImageFormatInfoNV structure members
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: { // Covers VUID-VkOpticalFlowImageFormatInfoNV-sType-sType
            if (is_const_param) {
                VkOpticalFlowImageFormatInfoNV *structure = (VkOpticalFlowImageFormatInfoNV *) header;
                skip |= ValidateFlags(loc, "usage", "VkOpticalFlowUsageFlagBitsNV", AllVkOpticalFlowUsageFlagBitsNV, structure->usage, kRequiredFlags, "VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter", "VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkOpticalFlowSessionCreatePrivateDataInfoNV structure members
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: { // Covers VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-sType-sType
            if (is_const_param) {
                VkOpticalFlowSessionCreatePrivateDataInfoNV *structure = (VkOpticalFlowSessionCreatePrivateDataInfoNV *) header;
                skip |= ValidateRequiredPointer(loc, "pPrivateData", structure->pPrivateData, "VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-pPrivateData-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceLegacyDitheringFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceLegacyDitheringFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceLegacyDitheringFeaturesEXT *structure = (VkPhysicalDeviceLegacyDitheringFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "legacyDithering", structure->legacyDithering);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineProtectedAccessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePipelineProtectedAccessFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *structure = (VkPhysicalDevicePipelineProtectedAccessFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "pipelineProtectedAccess", structure->pipelineProtectedAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderObjectFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceShaderObjectFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderObjectFeaturesEXT *structure = (VkPhysicalDeviceShaderObjectFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "shaderObject", structure->shaderObject);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderObjectPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceShaderObjectPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceTilePropertiesFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceTilePropertiesFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceTilePropertiesFeaturesQCOM *structure = (VkPhysicalDeviceTilePropertiesFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "tileProperties", structure->tileProperties);
            }
        } break;

        // Validation code for VkPhysicalDeviceAmigoProfilingFeaturesSEC structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC: { // Covers VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceAmigoProfilingFeaturesSEC *structure = (VkPhysicalDeviceAmigoProfilingFeaturesSEC *) header;
                skip |= ValidateBool32(loc, "amigoProfiling", structure->amigoProfiling);
            }
        } break;

        // No Validation code for VkAmigoProfilingSubmitInfoSEC structure members  -- Covers VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType

        // Validation code for VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *structure = (VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "multiviewPerViewViewports", structure->multiviewPerViewViewports);
            }
        } break;

        // No Validation code for VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV structure members  -- Covers VUID-VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV: { // Covers VUID-VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *structure = (VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *) header;
                skip |= ValidateBool32(loc, "rayTracingInvocationReorder", structure->rayTracingInvocationReorder);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: { // Covers VUID-VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *structure = (VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *) header;
                skip |= ValidateBool32(loc, "shaderCoreBuiltins", structure->shaderCoreBuiltins);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM structure members  -- Covers VUID-VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM-sType-sType

        // Validation code for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT: { // Covers VUID-VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *structure = (VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "pipelineLibraryGroupHandles", structure->pipelineLibraryGroupHandles);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *structure = (VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "dynamicRenderingUnusedAttachments", structure->dynamicRenderingUnusedAttachments);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *structure = (VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "multiviewPerViewRenderAreas", structure->multiviewPerViewRenderAreas);
            }
        } break;

        // Validation code for VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM structure members
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM: { // Covers VUID-VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM-sType-sType
            if (is_const_param) {
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM *structure = (VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM *) header;
                skip |= ValidateArray(loc, "perViewRenderAreaCount", "pPerViewRenderAreas", structure->perViewRenderAreaCount, &structure->pPerViewRenderAreas, false, true, kVUIDUndefined, "VUID-VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM-pPerViewRenderAreas-parameter");

                if (structure->pPerViewRenderAreas != nullptr)
                {
                    for (uint32_t perViewRenderAreaIndex = 0; perViewRenderAreaIndex < structure->perViewRenderAreaCount; ++perViewRenderAreaIndex)
                    {
                    }
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceImageProcessing2FeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceImageProcessing2FeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceImageProcessing2FeaturesQCOM *structure = (VkPhysicalDeviceImageProcessing2FeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "textureBlockMatch2", structure->textureBlockMatch2);
            }
        } break;

        // No Validation code for VkPhysicalDeviceImageProcessing2PropertiesQCOM structure members  -- Covers VUID-VkPhysicalDeviceImageProcessing2PropertiesQCOM-sType-sType

        // Validation code for VkSamplerBlockMatchWindowCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM: { // Covers VUID-VkSamplerBlockMatchWindowCreateInfoQCOM-sType-sType
            if (is_const_param) {
                VkSamplerBlockMatchWindowCreateInfoQCOM *structure = (VkSamplerBlockMatchWindowCreateInfoQCOM *) header;
                skip |= ValidateRangedEnum(loc, "windowCompareMode", "VkBlockMatchWindowCompareModeQCOM", structure->windowCompareMode, "VUID-VkSamplerBlockMatchWindowCreateInfoQCOM-windowCompareMode-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceCubicWeightsFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceCubicWeightsFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCubicWeightsFeaturesQCOM *structure = (VkPhysicalDeviceCubicWeightsFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "selectableCubicWeights", structure->selectableCubicWeights);
            }
        } break;

        // Validation code for VkSamplerCubicWeightsCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM: { // Covers VUID-VkSamplerCubicWeightsCreateInfoQCOM-sType-sType
            if (is_const_param) {
                VkSamplerCubicWeightsCreateInfoQCOM *structure = (VkSamplerCubicWeightsCreateInfoQCOM *) header;
                skip |= ValidateRangedEnum(loc, "cubicWeights", "VkCubicFilterWeightsQCOM", structure->cubicWeights, "VUID-VkSamplerCubicWeightsCreateInfoQCOM-cubicWeights-parameter");
            }
        } break;

        // Validation code for VkBlitImageCubicWeightsInfoQCOM structure members
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM: { // Covers VUID-VkBlitImageCubicWeightsInfoQCOM-sType-sType
            if (is_const_param) {
                VkBlitImageCubicWeightsInfoQCOM *structure = (VkBlitImageCubicWeightsInfoQCOM *) header;
                skip |= ValidateRangedEnum(loc, "cubicWeights", "VkCubicFilterWeightsQCOM", structure->cubicWeights, "VUID-VkBlitImageCubicWeightsInfoQCOM-cubicWeights-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcrDegammaFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceYcbcrDegammaFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *structure = (VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "ycbcrDegamma", structure->ycbcrDegamma);
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM: { // Covers VUID-VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM-sType-sType
            if (is_const_param) {
                VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM *structure = (VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM *) header;
                skip |= ValidateBool32(loc, "enableYDegamma", structure->enableYDegamma);

                skip |= ValidateBool32(loc, "enableCbCrDegamma", structure->enableCbCrDegamma);
            }
        } break;

        // Validation code for VkPhysicalDeviceCubicClampFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM: { // Covers VUID-VkPhysicalDeviceCubicClampFeaturesQCOM-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceCubicClampFeaturesQCOM *structure = (VkPhysicalDeviceCubicClampFeaturesQCOM *) header;
                skip |= ValidateBool32(loc, "cubicRangeClamp", structure->cubicRangeClamp);
            }
        } break;

        // Validation code for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *structure = (VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "attachmentFeedbackLoopDynamicState", structure->attachmentFeedbackLoopDynamicState);
            }
        } break;
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // No Validation code for VkScreenBufferFormatPropertiesQNX structure members  -- Covers VUID-VkScreenBufferFormatPropertiesQNX-sType-sType
#endif // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // No Validation code for VkImportScreenBufferInfoQNX structure members  -- Covers VUID-VkImportScreenBufferInfoQNX-sType-sType
#endif // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // No Validation code for VkExternalFormatQNX structure members  -- Covers VUID-VkExternalFormatQNX-sType-sType
#endif // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX: { // Covers VUID-VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX *structure = (VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX *) header;
                skip |= ValidateBool32(loc, "screenBufferImport", structure->screenBufferImport);
            }
        } break;
#endif // VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkWriteDescriptorSetAccelerationStructureKHR structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: { // Covers VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType
            if (is_const_param) {
                VkWriteDescriptorSetAccelerationStructureKHR *structure = (VkWriteDescriptorSetAccelerationStructureKHR *) header;
                skip |= ValidateArray(loc, "accelerationStructureCount", "pAccelerationStructures", structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false, "VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength", "VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceAccelerationStructureFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceAccelerationStructureFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceAccelerationStructureFeaturesKHR *structure = (VkPhysicalDeviceAccelerationStructureFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "accelerationStructure", structure->accelerationStructure);

                skip |= ValidateBool32(loc, "accelerationStructureCaptureReplay", structure->accelerationStructureCaptureReplay);

                skip |= ValidateBool32(loc, "accelerationStructureIndirectBuild", structure->accelerationStructureIndirectBuild);

                skip |= ValidateBool32(loc, "accelerationStructureHostCommands", structure->accelerationStructureHostCommands);

                skip |= ValidateBool32(loc, "descriptorBindingAccelerationStructureUpdateAfterBind", structure->descriptorBindingAccelerationStructureUpdateAfterBind);
            }
        } break;

        // No Validation code for VkPhysicalDeviceAccelerationStructurePropertiesKHR structure members  -- Covers VUID-VkPhysicalDeviceAccelerationStructurePropertiesKHR-sType-sType

        // Validation code for VkPhysicalDeviceRayTracingPipelineFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRayTracingPipelineFeaturesKHR *structure = (VkPhysicalDeviceRayTracingPipelineFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "rayTracingPipeline", structure->rayTracingPipeline);

                skip |= ValidateBool32(loc, "rayTracingPipelineShaderGroupHandleCaptureReplay", structure->rayTracingPipelineShaderGroupHandleCaptureReplay);

                skip |= ValidateBool32(loc, "rayTracingPipelineShaderGroupHandleCaptureReplayMixed", structure->rayTracingPipelineShaderGroupHandleCaptureReplayMixed);

                skip |= ValidateBool32(loc, "rayTracingPipelineTraceRaysIndirect", structure->rayTracingPipelineTraceRaysIndirect);

                skip |= ValidateBool32(loc, "rayTraversalPrimitiveCulling", structure->rayTraversalPrimitiveCulling);
            }
        } break;

        // No Validation code for VkPhysicalDeviceRayTracingPipelinePropertiesKHR structure members  -- Covers VUID-VkPhysicalDeviceRayTracingPipelinePropertiesKHR-sType-sType

        // Validation code for VkPhysicalDeviceRayQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: { // Covers VUID-VkPhysicalDeviceRayQueryFeaturesKHR-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceRayQueryFeaturesKHR *structure = (VkPhysicalDeviceRayQueryFeaturesKHR *) header;
                skip |= ValidateBool32(loc, "rayQuery", structure->rayQuery);
            }
        } break;

        // Validation code for VkPhysicalDeviceMeshShaderFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: { // Covers VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-sType-sType
            if (is_const_param) {
                VkPhysicalDeviceMeshShaderFeaturesEXT *structure = (VkPhysicalDeviceMeshShaderFeaturesEXT *) header;
                skip |= ValidateBool32(loc, "taskShader", structure->taskShader);

                skip |= ValidateBool32(loc, "meshShader", structure->meshShader);

                skip |= ValidateBool32(loc, "multiviewMeshShader", structure->multiviewMeshShader);

                skip |= ValidateBool32(loc, "primitiveFragmentShadingRateMeshShader", structure->primitiveFragmentShadingRateMeshShader);

                skip |= ValidateBool32(loc, "meshShaderQueries", structure->meshShaderQueries);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMeshShaderPropertiesEXT structure members  -- Covers VUID-VkPhysicalDeviceMeshShaderPropertiesEXT-sType-sType
        default:
            skip = false;
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, true, "VUID-vkCreateInstance-pCreateInfo-parameter", "VUID-VkInstanceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkInstanceCreateInfo = { VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT, VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT, VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT, VkDirectDriverLoadingListLUNARG, VkExportMetalObjectCreateInfoEXT, VkValidationFeaturesEXT, VkValidationFlagsEXT, VkLayerSettingsCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkInstanceCreateInfo.size(), allowed_structs_VkInstanceCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkInstanceCreateInfo-pNext-pNext", "VUID-VkInstanceCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkInstanceCreateFlagBits", AllVkInstanceCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkInstanceCreateInfo-flags-parameter");

        skip |= ValidateStructType(loc, "pCreateInfo->pApplicationInfo", "VK_STRUCTURE_TYPE_APPLICATION_INFO", pCreateInfo->pApplicationInfo, VK_STRUCTURE_TYPE_APPLICATION_INFO, false, "VUID-VkInstanceCreateInfo-pApplicationInfo-parameter", "VUID-VkApplicationInfo-sType-sType");

        if (pCreateInfo->pApplicationInfo != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pCreateInfo->pApplicationInfo->pNext", nullptr, pCreateInfo->pApplicationInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkApplicationInfo-pNext-pNext", kVUIDUndefined, false, true);
        }

        skip |= ValidateStringArray(loc, "pCreateInfo->enabledLayerCount", "pCreateInfo->ppEnabledLayerNames", pCreateInfo->enabledLayerCount, pCreateInfo->ppEnabledLayerNames, false, true, kVUIDUndefined, "VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter");

        skip |= ValidateStringArray(loc, "pCreateInfo->enabledExtensionCount", "pCreateInfo->ppEnabledExtensionNames", pCreateInfo->enabledExtensionCount, pCreateInfo->ppEnabledExtensionNames, false, true, kVUIDUndefined, "VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pInstance", pInstance, "VUID-vkCreateInstance-pInstance-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateInstance(pCreateInfo, pAllocator, pInstance, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "pPhysicalDeviceCount", "pPhysicalDevices", pPhysicalDeviceCount, &pPhysicalDevices, true, false, false, kVUIDUndefined, "VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFeatures(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures*                   pFeatures,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc, "pFeatures", pFeatures, "VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties*                         pFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "format", "VkFormat", format, "VUID-vkGetPhysicalDeviceFormatProperties-format-parameter");
    skip |= ValidateRequiredPointer(loc, "pFormatProperties", pFormatProperties, "VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter");
    if (pFormatProperties != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkImageFormatProperties*                    pImageFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "format", "VkFormat", format, "VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter");
    skip |= ValidateRangedEnum(loc, "type", "VkImageType", type, "VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter");
    skip |= ValidateRangedEnum(loc, "tiling", "VkImageTiling", tiling, "VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter");
    skip |= ValidateFlags(loc, "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, usage, kRequiredFlags, "VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter", "VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask");
    skip |= ValidateFlags(loc, "flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, flags, kOptionalFlags, "VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter");
    skip |= ValidateRequiredPointer(loc, "pImageFormatProperties", pImageFormatProperties, "VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter");
    if (pImageFormatProperties != nullptr)
    {
        // No xml-driven validation
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties*                 pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc, "pProperties", pProperties, "VUID-vkGetPhysicalDeviceProperties-pProperties-parameter");
    if (pProperties != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties*                    pQueueFamilyProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "pQueueFamilyPropertyCount", "pQueueFamilyProperties", pQueueFamilyPropertyCount, &pQueueFamilyProperties, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter");
    if (pQueueFamilyProperties != nullptr)
    {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount; ++pQueueFamilyPropertyIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc, "pMemoryProperties", pMemoryProperties, "VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter");
    if (pMemoryProperties != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, true, "VUID-vkCreateDevice-pCreateInfo-parameter", "VUID-VkDeviceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDeviceCreateInfo = { VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV, VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO, VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDeviceDeviceMemoryReportCreateInfoEXT, VkDeviceDiagnosticsConfigCreateInfoNV, VkDeviceGroupDeviceCreateInfo, VkDeviceMemoryOverallocationCreateInfoAMD, VkDevicePrivateDataCreateInfo, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice4444FormatsFeaturesEXT, VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceAccelerationStructureFeaturesKHR, VkPhysicalDeviceAddressBindingReportFeaturesEXT, VkPhysicalDeviceAmigoProfilingFeaturesSEC, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceColorWriteEnableFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesKHR, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCubicClampFeaturesQCOM, VkPhysicalDeviceCubicWeightsFeaturesQCOM, VkPhysicalDeviceCustomBorderColorFeaturesEXT, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthBiasControlFeaturesEXT, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, VkPhysicalDeviceDepthClipControlFeaturesEXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDescriptorBufferFeaturesEXT, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, VkPhysicalDeviceDiagnosticsConfigFeaturesNV, VkPhysicalDeviceDisplacementMicromapFeaturesNV, VkPhysicalDeviceDynamicRenderingFeatures, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, VkPhysicalDeviceFaultFeaturesEXT, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, VkPhysicalDeviceFragmentShadingRateFeaturesKHR, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, VkPhysicalDeviceHostImageCopyFeaturesEXT, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, VkPhysicalDeviceImageCompressionControlFeaturesEXT, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, VkPhysicalDeviceImageProcessing2FeaturesQCOM, VkPhysicalDeviceImageProcessingFeaturesQCOM, VkPhysicalDeviceImageRobustnessFeatures, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, VkPhysicalDeviceImageViewMinLodFeaturesEXT, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceIndexTypeUint8FeaturesEXT, VkPhysicalDeviceInheritedViewportScissorFeaturesNV, VkPhysicalDeviceInlineUniformBlockFeatures, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, VkPhysicalDeviceLegacyDitheringFeaturesEXT, VkPhysicalDeviceLineRasterizationFeaturesEXT, VkPhysicalDeviceLinearColorAttachmentFeaturesNV, VkPhysicalDeviceMaintenance4Features, VkPhysicalDeviceMaintenance5FeaturesKHR, VkPhysicalDeviceMemoryDecompressionFeaturesNV, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiDrawFeaturesEXT, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, VkPhysicalDeviceOpacityMicromapFeaturesEXT, VkPhysicalDeviceOpticalFlowFeaturesNV, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, VkPhysicalDevicePerformanceQueryFeaturesKHR, VkPhysicalDevicePipelineCreationCacheControlFeatures, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, VkPhysicalDevicePipelinePropertiesFeaturesEXT, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, VkPhysicalDevicePipelineRobustnessFeaturesEXT, VkPhysicalDevicePortabilitySubsetFeaturesKHR, VkPhysicalDevicePresentBarrierFeaturesNV, VkPhysicalDevicePresentIdFeaturesKHR, VkPhysicalDevicePresentWaitFeaturesKHR, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, VkPhysicalDevicePrivateDataFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProvokingVertexFeaturesEXT, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, VkPhysicalDeviceRayQueryFeaturesKHR, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, VkPhysicalDeviceRayTracingPipelineFeaturesKHR, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceRobustness2FeaturesEXT, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderClockFeaturesKHR, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, VkPhysicalDeviceShaderEnqueueFeaturesAMDX, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderIntegerDotProductFeatures, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, VkPhysicalDeviceShaderObjectFeaturesEXT, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, VkPhysicalDeviceShaderTerminateInvocationFeatures, VkPhysicalDeviceShaderTileImageFeaturesEXT, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceSubgroupSizeControlFeatures, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, VkPhysicalDeviceSynchronization2Features, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeatures, VkPhysicalDeviceTilePropertiesFeaturesQCOM, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, VkPhysicalDeviceVulkan11Features, VkPhysicalDeviceVulkan12Features, VkPhysicalDeviceVulkan13Features, VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures", pCreateInfo->pNext, allowed_structs_VkDeviceCreateInfo.size(), allowed_structs_VkDeviceCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDeviceCreateInfo-pNext-pNext", "VUID-VkDeviceCreateInfo-sType-unique", true, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDeviceCreateInfo-flags-zerobitmask");

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->queueCreateInfoCount", "pCreateInfo->pQueueCreateInfos", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", pCreateInfo->queueCreateInfoCount, pCreateInfo->pQueueCreateInfos, VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, true, true, "VUID-VkDeviceQueueCreateInfo-sType-sType", "VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter", "VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength");

        if (pCreateInfo->pQueueCreateInfos != nullptr)
        {
            for (uint32_t queueCreateInfoIndex = 0; queueCreateInfoIndex < pCreateInfo->queueCreateInfoCount; ++queueCreateInfoIndex)
            {
                constexpr std::array allowed_structs_VkDeviceQueueCreateInfo = { VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pQueueCreateInfos[%i].pNext", ParameterName::IndexVector{ queueCreateInfoIndex }), "VkDeviceQueueGlobalPriorityCreateInfoKHR", pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pNext, allowed_structs_VkDeviceQueueCreateInfo.size(), allowed_structs_VkDeviceQueueCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDeviceQueueCreateInfo-pNext-pNext", "VUID-VkDeviceQueueCreateInfo-sType-unique", true, true);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pQueueCreateInfos[%i].flags", ParameterName::IndexVector{ queueCreateInfoIndex }), "VkDeviceQueueCreateFlagBits", AllVkDeviceQueueCreateFlagBits, pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].flags, kOptionalFlags, "VUID-VkDeviceQueueCreateInfo-flags-parameter");

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pQueueCreateInfos[%i].queueCount", ParameterName::IndexVector{ queueCreateInfoIndex }), ParameterName("pCreateInfo->pQueueCreateInfos[%i].pQueuePriorities", ParameterName::IndexVector{ queueCreateInfoIndex }), pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].queueCount, &pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pQueuePriorities, true, true, "VUID-VkDeviceQueueCreateInfo-queueCount-arraylength", "VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter");
            }
        }

        skip |= ValidateStringArray(loc, "pCreateInfo->enabledLayerCount", "pCreateInfo->ppEnabledLayerNames", pCreateInfo->enabledLayerCount, pCreateInfo->ppEnabledLayerNames, false, true, kVUIDUndefined, "VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter");

        skip |= ValidateStringArray(loc, "pCreateInfo->enabledExtensionCount", "pCreateInfo->ppEnabledExtensionNames", pCreateInfo->enabledExtensionCount, pCreateInfo->ppEnabledExtensionNames, false, true, kVUIDUndefined, "VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter");

        if (pCreateInfo->pEnabledFeatures != nullptr)
        {
            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->robustBufferAccess", pCreateInfo->pEnabledFeatures->robustBufferAccess);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->fullDrawIndexUint32", pCreateInfo->pEnabledFeatures->fullDrawIndexUint32);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->imageCubeArray", pCreateInfo->pEnabledFeatures->imageCubeArray);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->independentBlend", pCreateInfo->pEnabledFeatures->independentBlend);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->geometryShader", pCreateInfo->pEnabledFeatures->geometryShader);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->tessellationShader", pCreateInfo->pEnabledFeatures->tessellationShader);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sampleRateShading", pCreateInfo->pEnabledFeatures->sampleRateShading);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->dualSrcBlend", pCreateInfo->pEnabledFeatures->dualSrcBlend);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->logicOp", pCreateInfo->pEnabledFeatures->logicOp);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->multiDrawIndirect", pCreateInfo->pEnabledFeatures->multiDrawIndirect);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->drawIndirectFirstInstance", pCreateInfo->pEnabledFeatures->drawIndirectFirstInstance);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->depthClamp", pCreateInfo->pEnabledFeatures->depthClamp);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->depthBiasClamp", pCreateInfo->pEnabledFeatures->depthBiasClamp);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->fillModeNonSolid", pCreateInfo->pEnabledFeatures->fillModeNonSolid);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->depthBounds", pCreateInfo->pEnabledFeatures->depthBounds);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->wideLines", pCreateInfo->pEnabledFeatures->wideLines);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->largePoints", pCreateInfo->pEnabledFeatures->largePoints);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->alphaToOne", pCreateInfo->pEnabledFeatures->alphaToOne);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->multiViewport", pCreateInfo->pEnabledFeatures->multiViewport);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->samplerAnisotropy", pCreateInfo->pEnabledFeatures->samplerAnisotropy);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->textureCompressionETC2", pCreateInfo->pEnabledFeatures->textureCompressionETC2);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->textureCompressionASTC_LDR", pCreateInfo->pEnabledFeatures->textureCompressionASTC_LDR);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->textureCompressionBC", pCreateInfo->pEnabledFeatures->textureCompressionBC);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->occlusionQueryPrecise", pCreateInfo->pEnabledFeatures->occlusionQueryPrecise);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->pipelineStatisticsQuery", pCreateInfo->pEnabledFeatures->pipelineStatisticsQuery);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->vertexPipelineStoresAndAtomics", pCreateInfo->pEnabledFeatures->vertexPipelineStoresAndAtomics);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->fragmentStoresAndAtomics", pCreateInfo->pEnabledFeatures->fragmentStoresAndAtomics);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderTessellationAndGeometryPointSize", pCreateInfo->pEnabledFeatures->shaderTessellationAndGeometryPointSize);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderImageGatherExtended", pCreateInfo->pEnabledFeatures->shaderImageGatherExtended);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderStorageImageExtendedFormats", pCreateInfo->pEnabledFeatures->shaderStorageImageExtendedFormats);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderStorageImageMultisample", pCreateInfo->pEnabledFeatures->shaderStorageImageMultisample);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderStorageImageReadWithoutFormat", pCreateInfo->pEnabledFeatures->shaderStorageImageReadWithoutFormat);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderStorageImageWriteWithoutFormat", pCreateInfo->pEnabledFeatures->shaderStorageImageWriteWithoutFormat);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderUniformBufferArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderUniformBufferArrayDynamicIndexing);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderSampledImageArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderSampledImageArrayDynamicIndexing);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderStorageBufferArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderStorageBufferArrayDynamicIndexing);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderStorageImageArrayDynamicIndexing", pCreateInfo->pEnabledFeatures->shaderStorageImageArrayDynamicIndexing);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderClipDistance", pCreateInfo->pEnabledFeatures->shaderClipDistance);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderCullDistance", pCreateInfo->pEnabledFeatures->shaderCullDistance);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderFloat64", pCreateInfo->pEnabledFeatures->shaderFloat64);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderInt64", pCreateInfo->pEnabledFeatures->shaderInt64);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderInt16", pCreateInfo->pEnabledFeatures->shaderInt16);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderResourceResidency", pCreateInfo->pEnabledFeatures->shaderResourceResidency);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->shaderResourceMinLod", pCreateInfo->pEnabledFeatures->shaderResourceMinLod);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseBinding", pCreateInfo->pEnabledFeatures->sparseBinding);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidencyBuffer", pCreateInfo->pEnabledFeatures->sparseResidencyBuffer);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidencyImage2D", pCreateInfo->pEnabledFeatures->sparseResidencyImage2D);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidencyImage3D", pCreateInfo->pEnabledFeatures->sparseResidencyImage3D);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidency2Samples", pCreateInfo->pEnabledFeatures->sparseResidency2Samples);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidency4Samples", pCreateInfo->pEnabledFeatures->sparseResidency4Samples);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidency8Samples", pCreateInfo->pEnabledFeatures->sparseResidency8Samples);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidency16Samples", pCreateInfo->pEnabledFeatures->sparseResidency16Samples);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->sparseResidencyAliased", pCreateInfo->pEnabledFeatures->sparseResidencyAliased);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->variableMultisampleRate", pCreateInfo->pEnabledFeatures->variableMultisampleRate);

            skip |= ValidateBool32(loc, "pCreateInfo->pEnabledFeatures->inheritedQueries", pCreateInfo->pEnabledFeatures->inheritedQueries);
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pDevice", pDevice, "VUID-vkCreateDevice-pDevice-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDevice(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceQueue(
    VkDevice                                    device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    VkQueue*                                    pQueue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc, "pQueue", pQueue, "VUID-vkGetDeviceQueue-pQueue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSubmit(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "submitCount", "pSubmits", "VK_STRUCTURE_TYPE_SUBMIT_INFO", submitCount, pSubmits, VK_STRUCTURE_TYPE_SUBMIT_INFO, false, true, "VUID-VkSubmitInfo-sType-sType", "VUID-vkQueueSubmit-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr)
    {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex)
        {
            constexpr std::array allowed_structs_VkSubmitInfo = { VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC, VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO, VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO, VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV };

            skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pNext", ParameterName::IndexVector{ submitIndex }), "VkAmigoProfilingSubmitInfoSEC, VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfo, VkPerformanceQuerySubmitInfoKHR, VkProtectedSubmitInfo, VkTimelineSemaphoreSubmitInfo, VkWin32KeyedMutexAcquireReleaseInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoNV", pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo.size(), allowed_structs_VkSubmitInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubmitInfo-pNext-pNext", "VUID-VkSubmitInfo-sType-unique", false, true);

            skip |= ValidateArray(loc, ParameterName("pSubmits[%i].waitSemaphoreCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pWaitSemaphores", ParameterName::IndexVector{ submitIndex }), pSubmits[submitIndex].waitSemaphoreCount, &pSubmits[submitIndex].pWaitSemaphores, false, true, kVUIDUndefined, "VUID-VkSubmitInfo-pWaitSemaphores-parameter");

            skip |= ValidateFlagsArray(loc, ParameterName("pSubmits[%i].waitSemaphoreCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pWaitDstStageMask", ParameterName::IndexVector{ submitIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pSubmits[submitIndex].waitSemaphoreCount, pSubmits[submitIndex].pWaitDstStageMask, false, "VUID-VkSubmitInfo-pWaitDstStageMask-parameter");

            skip |= ValidateArray(loc, ParameterName("pSubmits[%i].commandBufferCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pCommandBuffers", ParameterName::IndexVector{ submitIndex }), pSubmits[submitIndex].commandBufferCount, &pSubmits[submitIndex].pCommandBuffers, false, true, kVUIDUndefined, "VUID-VkSubmitInfo-pCommandBuffers-parameter");

            skip |= ValidateArray(loc, ParameterName("pSubmits[%i].signalSemaphoreCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pSignalSemaphores", ParameterName::IndexVector{ submitIndex }), pSubmits[submitIndex].signalSemaphoreCount, &pSubmits[submitIndex].pSignalSemaphores, false, true, kVUIDUndefined, "VUID-VkSubmitInfo-pSignalSemaphores-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateQueueWaitIdle(
    VkQueue                                     queue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateDeviceWaitIdle(
    VkDevice                                    device,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateAllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pAllocateInfo", "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", pAllocateInfo, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, true, "VUID-vkAllocateMemory-pAllocateInfo-parameter", "VUID-VkMemoryAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryAllocateInfo = { VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID, VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA, VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV, VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO, VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO, VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO, VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pAllocateInfo->pNext", "VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkExportMetalObjectCreateInfoEXT, VkImportAndroidHardwareBufferInfoANDROID, VkImportMemoryBufferCollectionFUCHSIA, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkImportMemoryZirconHandleInfoFUCHSIA, VkImportMetalBufferInfoEXT, VkImportScreenBufferInfoQNX, VkMemoryAllocateFlagsInfo, VkMemoryDedicatedAllocateInfo, VkMemoryOpaqueCaptureAddressAllocateInfo, VkMemoryPriorityAllocateInfoEXT", pAllocateInfo->pNext, allowed_structs_VkMemoryAllocateInfo.size(), allowed_structs_VkMemoryAllocateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryAllocateInfo-pNext-pNext", "VUID-VkMemoryAllocateInfo-sType-unique", false, true);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pMemory", pMemory, "VUID-vkAllocateMemory-pMemory-parameter");
    if (!skip) skip |= manual_PreCallValidateAllocateMemory(device, pAllocateInfo, pAllocator, pMemory, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    skip |= ValidateReservedFlags(loc, "flags", flags, "VUID-vkMapMemory-flags-zerobitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    return skip;
}

bool StatelessValidation::PreCallValidateFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "memoryRangeCount", "pMemoryRanges", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", memoryRangeCount, pMemoryRanges, VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, "VUID-VkMappedMemoryRange-sType-sType", "VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter", "VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength");
    if (pMemoryRanges != nullptr)
    {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pMemoryRanges[%i].pNext", ParameterName::IndexVector{ memoryRangeIndex }), nullptr, pMemoryRanges[memoryRangeIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMappedMemoryRange-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pMemoryRanges[%i].memory", ParameterName::IndexVector{ memoryRangeIndex }), pMemoryRanges[memoryRangeIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "memoryRangeCount", "pMemoryRanges", "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", memoryRangeCount, pMemoryRanges, VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, "VUID-VkMappedMemoryRange-sType-sType", "VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter", "VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength");
    if (pMemoryRanges != nullptr)
    {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pMemoryRanges[%i].pNext", ParameterName::IndexVector{ memoryRangeIndex }), nullptr, pMemoryRanges[memoryRangeIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMappedMemoryRange-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pMemoryRanges[%i].memory", ParameterName::IndexVector{ memoryRangeIndex }), pMemoryRanges[memoryRangeIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    skip |= ValidateRequiredPointer(loc, "pCommittedMemoryInBytes", pCommittedMemoryInBytes, "VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateBindBufferMemory(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    return skip;
}

bool StatelessValidation::PreCallValidateBindImageMemory(
    VkDevice                                    device,
    VkImage                                     image,
    VkDeviceMemory                              memory,
    VkDeviceSize                                memoryOffset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferMemoryRequirements(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    VkMemoryRequirements*                       pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredPointer(loc, "pMemoryRequirements", pMemoryRequirements, "VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter");
    if (pMemoryRequirements != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    VkMemoryRequirements*                       pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateRequiredPointer(loc, "pMemoryRequirements", pMemoryRequirements, "VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter");
    if (pMemoryRequirements != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSparseMemoryRequirements(
    VkDevice                                    device,
    VkImage                                     image,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements*            pSparseMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateArray(loc, "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", pSparseMemoryRequirementCount, &pSparseMemoryRequirements, true, false, false, kVUIDUndefined, "VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter");
    if (pSparseMemoryRequirements != nullptr)
    {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount; ++pSparseMemoryRequirementIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties*              pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "format", "VkFormat", format, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter");
    skip |= ValidateRangedEnum(loc, "type", "VkImageType", type, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter");
    skip |= ValidateFlags(loc, "samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, samples, kRequiredSingleBit, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter", "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter");
    skip |= ValidateFlags(loc, "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, usage, kRequiredFlags, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter", "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask");
    skip |= ValidateRangedEnum(loc, "tiling", "VkImageTiling", tiling, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter");
    skip |= ValidateArray(loc, "pPropertyCount", "pProperties", pPropertyCount, &pProperties, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter");
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateQueueBindSparse(
    VkQueue                                     queue,
    uint32_t                                    bindInfoCount,
    const VkBindSparseInfo*                     pBindInfo,
    VkFence                                     fence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "bindInfoCount", "pBindInfo", "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", bindInfoCount, pBindInfo, VK_STRUCTURE_TYPE_BIND_SPARSE_INFO, false, true, "VUID-VkBindSparseInfo-sType-sType", "VUID-vkQueueBindSparse-pBindInfo-parameter", kVUIDUndefined);
    if (pBindInfo != nullptr)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            constexpr std::array allowed_structs_VkBindSparseInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO, VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pBindInfo[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkDeviceGroupBindSparseInfo, VkTimelineSemaphoreSubmitInfo", pBindInfo[bindInfoIndex].pNext, allowed_structs_VkBindSparseInfo.size(), allowed_structs_VkBindSparseInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBindSparseInfo-pNext-pNext", "VUID-VkBindSparseInfo-sType-unique", false, true);

            skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].waitSemaphoreCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pWaitSemaphores", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].waitSemaphoreCount, &pBindInfo[bindInfoIndex].pWaitSemaphores, false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pWaitSemaphores-parameter");

            skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].bufferBindCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pBufferBinds", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].bufferBindCount, &pBindInfo[bindInfoIndex].pBufferBinds, false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pBufferBinds-parameter");

            if (pBindInfo[bindInfoIndex].pBufferBinds != nullptr)
            {
                for (uint32_t bufferBindIndex = 0; bufferBindIndex < pBindInfo[bindInfoIndex].bufferBindCount; ++bufferBindIndex)
                {
                    skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfo[%i].pBufferBinds[%i].buffer", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex }), pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].buffer);

                    skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].pBufferBinds[%i].bindCount", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex }), ParameterName("pBindInfo[%i].pBufferBinds[%i].pBinds", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex }), pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount, &pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds, true, true, "VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength", "VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds != nullptr)
                    {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount; ++bindIndex)
                        {
                            skip |= ValidateFlags(loc, ParameterName("pBindInfo[%i].pBufferBinds[%i].pBinds[%i].flags", ParameterName::IndexVector{ bindInfoIndex, bufferBindIndex, bindIndex }), "VkSparseMemoryBindFlagBits", AllVkSparseMemoryBindFlagBits, pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds[bindIndex].flags, kOptionalFlags, "VUID-VkSparseMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].imageOpaqueBindCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pImageOpaqueBinds", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].imageOpaqueBindCount, &pBindInfo[bindInfoIndex].pImageOpaqueBinds, false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter");

            if (pBindInfo[bindInfoIndex].pImageOpaqueBinds != nullptr)
            {
                for (uint32_t imageOpaqueBindIndex = 0; imageOpaqueBindIndex < pBindInfo[bindInfoIndex].imageOpaqueBindCount; ++imageOpaqueBindIndex)
                {
                    skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].image", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex }), pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].image);

                    skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].bindCount", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex }), ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].pBinds", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex }), pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount, &pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds, true, true, "VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength", "VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds != nullptr)
                    {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount; ++bindIndex)
                        {
                            skip |= ValidateFlags(loc, ParameterName("pBindInfo[%i].pImageOpaqueBinds[%i].pBinds[%i].flags", ParameterName::IndexVector{ bindInfoIndex, imageOpaqueBindIndex, bindIndex }), "VkSparseMemoryBindFlagBits", AllVkSparseMemoryBindFlagBits, pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds[bindIndex].flags, kOptionalFlags, "VUID-VkSparseMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].imageBindCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pImageBinds", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].imageBindCount, &pBindInfo[bindInfoIndex].pImageBinds, false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pImageBinds-parameter");

            if (pBindInfo[bindInfoIndex].pImageBinds != nullptr)
            {
                for (uint32_t imageBindIndex = 0; imageBindIndex < pBindInfo[bindInfoIndex].imageBindCount; ++imageBindIndex)
                {
                    skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfo[%i].pImageBinds[%i].image", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex }), pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].image);

                    skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].pImageBinds[%i].bindCount", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex }), ParameterName("pBindInfo[%i].pImageBinds[%i].pBinds", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex }), pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount, &pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds, true, true, "VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength", "VUID-VkSparseImageMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds != nullptr)
                    {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount; ++bindIndex)
                        {
                            skip |= ValidateFlags(loc, ParameterName("pBindInfo[%i].pImageBinds[%i].pBinds[%i].subresource.aspectMask", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex, bindIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].subresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");

                            // No xml-driven validation

                            // No xml-driven validation

                            skip |= ValidateFlags(loc, ParameterName("pBindInfo[%i].pImageBinds[%i].pBinds[%i].flags", ParameterName::IndexVector{ bindInfoIndex, imageBindIndex, bindIndex }), "VkSparseMemoryBindFlagBits", AllVkSparseMemoryBindFlagBits, pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].flags, kOptionalFlags, "VUID-VkSparseImageMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= ValidateArray(loc, ParameterName("pBindInfo[%i].signalSemaphoreCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfo[%i].pSignalSemaphores", ParameterName::IndexVector{ bindInfoIndex }), pBindInfo[bindInfoIndex].signalSemaphoreCount, &pBindInfo[bindInfoIndex].pSignalSemaphores, false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pSignalSemaphores-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateFence(
    VkDevice                                    device,
    const VkFenceCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, true, "VUID-vkCreateFence-pCreateInfo-parameter", "VUID-VkFenceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkFenceCreateInfo = { VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO, VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkExportFenceCreateInfo, VkExportFenceWin32HandleInfoKHR", pCreateInfo->pNext, allowed_structs_VkFenceCreateInfo.size(), allowed_structs_VkFenceCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkFenceCreateInfo-pNext-pNext", "VUID-VkFenceCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkFenceCreateFlagBits", AllVkFenceCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkFenceCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pFence", pFence, "VUID-vkCreateFence-pFence-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyFence(
    VkDevice                                    device,
    VkFence                                     fence,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateHandleArray(loc, "fenceCount", "pFences", fenceCount, pFences, true, true, "VUID-vkResetFences-fenceCount-arraylength");
    return skip;
}

bool StatelessValidation::PreCallValidateGetFenceStatus(
    VkDevice                                    device,
    VkFence                                     fence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "fence", fence);
    return skip;
}

bool StatelessValidation::PreCallValidateWaitForFences(
    VkDevice                                    device,
    uint32_t                                    fenceCount,
    const VkFence*                              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateHandleArray(loc, "fenceCount", "pFences", fenceCount, pFences, true, true, "VUID-vkWaitForFences-fenceCount-arraylength");
    skip |= ValidateBool32(loc, "waitAll", waitAll);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSemaphore(
    VkDevice                                    device,
    const VkSemaphoreCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSemaphore*                                pSemaphore,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, true, "VUID-vkCreateSemaphore-pCreateInfo-parameter", "VUID-VkSemaphoreCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSemaphoreCreateInfo = { VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT, VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV, VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkExportMetalObjectCreateInfoEXT, VkExportSemaphoreCreateInfo, VkExportSemaphoreWin32HandleInfoKHR, VkImportMetalSharedEventInfoEXT, VkQueryLowLatencySupportNV, VkSemaphoreTypeCreateInfo", pCreateInfo->pNext, allowed_structs_VkSemaphoreCreateInfo.size(), allowed_structs_VkSemaphoreCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreCreateInfo-pNext-pNext", "VUID-VkSemaphoreCreateInfo-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkSemaphoreCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSemaphore", pSemaphore, "VUID-vkCreateSemaphore-pSemaphore-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySemaphore(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_EVENT_CREATE_INFO, true, "VUID-vkCreateEvent-pCreateInfo-parameter", "VUID-VkEventCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkEventCreateInfo = { VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkExportMetalObjectCreateInfoEXT, VkImportMetalSharedEventInfoEXT", pCreateInfo->pNext, allowed_structs_VkEventCreateInfo.size(), allowed_structs_VkEventCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkEventCreateInfo-pNext-pNext", "VUID-VkEventCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkEventCreateFlagBits", AllVkEventCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkEventCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pEvent", pEvent, "VUID-vkCreateEvent-pEvent-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateEvent(device, pCreateInfo, pAllocator, pEvent, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetEventStatus(
    VkDevice                                    device,
    VkEvent                                     event,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    return skip;
}

bool StatelessValidation::PreCallValidateSetEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    return skip;
}

bool StatelessValidation::PreCallValidateResetEvent(
    VkDevice                                    device,
    VkEvent                                     event,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateQueryPool(
    VkDevice                                    device,
    const VkQueryPoolCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkQueryPool*                                pQueryPool,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, true, "VUID-vkCreateQueryPool-pCreateInfo-parameter", "VUID-VkQueryPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkQueryPoolCreateInfo = { VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL, VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkQueryPoolPerformanceCreateInfoKHR, VkQueryPoolPerformanceQueryCreateInfoINTEL, VkQueryPoolVideoEncodeFeedbackCreateInfoKHR, VkVideoDecodeH264ProfileInfoKHR, VkVideoDecodeH265ProfileInfoKHR, VkVideoDecodeUsageInfoKHR, VkVideoEncodeH264ProfileInfoEXT, VkVideoEncodeH265ProfileInfoEXT, VkVideoEncodeUsageInfoKHR, VkVideoProfileInfoKHR", pCreateInfo->pNext, allowed_structs_VkQueryPoolCreateInfo.size(), allowed_structs_VkQueryPoolCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkQueryPoolCreateInfo-pNext-pNext", "VUID-VkQueryPoolCreateInfo-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkQueryPoolCreateInfo-flags-zerobitmask");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->queryType", "VkQueryType", pCreateInfo->queryType, "VUID-VkQueryPoolCreateInfo-queryType-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pQueryPool", pQueryPool, "VUID-vkCreateQueryPool-pQueryPool-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetQueryPoolResults(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    void*                                       pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkGetQueryPoolResults-dataSize-arraylength", "VUID-vkGetQueryPoolResults-pData-parameter");
    skip |= ValidateFlags(loc, "flags", "VkQueryResultFlagBits", AllVkQueryResultFlagBits, flags, kOptionalFlags, "VUID-vkGetQueryPoolResults-flags-parameter");
    if (!skip) skip |= manual_PreCallValidateGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateBuffer(
    VkDevice                                    device,
    const VkBufferCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBuffer*                                   pBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true, "VUID-vkCreateBuffer-pCreateInfo-parameter", "VUID-VkBufferCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkBufferCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO, VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkBufferCollectionBufferCreateInfoFUCHSIA, VkBufferDeviceAddressCreateInfoEXT, VkBufferOpaqueCaptureAddressCreateInfo, VkBufferUsageFlags2CreateInfoKHR, VkDedicatedAllocationBufferCreateInfoNV, VkExternalMemoryBufferCreateInfo, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkVideoProfileListInfoKHR", pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(), allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkBufferCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->sharingMode", "VkSharingMode", pCreateInfo->sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pBuffer", pBuffer, "VUID-vkCreateBuffer-pBuffer-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateBuffer(device, pCreateInfo, pAllocator, pBuffer, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyBuffer(
    VkDevice                                    device,
    VkBuffer                                    buffer,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateBufferView(
    VkDevice                                    device,
    const VkBufferViewCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferView*                               pView,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, true, "VUID-vkCreateBufferView-pCreateInfo-parameter", "VUID-VkBufferViewCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkBufferViewCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkBufferUsageFlags2CreateInfoKHR, VkExportMetalObjectCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkBufferViewCreateInfo.size(), allowed_structs_VkBufferViewCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferViewCreateInfo-pNext-pNext", "VUID-VkBufferViewCreateInfo-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkBufferViewCreateInfo-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->buffer", pCreateInfo->buffer);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->format", "VkFormat", pCreateInfo->format, "VUID-VkBufferViewCreateInfo-format-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pView", pView, "VUID-vkCreateBufferView-pView-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateBufferView(device, pCreateInfo, pAllocator, pView, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyBufferView(
    VkDevice                                    device,
    VkBufferView                                bufferView,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateImage(
    VkDevice                                    device,
    const VkImageCreateInfo*                    pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImage*                                    pImage,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, "VUID-vkCreateImage-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->imageType", "VkImageType", pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->format", "VkFormat", pCreateInfo->format, "VUID-VkImageCreateInfo-format-parameter");

        // No xml-driven validation

        skip |= ValidateFlags(loc, "pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pCreateInfo->samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->tiling", "VkImageTiling", pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pCreateInfo->usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->sharingMode", "VkSharingMode", pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->initialLayout", "VkImageLayout", pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pImage", pImage, "VUID-vkCreateImage-pImage-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateImage(device, pCreateInfo, pAllocator, pImage, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyImage(
    VkDevice                                    device,
    VkImage                                     image,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSubresourceLayout(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource*                   pSubresource,
    VkSubresourceLayout*                        pLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateRequiredPointer(loc, "pSubresource", pSubresource, "VUID-vkGetImageSubresourceLayout-pSubresource-parameter");
    if (pSubresource != nullptr)
    {
        skip |= ValidateFlags(loc, "pSubresource->aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pSubresource->aspectMask, kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |= ValidateRequiredPointer(loc, "pLayout", pLayout, "VUID-vkGetImageSubresourceLayout-pLayout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateImageView(
    VkDevice                                    device,
    const VkImageViewCreateInfo*                pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkImageView*                                pView,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, true, "VUID-vkCreateImageView-pCreateInfo-parameter", "VUID-VkImageViewCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkImageViewCreateInfo = { VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT, VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM, VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkExportMetalObjectCreateInfoEXT, VkImageViewASTCDecodeModeEXT, VkImageViewMinLodCreateInfoEXT, VkImageViewSampleWeightCreateInfoQCOM, VkImageViewSlicedCreateInfoEXT, VkImageViewUsageCreateInfo, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkSamplerYcbcrConversionInfo", pCreateInfo->pNext, allowed_structs_VkImageViewCreateInfo.size(), allowed_structs_VkImageViewCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageViewCreateInfo-pNext-pNext", "VUID-VkImageViewCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkImageViewCreateFlagBits", AllVkImageViewCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkImageViewCreateInfo-flags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->image", pCreateInfo->image);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->viewType", "VkImageViewType", pCreateInfo->viewType, "VUID-VkImageViewCreateInfo-viewType-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->format", "VkFormat", pCreateInfo->format, "VUID-VkImageViewCreateInfo-format-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.r", "VkComponentSwizzle", pCreateInfo->components.r, "VUID-VkComponentMapping-r-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.g", "VkComponentSwizzle", pCreateInfo->components.g, "VUID-VkComponentMapping-g-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.b", "VkComponentSwizzle", pCreateInfo->components.b, "VUID-VkComponentMapping-b-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.a", "VkComponentSwizzle", pCreateInfo->components.a, "VUID-VkComponentMapping-a-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->subresourceRange.aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCreateInfo->subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pView", pView, "VUID-vkCreateImageView-pView-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateImageView(device, pCreateInfo, pAllocator, pView, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyImageView(
    VkDevice                                    device,
    VkImageView                                 imageView,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true, "VUID-vkCreateShaderModule-pCreateInfo-parameter", "VUID-VkShaderModuleCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(loc, "pCreateInfo->codeSize / 4", "pCreateInfo->pCode", pCreateInfo->codeSize / 4, &pCreateInfo->pCode, true, true, kVUIDUndefined, "VUID-VkShaderModuleCreateInfo-pCode-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pShaderModule", pShaderModule, "VUID-vkCreateShaderModule-pShaderModule-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyShaderModule(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePipelineCache(
    VkDevice                                    device,
    const VkPipelineCacheCreateInfo*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineCache*                            pPipelineCache,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, true, "VUID-vkCreatePipelineCache-pCreateInfo-parameter", "VUID-VkPipelineCacheCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineCacheCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkPipelineCacheCreateFlagBits", AllVkPipelineCacheCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkPipelineCacheCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->initialDataSize", "pCreateInfo->pInitialData", pCreateInfo->initialDataSize, &pCreateInfo->pInitialData, false, true, kVUIDUndefined, "VUID-VkPipelineCacheCreateInfo-pInitialData-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pPipelineCache", pPipelineCache, "VUID-vkCreatePipelineCache-pPipelineCache-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipelineCache(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineCacheData(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    size_t*                                     pDataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "pipelineCache", pipelineCache);
    skip |= ValidateArray(loc, "pDataSize", "pData", pDataSize, &pData, true, false, false, kVUIDUndefined, "VUID-vkGetPipelineCacheData-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateMergePipelineCaches(
    VkDevice                                    device,
    VkPipelineCache                             dstCache,
    uint32_t                                    srcCacheCount,
    const VkPipelineCache*                      pSrcCaches,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "dstCache", dstCache);
    skip |= ValidateHandleArray(loc, "srcCacheCount", "pSrcCaches", srcCacheCount, pSrcCaches, true, true, "VUID-vkMergePipelineCaches-srcCacheCount-arraylength");
    if (!skip) skip |= manual_PreCallValidateMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateGraphicsPipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkGraphicsPipelineCreateInfo*         pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, true, true, "VUID-VkGraphicsPipelineCreateInfo-sType-sType", "VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter", "VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            constexpr std::array allowed_structs_VkGraphicsPipelineCreateInfo = { VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD, VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX, VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkAttachmentSampleCountInfoAMD, VkGraphicsPipelineLibraryCreateInfoEXT, VkGraphicsPipelineShaderGroupsCreateInfoNV, VkMultiviewPerViewAttributesInfoNVX, VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreateFlags2CreateInfoKHR, VkPipelineCreationFeedbackCreateInfo, VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineFragmentShadingRateEnumStateCreateInfoNV, VkPipelineFragmentShadingRateStateCreateInfoKHR, VkPipelineLibraryCreateInfoKHR, VkPipelineRenderingCreateInfo, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, VkPipelineRobustnessCreateInfoEXT", pCreateInfos[createInfoIndex].pNext, allowed_structs_VkGraphicsPipelineCreateInfo.size(), allowed_structs_VkGraphicsPipelineCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkGraphicsPipelineCreateInfo-pNext-pNext", "VUID-VkGraphicsPipelineCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, kOptionalFlags, "VUID-VkGraphicsPipelineCreateInfo-flags-parameter");

            skip |= ValidateStructType(loc, ParameterName("pCreateInfos[%i].pDynamicState", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", pCreateInfos[createInfoIndex].pDynamicState, VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false, "VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter", "VUID-VkPipelineDynamicStateCreateInfo-sType-sType");

            if (pCreateInfos[createInfoIndex].pDynamicState != nullptr)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pDynamicState->pNext", ParameterName::IndexVector{ createInfoIndex }), nullptr, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateReservedFlags(loc, ParameterName("pCreateInfos[%i].pDynamicState->flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pDynamicState->flags, "VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask");

                skip |= ValidateRangedEnumArray(loc, ParameterName("pCreateInfos[%i].pDynamicState->dynamicStateCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pDynamicState->pDynamicStates", ParameterName::IndexVector{ createInfoIndex }), "VkDynamicState", pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount, pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, false, true);
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "createInfoCount", "pPipelines", createInfoCount, &pPipelines, true, true, "VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength", "VUID-vkCreateGraphicsPipelines-pPipelines-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateComputePipelines(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkComputePipelineCreateInfo*          pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, true, true, "VUID-VkComputePipelineCreateInfo-sType-sType", "VUID-vkCreateComputePipelines-pCreateInfos-parameter", "VUID-vkCreateComputePipelines-createInfoCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            constexpr std::array allowed_structs_VkComputePipelineCreateInfo = { VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreateFlags2CreateInfoKHR, VkPipelineCreationFeedbackCreateInfo, VkPipelineRobustnessCreateInfoEXT, VkSubpassShadingPipelineCreateInfoHUAWEI", pCreateInfos[createInfoIndex].pNext, allowed_structs_VkComputePipelineCreateInfo.size(), allowed_structs_VkComputePipelineCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkComputePipelineCreateInfo-pNext-pNext", "VUID-VkComputePipelineCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, kOptionalFlags, "VUID-VkComputePipelineCreateInfo-flags-parameter");

            skip |= ValidateStructType(loc, ParameterName("pCreateInfos[%i].stage", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", &(pCreateInfos[createInfoIndex].stage), VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, kVUIDUndefined, "VUID-VkPipelineShaderStageCreateInfo-sType-sType");

            constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = { VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].stage.pNext", ParameterName::IndexVector{ createInfoIndex }), "VkDebugUtilsObjectNameInfoEXT, VkPipelineRobustnessCreateInfoEXT, VkPipelineShaderStageModuleIdentifierCreateInfoEXT, VkPipelineShaderStageNodeCreateInfoAMDX, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, VkShaderModuleCreateInfo, VkShaderModuleValidationCacheCreateInfoEXT", pCreateInfos[createInfoIndex].stage.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(), allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].stage.flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineShaderStageCreateFlagBits", AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].stage.flags, kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].stage.stage", ParameterName::IndexVector{ createInfoIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage.stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

            skip |= ValidateRequiredPointer(loc, ParameterName("pCreateInfos[%i].stage.pName", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

            if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo != nullptr)
            {
                skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].stage.pSpecializationInfo->mapEntryCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].stage.pSpecializationInfo->pMapEntries", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.pSpecializationInfo->mapEntryCount, &pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pMapEntries != nullptr)
                {
                    for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfos[createInfoIndex].stage.pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                    {
                        // No xml-driven validation
                    }
                }

                skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].stage.pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].stage.pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].stage.pSpecializationInfo->dataSize, &pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
            }

            skip |= ValidateRequiredHandle(loc, ParameterName("pCreateInfos[%i].layout", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "createInfoCount", "pPipelines", createInfoCount, &pPipelines, true, true, "VUID-vkCreateComputePipelines-createInfoCount-arraylength", "VUID-vkCreateComputePipelines-pPipelines-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipeline(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePipelineLayout(
    VkDevice                                    device,
    const VkPipelineLayoutCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPipelineLayout*                           pPipelineLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, true, "VUID-vkCreatePipelineLayout-pCreateInfo-parameter", "VUID-VkPipelineLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineLayoutCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkPipelineLayoutCreateFlagBits", AllVkPipelineLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkPipelineLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->pushConstantRangeCount", "pCreateInfo->pPushConstantRanges", pCreateInfo->pushConstantRangeCount, &pCreateInfo->pPushConstantRanges, false, true, kVUIDUndefined, "VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter");

        if (pCreateInfo->pPushConstantRanges != nullptr)
        {
            for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < pCreateInfo->pushConstantRangeCount; ++pushConstantRangeIndex)
            {
                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pPushConstantRanges[%i].stageFlags", ParameterName::IndexVector{ pushConstantRangeIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfo->pPushConstantRanges[pushConstantRangeIndex].stageFlags, kRequiredFlags, "VUID-VkPushConstantRange-stageFlags-parameter", "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pPipelineLayout", pPipelineLayout, "VUID-vkCreatePipelineLayout-pPipelineLayout-parameter");
    if (!skip) skip |= manual_PreCallValidateCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipelineLayout(
    VkDevice                                    device,
    VkPipelineLayout                            pipelineLayout,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSampler(
    VkDevice                                    device,
    const VkSamplerCreateInfo*                  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSampler*                                  pSampler,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, true, "VUID-vkCreateSampler-pCreateInfo-parameter", "VUID-VkSamplerCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSamplerCreateInfo = { VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM, VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM, VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkSamplerBlockMatchWindowCreateInfoQCOM, VkSamplerBorderColorComponentMappingCreateInfoEXT, VkSamplerCubicWeightsCreateInfoQCOM, VkSamplerCustomBorderColorCreateInfoEXT, VkSamplerReductionModeCreateInfo, VkSamplerYcbcrConversionInfo", pCreateInfo->pNext, allowed_structs_VkSamplerCreateInfo.size(), allowed_structs_VkSamplerCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSamplerCreateInfo-pNext-pNext", "VUID-VkSamplerCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkSamplerCreateFlagBits", AllVkSamplerCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkSamplerCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->magFilter", "VkFilter", pCreateInfo->magFilter, "VUID-VkSamplerCreateInfo-magFilter-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->minFilter", "VkFilter", pCreateInfo->minFilter, "VUID-VkSamplerCreateInfo-minFilter-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->mipmapMode", "VkSamplerMipmapMode", pCreateInfo->mipmapMode, "VUID-VkSamplerCreateInfo-mipmapMode-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->addressModeU", "VkSamplerAddressMode", pCreateInfo->addressModeU, "VUID-VkSamplerCreateInfo-addressModeU-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->addressModeV", "VkSamplerAddressMode", pCreateInfo->addressModeV, "VUID-VkSamplerCreateInfo-addressModeV-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->addressModeW", "VkSamplerAddressMode", pCreateInfo->addressModeW, "VUID-VkSamplerCreateInfo-addressModeW-parameter");

        skip |= ValidateBool32(loc, "pCreateInfo->anisotropyEnable", pCreateInfo->anisotropyEnable);

        skip |= ValidateBool32(loc, "pCreateInfo->compareEnable", pCreateInfo->compareEnable);

        skip |= ValidateBool32(loc, "pCreateInfo->unnormalizedCoordinates", pCreateInfo->unnormalizedCoordinates);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSampler", pSampler, "VUID-vkCreateSampler-pSampler-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSampler(device, pCreateInfo, pAllocator, pSampler, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySampler(
    VkDevice                                    device,
    VkSampler                                   sampler,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorSetLayout(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorSetLayout*                      pSetLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true, "VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter", "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO, VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDescriptorSetLayoutBindingFlagsCreateInfo, VkMutableDescriptorTypeCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(), allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext", "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkDescriptorSetLayoutCreateFlagBits", AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->bindingCount", "pCreateInfo->pBindings", pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined, "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr)
        {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex)
            {
                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pBindings[%i].descriptorType", ParameterName::IndexVector{ bindingIndex }), "VkDescriptorType", pCreateInfo->pBindings[bindingIndex].descriptorType, "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter");
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSetLayout", pSetLayout, "VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorSetLayout(
    VkDevice                                    device,
    VkDescriptorSetLayout                       descriptorSetLayout,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorPool(
    VkDevice                                    device,
    const VkDescriptorPoolCreateInfo*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorPool*                           pDescriptorPool,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, true, "VUID-vkCreateDescriptorPool-pCreateInfo-parameter", "VUID-VkDescriptorPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorPoolCreateInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO, VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDescriptorPoolInlineUniformBlockCreateInfo, VkMutableDescriptorTypeCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkDescriptorPoolCreateInfo.size(), allowed_structs_VkDescriptorPoolCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorPoolCreateInfo-pNext-pNext", "VUID-VkDescriptorPoolCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkDescriptorPoolCreateFlagBits", AllVkDescriptorPoolCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkDescriptorPoolCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->poolSizeCount", "pCreateInfo->pPoolSizes", pCreateInfo->poolSizeCount, &pCreateInfo->pPoolSizes, false, true, kVUIDUndefined, "VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter");

        if (pCreateInfo->pPoolSizes != nullptr)
        {
            for (uint32_t poolSizeIndex = 0; poolSizeIndex < pCreateInfo->poolSizeCount; ++poolSizeIndex)
            {
                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pPoolSizes[%i].type", ParameterName::IndexVector{ poolSizeIndex }), "VkDescriptorType", pCreateInfo->pPoolSizes[poolSizeIndex].type, "VUID-VkDescriptorPoolSize-type-parameter");
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pDescriptorPool", pDescriptorPool, "VUID-vkCreateDescriptorPool-pDescriptorPool-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetDescriptorPool(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "descriptorPool", descriptorPool);
    skip |= ValidateReservedFlags(loc, "flags", flags, "VUID-vkResetDescriptorPool-flags-zerobitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateAllocateDescriptorSets(
    VkDevice                                    device,
    const VkDescriptorSetAllocateInfo*          pAllocateInfo,
    VkDescriptorSet*                            pDescriptorSets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pAllocateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", pAllocateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, true, "VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter", "VUID-VkDescriptorSetAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorSetAllocateInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO };

        skip |= ValidateStructPnext(loc, "pAllocateInfo->pNext", "VkDescriptorSetVariableDescriptorCountAllocateInfo", pAllocateInfo->pNext, allowed_structs_VkDescriptorSetAllocateInfo.size(), allowed_structs_VkDescriptorSetAllocateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetAllocateInfo-pNext-pNext", "VUID-VkDescriptorSetAllocateInfo-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pAllocateInfo->descriptorPool", pAllocateInfo->descriptorPool);

        skip |= ValidateHandleArray(loc, "pAllocateInfo->descriptorSetCount", "pAllocateInfo->pSetLayouts", pAllocateInfo->descriptorSetCount, pAllocateInfo->pSetLayouts, true, true, kVUIDUndefined);
    }
    if (pAllocateInfo != nullptr) {
        skip |= ValidateArray(loc, "pAllocateInfo->descriptorSetCount", "pDescriptorSets", pAllocateInfo->descriptorSetCount, &pDescriptorSets, true, true, "VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength", "VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateFreeDescriptorSets(
    VkDevice                                    device,
    VkDescriptorPool                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "descriptorPool", descriptorPool);
    skip |= ValidateArray(loc, "descriptorSetCount", "", descriptorSetCount, &pDescriptorSets, true, false, "VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength", kVUIDUndefined);
    if (!skip) skip |= manual_PreCallValidateFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateDescriptorSets(
    VkDevice                                    device,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    const VkCopyDescriptorSet*                  pDescriptorCopies,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "descriptorWriteCount", "pDescriptorWrites", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", descriptorWriteCount, pDescriptorWrites, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, false, true, "VUID-VkWriteDescriptorSet-sType-sType", "VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter", kVUIDUndefined);
    if (pDescriptorWrites != nullptr)
    {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex)
        {
            constexpr std::array allowed_structs_VkWriteDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK };

            skip |= ValidateStructPnext(loc, ParameterName("pDescriptorWrites[%i].pNext", ParameterName::IndexVector{ descriptorWriteIndex }), "VkWriteDescriptorSetAccelerationStructureKHR, VkWriteDescriptorSetAccelerationStructureNV, VkWriteDescriptorSetInlineUniformBlock", pDescriptorWrites[descriptorWriteIndex].pNext, allowed_structs_VkWriteDescriptorSet.size(), allowed_structs_VkWriteDescriptorSet.data(), GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext", "VUID-VkWriteDescriptorSet-sType-unique", false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pDescriptorWrites[%i].descriptorType", ParameterName::IndexVector{ descriptorWriteIndex }), "VkDescriptorType", pDescriptorWrites[descriptorWriteIndex].descriptorType, "VUID-VkWriteDescriptorSet-descriptorType-parameter");

            skip |= ValidateArray(loc, ParameterName("pDescriptorWrites[%i].descriptorCount", ParameterName::IndexVector{ descriptorWriteIndex }), "", pDescriptorWrites[descriptorWriteIndex].descriptorCount, &pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false, "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
        }
    }
    skip |= ValidateStructTypeArray(loc, "descriptorCopyCount", "pDescriptorCopies", "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", descriptorCopyCount, pDescriptorCopies, VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, false, true, "VUID-VkCopyDescriptorSet-sType-sType", "VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter", kVUIDUndefined);
    if (pDescriptorCopies != nullptr)
    {
        for (uint32_t descriptorCopyIndex = 0; descriptorCopyIndex < descriptorCopyCount; ++descriptorCopyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pDescriptorCopies[%i].pNext", ParameterName::IndexVector{ descriptorCopyIndex }), nullptr, pDescriptorCopies[descriptorCopyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyDescriptorSet-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pDescriptorCopies[%i].srcSet", ParameterName::IndexVector{ descriptorCopyIndex }), pDescriptorCopies[descriptorCopyIndex].srcSet);

            skip |= ValidateRequiredHandle(loc, ParameterName("pDescriptorCopies[%i].dstSet", ParameterName::IndexVector{ descriptorCopyIndex }), pDescriptorCopies[descriptorCopyIndex].dstSet);
        }
    }
    if (!skip) skip |= manual_PreCallValidateUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateFramebuffer(
    VkDevice                                    device,
    const VkFramebufferCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFramebuffer*                              pFramebuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, true, "VUID-vkCreateFramebuffer-pCreateInfo-parameter", "VUID-VkFramebufferCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkFramebufferCreateInfo = { VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkFramebufferAttachmentsCreateInfo", pCreateInfo->pNext, allowed_structs_VkFramebufferCreateInfo.size(), allowed_structs_VkFramebufferCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkFramebufferCreateInfo-pNext-pNext", "VUID-VkFramebufferCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkFramebufferCreateFlagBits", AllVkFramebufferCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkFramebufferCreateInfo-flags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->renderPass", pCreateInfo->renderPass);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pFramebuffer", pFramebuffer, "VUID-vkCreateFramebuffer-pFramebuffer-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyFramebuffer(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRenderPass(
    VkDevice                                    device,
    const VkRenderPassCreateInfo*               pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, true, "VUID-vkCreateRenderPass-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderPassCreateInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO, VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassInputAttachmentAspectCreateInfo, VkRenderPassMultiviewCreateInfo", pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo.size(), allowed_structs_VkRenderPassCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderPassCreateInfo-pNext-pNext", "VUID-VkRenderPassCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkRenderPassCreateFlagBits", AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkRenderPassCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->attachmentCount", "pCreateInfo->pAttachments", pCreateInfo->attachmentCount, &pCreateInfo->pAttachments, false, true, kVUIDUndefined, "VUID-VkRenderPassCreateInfo-pAttachments-parameter");

        if (pCreateInfo->pAttachments != nullptr)
        {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex)
            {
                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pAttachments[%i].flags", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentDescriptionFlagBits", AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags, kOptionalFlags, "VUID-VkAttachmentDescription-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].format", ParameterName::IndexVector{ attachmentIndex }), "VkFormat", pCreateInfo->pAttachments[attachmentIndex].format, "VUID-VkAttachmentDescription-format-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pAttachments[%i].samples", ParameterName::IndexVector{ attachmentIndex }), "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples, kRequiredSingleBit, "VUID-VkAttachmentDescription-samples-parameter", "VUID-VkAttachmentDescription-samples-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].loadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", pCreateInfo->pAttachments[attachmentIndex].loadOp, "VUID-VkAttachmentDescription-loadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].storeOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", pCreateInfo->pAttachments[attachmentIndex].storeOp, "VUID-VkAttachmentDescription-storeOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].stencilLoadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp, "VUID-VkAttachmentDescription-stencilLoadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].stencilStoreOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp, "VUID-VkAttachmentDescription-stencilStoreOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].initialLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", pCreateInfo->pAttachments[attachmentIndex].initialLayout, "VUID-VkAttachmentDescription-initialLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].finalLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", pCreateInfo->pAttachments[attachmentIndex].finalLayout, "VUID-VkAttachmentDescription-finalLayout-parameter");
            }
        }

        skip |= ValidateArray(loc, "pCreateInfo->subpassCount", "pCreateInfo->pSubpasses", pCreateInfo->subpassCount, &pCreateInfo->pSubpasses, true, true, "VUID-VkRenderPassCreateInfo-subpassCount-arraylength", "VUID-VkRenderPassCreateInfo-pSubpasses-parameter");

        if (pCreateInfo->pSubpasses != nullptr)
        {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex)
            {
                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pSubpasses[%i].flags", ParameterName::IndexVector{ subpassIndex }), "VkSubpassDescriptionFlagBits", AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags, kOptionalFlags, "VUID-VkSubpassDescription-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pipelineBindPoint", ParameterName::IndexVector{ subpassIndex }), "VkPipelineBindPoint", pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint, "VUID-VkSubpassDescription-pipelineBindPoint-parameter");

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].inputAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount, &pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, false, true, kVUIDUndefined, "VUID-VkSubpassDescription-pInputAttachments-parameter");

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr)
                {
                    for (uint32_t inputAttachmentIndex = 0; inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount; ++inputAttachmentIndex)
                    {
                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, inputAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout, "VUID-VkAttachmentReference-layout-parameter");
                    }
                }

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].colorAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount, &pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, false, true, kVUIDUndefined, "VUID-VkSubpassDescription-pColorAttachments-parameter");

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout, "VUID-VkAttachmentReference-layout-parameter");
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout, "VUID-VkAttachmentReference-layout-parameter");
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr)
                {
                    skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment->layout", ParameterName::IndexVector{ subpassIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout, "VUID-VkAttachmentReference-layout-parameter");
                }

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].preserveAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pPreserveAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount, &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true, kVUIDUndefined, "VUID-VkSubpassDescription-pPreserveAttachments-parameter");
            }
        }

        skip |= ValidateArray(loc, "pCreateInfo->dependencyCount", "pCreateInfo->pDependencies", pCreateInfo->dependencyCount, &pCreateInfo->pDependencies, false, true, kVUIDUndefined, "VUID-VkRenderPassCreateInfo-pDependencies-parameter");

        if (pCreateInfo->pDependencies != nullptr)
        {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex)
            {
                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].srcStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask, kOptionalFlags, "VUID-VkSubpassDependency-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dstStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask, kOptionalFlags, "VUID-VkSubpassDependency-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].srcAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask, kOptionalFlags, "VUID-VkSubpassDependency-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dstAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask, kOptionalFlags, "VUID-VkSubpassDependency-dstAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dependencyFlags", ParameterName::IndexVector{ dependencyIndex }), "VkDependencyFlagBits", AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags, kOptionalFlags, "VUID-VkSubpassDependency-dependencyFlags-parameter");
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pRenderPass", pRenderPass, "VUID-vkCreateRenderPass-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyRenderPass(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetRenderAreaGranularity(
    VkDevice                                    device,
    VkRenderPass                                renderPass,
    VkExtent2D*                                 pGranularity,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "renderPass", renderPass);
    skip |= ValidateRequiredPointer(loc, "pGranularity", pGranularity, "VUID-vkGetRenderAreaGranularity-pGranularity-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, true, "VUID-vkCreateCommandPool-pCreateInfo-parameter", "VUID-VkCommandPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCommandPoolCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkCommandPoolCreateFlagBits", AllVkCommandPoolCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkCommandPoolCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pCommandPool", pCommandPool, "VUID-vkCreateCommandPool-pCommandPool-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolResetFlags                     flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "commandPool", commandPool);
    skip |= ValidateFlags(loc, "flags", "VkCommandPoolResetFlagBits", AllVkCommandPoolResetFlagBits, flags, kOptionalFlags, "VUID-vkResetCommandPool-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pAllocateInfo", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", pAllocateInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, true, "VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter", "VUID-VkCommandBufferAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pAllocateInfo->pNext", nullptr, pAllocateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCommandBufferAllocateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pAllocateInfo->commandPool", pAllocateInfo->commandPool);

        skip |= ValidateRangedEnum(loc, "pAllocateInfo->level", "VkCommandBufferLevel", pAllocateInfo->level, "VUID-VkCommandBufferAllocateInfo-level-parameter");
    }
    if (pAllocateInfo != nullptr) {
        skip |= ValidateArray(loc, "pAllocateInfo->commandBufferCount", "pCommandBuffers", pAllocateInfo->commandBufferCount, &pCommandBuffers, true, true, "VUID-vkAllocateCommandBuffers-pAllocateInfo::commandBufferCount-arraylength", "VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateFreeCommandBuffers(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "commandPool", commandPool);
    skip |= ValidateArray(loc, "commandBufferCount", "", commandBufferCount, &pCommandBuffers, true, false, "VUID-vkFreeCommandBuffers-commandBufferCount-arraylength", kVUIDUndefined);
    if (!skip) skip |= manual_PreCallValidateFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateBeginCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const VkCommandBufferBeginInfo*             pBeginInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pBeginInfo", "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", pBeginInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, true, "VUID-vkBeginCommandBuffer-pBeginInfo-parameter", "VUID-VkCommandBufferBeginInfo-sType-sType");
    if (pBeginInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkCommandBufferBeginInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO };

        skip |= ValidateStructPnext(loc, "pBeginInfo->pNext", "VkDeviceGroupCommandBufferBeginInfo", pBeginInfo->pNext, allowed_structs_VkCommandBufferBeginInfo.size(), allowed_structs_VkCommandBufferBeginInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkCommandBufferBeginInfo-pNext-pNext", "VUID-VkCommandBufferBeginInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pBeginInfo->flags", "VkCommandBufferUsageFlagBits", AllVkCommandBufferUsageFlagBits, pBeginInfo->flags, kOptionalFlags, "VUID-VkCommandBufferBeginInfo-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateBeginCommandBuffer(commandBuffer, pBeginInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateEndCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateResetCommandBuffer(
    VkCommandBuffer                             commandBuffer,
    VkCommandBufferResetFlags                   flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "flags", "VkCommandBufferResetFlagBits", AllVkCommandBufferResetFlagBits, flags, kOptionalFlags, "VUID-vkResetCommandBuffer-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindPipeline(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdBindPipeline-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewport(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "viewportCount", "pViewports", viewportCount, &pViewports, true, true, "VUID-vkCmdSetViewport-viewportCount-arraylength", "VUID-vkCmdSetViewport-pViewports-parameter");
    if (pViewports != nullptr)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetScissor(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "scissorCount", "pScissors", scissorCount, &pScissors, true, true, "VUID-vkCmdSetScissor-scissorCount-arraylength", "VUID-vkCmdSetScissor-pScissors-parameter");
    if (pScissors != nullptr)
    {
        for (uint32_t scissorIndex = 0; scissorIndex < scissorCount; ++scissorIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineWidth(
    VkCommandBuffer                             commandBuffer,
    float                                       lineWidth,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdSetLineWidth(commandBuffer, lineWidth, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBias(
    VkCommandBuffer                             commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetBlendConstants(
    VkCommandBuffer                             commandBuffer,
    const float                                 blendConstants[4],
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBounds(
    VkCommandBuffer                             commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilCompareMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, kRequiredFlags, "VUID-vkCmdSetStencilCompareMask-faceMask-parameter", "VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilWriteMask(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, kRequiredFlags, "VUID-vkCmdSetStencilWriteMask-faceMask-parameter", "VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilReference(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, kRequiredFlags, "VUID-vkCmdSetStencilReference-faceMask-parameter", "VUID-vkCmdSetStencilReference-faceMask-requiredbitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorSets(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    const VkDescriptorSet*                      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    const uint32_t*                             pDynamicOffsets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    skip |= ValidateArray(loc, "descriptorSetCount", "pDescriptorSets", descriptorSetCount, &pDescriptorSets, true, false, "VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength", "VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter");
    skip |= ValidateArray(loc, "dynamicOffsetCount", "pDynamicOffsets", dynamicOffsetCount, &pDynamicOffsets, false, true, kVUIDUndefined, "VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRangedEnum(loc, "indexType", "VkIndexType", indexType, "VUID-vkCmdBindIndexBuffer-indexType-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindVertexBuffers(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "bindingCount", "pBuffers", bindingCount, &pBuffers, true, false, "VUID-vkCmdBindVertexBuffers-bindingCount-arraylength", "VUID-vkCmdBindVertexBuffers-pBuffers-parameter");
    skip |= ValidateArray(loc, "bindingCount", "pOffsets", bindingCount, &pOffsets, true, true, "VUID-vkCmdBindVertexBuffers-bindingCount-arraylength", "VUID-vkCmdBindVertexBuffers-pOffsets-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatch(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferCopy*                         pRegions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "srcBuffer", srcBuffer);
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    skip |= ValidateArray(loc, "regionCount", "pRegions", regionCount, &pRegions, true, true, "VUID-vkCmdCopyBuffer-regionCount-arraylength", "VUID-vkCmdCopyBuffer-pRegions-parameter");
    if (pRegions != nullptr)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageCopy*                          pRegions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "srcImage", srcImage);
    skip |= ValidateRangedEnum(loc, "srcImageLayout", "VkImageLayout", srcImageLayout, "VUID-vkCmdCopyImage-srcImageLayout-parameter");
    skip |= ValidateRequiredHandle(loc, "dstImage", dstImage);
    skip |= ValidateRangedEnum(loc, "dstImageLayout", "VkImageLayout", dstImageLayout, "VUID-vkCmdCopyImage-dstImageLayout-parameter");
    skip |= ValidateArray(loc, "regionCount", "pRegions", regionCount, &pRegions, true, true, "VUID-vkCmdCopyImage-regionCount-arraylength", "VUID-vkCmdCopyImage-pRegions-parameter");
    if (pRegions != nullptr)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBlitImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageBlit*                          pRegions,
    VkFilter                                    filter,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "srcImage", srcImage);
    skip |= ValidateRangedEnum(loc, "srcImageLayout", "VkImageLayout", srcImageLayout, "VUID-vkCmdBlitImage-srcImageLayout-parameter");
    skip |= ValidateRequiredHandle(loc, "dstImage", dstImage);
    skip |= ValidateRangedEnum(loc, "dstImageLayout", "VkImageLayout", dstImageLayout, "VUID-vkCmdBlitImage-dstImageLayout-parameter");
    skip |= ValidateArray(loc, "regionCount", "pRegions", regionCount, &pRegions, true, true, "VUID-vkCmdBlitImage-regionCount-arraylength", "VUID-vkCmdBlitImage-pRegions-parameter");
    if (pRegions != nullptr)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
        }
    }
    skip |= ValidateRangedEnum(loc, "filter", "VkFilter", filter, "VUID-vkCmdBlitImage-filter-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBufferToImage(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    srcBuffer,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "srcBuffer", srcBuffer);
    skip |= ValidateRequiredHandle(loc, "dstImage", dstImage);
    skip |= ValidateRangedEnum(loc, "dstImageLayout", "VkImageLayout", dstImageLayout, "VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter");
    skip |= ValidateArray(loc, "regionCount", "pRegions", regionCount, &pRegions, true, true, "VUID-vkCmdCopyBufferToImage-regionCount-arraylength", "VUID-vkCmdCopyBufferToImage-pRegions-parameter");
    if (pRegions != nullptr)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImageToBuffer(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkBuffer                                    dstBuffer,
    uint32_t                                    regionCount,
    const VkBufferImageCopy*                    pRegions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "srcImage", srcImage);
    skip |= ValidateRangedEnum(loc, "srcImageLayout", "VkImageLayout", srcImageLayout, "VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter");
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    skip |= ValidateArray(loc, "regionCount", "pRegions", regionCount, &pRegions, true, true, "VUID-vkCmdCopyImageToBuffer-regionCount-arraylength", "VUID-vkCmdCopyImageToBuffer-pRegions-parameter");
    if (pRegions != nullptr)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdUpdateBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    const void*                                 pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkCmdUpdateBuffer-dataSize-arraylength", "VUID-vkCmdUpdateBuffer-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdFillBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    if (!skip) skip |= manual_PreCallValidateCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdClearColorImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearColorValue*                    pColor,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateRangedEnum(loc, "imageLayout", "VkImageLayout", imageLayout, "VUID-vkCmdClearColorImage-imageLayout-parameter");
    skip |= ValidateArray(loc, "rangeCount", "pRanges", rangeCount, &pRanges, true, true, "VUID-vkCmdClearColorImage-rangeCount-arraylength", "VUID-vkCmdClearColorImage-pRanges-parameter");
    if (pRanges != nullptr)
    {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRanges[%i].aspectMask", ParameterName::IndexVector{ rangeIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdClearDepthStencilImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     image,
    VkImageLayout                               imageLayout,
    const VkClearDepthStencilValue*             pDepthStencil,
    uint32_t                                    rangeCount,
    const VkImageSubresourceRange*              pRanges,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateRangedEnum(loc, "imageLayout", "VkImageLayout", imageLayout, "VUID-vkCmdClearDepthStencilImage-imageLayout-parameter");
    skip |= ValidateRequiredPointer(loc, "pDepthStencil", pDepthStencil, "VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter");
    if (pDepthStencil != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateArray(loc, "rangeCount", "pRanges", rangeCount, &pRanges, true, true, "VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength", "VUID-vkCmdClearDepthStencilImage-pRanges-parameter");
    if (pRanges != nullptr)
    {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRanges[%i].aspectMask", ParameterName::IndexVector{ rangeIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdClearAttachments(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkClearAttachment*                    pAttachments,
    uint32_t                                    rectCount,
    const VkClearRect*                          pRects,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "attachmentCount", "pAttachments", attachmentCount, &pAttachments, true, true, "VUID-vkCmdClearAttachments-attachmentCount-arraylength", "VUID-vkCmdClearAttachments-pAttachments-parameter");
    if (pAttachments != nullptr)
    {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pAttachments[%i].aspectMask", ParameterName::IndexVector{ attachmentIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pAttachments[attachmentIndex].aspectMask, kRequiredFlags, "VUID-VkClearAttachment-aspectMask-parameter", "VUID-VkClearAttachment-aspectMask-requiredbitmask");
        }
    }
    skip |= ValidateArray(loc, "rectCount", "pRects", rectCount, &pRects, true, true, "VUID-vkCmdClearAttachments-rectCount-arraylength", "VUID-vkCmdClearAttachments-pRects-parameter");
    if (pRects != nullptr)
    {
        for (uint32_t rectIndex = 0; rectIndex < rectCount; ++rectIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResolveImage(
    VkCommandBuffer                             commandBuffer,
    VkImage                                     srcImage,
    VkImageLayout                               srcImageLayout,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    const VkImageResolve*                       pRegions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "srcImage", srcImage);
    skip |= ValidateRangedEnum(loc, "srcImageLayout", "VkImageLayout", srcImageLayout, "VUID-vkCmdResolveImage-srcImageLayout-parameter");
    skip |= ValidateRequiredHandle(loc, "dstImage", dstImage);
    skip |= ValidateRangedEnum(loc, "dstImageLayout", "VkImageLayout", dstImageLayout, "VUID-vkCmdResolveImage-dstImageLayout-parameter");
    skip |= ValidateArray(loc, "regionCount", "pRegions", regionCount, &pRegions, true, true, "VUID-vkCmdResolveImage-regionCount-arraylength", "VUID-vkCmdResolveImage-pRegions-parameter");
    if (pRegions != nullptr)
    {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            skip |= ValidateFlags(loc, ParameterName("pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    skip |= ValidateFlags(loc, "stageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, stageMask, kOptionalFlags, "VUID-vkCmdSetEvent-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetEvent(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags                        stageMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    skip |= ValidateFlags(loc, "stageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, stageMask, kOptionalFlags, "VUID-vkCmdResetEvent-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateHandleArray(loc, "eventCount", "pEvents", eventCount, pEvents, true, true, "VUID-vkCmdWaitEvents-eventCount-arraylength");
    skip |= ValidateFlags(loc, "srcStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, srcStageMask, kOptionalFlags, "VUID-vkCmdWaitEvents-srcStageMask-parameter");
    skip |= ValidateFlags(loc, "dstStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, dstStageMask, kOptionalFlags, "VUID-vkCmdWaitEvents-dstStageMask-parameter");
    skip |= ValidateStructTypeArray(loc, "memoryBarrierCount", "pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER", memoryBarrierCount, pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true, "VUID-VkMemoryBarrier-sType-sType", "VUID-vkCmdWaitEvents-pMemoryBarriers-parameter", kVUIDUndefined);
    if (pMemoryBarriers != nullptr)
    {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), nullptr, pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryBarrier-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateFlags(loc, ParameterName("pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier-srcAccessMask-parameter");

            skip |= ValidateFlags(loc, ParameterName("pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier-dstAccessMask-parameter");
        }
    }
    skip |= ValidateStructTypeArray(loc, "bufferMemoryBarrierCount", "pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", bufferMemoryBarrierCount, pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false, true, "VUID-VkBufferMemoryBarrier-sType-sType", "VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter", kVUIDUndefined);
    if (pBufferMemoryBarriers != nullptr)
    {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
        {
            constexpr std::array allowed_structs_VkBufferMemoryBarrier = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier.size(), allowed_structs_VkBufferMemoryBarrier.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier-pNext-pNext", "VUID-VkBufferMemoryBarrier-sType-unique", false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }
    skip |= ValidateStructTypeArray(loc, "imageMemoryBarrierCount", "pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, false, true, "VUID-VkImageMemoryBarrier-sType-sType", "VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter", kVUIDUndefined);
    if (pImageMemoryBarriers != nullptr)
    {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
        {
            constexpr std::array allowed_structs_VkImageMemoryBarrier = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier.size(), allowed_structs_VkImageMemoryBarrier.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier-pNext-pNext", "VUID-VkImageMemoryBarrier-sType-unique", false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier-oldLayout-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier-newLayout-parameter");

            skip |= ValidateRequiredHandle(loc, ParameterName("pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= ValidateFlags(loc, ParameterName("pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPipelineBarrier(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "srcStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, srcStageMask, kOptionalFlags, "VUID-vkCmdPipelineBarrier-srcStageMask-parameter");
    skip |= ValidateFlags(loc, "dstStageMask", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, dstStageMask, kOptionalFlags, "VUID-vkCmdPipelineBarrier-dstStageMask-parameter");
    skip |= ValidateFlags(loc, "dependencyFlags", "VkDependencyFlagBits", AllVkDependencyFlagBits, dependencyFlags, kOptionalFlags, "VUID-vkCmdPipelineBarrier-dependencyFlags-parameter");
    skip |= ValidateStructTypeArray(loc, "memoryBarrierCount", "pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER", memoryBarrierCount, pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true, "VUID-VkMemoryBarrier-sType-sType", "VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter", kVUIDUndefined);
    if (pMemoryBarriers != nullptr)
    {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), nullptr, pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryBarrier-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateFlags(loc, ParameterName("pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier-srcAccessMask-parameter");

            skip |= ValidateFlags(loc, ParameterName("pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier-dstAccessMask-parameter");
        }
    }
    skip |= ValidateStructTypeArray(loc, "bufferMemoryBarrierCount", "pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", bufferMemoryBarrierCount, pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false, true, "VUID-VkBufferMemoryBarrier-sType-sType", "VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter", kVUIDUndefined);
    if (pBufferMemoryBarriers != nullptr)
    {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
        {
            constexpr std::array allowed_structs_VkBufferMemoryBarrier = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier.size(), allowed_structs_VkBufferMemoryBarrier.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier-pNext-pNext", "VUID-VkBufferMemoryBarrier-sType-unique", false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }
    skip |= ValidateStructTypeArray(loc, "imageMemoryBarrierCount", "pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, false, true, "VUID-VkImageMemoryBarrier-sType-sType", "VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter", kVUIDUndefined);
    if (pImageMemoryBarriers != nullptr)
    {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
        {
            constexpr std::array allowed_structs_VkImageMemoryBarrier = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier.size(), allowed_structs_VkImageMemoryBarrier.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier-pNext-pNext", "VUID-VkImageMemoryBarrier-sType-unique", false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier-oldLayout-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier-newLayout-parameter");

            skip |= ValidateRequiredHandle(loc, ParameterName("pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= ValidateFlags(loc, ParameterName("pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    skip |= ValidateFlags(loc, "flags", "VkQueryControlFlagBits", AllVkQueryControlFlagBits, flags, kOptionalFlags, "VUID-vkCmdBeginQuery-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndQuery(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetQueryPool(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteTimestamp(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "pipelineStage", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pipelineStage, kRequiredSingleBit, "VUID-vkCmdWriteTimestamp-pipelineStage-parameter", "VUID-vkCmdWriteTimestamp-pipelineStage-parameter");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyQueryPoolResults(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    skip |= ValidateFlags(loc, "flags", "VkQueryResultFlagBits", AllVkQueryResultFlagBits, flags, kOptionalFlags, "VUID-vkCmdCopyQueryPoolResults-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushConstants(
    VkCommandBuffer                             commandBuffer,
    VkPipelineLayout                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    const void*                                 pValues,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    skip |= ValidateFlags(loc, "stageFlags", "VkShaderStageFlagBits", AllVkShaderStageFlagBits, stageFlags, kRequiredFlags, "VUID-vkCmdPushConstants-stageFlags-parameter", "VUID-vkCmdPushConstants-stageFlags-requiredbitmask");
    skip |= ValidateArray(loc, "size", "pValues", size, &pValues, true, true, "VUID-vkCmdPushConstants-size-arraylength", "VUID-vkCmdPushConstants-pValues-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderPass(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    VkSubpassContents                           contents,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pRenderPassBegin", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, true, "VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter", "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO, VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pRenderPassBegin->pNext", "VkDeviceGroupRenderPassBeginInfo, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, VkRenderPassAttachmentBeginInfo, VkRenderPassSampleLocationsBeginInfoEXT, VkRenderPassTransformBeginInfoQCOM", pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(), allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pRenderPassBegin->renderPass", pRenderPassBegin->renderPass);

        skip |= ValidateRequiredHandle(loc, "pRenderPassBegin->framebuffer", pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |= ValidateRangedEnum(loc, "contents", "VkSubpassContents", contents, "VUID-vkCmdBeginRenderPass-contents-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdNextSubpass(
    VkCommandBuffer                             commandBuffer,
    VkSubpassContents                           contents,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "contents", "VkSubpassContents", contents, "VUID-vkCmdNextSubpass-contents-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderPass(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdExecuteCommands(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    commandBufferCount,
    const VkCommandBuffer*                      pCommandBuffers,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateHandleArray(loc, "commandBufferCount", "pCommandBuffers", commandBufferCount, pCommandBuffers, true, true, "VUID-vkCmdExecuteCommands-commandBufferCount-arraylength");
    return skip;
}

bool StatelessValidation::PreCallValidateBindBufferMemory2(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindBufferMemoryInfo*               pBindInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO, true, true, "VUID-VkBindBufferMemoryInfo-sType-sType", "VUID-vkBindBufferMemory2-pBindInfos-parameter", "VUID-vkBindBufferMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            constexpr std::array allowed_structs_VkBindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkBindBufferMemoryDeviceGroupInfo", pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindBufferMemoryInfo.size(), allowed_structs_VkBindBufferMemoryInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBindBufferMemoryInfo-pNext-pNext", "VUID-VkBindBufferMemoryInfo-sType-unique", false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].buffer", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].buffer);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].memory", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindImageMemory2(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindImageMemoryInfo*                pBindInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO, true, true, "VUID-VkBindImageMemoryInfo-sType-sType", "VUID-vkBindImageMemory2-pBindInfos-parameter", "VUID-vkBindImageMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            constexpr std::array allowed_structs_VkBindImageMemoryInfo = { VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR, VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, VkBindImagePlaneMemoryInfo", pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindImageMemoryInfo.size(), allowed_structs_VkBindImageMemoryInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBindImageMemoryInfo-pNext-pNext", "VUID-VkBindImageMemoryInfo-sType-unique", false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].image", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].image);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupPeerMemoryFeatures(
    VkDevice                                    device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    VkPeerMemoryFeatureFlags*                   pPeerMemoryFeatures,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc, "pPeerMemoryFeatures", pPeerMemoryFeatures, "VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDeviceMask(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    deviceMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchBase(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDeviceGroups(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties*            pPhysicalDeviceGroupProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(instance, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructTypeArray(loc, "pPhysicalDeviceGroupCount", "pPhysicalDeviceGroupProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES", pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, true, false, false, "VUID-VkPhysicalDeviceGroupProperties-sType-sType", "VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter", kVUIDUndefined);
    if (pPhysicalDeviceGroupProperties != nullptr)
    {
        for (uint32_t pPhysicalDeviceGroupIndex = 0; pPhysicalDeviceGroupIndex < *pPhysicalDeviceGroupCount; ++pPhysicalDeviceGroupIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pPhysicalDeviceGroupProperties[%i].pNext", ParameterName::IndexVector{ pPhysicalDeviceGroupIndex }), nullptr, pPhysicalDeviceGroupProperties[pPhysicalDeviceGroupIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceGroupProperties-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageMemoryRequirements2(
    VkDevice                                    device,
    const VkImageMemoryRequirementsInfo2*       pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2", pInfo, VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, true, "VUID-vkGetImageMemoryRequirements2-pInfo-parameter", "VUID-VkImageMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkImageMemoryRequirementsInfo2 = { VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO };

        skip |= ValidateStructPnext(loc, "pInfo->pNext", "VkImagePlaneMemoryRequirementsInfo", pInfo->pNext, allowed_structs_VkImageMemoryRequirementsInfo2.size(), allowed_structs_VkImageMemoryRequirementsInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryRequirementsInfo2-pNext-pNext", "VUID-VkImageMemoryRequirementsInfo2-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->image", pInfo->image);
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferMemoryRequirements2(
    VkDevice                                    device,
    const VkBufferMemoryRequirementsInfo2*      pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2", pInfo, VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2, true, "VUID-vkGetBufferMemoryRequirements2-pInfo-parameter", "VUID-VkBufferMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSparseMemoryRequirements2(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2", pInfo, VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2, true, "VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter", "VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->image", pInfo->image);
    }
    skip |= ValidateStructTypeArray(loc, "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2", pSparseMemoryRequirementCount, pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false, "VUID-VkSparseImageMemoryRequirements2-sType-sType", "VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirements-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr)
    {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount; ++pSparseMemoryRequirementIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pSparseMemoryRequirements[%i].pNext", ParameterName::IndexVector{ pSparseMemoryRequirementIndex }), nullptr, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFeatures2(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures2*                  pFeatures,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pFeatures", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2", pFeatures, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, true, "VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter", "VUID-VkPhysicalDeviceFeatures2-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceProperties2(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties2*                pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2", pProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter", "VUID-VkPhysicalDeviceProperties2-sType-sType");
    if (pProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceProperties2 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES };

        skip |= ValidateStructPnext(loc, "pProperties->pNext", "VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixPropertiesKHR, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV, VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, VkPhysicalDeviceDescriptorBufferPropertiesEXT, VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDisplacementMicromapPropertiesNV, VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDrmPropertiesEXT, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRatePropertiesKHR, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, VkPhysicalDeviceHostImageCopyPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceImageProcessing2PropertiesQCOM, VkPhysicalDeviceImageProcessingPropertiesQCOM, VkPhysicalDeviceInlineUniformBlockProperties, VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance4Properties, VkPhysicalDeviceMaintenance5PropertiesKHR, VkPhysicalDeviceMemoryDecompressionPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesEXT, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiDrawPropertiesEXT, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceOpacityMicromapPropertiesEXT, VkPhysicalDeviceOpticalFlowPropertiesNV, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePerformanceQueryPropertiesKHR, VkPhysicalDevicePipelineRobustnessPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePortabilitySubsetPropertiesKHR, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProvokingVertexPropertiesEXT, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRobustness2PropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesARM, VkPhysicalDeviceShaderEnqueuePropertiesAMDX, VkPhysicalDeviceShaderIntegerDotProductProperties, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, VkPhysicalDeviceShaderObjectPropertiesEXT, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShaderTileImagePropertiesEXT, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSubgroupSizeControlProperties, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, VkPhysicalDeviceTexelBufferAlignmentProperties, VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan12Properties, VkPhysicalDeviceVulkan13Properties", pProperties->pNext, allowed_structs_VkPhysicalDeviceProperties2.size(), allowed_structs_VkPhysicalDeviceProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceProperties2-pNext-pNext", "VUID-VkPhysicalDeviceProperties2-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFormatProperties2(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties2*                        pFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateRangedEnum(loc, "format", "VkFormat", format, "VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter");
    skip |= ValidateStructType(loc, "pFormatProperties", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2", pFormatProperties, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter", "VUID-VkFormatProperties2-sType-sType");
    if (pFormatProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkFormatProperties2 = { VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT };

        skip |= ValidateStructPnext(loc, "pFormatProperties->pNext", "VkDrmFormatModifierPropertiesList2EXT, VkDrmFormatModifierPropertiesListEXT, VkFormatProperties3, VkSubpassResolvePerformanceQueryEXT", pFormatProperties->pNext, allowed_structs_VkFormatProperties2.size(), allowed_structs_VkFormatProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkFormatProperties2-pNext-pNext", "VUID-VkFormatProperties2-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2*     pImageFormatInfo,
    VkImageFormatProperties2*                   pImageFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pImageFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2", pImageFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2, true, "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter", "VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType");
    if (pImageFormatInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceImageFormatInfo2 = { VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pImageFormatInfo->pNext", "VkImageCompressionControlEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkOpticalFlowImageFormatInfoNV, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkPhysicalDeviceImageViewImageFormatInfoEXT, VkVideoProfileListInfoKHR", pImageFormatInfo->pNext, allowed_structs_VkPhysicalDeviceImageFormatInfo2.size(), allowed_structs_VkPhysicalDeviceImageFormatInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext", "VUID-VkPhysicalDeviceImageFormatInfo2-sType-unique", true, true);

        skip |= ValidateRangedEnum(loc, "pImageFormatInfo->format", "VkFormat", pImageFormatInfo->format, "VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter");

        skip |= ValidateRangedEnum(loc, "pImageFormatInfo->type", "VkImageType", pImageFormatInfo->type, "VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter");

        skip |= ValidateRangedEnum(loc, "pImageFormatInfo->tiling", "VkImageTiling", pImageFormatInfo->tiling, "VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter");

        skip |= ValidateFlags(loc, "pImageFormatInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pImageFormatInfo->usage, kRequiredFlags, "VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter", "VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask");

        skip |= ValidateFlags(loc, "pImageFormatInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pImageFormatInfo->flags, kOptionalFlags, "VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter");
    }
    skip |= ValidateStructType(loc, "pImageFormatProperties", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2", pImageFormatProperties, VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter", "VUID-VkImageFormatProperties2-sType-sType");
    if (pImageFormatProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkImageFormatProperties2 = { VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES, VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD };

        skip |= ValidateStructPnext(loc, "pImageFormatProperties->pNext", "VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkFilterCubicImageViewImageFormatPropertiesEXT, VkHostImageCopyDevicePerformanceQueryEXT, VkImageCompressionPropertiesEXT, VkSamplerYcbcrConversionImageFormatProperties, VkTextureLODGatherFormatPropertiesAMD", pImageFormatProperties->pNext, allowed_structs_VkImageFormatProperties2.size(), allowed_structs_VkImageFormatProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageFormatProperties2-pNext-pNext", "VUID-VkImageFormatProperties2-sType-unique", true, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyProperties2(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2*                   pQueueFamilyProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructTypeArray(loc, "pQueueFamilyPropertyCount", "pQueueFamilyProperties", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2", pQueueFamilyPropertyCount, pQueueFamilyProperties, VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, true, false, false, "VUID-VkQueueFamilyProperties2-sType-sType", "VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter", kVUIDUndefined);
    if (pQueueFamilyProperties != nullptr)
    {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount; ++pQueueFamilyPropertyIndex)
        {
            constexpr std::array allowed_structs_VkQueueFamilyProperties2 = { VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV, VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR, VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR, VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR };

            skip |= ValidateStructPnext(loc, ParameterName("pQueueFamilyProperties[%i].pNext", ParameterName::IndexVector{ pQueueFamilyPropertyIndex }), "VkQueueFamilyCheckpointProperties2NV, VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyGlobalPriorityPropertiesKHR, VkQueueFamilyQueryResultStatusPropertiesKHR, VkQueueFamilyVideoPropertiesKHR", pQueueFamilyProperties[pQueueFamilyPropertyIndex].pNext, allowed_structs_VkQueueFamilyProperties2.size(), allowed_structs_VkQueueFamilyProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkQueueFamilyProperties2-pNext-pNext", "VUID-VkQueueFamilyProperties2-sType-unique", true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMemoryProperties2(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties2*          pMemoryProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pMemoryProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2", pMemoryProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter", "VUID-VkPhysicalDeviceMemoryProperties2-sType-sType");
    if (pMemoryProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceMemoryProperties2 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT };

        skip |= ValidateStructPnext(loc, "pMemoryProperties->pNext", "VkPhysicalDeviceMemoryBudgetPropertiesEXT", pMemoryProperties->pNext, allowed_structs_VkPhysicalDeviceMemoryProperties2.size(), allowed_structs_VkPhysicalDeviceMemoryProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext", "VUID-VkPhysicalDeviceMemoryProperties2-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties2*             pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2", pFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2, true, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter", "VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType");
    if (pFormatInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pFormatInfo->pNext", nullptr, pFormatInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateRangedEnum(loc, "pFormatInfo->format", "VkFormat", pFormatInfo->format, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter");

        skip |= ValidateRangedEnum(loc, "pFormatInfo->type", "VkImageType", pFormatInfo->type, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter");

        skip |= ValidateFlags(loc, "pFormatInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pFormatInfo->samples, kRequiredSingleBit, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter", "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter");

        skip |= ValidateFlags(loc, "pFormatInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pFormatInfo->usage, kRequiredFlags, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter", "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask");

        skip |= ValidateRangedEnum(loc, "pFormatInfo->tiling", "VkImageTiling", pFormatInfo->tiling, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter");
    }
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, true, false, false, "VUID-VkSparseImageFormatProperties2-sType-sType", "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pProperties-parameter", kVUIDUndefined);
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pProperties[%i].pNext", ParameterName::IndexVector{ pPropertyIndex }), nullptr, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageFormatProperties2-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateTrimCommandPool(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolTrimFlags                      flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "commandPool", commandPool);
    skip |= ValidateReservedFlags(loc, "flags", flags, "VUID-vkTrimCommandPool-flags-zerobitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceQueue2(
    VkDevice                                    device,
    const VkDeviceQueueInfo2*                   pQueueInfo,
    VkQueue*                                    pQueue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pQueueInfo", "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2", pQueueInfo, VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2, true, "VUID-vkGetDeviceQueue2-pQueueInfo-parameter", "VUID-VkDeviceQueueInfo2-sType-sType");
    if (pQueueInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pQueueInfo->pNext", nullptr, pQueueInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceQueueInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pQueueInfo->flags", "VkDeviceQueueCreateFlagBits", AllVkDeviceQueueCreateFlagBits, pQueueInfo->flags, kOptionalFlags, "VUID-VkDeviceQueueInfo2-flags-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pQueue", pQueue, "VUID-vkGetDeviceQueue2-pQueue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSamplerYcbcrConversion(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversion*                   pYcbcrConversion,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO, true, "VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter", "VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSamplerYcbcrConversionCreateInfo = { VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkExternalFormatANDROID, VkExternalFormatQNX, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM", pCreateInfo->pNext, allowed_structs_VkSamplerYcbcrConversionCreateInfo.size(), allowed_structs_VkSamplerYcbcrConversionCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext", "VUID-VkSamplerYcbcrConversionCreateInfo-sType-unique", false, true);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->format", "VkFormat", pCreateInfo->format, "VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->ycbcrModel", "VkSamplerYcbcrModelConversion", pCreateInfo->ycbcrModel, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->ycbcrRange", "VkSamplerYcbcrRange", pCreateInfo->ycbcrRange, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.r", "VkComponentSwizzle", pCreateInfo->components.r, "VUID-VkComponentMapping-r-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.g", "VkComponentSwizzle", pCreateInfo->components.g, "VUID-VkComponentMapping-g-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.b", "VkComponentSwizzle", pCreateInfo->components.b, "VUID-VkComponentMapping-b-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.a", "VkComponentSwizzle", pCreateInfo->components.a, "VUID-VkComponentMapping-a-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->xChromaOffset", "VkChromaLocation", pCreateInfo->xChromaOffset, "VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->yChromaOffset", "VkChromaLocation", pCreateInfo->yChromaOffset, "VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->chromaFilter", "VkFilter", pCreateInfo->chromaFilter, "VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter");

        skip |= ValidateBool32(loc, "pCreateInfo->forceExplicitReconstruction", pCreateInfo->forceExplicitReconstruction);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pYcbcrConversion", pYcbcrConversion, "VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySamplerYcbcrConversion(
    VkDevice                                    device,
    VkSamplerYcbcrConversion                    ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorUpdateTemplate(
    VkDevice                                    device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO, true, "VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter", "VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(loc, "pCreateInfo->descriptorUpdateEntryCount", "pCreateInfo->pDescriptorUpdateEntries", pCreateInfo->descriptorUpdateEntryCount, &pCreateInfo->pDescriptorUpdateEntries, true, true, "VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength", "VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter");

        if (pCreateInfo->pDescriptorUpdateEntries != nullptr)
        {
            for (uint32_t descriptorUpdateEntryIndex = 0; descriptorUpdateEntryIndex < pCreateInfo->descriptorUpdateEntryCount; ++descriptorUpdateEntryIndex)
            {
                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pDescriptorUpdateEntries[%i].descriptorType", ParameterName::IndexVector{ descriptorUpdateEntryIndex }), "VkDescriptorType", pCreateInfo->pDescriptorUpdateEntries[descriptorUpdateEntryIndex].descriptorType, "VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter");
            }
        }

        skip |= ValidateRangedEnum(loc, "pCreateInfo->templateType", "VkDescriptorUpdateTemplateType", pCreateInfo->templateType, "VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pDescriptorUpdateTemplate", pDescriptorUpdateTemplate, "VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorUpdateTemplate(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateDescriptorSetWithTemplate(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const void*                                 pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "descriptorSet", descriptorSet);
    skip |= ValidateRequiredHandle(loc, "descriptorUpdateTemplate", descriptorUpdateTemplate);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo*   pExternalBufferInfo,
    VkExternalBufferProperties*                 pExternalBufferProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pExternalBufferInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO", pExternalBufferInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO, true, "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter", "VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType");
    if (pExternalBufferInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalBufferInfo = { VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pExternalBufferInfo->pNext", "VkBufferUsageFlags2CreateInfoKHR", pExternalBufferInfo->pNext, allowed_structs_VkPhysicalDeviceExternalBufferInfo.size(), allowed_structs_VkPhysicalDeviceExternalBufferInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext", "VUID-VkPhysicalDeviceExternalBufferInfo-sType-unique", true, true);

        skip |= ValidateFlags(loc, "pExternalBufferInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pExternalBufferInfo->flags, kOptionalFlags, "VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter");

        skip |= ValidateFlags(loc, "pExternalBufferInfo->usage", "VkBufferUsageFlagBits", AllVkBufferUsageFlagBits, pExternalBufferInfo->usage, kRequiredFlags, "VUID-VkPhysicalDeviceExternalBufferInfo-usage-parameter", "VUID-VkPhysicalDeviceExternalBufferInfo-usage-requiredbitmask");

        skip |= ValidateFlags(loc, "pExternalBufferInfo->handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, pExternalBufferInfo->handleType, kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter", "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc, "pExternalBufferProperties", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES", pExternalBufferProperties, VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, true, "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter", "VUID-VkExternalBufferProperties-sType-sType");
    if (pExternalBufferProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalBufferProperties->pNext", nullptr, pExternalBufferProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkExternalBufferProperties-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo*    pExternalFenceInfo,
    VkExternalFenceProperties*                  pExternalFenceProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pExternalFenceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO", pExternalFenceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, true, "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter", "VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType");
    if (pExternalFenceInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalFenceInfo->pNext", nullptr, pExternalFenceInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateFlags(loc, "pExternalFenceInfo->handleType", "VkExternalFenceHandleTypeFlagBits", AllVkExternalFenceHandleTypeFlagBits, pExternalFenceInfo->handleType, kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter", "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc, "pExternalFenceProperties", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES", pExternalFenceProperties, VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, true, "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter", "VUID-VkExternalFenceProperties-sType-sType");
    if (pExternalFenceProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalFenceProperties->pNext", nullptr, pExternalFenceProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkExternalFenceProperties-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties*              pExternalSemaphoreProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1)) return true;
    skip |= ValidateStructType(loc, "pExternalSemaphoreInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO", pExternalSemaphoreInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, true, "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter", "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType");
    if (pExternalSemaphoreInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo = { VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO };

        skip |= ValidateStructPnext(loc, "pExternalSemaphoreInfo->pNext", "VkSemaphoreTypeCreateInfo", pExternalSemaphoreInfo->pNext, allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.size(), allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext", "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-unique", true, true);

        skip |= ValidateFlags(loc, "pExternalSemaphoreInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pExternalSemaphoreInfo->handleType, kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter", "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc, "pExternalSemaphoreProperties", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES", pExternalSemaphoreProperties, VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, true, "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter", "VUID-VkExternalSemaphoreProperties-sType-sType");
    if (pExternalSemaphoreProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalSemaphoreProperties->pNext", nullptr, pExternalSemaphoreProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkExternalSemaphoreProperties-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutSupport(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true, "VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter", "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO, VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDescriptorSetLayoutBindingFlagsCreateInfo, VkMutableDescriptorTypeCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(), allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext", "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkDescriptorSetLayoutCreateFlagBits", AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->bindingCount", "pCreateInfo->pBindings", pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined, "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr)
        {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex)
            {
                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pBindings[%i].descriptorType", ParameterName::IndexVector{ bindingIndex }), "VkDescriptorType", pCreateInfo->pBindings[bindingIndex].descriptorType, "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter");
            }
        }
    }
    skip |= ValidateStructType(loc, "pSupport", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT", pSupport, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, true, "VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter", "VUID-VkDescriptorSetLayoutSupport-sType-sType");
    if (pSupport != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorSetLayoutSupport = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT };

        skip |= ValidateStructPnext(loc, "pSupport->pNext", "VkDescriptorSetVariableDescriptorCountLayoutSupport", pSupport->pNext, allowed_structs_VkDescriptorSetLayoutSupport.size(), allowed_structs_VkDescriptorSetLayoutSupport.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetLayoutSupport-pNext-pNext", "VUID-VkDescriptorSetLayoutSupport-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectCount(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirectCount(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRenderPass2(
    VkDevice                                    device,
    const VkRenderPassCreateInfo2*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2", pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, true, "VUID-vkCreateRenderPass2-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo2-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderPassCreateInfo2 = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkRenderPassCreationControlEXT, VkRenderPassCreationFeedbackCreateInfoEXT, VkRenderPassFragmentDensityMapCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo2.size(), allowed_structs_VkRenderPassCreateInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderPassCreateInfo2-pNext-pNext", "VUID-VkRenderPassCreateInfo2-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkRenderPassCreateFlagBits", AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkRenderPassCreateInfo2-flags-parameter");

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->attachmentCount", "pCreateInfo->pAttachments", "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2", pCreateInfo->attachmentCount, pCreateInfo->pAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, false, true, "VUID-VkAttachmentDescription2-sType-sType", "VUID-VkRenderPassCreateInfo2-pAttachments-parameter", kVUIDUndefined);

        if (pCreateInfo->pAttachments != nullptr)
        {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex)
            {
                constexpr std::array allowed_structs_VkAttachmentDescription2 = { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pAttachments[%i].pNext", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentDescriptionStencilLayout", pCreateInfo->pAttachments[attachmentIndex].pNext, allowed_structs_VkAttachmentDescription2.size(), allowed_structs_VkAttachmentDescription2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentDescription2-pNext-pNext", "VUID-VkAttachmentDescription2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pAttachments[%i].flags", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentDescriptionFlagBits", AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags, kOptionalFlags, "VUID-VkAttachmentDescription2-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].format", ParameterName::IndexVector{ attachmentIndex }), "VkFormat", pCreateInfo->pAttachments[attachmentIndex].format, "VUID-VkAttachmentDescription2-format-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pAttachments[%i].samples", ParameterName::IndexVector{ attachmentIndex }), "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples, kRequiredSingleBit, "VUID-VkAttachmentDescription2-samples-parameter", "VUID-VkAttachmentDescription2-samples-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].loadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", pCreateInfo->pAttachments[attachmentIndex].loadOp, "VUID-VkAttachmentDescription2-loadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].storeOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", pCreateInfo->pAttachments[attachmentIndex].storeOp, "VUID-VkAttachmentDescription2-storeOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].stencilLoadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp, "VUID-VkAttachmentDescription2-stencilLoadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].stencilStoreOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp, "VUID-VkAttachmentDescription2-stencilStoreOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].initialLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", pCreateInfo->pAttachments[attachmentIndex].initialLayout, "VUID-VkAttachmentDescription2-initialLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].finalLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", pCreateInfo->pAttachments[attachmentIndex].finalLayout, "VUID-VkAttachmentDescription2-finalLayout-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->subpassCount", "pCreateInfo->pSubpasses", "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2", pCreateInfo->subpassCount, pCreateInfo->pSubpasses, VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, true, true, "VUID-VkSubpassDescription2-sType-sType", "VUID-VkRenderPassCreateInfo2-pSubpasses-parameter", "VUID-VkRenderPassCreateInfo2-subpassCount-arraylength");

        if (pCreateInfo->pSubpasses != nullptr)
        {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex)
            {
                constexpr std::array allowed_structs_VkSubpassDescription2 = { VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pNext", ParameterName::IndexVector{ subpassIndex }), "VkFragmentShadingRateAttachmentInfoKHR, VkMultisampledRenderToSingleSampledInfoEXT, VkRenderPassCreationControlEXT, VkRenderPassSubpassFeedbackCreateInfoEXT, VkSubpassDescriptionDepthStencilResolve", pCreateInfo->pSubpasses[subpassIndex].pNext, allowed_structs_VkSubpassDescription2.size(), allowed_structs_VkSubpassDescription2.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassDescription2-pNext-pNext", "VUID-VkSubpassDescription2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pSubpasses[%i].flags", ParameterName::IndexVector{ subpassIndex }), "VkSubpassDescriptionFlagBits", AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags, kOptionalFlags, "VUID-VkSubpassDescription2-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pipelineBindPoint", ParameterName::IndexVector{ subpassIndex }), "VkPipelineBindPoint", pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint, "VUID-VkSubpassDescription2-pipelineBindPoint-parameter");

                skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].inputAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pInputAttachments-parameter", kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr)
                {
                    for (uint32_t inputAttachmentIndex = 0; inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount; ++inputAttachmentIndex)
                    {
                        constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                        skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments[%i].pNext", ParameterName::IndexVector{ subpassIndex, inputAttachmentIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, inputAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout, "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].colorAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pColorAttachments-parameter", kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                        skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments[%i].pNext", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout, "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].colorAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, false, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pResolveAttachments-parameter", kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                        skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments[%i].pNext", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout, "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= ValidateStructType(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, "VUID-VkSubpassDescription2-pDepthStencilAttachment-parameter", "VUID-VkAttachmentReference2-sType-sType");

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr)
                {
                    constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment->pNext", ParameterName::IndexVector{ subpassIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment->layout", ParameterName::IndexVector{ subpassIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout, "VUID-VkAttachmentReference2-layout-parameter");
                }

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].preserveAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pPreserveAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount, &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true, kVUIDUndefined, "VUID-VkSubpassDescription2-pPreserveAttachments-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->dependencyCount", "pCreateInfo->pDependencies", "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2", pCreateInfo->dependencyCount, pCreateInfo->pDependencies, VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, false, true, "VUID-VkSubpassDependency2-sType-sType", "VUID-VkRenderPassCreateInfo2-pDependencies-parameter", kVUIDUndefined);

        if (pCreateInfo->pDependencies != nullptr)
        {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex)
            {
                constexpr std::array allowed_structs_VkSubpassDependency2 = { VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pDependencies[%i].pNext", ParameterName::IndexVector{ dependencyIndex }), "VkMemoryBarrier2", pCreateInfo->pDependencies[dependencyIndex].pNext, allowed_structs_VkSubpassDependency2.size(), allowed_structs_VkSubpassDependency2.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassDependency2-pNext-pNext", "VUID-VkSubpassDependency2-sType-unique", false, true);

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].srcStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask, kOptionalFlags, "VUID-VkSubpassDependency2-srcStageMask-parameter");
                }

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dstStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask, kOptionalFlags, "VUID-VkSubpassDependency2-dstStageMask-parameter");
                }

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].srcAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask, kOptionalFlags, "VUID-VkSubpassDependency2-srcAccessMask-parameter");
                }

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dstAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask, kOptionalFlags, "VUID-VkSubpassDependency2-dstAccessMask-parameter");
                }

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dependencyFlags", ParameterName::IndexVector{ dependencyIndex }), "VkDependencyFlagBits", AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags, kOptionalFlags, "VUID-VkSubpassDependency2-dependencyFlags-parameter");
            }
        }

        skip |= ValidateArray(loc, "pCreateInfo->correlatedViewMaskCount", "pCreateInfo->pCorrelatedViewMasks", pCreateInfo->correlatedViewMaskCount, &pCreateInfo->pCorrelatedViewMasks, false, true, kVUIDUndefined, "VUID-VkRenderPassCreateInfo2-pCorrelatedViewMasks-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pRenderPass", pRenderPass, "VUID-vkCreateRenderPass2-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderPass2(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    const VkSubpassBeginInfo*                   pSubpassBeginInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pRenderPassBegin", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, true, "VUID-vkCmdBeginRenderPass2-pRenderPassBegin-parameter", "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO, VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pRenderPassBegin->pNext", "VkDeviceGroupRenderPassBeginInfo, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, VkRenderPassAttachmentBeginInfo, VkRenderPassSampleLocationsBeginInfoEXT, VkRenderPassTransformBeginInfoQCOM", pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(), allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pRenderPassBegin->renderPass", pRenderPassBegin->renderPass);

        skip |= ValidateRequiredHandle(loc, "pRenderPassBegin->framebuffer", pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |= ValidateStructType(loc, "pSubpassBeginInfo", "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true, "VUID-vkCmdBeginRenderPass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSubpassBeginInfo->pNext", nullptr, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pSubpassBeginInfo->contents", "VkSubpassContents", pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdNextSubpass2(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassBeginInfo*                   pSubpassBeginInfo,
    const VkSubpassEndInfo*                     pSubpassEndInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pSubpassBeginInfo", "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true, "VUID-vkCmdNextSubpass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSubpassBeginInfo->pNext", nullptr, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pSubpassBeginInfo->contents", "VkSubpassContents", pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter");
    }
    skip |= ValidateStructType(loc, "pSubpassEndInfo", "VK_STRUCTURE_TYPE_SUBPASS_END_INFO", pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true, "VUID-vkCmdNextSubpass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSubpassEndInfo = { VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pSubpassEndInfo->pNext", "VkSubpassFragmentDensityMapOffsetEndInfoQCOM", pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(), allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderPass2(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassEndInfo*                     pSubpassEndInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pSubpassEndInfo", "VK_STRUCTURE_TYPE_SUBPASS_END_INFO", pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true, "VUID-vkCmdEndRenderPass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSubpassEndInfo = { VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pSubpassEndInfo->pNext", "VkSubpassFragmentDensityMapOffsetEndInfoQCOM", pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(), allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetQueryPool(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreCounterValue(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    uint64_t*                                   pValue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "semaphore", semaphore);
    skip |= ValidateRequiredPointer(loc, "pValue", pValue, "VUID-vkGetSemaphoreCounterValue-pValue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateWaitSemaphores(
    VkDevice                                    device,
    const VkSemaphoreWaitInfo*                  pWaitInfo,
    uint64_t                                    timeout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pWaitInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO", pWaitInfo, VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, true, "VUID-vkWaitSemaphores-pWaitInfo-parameter", "VUID-VkSemaphoreWaitInfo-sType-sType");
    if (pWaitInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pWaitInfo->pNext", nullptr, pWaitInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreWaitInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pWaitInfo->flags", "VkSemaphoreWaitFlagBits", AllVkSemaphoreWaitFlagBits, pWaitInfo->flags, kOptionalFlags, "VUID-VkSemaphoreWaitInfo-flags-parameter");

        skip |= ValidateHandleArray(loc, "pWaitInfo->semaphoreCount", "pWaitInfo->pSemaphores", pWaitInfo->semaphoreCount, pWaitInfo->pSemaphores, true, true, kVUIDUndefined);

        skip |= ValidateArray(loc, "pWaitInfo->semaphoreCount", "pWaitInfo->pValues", pWaitInfo->semaphoreCount, &pWaitInfo->pValues, true, true, "VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength", "VUID-VkSemaphoreWaitInfo-pValues-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSignalSemaphore(
    VkDevice                                    device,
    const VkSemaphoreSignalInfo*                pSignalInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pSignalInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO", pSignalInfo, VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, true, "VUID-vkSignalSemaphore-pSignalInfo-parameter", "VUID-VkSemaphoreSignalInfo-sType-sType");
    if (pSignalInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSignalInfo->pNext", nullptr, pSignalInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSignalInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pSignalInfo->semaphore", pSignalInfo->semaphore);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferDeviceAddress(
    VkDevice                                    device,
    const VkBufferDeviceAddressInfo*            pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true, "VUID-vkGetBufferDeviceAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferOpaqueCaptureAddress(
    VkDevice                                    device,
    const VkBufferDeviceAddressInfo*            pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true, "VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMemoryOpaqueCaptureAddress(
    VkDevice                                    device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO, true, "VUID-vkGetDeviceMemoryOpaqueCaptureAddress-pInfo-parameter", "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->memory", pInfo->memory);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceToolProperties(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pToolCount,
    VkPhysicalDeviceToolProperties*             pToolProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
     if (CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_3)) return true;
    skip |= ValidateStructTypeArray(loc, "pToolCount", "pToolProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES", pToolCount, pToolProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, true, false, false, "VUID-VkPhysicalDeviceToolProperties-sType-sType", "VUID-vkGetPhysicalDeviceToolProperties-pToolProperties-parameter", kVUIDUndefined);
    if (pToolProperties != nullptr)
    {
        for (uint32_t pToolIndex = 0; pToolIndex < *pToolCount; ++pToolIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pToolProperties[%i].pNext", ParameterName::IndexVector{ pToolIndex }), nullptr, pToolProperties[pToolIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceToolProperties-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePrivateDataSlot(
    VkDevice                                    device,
    const VkPrivateDataSlotCreateInfo*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPrivateDataSlot*                          pPrivateDataSlot,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO, true, "VUID-vkCreatePrivateDataSlot-pCreateInfo-parameter", "VUID-VkPrivateDataSlotCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPrivateDataSlotCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkPrivateDataSlotCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pPrivateDataSlot", pPrivateDataSlot, "VUID-vkCreatePrivateDataSlot-pPrivateDataSlot-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPrivateDataSlot(
    VkDevice                                    device,
    VkPrivateDataSlot                           privateDataSlot,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSetPrivateData(
    VkDevice                                    device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    VkPrivateDataSlot                           privateDataSlot,
    uint64_t                                    data,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "objectType", "VkObjectType", objectType, "VUID-vkSetPrivateData-objectType-parameter");
    skip |= ValidateRequiredHandle(loc, "privateDataSlot", privateDataSlot);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPrivateData(
    VkDevice                                    device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    VkPrivateDataSlot                           privateDataSlot,
    uint64_t*                                   pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "objectType", "VkObjectType", objectType, "VUID-vkGetPrivateData-objectType-parameter");
    skip |= ValidateRequiredHandle(loc, "privateDataSlot", privateDataSlot);
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetPrivateData-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetEvent2(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    const VkDependencyInfo*                     pDependencyInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    skip |= ValidateStructType(loc, "pDependencyInfo", "VK_STRUCTURE_TYPE_DEPENDENCY_INFO", pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, "VUID-vkCmdSetEvent2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDependencyInfo->pNext", nullptr, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pDependencyInfo->dependencyFlags", "VkDependencyFlagBits", AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags, "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->memoryBarrierCount", "pDependencyInfo->pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr)
        {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), nullptr, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->bufferMemoryBarrierCount", "pDependencyInfo->pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr)
        {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext", "VUID-VkBufferMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->imageMemoryBarrierCount", "pDependencyInfo->pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr)
        {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext", "VUID-VkImageMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetEvent2(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags2                       stageMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "event", event);
    skip |= ValidateFlags(loc, "stageMask", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, stageMask, kOptionalFlags, "VUID-vkCmdResetEvent2-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWaitEvents2(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    const VkDependencyInfo*                     pDependencyInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateHandleArray(loc, "eventCount", "pEvents", eventCount, pEvents, true, true, "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    skip |= ValidateStructTypeArray(loc, "eventCount", "pDependencyInfos", "VK_STRUCTURE_TYPE_DEPENDENCY_INFO", eventCount, pDependencyInfos, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, true, "VUID-VkDependencyInfo-sType-sType", "VUID-vkCmdWaitEvents2-pDependencyInfos-parameter", "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    if (pDependencyInfos != nullptr)
    {
        for (uint32_t eventIndex = 0; eventIndex < eventCount; ++eventIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pNext", ParameterName::IndexVector{ eventIndex }), nullptr, pDependencyInfos[eventIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].dependencyFlags", ParameterName::IndexVector{ eventIndex }), "VkDependencyFlagBits", AllVkDependencyFlagBits, pDependencyInfos[eventIndex].dependencyFlags, kOptionalFlags, "VUID-VkDependencyInfo-dependencyFlags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pDependencyInfos[%i].memoryBarrierCount", ParameterName::IndexVector{ eventIndex }), ParameterName("pDependencyInfos[%i].pMemoryBarriers", ParameterName::IndexVector{ eventIndex }), "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", pDependencyInfos[eventIndex].memoryBarrierCount, pDependencyInfos[eventIndex].pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pMemoryBarriers != nullptr)
            {
                for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfos[eventIndex].memoryBarrierCount; ++memoryBarrierIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), nullptr, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pDependencyInfos[%i].bufferMemoryBarrierCount", ParameterName::IndexVector{ eventIndex }), ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers", ParameterName::IndexVector{ eventIndex }), "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", pDependencyInfos[eventIndex].bufferMemoryBarrierCount, pDependencyInfos[eventIndex].pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pBufferMemoryBarriers != nullptr)
            {
                for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfos[eventIndex].bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
                {
                    constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext", "VUID-VkBufferMemoryBarrier2-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                    skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pDependencyInfos[%i].imageMemoryBarrierCount", ParameterName::IndexVector{ eventIndex }), ParameterName("pDependencyInfos[%i].pImageMemoryBarriers", ParameterName::IndexVector{ eventIndex }), "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", pDependencyInfos[eventIndex].imageMemoryBarrierCount, pDependencyInfos[eventIndex].pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pImageMemoryBarriers != nullptr)
            {
                for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfos[eventIndex].imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
                {
                    constexpr std::array allowed_structs_VkImageMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext", "VUID-VkImageMemoryBarrier2-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                    skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                    skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                    skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPipelineBarrier2(
    VkCommandBuffer                             commandBuffer,
    const VkDependencyInfo*                     pDependencyInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pDependencyInfo", "VK_STRUCTURE_TYPE_DEPENDENCY_INFO", pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, "VUID-vkCmdPipelineBarrier2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDependencyInfo->pNext", nullptr, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pDependencyInfo->dependencyFlags", "VkDependencyFlagBits", AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags, "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->memoryBarrierCount", "pDependencyInfo->pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr)
        {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), nullptr, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->bufferMemoryBarrierCount", "pDependencyInfo->pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr)
        {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext", "VUID-VkBufferMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->imageMemoryBarrierCount", "pDependencyInfo->pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr)
        {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext", "VUID-VkImageMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteTimestamp2(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags2                       stage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "stage", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, stage, kOptionalFlags, "VUID-vkCmdWriteTimestamp2-stage-parameter");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSubmit2(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo2*                        pSubmits,
    VkFence                                     fence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "submitCount", "pSubmits", "VK_STRUCTURE_TYPE_SUBMIT_INFO_2", submitCount, pSubmits, VK_STRUCTURE_TYPE_SUBMIT_INFO_2, false, true, "VUID-VkSubmitInfo2-sType-sType", "VUID-vkQueueSubmit2-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr)
    {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex)
        {
            constexpr std::array allowed_structs_VkSubmitInfo2 = { VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV };

            skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pNext", ParameterName::IndexVector{ submitIndex }), "VkPerformanceQuerySubmitInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoNV", pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo2.size(), allowed_structs_VkSubmitInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubmitInfo2-pNext-pNext", "VUID-VkSubmitInfo2-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pSubmits[%i].flags", ParameterName::IndexVector{ submitIndex }), "VkSubmitFlagBits", AllVkSubmitFlagBits, pSubmits[submitIndex].flags, kOptionalFlags, "VUID-VkSubmitInfo2-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pSubmits[%i].waitSemaphoreInfoCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pWaitSemaphoreInfos", ParameterName::IndexVector{ submitIndex }), "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", pSubmits[submitIndex].waitSemaphoreInfoCount, pSubmits[submitIndex].pWaitSemaphoreInfos, VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType", "VUID-VkSubmitInfo2-pWaitSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pWaitSemaphoreInfos != nullptr)
            {
                for (uint32_t waitSemaphoreInfoIndex = 0; waitSemaphoreInfoIndex < pSubmits[submitIndex].waitSemaphoreInfoCount; ++waitSemaphoreInfoIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pWaitSemaphoreInfos[%i].pNext", ParameterName::IndexVector{ submitIndex, waitSemaphoreInfoIndex }), nullptr, pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRequiredHandle(loc, ParameterName("pSubmits[%i].pWaitSemaphoreInfos[%i].semaphore", ParameterName::IndexVector{ submitIndex, waitSemaphoreInfoIndex }), pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].semaphore);

                    skip |= ValidateFlags(loc, ParameterName("pSubmits[%i].pWaitSemaphoreInfos[%i].stageMask", ParameterName::IndexVector{ submitIndex, waitSemaphoreInfoIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].stageMask, kOptionalFlags, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pSubmits[%i].commandBufferInfoCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pCommandBufferInfos", ParameterName::IndexVector{ submitIndex }), "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO", pSubmits[submitIndex].commandBufferInfoCount, pSubmits[submitIndex].pCommandBufferInfos, VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO, false, true, "VUID-VkCommandBufferSubmitInfo-sType-sType", "VUID-VkSubmitInfo2-pCommandBufferInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pCommandBufferInfos != nullptr)
            {
                for (uint32_t commandBufferInfoIndex = 0; commandBufferInfoIndex < pSubmits[submitIndex].commandBufferInfoCount; ++commandBufferInfoIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pCommandBufferInfos[%i].pNext", ParameterName::IndexVector{ submitIndex, commandBufferInfoIndex }), nullptr, pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCommandBufferSubmitInfo-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRequiredHandle(loc, ParameterName("pSubmits[%i].pCommandBufferInfos[%i].commandBuffer", ParameterName::IndexVector{ submitIndex, commandBufferInfoIndex }), pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].commandBuffer);
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pSubmits[%i].signalSemaphoreInfoCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pSignalSemaphoreInfos", ParameterName::IndexVector{ submitIndex }), "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", pSubmits[submitIndex].signalSemaphoreInfoCount, pSubmits[submitIndex].pSignalSemaphoreInfos, VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType", "VUID-VkSubmitInfo2-pSignalSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pSignalSemaphoreInfos != nullptr)
            {
                for (uint32_t signalSemaphoreInfoIndex = 0; signalSemaphoreInfoIndex < pSubmits[submitIndex].signalSemaphoreInfoCount; ++signalSemaphoreInfoIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pSignalSemaphoreInfos[%i].pNext", ParameterName::IndexVector{ submitIndex, signalSemaphoreInfoIndex }), nullptr, pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRequiredHandle(loc, ParameterName("pSubmits[%i].pSignalSemaphoreInfos[%i].semaphore", ParameterName::IndexVector{ submitIndex, signalSemaphoreInfoIndex }), pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].semaphore);

                    skip |= ValidateFlags(loc, ParameterName("pSubmits[%i].pSignalSemaphoreInfos[%i].stageMask", ParameterName::IndexVector{ submitIndex, signalSemaphoreInfoIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].stageMask, kOptionalFlags, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBuffer2(
    VkCommandBuffer                             commandBuffer,
    const VkCopyBufferInfo2*                    pCopyBufferInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCopyBufferInfo", "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2", pCopyBufferInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2, true, "VUID-vkCmdCopyBuffer2-pCopyBufferInfo-parameter", "VUID-VkCopyBufferInfo2-sType-sType");
    if (pCopyBufferInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyBufferInfo->pNext", nullptr, pCopyBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyBufferInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferInfo->srcBuffer", pCopyBufferInfo->srcBuffer);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferInfo->dstBuffer", pCopyBufferInfo->dstBuffer);

        skip |= ValidateStructTypeArray(loc, "pCopyBufferInfo->regionCount", "pCopyBufferInfo->pRegions", "VK_STRUCTURE_TYPE_BUFFER_COPY_2", pCopyBufferInfo->regionCount, pCopyBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_COPY_2, true, true, "VUID-VkBufferCopy2-sType-sType", "VUID-VkCopyBufferInfo2-pRegions-parameter", "VUID-VkCopyBufferInfo2-regionCount-arraylength");

        if (pCopyBufferInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyBufferInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyBufferInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferCopy2-pNext-pNext", kVUIDUndefined, false, true);
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer2(commandBuffer, pCopyBufferInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImage2(
    VkCommandBuffer                             commandBuffer,
    const VkCopyImageInfo2*                     pCopyImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCopyImageInfo", "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2", pCopyImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2, true, "VUID-vkCmdCopyImage2-pCopyImageInfo-parameter", "VUID-VkCopyImageInfo2-sType-sType");
    if (pCopyImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyImageInfo->pNext", nullptr, pCopyImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyImageInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyImageInfo->srcImage", pCopyImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageInfo->srcImageLayout", "VkImageLayout", pCopyImageInfo->srcImageLayout, "VUID-VkCopyImageInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageInfo->dstImage", pCopyImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageInfo->dstImageLayout", "VkImageLayout", pCopyImageInfo->dstImageLayout, "VUID-VkCopyImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyImageInfo->regionCount", "pCopyImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_COPY_2", pCopyImageInfo->regionCount, pCopyImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true, true, "VUID-VkImageCopy2-sType-sType", "VUID-VkCopyImageInfo2-pRegions-parameter", "VUID-VkCopyImageInfo2-regionCount-arraylength");

        if (pCopyImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyImageInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(loc, ParameterName("pCopyImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBufferToImage2(
    VkCommandBuffer                             commandBuffer,
    const VkCopyBufferToImageInfo2*             pCopyBufferToImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCopyBufferToImageInfo", "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2", pCopyBufferToImageInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2, true, "VUID-vkCmdCopyBufferToImage2-pCopyBufferToImageInfo-parameter", "VUID-VkCopyBufferToImageInfo2-sType-sType");
    if (pCopyBufferToImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyBufferToImageInfo->pNext", nullptr, pCopyBufferToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyBufferToImageInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferToImageInfo->srcBuffer", pCopyBufferToImageInfo->srcBuffer);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferToImageInfo->dstImage", pCopyBufferToImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pCopyBufferToImageInfo->dstImageLayout", "VkImageLayout", pCopyBufferToImageInfo->dstImageLayout, "VUID-VkCopyBufferToImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyBufferToImageInfo->regionCount", "pCopyBufferToImageInfo->pRegions", "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", pCopyBufferToImageInfo->regionCount, pCopyBufferToImageInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true, true, "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyBufferToImageInfo2-pRegions-parameter", "VUID-VkCopyBufferToImageInfo2-regionCount-arraylength");

        if (pCopyBufferToImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferToImageInfo->regionCount; ++regionIndex)
            {
                constexpr std::array allowed_structs_VkBufferImageCopy2 = { VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM };

                skip |= ValidateStructPnext(loc, ParameterName("pCopyBufferToImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), "VkCopyCommandTransformInfoQCOM", pCopyBufferToImageInfo->pRegions[regionIndex].pNext, allowed_structs_VkBufferImageCopy2.size(), allowed_structs_VkBufferImageCopy2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext", "VUID-VkBufferImageCopy2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyBufferToImageInfo->pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyBufferToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImageToBuffer2(
    VkCommandBuffer                             commandBuffer,
    const VkCopyImageToBufferInfo2*             pCopyImageToBufferInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pCopyImageToBufferInfo", "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2", pCopyImageToBufferInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2, true, "VUID-vkCmdCopyImageToBuffer2-pCopyImageToBufferInfo-parameter", "VUID-VkCopyImageToBufferInfo2-sType-sType");
    if (pCopyImageToBufferInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyImageToBufferInfo->pNext", nullptr, pCopyImageToBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToBufferInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyImageToBufferInfo->srcImage", pCopyImageToBufferInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageToBufferInfo->srcImageLayout", "VkImageLayout", pCopyImageToBufferInfo->srcImageLayout, "VUID-VkCopyImageToBufferInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageToBufferInfo->dstBuffer", pCopyImageToBufferInfo->dstBuffer);

        skip |= ValidateStructTypeArray(loc, "pCopyImageToBufferInfo->regionCount", "pCopyImageToBufferInfo->pRegions", "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", pCopyImageToBufferInfo->regionCount, pCopyImageToBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true, true, "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyImageToBufferInfo2-pRegions-parameter", "VUID-VkCopyImageToBufferInfo2-regionCount-arraylength");

        if (pCopyImageToBufferInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToBufferInfo->regionCount; ++regionIndex)
            {
                constexpr std::array allowed_structs_VkBufferImageCopy2 = { VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM };

                skip |= ValidateStructPnext(loc, ParameterName("pCopyImageToBufferInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), "VkCopyCommandTransformInfoQCOM", pCopyImageToBufferInfo->pRegions[regionIndex].pNext, allowed_structs_VkBufferImageCopy2.size(), allowed_structs_VkBufferImageCopy2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext", "VUID-VkBufferImageCopy2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyImageToBufferInfo->pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageToBufferInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBlitImage2(
    VkCommandBuffer                             commandBuffer,
    const VkBlitImageInfo2*                     pBlitImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pBlitImageInfo", "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2", pBlitImageInfo, VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2, true, "VUID-vkCmdBlitImage2-pBlitImageInfo-parameter", "VUID-VkBlitImageInfo2-sType-sType");
    if (pBlitImageInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkBlitImageInfo2 = { VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pBlitImageInfo->pNext", "VkBlitImageCubicWeightsInfoQCOM", pBlitImageInfo->pNext, allowed_structs_VkBlitImageInfo2.size(), allowed_structs_VkBlitImageInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBlitImageInfo2-pNext-pNext", "VUID-VkBlitImageInfo2-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pBlitImageInfo->srcImage", pBlitImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pBlitImageInfo->srcImageLayout", "VkImageLayout", pBlitImageInfo->srcImageLayout, "VUID-VkBlitImageInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pBlitImageInfo->dstImage", pBlitImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pBlitImageInfo->dstImageLayout", "VkImageLayout", pBlitImageInfo->dstImageLayout, "VUID-VkBlitImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pBlitImageInfo->regionCount", "pBlitImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_BLIT_2", pBlitImageInfo->regionCount, pBlitImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_BLIT_2, true, true, "VUID-VkImageBlit2-sType-sType", "VUID-VkBlitImageInfo2-pRegions-parameter", "VUID-VkBlitImageInfo2-regionCount-arraylength");

        if (pBlitImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pBlitImageInfo->regionCount; ++regionIndex)
            {
                constexpr std::array allowed_structs_VkImageBlit2 = { VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM };

                skip |= ValidateStructPnext(loc, ParameterName("pBlitImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), "VkCopyCommandTransformInfoQCOM", pBlitImageInfo->pRegions[regionIndex].pNext, allowed_structs_VkImageBlit2.size(), allowed_structs_VkImageBlit2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageBlit2-pNext-pNext", "VUID-VkImageBlit2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pBlitImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                skip |= ValidateFlags(loc, ParameterName("pBlitImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
            }
        }

        skip |= ValidateRangedEnum(loc, "pBlitImageInfo->filter", "VkFilter", pBlitImageInfo->filter, "VUID-VkBlitImageInfo2-filter-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResolveImage2(
    VkCommandBuffer                             commandBuffer,
    const VkResolveImageInfo2*                  pResolveImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pResolveImageInfo", "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2", pResolveImageInfo, VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2, true, "VUID-vkCmdResolveImage2-pResolveImageInfo-parameter", "VUID-VkResolveImageInfo2-sType-sType");
    if (pResolveImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pResolveImageInfo->pNext", nullptr, pResolveImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkResolveImageInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pResolveImageInfo->srcImage", pResolveImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pResolveImageInfo->srcImageLayout", "VkImageLayout", pResolveImageInfo->srcImageLayout, "VUID-VkResolveImageInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pResolveImageInfo->dstImage", pResolveImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pResolveImageInfo->dstImageLayout", "VkImageLayout", pResolveImageInfo->dstImageLayout, "VUID-VkResolveImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pResolveImageInfo->regionCount", "pResolveImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2", pResolveImageInfo->regionCount, pResolveImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2, true, true, "VUID-VkImageResolve2-sType-sType", "VUID-VkResolveImageInfo2-pRegions-parameter", "VUID-VkResolveImageInfo2-regionCount-arraylength");

        if (pResolveImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pResolveImageInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pResolveImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pResolveImageInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageResolve2-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pResolveImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pResolveImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(loc, ParameterName("pResolveImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pResolveImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRendering(
    VkCommandBuffer                             commandBuffer,
    const VkRenderingInfo*                      pRenderingInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pRenderingInfo", "VK_STRUCTURE_TYPE_RENDERING_INFO", pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true, "VUID-vkCmdBeginRendering-pRenderingInfo-parameter", "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderingInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT, VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pRenderingInfo->pNext", "VkDeviceGroupRenderPassBeginInfo, VkMultisampledRenderToSingleSampledInfoEXT, VkMultiviewPerViewAttributesInfoNVX, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, VkRenderingFragmentDensityMapAttachmentInfoEXT, VkRenderingFragmentShadingRateAttachmentInfoKHR", pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(), allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pRenderingInfo->flags", "VkRenderingFlagBits", AllVkRenderingFlagBits, pRenderingInfo->flags, kOptionalFlags, "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateStructTypeArray(loc, "pRenderingInfo->colorAttachmentCount", "pRenderingInfo->pColorAttachments", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->colorAttachmentCount, pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, true, "VUID-VkRenderingAttachmentInfo-sType-sType", "VUID-VkRenderingInfo-pColorAttachments-parameter", kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr)
        {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount; ++colorAttachmentIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].pNext", ParameterName::IndexVector{ colorAttachmentIndex }), nullptr, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].imageLayout", ParameterName::IndexVector{ colorAttachmentIndex }), "VkImageLayout", pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

                skip |= ValidateFlags(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].resolveMode", ParameterName::IndexVector{ colorAttachmentIndex }), "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].resolveImageLayout", ParameterName::IndexVector{ colorAttachmentIndex }), "VkImageLayout", pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].loadOp", ParameterName::IndexVector{ colorAttachmentIndex }), "VkAttachmentLoadOp", pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].storeOp", ParameterName::IndexVector{ colorAttachmentIndex }), "VkAttachmentStoreOp", pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

                // No xml-driven validation
            }
        }

        skip |= ValidateStructType(loc, "pRenderingInfo->pDepthAttachment", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->pDepthAttachment, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, "VUID-VkRenderingInfo-pDepthAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pRenderingInfo->pDepthAttachment->pNext", nullptr, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->imageLayout", "VkImageLayout", pRenderingInfo->pDepthAttachment->imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= ValidateFlags(loc, "pRenderingInfo->pDepthAttachment->resolveMode", "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->resolveImageLayout", "VkImageLayout", pRenderingInfo->pDepthAttachment->resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->loadOp", "VkAttachmentLoadOp", pRenderingInfo->pDepthAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->storeOp", "VkAttachmentStoreOp", pRenderingInfo->pDepthAttachment->storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }

        skip |= ValidateStructType(loc, "pRenderingInfo->pStencilAttachment", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->pStencilAttachment, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, "VUID-VkRenderingInfo-pStencilAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pRenderingInfo->pStencilAttachment->pNext", nullptr, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->imageLayout", "VkImageLayout", pRenderingInfo->pStencilAttachment->imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= ValidateFlags(loc, "pRenderingInfo->pStencilAttachment->resolveMode", "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->resolveImageLayout", "VkImageLayout", pRenderingInfo->pStencilAttachment->resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->loadOp", "VkAttachmentLoadOp", pRenderingInfo->pStencilAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->storeOp", "VkAttachmentStoreOp", pRenderingInfo->pStencilAttachment->storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRendering(commandBuffer, pRenderingInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRendering(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCullMode(
    VkCommandBuffer                             commandBuffer,
    VkCullModeFlags                             cullMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "cullMode", "VkCullModeFlagBits", AllVkCullModeFlagBits, cullMode, kOptionalFlags, "VUID-vkCmdSetCullMode-cullMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFrontFace(
    VkCommandBuffer                             commandBuffer,
    VkFrontFace                                 frontFace,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "frontFace", "VkFrontFace", frontFace, "VUID-vkCmdSetFrontFace-frontFace-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveTopology(
    VkCommandBuffer                             commandBuffer,
    VkPrimitiveTopology                         primitiveTopology,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "primitiveTopology", "VkPrimitiveTopology", primitiveTopology, "VUID-vkCmdSetPrimitiveTopology-primitiveTopology-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWithCount(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "viewportCount", "pViewports", viewportCount, &pViewports, true, true, "VUID-vkCmdSetViewportWithCount-viewportCount-arraylength", "VUID-vkCmdSetViewportWithCount-pViewports-parameter");
    if (pViewports != nullptr)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetScissorWithCount(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "scissorCount", "pScissors", scissorCount, &pScissors, true, true, "VUID-vkCmdSetScissorWithCount-scissorCount-arraylength", "VUID-vkCmdSetScissorWithCount-pScissors-parameter");
    if (pScissors != nullptr)
    {
        for (uint32_t scissorIndex = 0; scissorIndex < scissorCount; ++scissorIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindVertexBuffers2(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets,
    const VkDeviceSize*                         pSizes,
    const VkDeviceSize*                         pStrides,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthTestEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "depthTestEnable", depthTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthWriteEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthWriteEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "depthWriteEnable", depthWriteEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthCompareOp(
    VkCommandBuffer                             commandBuffer,
    VkCompareOp                                 depthCompareOp,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRangedEnum(loc, "depthCompareOp", "VkCompareOp", depthCompareOp, "VUID-vkCmdSetDepthCompareOp-depthCompareOp-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBoundsTestEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthBoundsTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "depthBoundsTestEnable", depthBoundsTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilTestEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    stencilTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "stencilTestEnable", stencilTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilOp(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, kRequiredFlags, "VUID-vkCmdSetStencilOp-faceMask-parameter", "VUID-vkCmdSetStencilOp-faceMask-requiredbitmask");
    skip |= ValidateRangedEnum(loc, "failOp", "VkStencilOp", failOp, "VUID-vkCmdSetStencilOp-failOp-parameter");
    skip |= ValidateRangedEnum(loc, "passOp", "VkStencilOp", passOp, "VUID-vkCmdSetStencilOp-passOp-parameter");
    skip |= ValidateRangedEnum(loc, "depthFailOp", "VkStencilOp", depthFailOp, "VUID-vkCmdSetStencilOp-depthFailOp-parameter");
    skip |= ValidateRangedEnum(loc, "compareOp", "VkCompareOp", compareOp, "VUID-vkCmdSetStencilOp-compareOp-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizerDiscardEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    rasterizerDiscardEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "rasterizerDiscardEnable", rasterizerDiscardEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBiasEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthBiasEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "depthBiasEnable", depthBiasEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveRestartEnable(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    primitiveRestartEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateBool32(loc, "primitiveRestartEnable", primitiveRestartEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceBufferMemoryRequirements(
    VkDevice                                    device,
    const VkDeviceBufferMemoryRequirements*     pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS", pInfo, VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS, true, "VUID-vkGetDeviceBufferMemoryRequirements-pInfo-parameter", "VUID-VkDeviceBufferMemoryRequirements-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceBufferMemoryRequirements-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true, "VUID-VkDeviceBufferMemoryRequirements-pCreateInfo-parameter", "VUID-VkBufferCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkBufferCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO, VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionBufferCreateInfoFUCHSIA, VkBufferDeviceAddressCreateInfoEXT, VkBufferOpaqueCaptureAddressCreateInfo, VkBufferUsageFlags2CreateInfoKHR, VkDedicatedAllocationBufferCreateInfoNV, VkExternalMemoryBufferCreateInfo, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(), allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkBufferCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter");
        }
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetDeviceBufferMemoryRequirements-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageMemoryRequirements(
    VkDevice                                    device,
    const VkDeviceImageMemoryRequirements*      pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS", pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true, "VUID-vkGetDeviceImageMemoryRequirements-pInfo-parameter", "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->imageType", "VkImageType", pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->format", "VkFormat", pInfo->pCreateInfo->format, "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->tiling", "VkImageTiling", pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->initialLayout", "VkImageLayout", pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= ValidateFlags(loc, "pInfo->planeAspect", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pInfo->planeAspect, kOptionalSingleBit, "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetDeviceImageMemoryRequirements-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageSparseMemoryRequirements(
    VkDevice                                    device,
    const VkDeviceImageMemoryRequirements*      pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS", pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true, "VUID-vkGetDeviceImageSparseMemoryRequirements-pInfo-parameter", "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->imageType", "VkImageType", pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->format", "VkFormat", pInfo->pCreateInfo->format, "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->tiling", "VkImageTiling", pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->initialLayout", "VkImageLayout", pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= ValidateFlags(loc, "pInfo->planeAspect", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pInfo->planeAspect, kOptionalSingleBit, "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= ValidateStructTypeArray(loc, "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2", pSparseMemoryRequirementCount, pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false, "VUID-VkSparseImageMemoryRequirements2-sType-sType", "VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr)
    {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount; ++pSparseMemoryRequirementIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pSparseMemoryRequirements[%i].pNext", ParameterName::IndexVector{ pSparseMemoryRequirementIndex }), nullptr, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySurfaceKHR(
    VkInstance                                  instance,
    VkSurfaceKHR                                surface,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_surface) skip |= OutputExtensionError(loc, "VK_KHR_surface");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    VkSurfaceKHR                                surface,
    VkBool32*                                   pSupported,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_surface) skip |= OutputExtensionError(loc, "VK_KHR_surface");
    skip |= ValidateRequiredHandle(loc, "surface", surface);
    skip |= ValidateRequiredPointer(loc, "pSupported", pSupported, "VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_surface) skip |= OutputExtensionError(loc, "VK_KHR_surface");
    skip |= ValidateRequiredHandle(loc, "surface", surface);
    skip |= ValidateRequiredPointer(loc, "pSurfaceCapabilities", pSurfaceCapabilities, "VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter");
    if (pSurfaceCapabilities != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceFormatsKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormatKHR*                         pSurfaceFormats,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_surface) skip |= OutputExtensionError(loc, "VK_KHR_surface");
    skip |= ValidateArray(loc, "pSurfaceFormatCount", "pSurfaceFormats", pSurfaceFormatCount, &pSurfaceFormats, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter");
    if (pSurfaceFormats != nullptr)
    {
        for (uint32_t pSurfaceFormatIndex = 0; pSurfaceFormatIndex < *pSurfaceFormatCount; ++pSurfaceFormatIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfacePresentModesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_surface) skip |= OutputExtensionError(loc, "VK_KHR_surface");
    skip |= ValidateArray(loc, "pPresentModeCount", "pPresentModes", pPresentModeCount, &pPresentModes, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter");
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSwapchainKHR(
    VkDevice                                    device,
    const VkSwapchainCreateInfoKHR*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchain,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, "VK_KHR_swapchain");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true, "VUID-vkCreateSwapchainKHR-pCreateInfo-parameter", "VUID-VkSwapchainCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSwapchainCreateInfoKHR = { VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDeviceGroupSwapchainCreateInfoKHR, VkImageCompressionControlEXT, VkImageFormatListCreateInfo, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSwapchainCounterCreateInfoEXT, VkSwapchainDisplayNativeHdrCreateInfoAMD, VkSwapchainPresentBarrierCreateInfoNV, VkSwapchainPresentModesCreateInfoEXT, VkSwapchainPresentScalingCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkSwapchainCreateInfoKHR.size(), allowed_structs_VkSwapchainCreateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSwapchainCreateInfoKHR-pNext-pNext", "VUID-VkSwapchainCreateInfoKHR-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkSwapchainCreateFlagBitsKHR", AllVkSwapchainCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags, "VUID-VkSwapchainCreateInfoKHR-flags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->surface", pCreateInfo->surface);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->imageFormat", "VkFormat", pCreateInfo->imageFormat, "VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->imageColorSpace", "VkColorSpaceKHR", pCreateInfo->imageColorSpace, "VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter");

        // No xml-driven validation

        skip |= ValidateFlags(loc, "pCreateInfo->imageUsage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pCreateInfo->imageUsage, kRequiredFlags, "VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter", "VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->imageSharingMode", "VkSharingMode", pCreateInfo->imageSharingMode, "VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->preTransform", "VkSurfaceTransformFlagBitsKHR", AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->preTransform, kRequiredSingleBit, "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter", "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->compositeAlpha", "VkCompositeAlphaFlagBitsKHR", AllVkCompositeAlphaFlagBitsKHR, pCreateInfo->compositeAlpha, kRequiredSingleBit, "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter", "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->presentMode", "VkPresentModeKHR", pCreateInfo->presentMode, "VUID-VkSwapchainCreateInfoKHR-presentMode-parameter");

        skip |= ValidateBool32(loc, "pCreateInfo->clipped", pCreateInfo->clipped);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSwapchain", pSwapchain, "VUID-vkCreateSwapchainKHR-pSwapchain-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySwapchainKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, "VK_KHR_swapchain");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetSwapchainImagesKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pSwapchainImageCount,
    VkImage*                                    pSwapchainImages,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, "VK_KHR_swapchain");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    skip |= ValidateArray(loc, "pSwapchainImageCount", "pSwapchainImages", pSwapchainImageCount, &pSwapchainImages, true, false, false, kVUIDUndefined, "VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireNextImageKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    timeout,
    VkSemaphore                                 semaphore,
    VkFence                                     fence,
    uint32_t*                                   pImageIndex,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, "VK_KHR_swapchain");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    skip |= ValidateRequiredPointer(loc, "pImageIndex", pImageIndex, "VUID-vkAcquireNextImageKHR-pImageIndex-parameter");
    if (!skip) skip |= manual_PreCallValidateAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateQueuePresentKHR(
    VkQueue                                     queue,
    const VkPresentInfoKHR*                     pPresentInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, "VK_KHR_swapchain");
    skip |= ValidateStructType(loc, "pPresentInfo", "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR", pPresentInfo, VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, true, "VUID-vkQueuePresentKHR-pPresentInfo-parameter", "VUID-VkPresentInfoKHR-sType-sType");
    if (pPresentInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPresentInfoKHR = { VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR, VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR, VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP, VK_STRUCTURE_TYPE_PRESENT_ID_KHR, VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR, VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pPresentInfo->pNext", "VkDeviceGroupPresentInfoKHR, VkDisplayPresentInfoKHR, VkPresentFrameTokenGGP, VkPresentIdKHR, VkPresentRegionsKHR, VkPresentTimesInfoGOOGLE, VkSwapchainPresentFenceInfoEXT, VkSwapchainPresentModeInfoEXT", pPresentInfo->pNext, allowed_structs_VkPresentInfoKHR.size(), allowed_structs_VkPresentInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkPresentInfoKHR-pNext-pNext", "VUID-VkPresentInfoKHR-sType-unique", false, true);

        skip |= ValidateArray(loc, "pPresentInfo->waitSemaphoreCount", "pPresentInfo->pWaitSemaphores", pPresentInfo->waitSemaphoreCount, &pPresentInfo->pWaitSemaphores, false, true, kVUIDUndefined, "VUID-VkPresentInfoKHR-pWaitSemaphores-parameter");

        skip |= ValidateHandleArray(loc, "pPresentInfo->swapchainCount", "pPresentInfo->pSwapchains", pPresentInfo->swapchainCount, pPresentInfo->pSwapchains, true, true, kVUIDUndefined);

        skip |= ValidateArray(loc, "pPresentInfo->swapchainCount", "pPresentInfo->pImageIndices", pPresentInfo->swapchainCount, &pPresentInfo->pImageIndices, true, true, "VUID-VkPresentInfoKHR-swapchainCount-arraylength", "VUID-VkPresentInfoKHR-pImageIndices-parameter");

        skip |= ValidateArray(loc, "pPresentInfo->swapchainCount", "pPresentInfo->pResults", pPresentInfo->swapchainCount, &pPresentInfo->pResults, true, false, "VUID-VkPresentInfoKHR-swapchainCount-arraylength", "VUID-VkPresentInfoKHR-pResults-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateQueuePresentKHR(queue, pPresentInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice                                    device,
    VkDeviceGroupPresentCapabilitiesKHR*        pDeviceGroupPresentCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group))) skip |= OutputExtensionError(loc, "VK_KHR_swapchain || VK_KHR_device_group");
    skip |= ValidateStructType(loc, "pDeviceGroupPresentCapabilities", "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR", pDeviceGroupPresentCapabilities, VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR, true, "VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter", "VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType");
    if (pDeviceGroupPresentCapabilities != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDeviceGroupPresentCapabilities->pNext", nullptr, pDeviceGroupPresentCapabilities->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupSurfacePresentModesKHR(
    VkDevice                                    device,
    VkSurfaceKHR                                surface,
    VkDeviceGroupPresentModeFlagsKHR*           pModes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group))) skip |= OutputExtensionError(loc, "VK_KHR_swapchain || VK_KHR_device_group");
    skip |= ValidateRequiredHandle(loc, "surface", surface);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDevicePresentRectanglesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    uint32_t*                                   pRectCount,
    VkRect2D*                                   pRects,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "surface", surface);
    skip |= ValidateArray(loc, "pRectCount", "pRects", pRectCount, &pRects, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireNextImage2KHR(
    VkDevice                                    device,
    const VkAcquireNextImageInfoKHR*            pAcquireInfo,
    uint32_t*                                   pImageIndex,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group))) skip |= OutputExtensionError(loc, "VK_KHR_swapchain || VK_KHR_device_group");
    skip |= ValidateStructType(loc, "pAcquireInfo", "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR", pAcquireInfo, VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR, true, "VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter", "VUID-VkAcquireNextImageInfoKHR-sType-sType");
    if (pAcquireInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pAcquireInfo->pNext", nullptr, pAcquireInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAcquireNextImageInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pAcquireInfo->swapchain", pAcquireInfo->swapchain);
    }
    skip |= ValidateRequiredPointer(loc, "pImageIndex", pImageIndex, "VUID-vkAcquireNextImage2KHR-pImageIndex-parameter");
    if (!skip) skip |= manual_PreCallValidateAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPropertiesKHR*                     pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateArray(loc, "pPropertyCount", "pProperties", pPropertyCount, &pProperties, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayPlanePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlanePropertiesKHR*                pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateArray(loc, "pPropertyCount", "pProperties", pPropertyCount, &pProperties, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayPlaneSupportedDisplaysKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    planeIndex,
    uint32_t*                                   pDisplayCount,
    VkDisplayKHR*                               pDisplays,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateArray(loc, "pDisplayCount", "pDisplays", pDisplayCount, &pDisplays, true, false, false, kVUIDUndefined, "VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayModePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModePropertiesKHR*                 pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateRequiredHandle(loc, "display", display);
    skip |= ValidateArray(loc, "pPropertyCount", "pProperties", pPropertyCount, &pProperties, true, false, false, kVUIDUndefined, "VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDisplayModeKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    const VkDisplayModeCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDisplayModeKHR*                           pMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateRequiredHandle(loc, "display", display);
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR, true, "VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter", "VUID-VkDisplayModeCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayModeCreateInfoKHR-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask");

        // No xml-driven validation
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pMode", pMode, "VUID-vkCreateDisplayModeKHR-pMode-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayPlaneCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayModeKHR                            mode,
    uint32_t                                    planeIndex,
    VkDisplayPlaneCapabilitiesKHR*              pCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateRequiredHandle(loc, "mode", mode);
    skip |= ValidateRequiredPointer(loc, "pCapabilities", pCapabilities, "VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter");
    if (pCapabilities != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDisplayPlaneSurfaceKHR(
    VkInstance                                  instance,
    const VkDisplaySurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_display) skip |= OutputExtensionError(loc, "VK_KHR_display");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR, true, "VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter", "VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->displayMode", pCreateInfo->displayMode);

        skip |= ValidateFlags(loc, "pCreateInfo->transform", "VkSurfaceTransformFlagBitsKHR", AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->transform, kRequiredSingleBit, "VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter", "VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->alphaMode", "VkDisplayPlaneAlphaFlagBitsKHR", AllVkDisplayPlaneAlphaFlagBitsKHR, pCreateInfo->alphaMode, kRequiredSingleBit, "VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter", "VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter");

        // No xml-driven validation
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSharedSwapchainsKHR(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainCreateInfoKHR*             pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkSwapchainKHR*                             pSwapchains,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_display_swapchain)) skip |= OutputExtensionError(loc, "VK_KHR_display_swapchain");
    skip |= ValidateStructTypeArray(loc, "swapchainCount", "pCreateInfos", "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", swapchainCount, pCreateInfos, VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true, true, "VUID-VkSwapchainCreateInfoKHR-sType-sType", "VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter", "VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex)
        {
            constexpr std::array allowed_structs_VkSwapchainCreateInfoKHR = { VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ swapchainIndex }), "VkDeviceGroupSwapchainCreateInfoKHR, VkImageCompressionControlEXT, VkImageFormatListCreateInfo, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSwapchainCounterCreateInfoEXT, VkSwapchainDisplayNativeHdrCreateInfoAMD, VkSwapchainPresentBarrierCreateInfoNV, VkSwapchainPresentModesCreateInfoEXT, VkSwapchainPresentScalingCreateInfoEXT", pCreateInfos[swapchainIndex].pNext, allowed_structs_VkSwapchainCreateInfoKHR.size(), allowed_structs_VkSwapchainCreateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSwapchainCreateInfoKHR-pNext-pNext", "VUID-VkSwapchainCreateInfoKHR-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ swapchainIndex }), "VkSwapchainCreateFlagBitsKHR", AllVkSwapchainCreateFlagBitsKHR, pCreateInfos[swapchainIndex].flags, kOptionalFlags, "VUID-VkSwapchainCreateInfoKHR-flags-parameter");

            skip |= ValidateRequiredHandle(loc, ParameterName("pCreateInfos[%i].surface", ParameterName::IndexVector{ swapchainIndex }), pCreateInfos[swapchainIndex].surface);

            skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].imageFormat", ParameterName::IndexVector{ swapchainIndex }), "VkFormat", pCreateInfos[swapchainIndex].imageFormat, "VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].imageColorSpace", ParameterName::IndexVector{ swapchainIndex }), "VkColorSpaceKHR", pCreateInfos[swapchainIndex].imageColorSpace, "VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter");

            // No xml-driven validation

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].imageUsage", ParameterName::IndexVector{ swapchainIndex }), "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pCreateInfos[swapchainIndex].imageUsage, kRequiredFlags, "VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter", "VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask");

            skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].imageSharingMode", ParameterName::IndexVector{ swapchainIndex }), "VkSharingMode", pCreateInfos[swapchainIndex].imageSharingMode, "VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter");

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].preTransform", ParameterName::IndexVector{ swapchainIndex }), "VkSurfaceTransformFlagBitsKHR", AllVkSurfaceTransformFlagBitsKHR, pCreateInfos[swapchainIndex].preTransform, kRequiredSingleBit, "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter", "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter");

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].compositeAlpha", ParameterName::IndexVector{ swapchainIndex }), "VkCompositeAlphaFlagBitsKHR", AllVkCompositeAlphaFlagBitsKHR, pCreateInfos[swapchainIndex].compositeAlpha, kRequiredSingleBit, "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter", "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].presentMode", ParameterName::IndexVector{ swapchainIndex }), "VkPresentModeKHR", pCreateInfos[swapchainIndex].presentMode, "VUID-VkSwapchainCreateInfoKHR-presentMode-parameter");

            skip |= ValidateBool32(loc, ParameterName("pCreateInfos[%i].clipped", ParameterName::IndexVector{ swapchainIndex }), pCreateInfos[swapchainIndex].clipped);
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "swapchainCount", "pSwapchains", swapchainCount, &pSwapchains, true, true, "VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength", "VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_XLIB_KHR
bool StatelessValidation::PreCallValidateCreateXlibSurfaceKHR(
    VkInstance                                  instance,
    const VkXlibSurfaceCreateInfoKHR*           pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_xlib_surface) skip |= OutputExtensionError(loc, "VK_KHR_xlib_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, true, "VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter", "VUID-VkXlibSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateXlibSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XLIB_KHR
bool StatelessValidation::PreCallValidateGetPhysicalDeviceXlibPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    Display*                                    dpy,
    VisualID                                    visualID,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_xlib_surface) skip |= OutputExtensionError(loc, "VK_KHR_xlib_surface");
    skip |= ValidateRequiredPointer(loc, "dpy", dpy, "VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
bool StatelessValidation::PreCallValidateCreateXcbSurfaceKHR(
    VkInstance                                  instance,
    const VkXcbSurfaceCreateInfoKHR*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_xcb_surface) skip |= OutputExtensionError(loc, "VK_KHR_xcb_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, true, "VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter", "VUID-VkXcbSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateXcbSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
bool StatelessValidation::PreCallValidateGetPhysicalDeviceXcbPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    xcb_connection_t*                           connection,
    xcb_visualid_t                              visual_id,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_xcb_surface) skip |= OutputExtensionError(loc, "VK_KHR_xcb_surface");
    skip |= ValidateRequiredPointer(loc, "connection", connection, "VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
bool StatelessValidation::PreCallValidateCreateWaylandSurfaceKHR(
    VkInstance                                  instance,
    const VkWaylandSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_wayland_surface) skip |= OutputExtensionError(loc, "VK_KHR_wayland_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR, true, "VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter", "VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
bool StatelessValidation::PreCallValidateGetPhysicalDeviceWaylandPresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct wl_display*                          display,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_wayland_surface) skip |= OutputExtensionError(loc, "VK_KHR_wayland_surface");
    skip |= ValidateRequiredPointer(loc, "display", display, "VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool StatelessValidation::PreCallValidateCreateAndroidSurfaceKHR(
    VkInstance                                  instance,
    const VkAndroidSurfaceCreateInfoKHR*        pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_android_surface) skip |= OutputExtensionError(loc, "VK_KHR_android_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR, true, "VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter", "VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateCreateWin32SurfaceKHR(
    VkInstance                                  instance,
    const VkWin32SurfaceCreateInfoKHR*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_win32_surface) skip |= OutputExtensionError(loc, "VK_KHR_win32_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR, true, "VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter", "VUID-VkWin32SurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateWin32SurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetPhysicalDeviceWin32PresentationSupportKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_win32_surface) skip |= OutputExtensionError(loc, "VK_KHR_win32_surface");
    // No xml-driven validation
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateGetPhysicalDeviceVideoCapabilitiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkVideoProfileInfoKHR*                pVideoProfile,
    VkVideoCapabilitiesKHR*                     pCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pVideoProfile", "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR", pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true, "VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-parameter", "VUID-VkVideoProfileInfoKHR-sType-sType");
    if (pVideoProfile != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoProfileInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pVideoProfile->pNext", "VkVideoDecodeH264ProfileInfoKHR, VkVideoDecodeH265ProfileInfoKHR, VkVideoDecodeUsageInfoKHR, VkVideoEncodeH264ProfileInfoEXT, VkVideoEncodeH265ProfileInfoEXT, VkVideoEncodeUsageInfoKHR", pVideoProfile->pNext, allowed_structs_VkVideoProfileInfoKHR.size(), allowed_structs_VkVideoProfileInfoKHR.data(), GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, true, true);

        skip |= ValidateFlags(loc, "pVideoProfile->videoCodecOperation", "VkVideoCodecOperationFlagBitsKHR", AllVkVideoCodecOperationFlagBitsKHR, pVideoProfile->videoCodecOperation, kRequiredSingleBit, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

        skip |= ValidateFlags(loc, "pVideoProfile->chromaSubsampling", "VkVideoChromaSubsamplingFlagBitsKHR", AllVkVideoChromaSubsamplingFlagBitsKHR, pVideoProfile->chromaSubsampling, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter", "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

        skip |= ValidateFlags(loc, "pVideoProfile->lumaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, pVideoProfile->lumaBitDepth, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

        skip |= ValidateFlags(loc, "pVideoProfile->chromaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, pVideoProfile->chromaBitDepth, kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
    }
    skip |= ValidateStructType(loc, "pCapabilities", "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR", pCapabilities, VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR, true, "VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pCapabilities-parameter", "VUID-VkVideoCapabilitiesKHR-sType-sType");
    if (pCapabilities != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoCapabilitiesKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT };

        skip |= ValidateStructPnext(loc, "pCapabilities->pNext", "VkVideoDecodeCapabilitiesKHR, VkVideoDecodeH264CapabilitiesKHR, VkVideoDecodeH265CapabilitiesKHR, VkVideoEncodeCapabilitiesKHR, VkVideoEncodeH264CapabilitiesEXT, VkVideoEncodeH265CapabilitiesEXT", pCapabilities->pNext, allowed_structs_VkVideoCapabilitiesKHR.size(), allowed_structs_VkVideoCapabilitiesKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoCapabilitiesKHR-pNext-pNext", "VUID-VkVideoCapabilitiesKHR-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceVideoFormatPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceVideoFormatInfoKHR*   pVideoFormatInfo,
    uint32_t*                                   pVideoFormatPropertyCount,
    VkVideoFormatPropertiesKHR*                 pVideoFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pVideoFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR", pVideoFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR, true, "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatInfo-parameter", "VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-sType");
    if (pVideoFormatInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pVideoFormatInfo->pNext", "VkVideoProfileListInfoKHR", pVideoFormatInfo->pNext, allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR.size(), allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceVideoFormatInfoKHR-pNext-pNext", "VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-unique", true, true);

        skip |= ValidateFlags(loc, "pVideoFormatInfo->imageUsage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pVideoFormatInfo->imageUsage, kRequiredFlags, "VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-parameter", "VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-requiredbitmask");
    }
    skip |= ValidateStructTypeArray(loc, "pVideoFormatPropertyCount", "pVideoFormatProperties", "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR", pVideoFormatPropertyCount, pVideoFormatProperties, VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR, true, false, false, "VUID-VkVideoFormatPropertiesKHR-sType-sType", "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatProperties-parameter", kVUIDUndefined);
    if (pVideoFormatProperties != nullptr)
    {
        for (uint32_t pVideoFormatPropertyIndex = 0; pVideoFormatPropertyIndex < *pVideoFormatPropertyCount; ++pVideoFormatPropertyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pVideoFormatProperties[%i].pNext", ParameterName::IndexVector{ pVideoFormatPropertyIndex }), nullptr, pVideoFormatProperties[pVideoFormatPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoFormatPropertiesKHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateVideoSessionKHR(
    VkDevice                                    device,
    const VkVideoSessionCreateInfoKHR*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkVideoSessionKHR*                          pVideoSession,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR, true, "VUID-vkCreateVideoSessionKHR-pCreateInfo-parameter", "VUID-VkVideoSessionCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoSessionCreateInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkVideoEncodeH264SessionCreateInfoEXT, VkVideoEncodeH265SessionCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkVideoSessionCreateInfoKHR.size(), allowed_structs_VkVideoSessionCreateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionCreateInfoKHR-pNext-pNext", "VUID-VkVideoSessionCreateInfoKHR-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkVideoSessionCreateFlagBitsKHR", AllVkVideoSessionCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags, "VUID-VkVideoSessionCreateInfoKHR-flags-parameter");

        skip |= ValidateStructType(loc, "pCreateInfo->pVideoProfile", "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR", pCreateInfo->pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true, "VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-parameter", "VUID-VkVideoProfileInfoKHR-sType-sType");

        if (pCreateInfo->pVideoProfile != nullptr)
        {
            constexpr std::array allowed_structs_VkVideoProfileInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pCreateInfo->pVideoProfile->pNext", "VkVideoDecodeH264ProfileInfoKHR, VkVideoDecodeH265ProfileInfoKHR, VkVideoDecodeUsageInfoKHR, VkVideoEncodeH264ProfileInfoEXT, VkVideoEncodeH265ProfileInfoEXT, VkVideoEncodeUsageInfoKHR", pCreateInfo->pVideoProfile->pNext, allowed_structs_VkVideoProfileInfoKHR.size(), allowed_structs_VkVideoProfileInfoKHR.data(), GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

            skip |= ValidateFlags(loc, "pCreateInfo->pVideoProfile->videoCodecOperation", "VkVideoCodecOperationFlagBitsKHR", AllVkVideoCodecOperationFlagBitsKHR, pCreateInfo->pVideoProfile->videoCodecOperation, kRequiredSingleBit, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

            skip |= ValidateFlags(loc, "pCreateInfo->pVideoProfile->chromaSubsampling", "VkVideoChromaSubsamplingFlagBitsKHR", AllVkVideoChromaSubsamplingFlagBitsKHR, pCreateInfo->pVideoProfile->chromaSubsampling, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter", "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

            skip |= ValidateFlags(loc, "pCreateInfo->pVideoProfile->lumaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, pCreateInfo->pVideoProfile->lumaBitDepth, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

            skip |= ValidateFlags(loc, "pCreateInfo->pVideoProfile->chromaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, pCreateInfo->pVideoProfile->chromaBitDepth, kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
        }

        skip |= ValidateRangedEnum(loc, "pCreateInfo->pictureFormat", "VkFormat", pCreateInfo->pictureFormat, "VUID-VkVideoSessionCreateInfoKHR-pictureFormat-parameter");

        // No xml-driven validation

        skip |= ValidateRangedEnum(loc, "pCreateInfo->referencePictureFormat", "VkFormat", pCreateInfo->referencePictureFormat, "VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-parameter");

        skip |= ValidateRequiredPointer(loc, "pCreateInfo->pStdHeaderVersion", pCreateInfo->pStdHeaderVersion, "VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-parameter");

        if (pCreateInfo->pStdHeaderVersion != nullptr)
        {
            // No xml-driven validation
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pVideoSession", pVideoSession, "VUID-vkCreateVideoSessionKHR-pVideoSession-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyVideoSessionKHR(
    VkDevice                                    device,
    VkVideoSessionKHR                           videoSession,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetVideoSessionMemoryRequirementsKHR(
    VkDevice                                    device,
    VkVideoSessionKHR                           videoSession,
    uint32_t*                                   pMemoryRequirementsCount,
    VkVideoSessionMemoryRequirementsKHR*        pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateRequiredHandle(loc, "videoSession", videoSession);
    skip |= ValidateStructTypeArray(loc, "pMemoryRequirementsCount", "pMemoryRequirements", "VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR", pMemoryRequirementsCount, pMemoryRequirements, VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR, true, false, false, "VUID-VkVideoSessionMemoryRequirementsKHR-sType-sType", "VUID-vkGetVideoSessionMemoryRequirementsKHR-pMemoryRequirements-parameter", kVUIDUndefined);
    if (pMemoryRequirements != nullptr)
    {
        for (uint32_t pMemoryRequirementsIndex = 0; pMemoryRequirementsIndex < *pMemoryRequirementsCount; ++pMemoryRequirementsIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pMemoryRequirements[%i].pNext", ParameterName::IndexVector{ pMemoryRequirementsIndex }), nullptr, pMemoryRequirements[pMemoryRequirementsIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionMemoryRequirementsKHR-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindVideoSessionMemoryKHR(
    VkDevice                                    device,
    VkVideoSessionKHR                           videoSession,
    uint32_t                                    bindSessionMemoryInfoCount,
    const VkBindVideoSessionMemoryInfoKHR*      pBindSessionMemoryInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateRequiredHandle(loc, "videoSession", videoSession);
    skip |= ValidateStructTypeArray(loc, "bindSessionMemoryInfoCount", "pBindSessionMemoryInfos", "VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR", bindSessionMemoryInfoCount, pBindSessionMemoryInfos, VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR, true, true, "VUID-VkBindVideoSessionMemoryInfoKHR-sType-sType", "VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-parameter", "VUID-vkBindVideoSessionMemoryKHR-bindSessionMemoryInfoCount-arraylength");
    if (pBindSessionMemoryInfos != nullptr)
    {
        for (uint32_t bindSessionMemoryInfoIndex = 0; bindSessionMemoryInfoIndex < bindSessionMemoryInfoCount; ++bindSessionMemoryInfoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pBindSessionMemoryInfos[%i].pNext", ParameterName::IndexVector{ bindSessionMemoryInfoIndex }), nullptr, pBindSessionMemoryInfos[bindSessionMemoryInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBindVideoSessionMemoryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindSessionMemoryInfos[%i].memory", ParameterName::IndexVector{ bindSessionMemoryInfoIndex }), pBindSessionMemoryInfos[bindSessionMemoryInfoIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateVideoSessionParametersKHR(
    VkDevice                                    device,
    const VkVideoSessionParametersCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkVideoSessionParametersKHR*                pVideoSessionParameters,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR, true, "VUID-vkCreateVideoSessionParametersKHR-pCreateInfo-parameter", "VUID-VkVideoSessionParametersCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoSessionParametersCreateInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkVideoDecodeH264SessionParametersCreateInfoKHR, VkVideoDecodeH265SessionParametersCreateInfoKHR, VkVideoEncodeH264SessionParametersCreateInfoEXT, VkVideoEncodeH265SessionParametersCreateInfoEXT, VkVideoEncodeQualityLevelInfoKHR", pCreateInfo->pNext, allowed_structs_VkVideoSessionParametersCreateInfoKHR.size(), allowed_structs_VkVideoSessionParametersCreateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionParametersCreateInfoKHR-pNext-pNext", "VUID-VkVideoSessionParametersCreateInfoKHR-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkVideoSessionParametersCreateInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->videoSession", pCreateInfo->videoSession);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pVideoSessionParameters", pVideoSessionParameters, "VUID-vkCreateVideoSessionParametersKHR-pVideoSessionParameters-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateVideoSessionParametersKHR(
    VkDevice                                    device,
    VkVideoSessionParametersKHR                 videoSessionParameters,
    const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateRequiredHandle(loc, "videoSessionParameters", videoSessionParameters);
    skip |= ValidateStructType(loc, "pUpdateInfo", "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR", pUpdateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR, true, "VUID-vkUpdateVideoSessionParametersKHR-pUpdateInfo-parameter", "VUID-VkVideoSessionParametersUpdateInfoKHR-sType-sType");
    if (pUpdateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoSessionParametersUpdateInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pUpdateInfo->pNext", "VkVideoDecodeH264SessionParametersAddInfoKHR, VkVideoDecodeH265SessionParametersAddInfoKHR, VkVideoEncodeH264SessionParametersAddInfoEXT, VkVideoEncodeH265SessionParametersAddInfoEXT", pUpdateInfo->pNext, allowed_structs_VkVideoSessionParametersUpdateInfoKHR.size(), allowed_structs_VkVideoSessionParametersUpdateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionParametersUpdateInfoKHR-pNext-pNext", "VUID-VkVideoSessionParametersUpdateInfoKHR-sType-unique", false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyVideoSessionParametersKHR(
    VkDevice                                    device,
    VkVideoSessionParametersKHR                 videoSessionParameters,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginVideoCodingKHR(
    VkCommandBuffer                             commandBuffer,
    const VkVideoBeginCodingInfoKHR*            pBeginInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateStructType(loc, "pBeginInfo", "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR", pBeginInfo, VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR, true, "VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-parameter", "VUID-VkVideoBeginCodingInfoKHR-sType-sType");
    if (pBeginInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoBeginCodingInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pBeginInfo->pNext", "VkVideoEncodeH264GopRemainingFrameInfoEXT, VkVideoEncodeH264RateControlInfoEXT, VkVideoEncodeH265GopRemainingFrameInfoEXT, VkVideoEncodeH265RateControlInfoEXT, VkVideoEncodeRateControlInfoKHR", pBeginInfo->pNext, allowed_structs_VkVideoBeginCodingInfoKHR.size(), allowed_structs_VkVideoBeginCodingInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoBeginCodingInfoKHR-pNext-pNext", "VUID-VkVideoBeginCodingInfoKHR-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pBeginInfo->flags", pBeginInfo->flags, "VUID-VkVideoBeginCodingInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pBeginInfo->videoSession", pBeginInfo->videoSession);

        skip |= ValidateStructTypeArray(loc, "pBeginInfo->referenceSlotCount", "pBeginInfo->pReferenceSlots", "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR", pBeginInfo->referenceSlotCount, pBeginInfo->pReferenceSlots, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, true, "VUID-VkVideoReferenceSlotInfoKHR-sType-sType", "VUID-VkVideoBeginCodingInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pBeginInfo->pReferenceSlots != nullptr)
        {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pBeginInfo->referenceSlotCount; ++referenceSlotIndex)
            {
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pBeginInfo->pReferenceSlots[%i].pNext", ParameterName::IndexVector{ referenceSlotIndex }), "VkVideoDecodeH264DpbSlotInfoKHR, VkVideoDecodeH265DpbSlotInfoKHR, VkVideoEncodeH264DpbSlotInfoEXT, VkVideoEncodeH265DpbSlotInfoEXT", pBeginInfo->pReferenceSlots[referenceSlotIndex].pNext, allowed_structs_VkVideoReferenceSlotInfoKHR.size(), allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext", "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", false, true);

                skip |= ValidateStructType(loc, ParameterName("pBeginInfo->pReferenceSlots[%i].pPictureResource", ParameterName::IndexVector{ referenceSlotIndex }), "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource, VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pBeginInfo->pReferenceSlots[%i].pPictureResource->pNext", ParameterName::IndexVector{ referenceSlotIndex }), nullptr, pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |= ValidateRequiredHandle(loc, ParameterName("pBeginInfo->pReferenceSlots[%i].pPictureResource->imageViewBinding", ParameterName::IndexVector{ referenceSlotIndex }), pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndVideoCodingKHR(
    VkCommandBuffer                             commandBuffer,
    const VkVideoEndCodingInfoKHR*              pEndCodingInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateStructType(loc, "pEndCodingInfo", "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR", pEndCodingInfo, VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR, true, "VUID-vkCmdEndVideoCodingKHR-pEndCodingInfo-parameter", "VUID-VkVideoEndCodingInfoKHR-sType-sType");
    if (pEndCodingInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pEndCodingInfo->pNext", nullptr, pEndCodingInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoEndCodingInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pEndCodingInfo->flags", pEndCodingInfo->flags, "VUID-VkVideoEndCodingInfoKHR-flags-zerobitmask");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdControlVideoCodingKHR(
    VkCommandBuffer                             commandBuffer,
    const VkVideoCodingControlInfoKHR*          pCodingControlInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_queue");
    skip |= ValidateStructType(loc, "pCodingControlInfo", "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR", pCodingControlInfo, VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR, true, "VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-parameter", "VUID-VkVideoCodingControlInfoKHR-sType-sType");
    if (pCodingControlInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoCodingControlInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pCodingControlInfo->pNext", "VkVideoEncodeH264RateControlInfoEXT, VkVideoEncodeH265RateControlInfoEXT, VkVideoEncodeQualityLevelInfoKHR, VkVideoEncodeRateControlInfoKHR", pCodingControlInfo->pNext, allowed_structs_VkVideoCodingControlInfoKHR.size(), allowed_structs_VkVideoCodingControlInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoCodingControlInfoKHR-pNext-pNext", "VUID-VkVideoCodingControlInfoKHR-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCodingControlInfo->flags", "VkVideoCodingControlFlagBitsKHR", AllVkVideoCodingControlFlagBitsKHR, pCodingControlInfo->flags, kRequiredFlags, "VUID-VkVideoCodingControlInfoKHR-flags-parameter", "VUID-VkVideoCodingControlInfoKHR-flags-requiredbitmask");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDecodeVideoKHR(
    VkCommandBuffer                             commandBuffer,
    const VkVideoDecodeInfoKHR*                 pDecodeInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_decode_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_decode_queue");
    skip |= ValidateStructType(loc, "pDecodeInfo", "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR", pDecodeInfo, VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR, true, "VUID-vkCmdDecodeVideoKHR-pDecodeInfo-parameter", "VUID-VkVideoDecodeInfoKHR-sType-sType");
    if (pDecodeInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoDecodeInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pDecodeInfo->pNext", "VkVideoDecodeH264PictureInfoKHR, VkVideoDecodeH265PictureInfoKHR", pDecodeInfo->pNext, allowed_structs_VkVideoDecodeInfoKHR.size(), allowed_structs_VkVideoDecodeInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoDecodeInfoKHR-pNext-pNext", "VUID-VkVideoDecodeInfoKHR-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pDecodeInfo->flags", pDecodeInfo->flags, "VUID-VkVideoDecodeInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pDecodeInfo->srcBuffer", pDecodeInfo->srcBuffer);

        skip |= ValidateStructType(loc, "pDecodeInfo->dstPictureResource", "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", &(pDecodeInfo->dstPictureResource), VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, kVUIDUndefined, "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

        skip |= ValidateStructPnext(loc, "pDecodeInfo->dstPictureResource.pNext", nullptr, pDecodeInfo->dstPictureResource.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateRequiredHandle(loc, "pDecodeInfo->dstPictureResource.imageViewBinding", pDecodeInfo->dstPictureResource.imageViewBinding);

        skip |= ValidateStructType(loc, "pDecodeInfo->pSetupReferenceSlot", "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR", pDecodeInfo->pSetupReferenceSlot, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, "VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-parameter", "VUID-VkVideoReferenceSlotInfoKHR-sType-sType");

        if (pDecodeInfo->pSetupReferenceSlot != nullptr)
        {
            constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT };

            skip |= ValidateStructPnext(loc, "pDecodeInfo->pSetupReferenceSlot->pNext", "VkVideoDecodeH264DpbSlotInfoKHR, VkVideoDecodeH265DpbSlotInfoKHR, VkVideoEncodeH264DpbSlotInfoEXT, VkVideoEncodeH265DpbSlotInfoEXT", pDecodeInfo->pSetupReferenceSlot->pNext, allowed_structs_VkVideoReferenceSlotInfoKHR.size(), allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext", "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", false, true);

            skip |= ValidateStructType(loc, "pDecodeInfo->pSetupReferenceSlot->pPictureResource", "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", pDecodeInfo->pSetupReferenceSlot->pPictureResource, VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

            if (pDecodeInfo->pSetupReferenceSlot->pPictureResource != nullptr)
            {
                skip |= ValidateStructPnext(loc, "pDecodeInfo->pSetupReferenceSlot->pPictureResource->pNext", nullptr, pDecodeInfo->pSetupReferenceSlot->pPictureResource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

                // No xml-driven validation

                // No xml-driven validation

                skip |= ValidateRequiredHandle(loc, "pDecodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding", pDecodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding);
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDecodeInfo->referenceSlotCount", "pDecodeInfo->pReferenceSlots", "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR", pDecodeInfo->referenceSlotCount, pDecodeInfo->pReferenceSlots, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, true, "VUID-VkVideoReferenceSlotInfoKHR-sType-sType", "VUID-VkVideoDecodeInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pDecodeInfo->pReferenceSlots != nullptr)
        {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pDecodeInfo->referenceSlotCount; ++referenceSlotIndex)
            {
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDecodeInfo->pReferenceSlots[%i].pNext", ParameterName::IndexVector{ referenceSlotIndex }), "VkVideoDecodeH264DpbSlotInfoKHR, VkVideoDecodeH265DpbSlotInfoKHR, VkVideoEncodeH264DpbSlotInfoEXT, VkVideoEncodeH265DpbSlotInfoEXT", pDecodeInfo->pReferenceSlots[referenceSlotIndex].pNext, allowed_structs_VkVideoReferenceSlotInfoKHR.size(), allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext", "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", false, true);

                skip |= ValidateStructType(loc, ParameterName("pDecodeInfo->pReferenceSlots[%i].pPictureResource", ParameterName::IndexVector{ referenceSlotIndex }), "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource, VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pDecodeInfo->pReferenceSlots[%i].pPictureResource->pNext", ParameterName::IndexVector{ referenceSlotIndex }), nullptr, pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |= ValidateRequiredHandle(loc, ParameterName("pDecodeInfo->pReferenceSlots[%i].pPictureResource->imageViewBinding", ParameterName::IndexVector{ referenceSlotIndex }), pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderingKHR(
    VkCommandBuffer                             commandBuffer,
    const VkRenderingInfo*                      pRenderingInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) skip |= OutputExtensionError(loc, "VK_KHR_dynamic_rendering");
    skip |= ValidateStructType(loc, "pRenderingInfo", "VK_STRUCTURE_TYPE_RENDERING_INFO", pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true, "VUID-vkCmdBeginRendering-pRenderingInfo-parameter", "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderingInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT, VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pRenderingInfo->pNext", "VkDeviceGroupRenderPassBeginInfo, VkMultisampledRenderToSingleSampledInfoEXT, VkMultiviewPerViewAttributesInfoNVX, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, VkRenderingFragmentDensityMapAttachmentInfoEXT, VkRenderingFragmentShadingRateAttachmentInfoKHR", pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(), allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pRenderingInfo->flags", "VkRenderingFlagBits", AllVkRenderingFlagBits, pRenderingInfo->flags, kOptionalFlags, "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateStructTypeArray(loc, "pRenderingInfo->colorAttachmentCount", "pRenderingInfo->pColorAttachments", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->colorAttachmentCount, pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, true, "VUID-VkRenderingAttachmentInfo-sType-sType", "VUID-VkRenderingInfo-pColorAttachments-parameter", kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr)
        {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount; ++colorAttachmentIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].pNext", ParameterName::IndexVector{ colorAttachmentIndex }), nullptr, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].imageLayout", ParameterName::IndexVector{ colorAttachmentIndex }), "VkImageLayout", pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

                skip |= ValidateFlags(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].resolveMode", ParameterName::IndexVector{ colorAttachmentIndex }), "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].resolveImageLayout", ParameterName::IndexVector{ colorAttachmentIndex }), "VkImageLayout", pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].loadOp", ParameterName::IndexVector{ colorAttachmentIndex }), "VkAttachmentLoadOp", pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].storeOp", ParameterName::IndexVector{ colorAttachmentIndex }), "VkAttachmentStoreOp", pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

                // No xml-driven validation
            }
        }

        skip |= ValidateStructType(loc, "pRenderingInfo->pDepthAttachment", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->pDepthAttachment, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, "VUID-VkRenderingInfo-pDepthAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pRenderingInfo->pDepthAttachment->pNext", nullptr, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->imageLayout", "VkImageLayout", pRenderingInfo->pDepthAttachment->imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= ValidateFlags(loc, "pRenderingInfo->pDepthAttachment->resolveMode", "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->resolveImageLayout", "VkImageLayout", pRenderingInfo->pDepthAttachment->resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->loadOp", "VkAttachmentLoadOp", pRenderingInfo->pDepthAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->storeOp", "VkAttachmentStoreOp", pRenderingInfo->pDepthAttachment->storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }

        skip |= ValidateStructType(loc, "pRenderingInfo->pStencilAttachment", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->pStencilAttachment, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, "VUID-VkRenderingInfo-pStencilAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pRenderingInfo->pStencilAttachment->pNext", nullptr, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->imageLayout", "VkImageLayout", pRenderingInfo->pStencilAttachment->imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= ValidateFlags(loc, "pRenderingInfo->pStencilAttachment->resolveMode", "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->resolveImageLayout", "VkImageLayout", pRenderingInfo->pStencilAttachment->resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->loadOp", "VkAttachmentLoadOp", pRenderingInfo->pStencilAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->storeOp", "VkAttachmentStoreOp", pRenderingInfo->pStencilAttachment->storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderingKHR(commandBuffer, pRenderingInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderingKHR(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) skip |= OutputExtensionError(loc, "VK_KHR_dynamic_rendering");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFeatures2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceFeatures2*                  pFeatures,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateStructType(loc, "pFeatures", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2", pFeatures, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, true, "VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter", "VUID-VkPhysicalDeviceFeatures2-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceProperties2*                pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2", pProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter", "VUID-VkPhysicalDeviceProperties2-sType-sType");
    if (pProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceProperties2 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES };

        skip |= ValidateStructPnext(loc, "pProperties->pNext", "VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixPropertiesKHR, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV, VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, VkPhysicalDeviceDescriptorBufferPropertiesEXT, VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDisplacementMicromapPropertiesNV, VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDrmPropertiesEXT, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRatePropertiesKHR, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, VkPhysicalDeviceHostImageCopyPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceImageProcessing2PropertiesQCOM, VkPhysicalDeviceImageProcessingPropertiesQCOM, VkPhysicalDeviceInlineUniformBlockProperties, VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance4Properties, VkPhysicalDeviceMaintenance5PropertiesKHR, VkPhysicalDeviceMemoryDecompressionPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesEXT, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiDrawPropertiesEXT, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceOpacityMicromapPropertiesEXT, VkPhysicalDeviceOpticalFlowPropertiesNV, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePerformanceQueryPropertiesKHR, VkPhysicalDevicePipelineRobustnessPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePortabilitySubsetPropertiesKHR, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProvokingVertexPropertiesEXT, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRobustness2PropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesARM, VkPhysicalDeviceShaderEnqueuePropertiesAMDX, VkPhysicalDeviceShaderIntegerDotProductProperties, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, VkPhysicalDeviceShaderObjectPropertiesEXT, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShaderTileImagePropertiesEXT, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSubgroupSizeControlProperties, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, VkPhysicalDeviceTexelBufferAlignmentProperties, VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan12Properties, VkPhysicalDeviceVulkan13Properties", pProperties->pNext, allowed_structs_VkPhysicalDeviceProperties2.size(), allowed_structs_VkPhysicalDeviceProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceProperties2-pNext-pNext", "VUID-VkPhysicalDeviceProperties2-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkFormatProperties2*                        pFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateRangedEnum(loc, "format", "VkFormat", format, "VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter");
    skip |= ValidateStructType(loc, "pFormatProperties", "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2", pFormatProperties, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter", "VUID-VkFormatProperties2-sType-sType");
    if (pFormatProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkFormatProperties2 = { VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT };

        skip |= ValidateStructPnext(loc, "pFormatProperties->pNext", "VkDrmFormatModifierPropertiesList2EXT, VkDrmFormatModifierPropertiesListEXT, VkFormatProperties3, VkSubpassResolvePerformanceQueryEXT", pFormatProperties->pNext, allowed_structs_VkFormatProperties2.size(), allowed_structs_VkFormatProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkFormatProperties2-pNext-pNext", "VUID-VkFormatProperties2-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceImageFormatInfo2*     pImageFormatInfo,
    VkImageFormatProperties2*                   pImageFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateStructType(loc, "pImageFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2", pImageFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2, true, "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter", "VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType");
    if (pImageFormatInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceImageFormatInfo2 = { VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pImageFormatInfo->pNext", "VkImageCompressionControlEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkOpticalFlowImageFormatInfoNV, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkPhysicalDeviceImageViewImageFormatInfoEXT, VkVideoProfileListInfoKHR", pImageFormatInfo->pNext, allowed_structs_VkPhysicalDeviceImageFormatInfo2.size(), allowed_structs_VkPhysicalDeviceImageFormatInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext", "VUID-VkPhysicalDeviceImageFormatInfo2-sType-unique", true, true);

        skip |= ValidateRangedEnum(loc, "pImageFormatInfo->format", "VkFormat", pImageFormatInfo->format, "VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter");

        skip |= ValidateRangedEnum(loc, "pImageFormatInfo->type", "VkImageType", pImageFormatInfo->type, "VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter");

        skip |= ValidateRangedEnum(loc, "pImageFormatInfo->tiling", "VkImageTiling", pImageFormatInfo->tiling, "VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter");

        skip |= ValidateFlags(loc, "pImageFormatInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pImageFormatInfo->usage, kRequiredFlags, "VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter", "VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask");

        skip |= ValidateFlags(loc, "pImageFormatInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pImageFormatInfo->flags, kOptionalFlags, "VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter");
    }
    skip |= ValidateStructType(loc, "pImageFormatProperties", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2", pImageFormatProperties, VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter", "VUID-VkImageFormatProperties2-sType-sType");
    if (pImageFormatProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkImageFormatProperties2 = { VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES, VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD };

        skip |= ValidateStructPnext(loc, "pImageFormatProperties->pNext", "VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkFilterCubicImageViewImageFormatPropertiesEXT, VkHostImageCopyDevicePerformanceQueryEXT, VkImageCompressionPropertiesEXT, VkSamplerYcbcrConversionImageFormatProperties, VkTextureLODGatherFormatPropertiesAMD", pImageFormatProperties->pNext, allowed_structs_VkImageFormatProperties2.size(), allowed_structs_VkImageFormatProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageFormatProperties2-pNext-pNext", "VUID-VkImageFormatProperties2-sType-unique", true, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2*                   pQueueFamilyProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateStructTypeArray(loc, "pQueueFamilyPropertyCount", "pQueueFamilyProperties", "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2", pQueueFamilyPropertyCount, pQueueFamilyProperties, VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, true, false, false, "VUID-VkQueueFamilyProperties2-sType-sType", "VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter", kVUIDUndefined);
    if (pQueueFamilyProperties != nullptr)
    {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount; ++pQueueFamilyPropertyIndex)
        {
            constexpr std::array allowed_structs_VkQueueFamilyProperties2 = { VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV, VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR, VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR, VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR };

            skip |= ValidateStructPnext(loc, ParameterName("pQueueFamilyProperties[%i].pNext", ParameterName::IndexVector{ pQueueFamilyPropertyIndex }), "VkQueueFamilyCheckpointProperties2NV, VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyGlobalPriorityPropertiesKHR, VkQueueFamilyQueryResultStatusPropertiesKHR, VkQueueFamilyVideoPropertiesKHR", pQueueFamilyProperties[pQueueFamilyPropertyIndex].pNext, allowed_structs_VkQueueFamilyProperties2.size(), allowed_structs_VkQueueFamilyProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkQueueFamilyProperties2-pNext-pNext", "VUID-VkQueueFamilyProperties2-sType-unique", true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMemoryProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties2*          pMemoryProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateStructType(loc, "pMemoryProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2", pMemoryProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, true, "VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter", "VUID-VkPhysicalDeviceMemoryProperties2-sType-sType");
    if (pMemoryProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceMemoryProperties2 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT };

        skip |= ValidateStructPnext(loc, "pMemoryProperties->pNext", "VkPhysicalDeviceMemoryBudgetPropertiesEXT", pMemoryProperties->pNext, allowed_structs_VkPhysicalDeviceMemoryProperties2.size(), allowed_structs_VkPhysicalDeviceMemoryProperties2.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext", "VUID-VkPhysicalDeviceMemoryProperties2-sType-unique", true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
    uint32_t*                                   pPropertyCount,
    VkSparseImageFormatProperties2*             pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_physical_device_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_physical_device_properties2");
    skip |= ValidateStructType(loc, "pFormatInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2", pFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2, true, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter", "VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType");
    if (pFormatInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pFormatInfo->pNext", nullptr, pFormatInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateRangedEnum(loc, "pFormatInfo->format", "VkFormat", pFormatInfo->format, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter");

        skip |= ValidateRangedEnum(loc, "pFormatInfo->type", "VkImageType", pFormatInfo->type, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter");

        skip |= ValidateFlags(loc, "pFormatInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pFormatInfo->samples, kRequiredSingleBit, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter", "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter");

        skip |= ValidateFlags(loc, "pFormatInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pFormatInfo->usage, kRequiredFlags, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter", "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask");

        skip |= ValidateRangedEnum(loc, "pFormatInfo->tiling", "VkImageTiling", pFormatInfo->tiling, "VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter");
    }
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, true, false, false, "VUID-VkSparseImageFormatProperties2-sType-sType", "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pProperties-parameter", kVUIDUndefined);
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pProperties[%i].pNext", ParameterName::IndexVector{ pPropertyIndex }), nullptr, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageFormatProperties2-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupPeerMemoryFeaturesKHR(
    VkDevice                                    device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    VkPeerMemoryFeatureFlags*                   pPeerMemoryFeatures,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_device_group)) skip |= OutputExtensionError(loc, "VK_KHR_device_group");
    skip |= ValidateRequiredPointer(loc, "pPeerMemoryFeatures", pPeerMemoryFeatures, "VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDeviceMaskKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    deviceMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_device_group)) skip |= OutputExtensionError(loc, "VK_KHR_device_group");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchBaseKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_device_group)) skip |= OutputExtensionError(loc, "VK_KHR_device_group");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateTrimCommandPoolKHR(
    VkDevice                                    device,
    VkCommandPool                               commandPool,
    VkCommandPoolTrimFlags                      flags,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance1)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance1");
    skip |= ValidateRequiredHandle(loc, "commandPool", commandPool);
    skip |= ValidateReservedFlags(loc, "flags", flags, "VUID-vkTrimCommandPool-flags-zerobitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDeviceGroupsKHR(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties*            pPhysicalDeviceGroupProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_device_group_creation) skip |= OutputExtensionError(loc, "VK_KHR_device_group_creation");
    skip |= ValidateStructTypeArray(loc, "pPhysicalDeviceGroupCount", "pPhysicalDeviceGroupProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES", pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, true, false, false, "VUID-VkPhysicalDeviceGroupProperties-sType-sType", "VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter", kVUIDUndefined);
    if (pPhysicalDeviceGroupProperties != nullptr)
    {
        for (uint32_t pPhysicalDeviceGroupIndex = 0; pPhysicalDeviceGroupIndex < *pPhysicalDeviceGroupCount; ++pPhysicalDeviceGroupIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pPhysicalDeviceGroupProperties[%i].pNext", ParameterName::IndexVector{ pPhysicalDeviceGroupIndex }), nullptr, pPhysicalDeviceGroupProperties[pPhysicalDeviceGroupIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceGroupProperties-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalBufferInfo*   pExternalBufferInfo,
    VkExternalBufferProperties*                 pExternalBufferProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_external_memory_capabilities) skip |= OutputExtensionError(loc, "VK_KHR_external_memory_capabilities");
    skip |= ValidateStructType(loc, "pExternalBufferInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO", pExternalBufferInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO, true, "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter", "VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType");
    if (pExternalBufferInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalBufferInfo = { VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pExternalBufferInfo->pNext", "VkBufferUsageFlags2CreateInfoKHR", pExternalBufferInfo->pNext, allowed_structs_VkPhysicalDeviceExternalBufferInfo.size(), allowed_structs_VkPhysicalDeviceExternalBufferInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext", "VUID-VkPhysicalDeviceExternalBufferInfo-sType-unique", true, true);

        skip |= ValidateFlags(loc, "pExternalBufferInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pExternalBufferInfo->flags, kOptionalFlags, "VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter");

        skip |= ValidateFlags(loc, "pExternalBufferInfo->usage", "VkBufferUsageFlagBits", AllVkBufferUsageFlagBits, pExternalBufferInfo->usage, kRequiredFlags, "VUID-VkPhysicalDeviceExternalBufferInfo-usage-parameter", "VUID-VkPhysicalDeviceExternalBufferInfo-usage-requiredbitmask");

        skip |= ValidateFlags(loc, "pExternalBufferInfo->handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, pExternalBufferInfo->handleType, kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter", "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc, "pExternalBufferProperties", "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES", pExternalBufferProperties, VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, true, "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter", "VUID-VkExternalBufferProperties-sType-sType");
    if (pExternalBufferProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalBufferProperties->pNext", nullptr, pExternalBufferProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkExternalBufferProperties-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetMemoryWin32HandleKHR(
    VkDevice                                    device,
    const VkMemoryGetWin32HandleInfoKHR*        pGetWin32HandleInfo,
    HANDLE*                                     pHandle,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_win32)) skip |= OutputExtensionError(loc, "VK_KHR_external_memory_win32");
    skip |= ValidateStructType(loc, "pGetWin32HandleInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR", pGetWin32HandleInfo, VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR, true, "VUID-vkGetMemoryWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkMemoryGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetWin32HandleInfo->pNext", nullptr, pGetWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetWin32HandleInfo->memory", pGetWin32HandleInfo->memory);

        skip |= ValidateFlags(loc, "pGetWin32HandleInfo->handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit, "VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter", "VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pHandle", pHandle, "VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetMemoryWin32HandlePropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    HANDLE                                      handle,
    VkMemoryWin32HandlePropertiesKHR*           pMemoryWin32HandleProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_win32)) skip |= OutputExtensionError(loc, "VK_KHR_external_memory_win32");
    skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, "VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter", "VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter");
    skip |= ValidateStructType(loc, "pMemoryWin32HandleProperties", "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR", pMemoryWin32HandleProperties, VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR, true, "VUID-vkGetMemoryWin32HandlePropertiesKHR-pMemoryWin32HandleProperties-parameter", "VUID-VkMemoryWin32HandlePropertiesKHR-sType-sType");
    if (pMemoryWin32HandleProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryWin32HandleProperties->pNext", nullptr, pMemoryWin32HandleProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryWin32HandlePropertiesKHR-pNext-pNext", kVUIDUndefined, false, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateGetMemoryFdKHR(
    VkDevice                                    device,
    const VkMemoryGetFdInfoKHR*                 pGetFdInfo,
    int*                                        pFd,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_fd)) skip |= OutputExtensionError(loc, "VK_KHR_external_memory_fd");
    skip |= ValidateStructType(loc, "pGetFdInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR", pGetFdInfo, VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, true, "VUID-vkGetMemoryFdKHR-pGetFdInfo-parameter", "VUID-VkMemoryGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetFdInfo->pNext", nullptr, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetFdInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetFdInfo->memory", pGetFdInfo->memory);

        skip |= ValidateFlags(loc, "pGetFdInfo->handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit, "VUID-VkMemoryGetFdInfoKHR-handleType-parameter", "VUID-VkMemoryGetFdInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pFd", pFd, "VUID-vkGetMemoryFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetMemoryFdKHR(device, pGetFdInfo, pFd, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryFdPropertiesKHR(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd,
    VkMemoryFdPropertiesKHR*                    pMemoryFdProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_fd)) skip |= OutputExtensionError(loc, "VK_KHR_external_memory_fd");
    skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, "VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter", "VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter");
    skip |= ValidateStructType(loc, "pMemoryFdProperties", "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR", pMemoryFdProperties, VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR, true, "VUID-vkGetMemoryFdPropertiesKHR-pMemoryFdProperties-parameter", "VUID-VkMemoryFdPropertiesKHR-sType-sType");
    if (pMemoryFdProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryFdProperties->pNext", nullptr, pMemoryFdProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryFdPropertiesKHR-pNext-pNext", kVUIDUndefined, false, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties*              pExternalSemaphoreProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_external_semaphore_capabilities) skip |= OutputExtensionError(loc, "VK_KHR_external_semaphore_capabilities");
    skip |= ValidateStructType(loc, "pExternalSemaphoreInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO", pExternalSemaphoreInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, true, "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter", "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType");
    if (pExternalSemaphoreInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo = { VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO };

        skip |= ValidateStructPnext(loc, "pExternalSemaphoreInfo->pNext", "VkSemaphoreTypeCreateInfo", pExternalSemaphoreInfo->pNext, allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.size(), allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext", "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-unique", true, true);

        skip |= ValidateFlags(loc, "pExternalSemaphoreInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pExternalSemaphoreInfo->handleType, kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter", "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc, "pExternalSemaphoreProperties", "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES", pExternalSemaphoreProperties, VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, true, "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter", "VUID-VkExternalSemaphoreProperties-sType-sType");
    if (pExternalSemaphoreProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalSemaphoreProperties->pNext", nullptr, pExternalSemaphoreProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkExternalSemaphoreProperties-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateImportSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkImportSemaphoreWin32HandleInfoKHR*  pImportSemaphoreWin32HandleInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_win32)) skip |= OutputExtensionError(loc, "VK_KHR_external_semaphore_win32");
    skip |= ValidateStructType(loc, "pImportSemaphoreWin32HandleInfo", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR", pImportSemaphoreWin32HandleInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, true, "VUID-vkImportSemaphoreWin32HandleKHR-pImportSemaphoreWin32HandleInfo-parameter", "VUID-VkImportSemaphoreWin32HandleInfoKHR-sType-sType");
    if (pImportSemaphoreWin32HandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pImportSemaphoreWin32HandleInfo->pNext", nullptr, pImportSemaphoreWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pImportSemaphoreWin32HandleInfo->semaphore", pImportSemaphoreWin32HandleInfo->semaphore);

        skip |= ValidateFlags(loc, "pImportSemaphoreWin32HandleInfo->flags", "VkSemaphoreImportFlagBits", AllVkSemaphoreImportFlagBits, pImportSemaphoreWin32HandleInfo->flags, kOptionalFlags, "VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetSemaphoreWin32HandleKHR(
    VkDevice                                    device,
    const VkSemaphoreGetWin32HandleInfoKHR*     pGetWin32HandleInfo,
    HANDLE*                                     pHandle,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_win32)) skip |= OutputExtensionError(loc, "VK_KHR_external_semaphore_win32");
    skip |= ValidateStructType(loc, "pGetWin32HandleInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR", pGetWin32HandleInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR, true, "VUID-vkGetSemaphoreWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkSemaphoreGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetWin32HandleInfo->pNext", nullptr, pGetWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreGetWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetWin32HandleInfo->semaphore", pGetWin32HandleInfo->semaphore);

        skip |= ValidateFlags(loc, "pGetWin32HandleInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit, "VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter", "VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pHandle", pHandle, "VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateImportSemaphoreFdKHR(
    VkDevice                                    device,
    const VkImportSemaphoreFdInfoKHR*           pImportSemaphoreFdInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_fd)) skip |= OutputExtensionError(loc, "VK_KHR_external_semaphore_fd");
    skip |= ValidateStructType(loc, "pImportSemaphoreFdInfo", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR", pImportSemaphoreFdInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR, true, "VUID-vkImportSemaphoreFdKHR-pImportSemaphoreFdInfo-parameter", "VUID-VkImportSemaphoreFdInfoKHR-sType-sType");
    if (pImportSemaphoreFdInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pImportSemaphoreFdInfo->pNext", nullptr, pImportSemaphoreFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreFdInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pImportSemaphoreFdInfo->semaphore", pImportSemaphoreFdInfo->semaphore);

        skip |= ValidateFlags(loc, "pImportSemaphoreFdInfo->flags", "VkSemaphoreImportFlagBits", AllVkSemaphoreImportFlagBits, pImportSemaphoreFdInfo->flags, kOptionalFlags, "VUID-VkImportSemaphoreFdInfoKHR-flags-parameter");

        skip |= ValidateFlags(loc, "pImportSemaphoreFdInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pImportSemaphoreFdInfo->handleType, kRequiredSingleBit, "VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter", "VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreFdKHR(
    VkDevice                                    device,
    const VkSemaphoreGetFdInfoKHR*              pGetFdInfo,
    int*                                        pFd,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_fd)) skip |= OutputExtensionError(loc, "VK_KHR_external_semaphore_fd");
    skip |= ValidateStructType(loc, "pGetFdInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR", pGetFdInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, true, "VUID-vkGetSemaphoreFdKHR-pGetFdInfo-parameter", "VUID-VkSemaphoreGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetFdInfo->pNext", nullptr, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreGetFdInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetFdInfo->semaphore", pGetFdInfo->semaphore);

        skip |= ValidateFlags(loc, "pGetFdInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit, "VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter", "VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pFd", pFd, "VUID-vkGetSemaphoreFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetSemaphoreFdKHR(device, pGetFdInfo, pFd, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushDescriptorSetKHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    const VkWriteDescriptorSet*                 pDescriptorWrites,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_push_descriptor)) skip |= OutputExtensionError(loc, "VK_KHR_push_descriptor");
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    skip |= ValidateStructTypeArray(loc, "descriptorWriteCount", "pDescriptorWrites", "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", descriptorWriteCount, pDescriptorWrites, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, true, true, "VUID-VkWriteDescriptorSet-sType-sType", "VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter", "VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength");
    if (pDescriptorWrites != nullptr)
    {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex)
        {
            constexpr std::array allowed_structs_VkWriteDescriptorSet = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK };

            skip |= ValidateStructPnext(loc, ParameterName("pDescriptorWrites[%i].pNext", ParameterName::IndexVector{ descriptorWriteIndex }), "VkWriteDescriptorSetAccelerationStructureKHR, VkWriteDescriptorSetAccelerationStructureNV, VkWriteDescriptorSetInlineUniformBlock", pDescriptorWrites[descriptorWriteIndex].pNext, allowed_structs_VkWriteDescriptorSet.size(), allowed_structs_VkWriteDescriptorSet.data(), GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext", "VUID-VkWriteDescriptorSet-sType-unique", false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pDescriptorWrites[%i].descriptorType", ParameterName::IndexVector{ descriptorWriteIndex }), "VkDescriptorType", pDescriptorWrites[descriptorWriteIndex].descriptorType, "VUID-VkWriteDescriptorSet-descriptorType-parameter");

            skip |= ValidateArray(loc, ParameterName("pDescriptorWrites[%i].descriptorCount", ParameterName::IndexVector{ descriptorWriteIndex }), "", pDescriptorWrites[descriptorWriteIndex].descriptorCount, &pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false, "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer                             commandBuffer,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    const void*                                 pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_push_descriptor) || IsExtEnabled(device_extensions.vk_khr_descriptor_update_template))) skip |= OutputExtensionError(loc, "VK_KHR_push_descriptor || VK_KHR_descriptor_update_template");
    skip |= ValidateRequiredHandle(loc, "descriptorUpdateTemplate", descriptorUpdateTemplate);
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_descriptor_update_template)) skip |= OutputExtensionError(loc, "VK_KHR_descriptor_update_template");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO, true, "VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter", "VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(loc, "pCreateInfo->descriptorUpdateEntryCount", "pCreateInfo->pDescriptorUpdateEntries", pCreateInfo->descriptorUpdateEntryCount, &pCreateInfo->pDescriptorUpdateEntries, true, true, "VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength", "VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter");

        if (pCreateInfo->pDescriptorUpdateEntries != nullptr)
        {
            for (uint32_t descriptorUpdateEntryIndex = 0; descriptorUpdateEntryIndex < pCreateInfo->descriptorUpdateEntryCount; ++descriptorUpdateEntryIndex)
            {
                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pDescriptorUpdateEntries[%i].descriptorType", ParameterName::IndexVector{ descriptorUpdateEntryIndex }), "VkDescriptorType", pCreateInfo->pDescriptorUpdateEntries[descriptorUpdateEntryIndex].descriptorType, "VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter");
            }
        }

        skip |= ValidateRangedEnum(loc, "pCreateInfo->templateType", "VkDescriptorUpdateTemplateType", pCreateInfo->templateType, "VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pDescriptorUpdateTemplate", pDescriptorUpdateTemplate, "VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorUpdateTemplateKHR(
    VkDevice                                    device,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_descriptor_update_template)) skip |= OutputExtensionError(loc, "VK_KHR_descriptor_update_template");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateDescriptorSetWithTemplateKHR(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
    const void*                                 pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_descriptor_update_template)) skip |= OutputExtensionError(loc, "VK_KHR_descriptor_update_template");
    skip |= ValidateRequiredHandle(loc, "descriptorSet", descriptorSet);
    skip |= ValidateRequiredHandle(loc, "descriptorUpdateTemplate", descriptorUpdateTemplate);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRenderPass2KHR(
    VkDevice                                    device,
    const VkRenderPassCreateInfo2*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkRenderPass*                               pRenderPass,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2)) skip |= OutputExtensionError(loc, "VK_KHR_create_renderpass2");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2", pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, true, "VUID-vkCreateRenderPass2-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo2-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderPassCreateInfo2 = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkRenderPassCreationControlEXT, VkRenderPassCreationFeedbackCreateInfoEXT, VkRenderPassFragmentDensityMapCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo2.size(), allowed_structs_VkRenderPassCreateInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderPassCreateInfo2-pNext-pNext", "VUID-VkRenderPassCreateInfo2-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkRenderPassCreateFlagBits", AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkRenderPassCreateInfo2-flags-parameter");

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->attachmentCount", "pCreateInfo->pAttachments", "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2", pCreateInfo->attachmentCount, pCreateInfo->pAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, false, true, "VUID-VkAttachmentDescription2-sType-sType", "VUID-VkRenderPassCreateInfo2-pAttachments-parameter", kVUIDUndefined);

        if (pCreateInfo->pAttachments != nullptr)
        {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex)
            {
                constexpr std::array allowed_structs_VkAttachmentDescription2 = { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pAttachments[%i].pNext", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentDescriptionStencilLayout", pCreateInfo->pAttachments[attachmentIndex].pNext, allowed_structs_VkAttachmentDescription2.size(), allowed_structs_VkAttachmentDescription2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentDescription2-pNext-pNext", "VUID-VkAttachmentDescription2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pAttachments[%i].flags", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentDescriptionFlagBits", AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags, kOptionalFlags, "VUID-VkAttachmentDescription2-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].format", ParameterName::IndexVector{ attachmentIndex }), "VkFormat", pCreateInfo->pAttachments[attachmentIndex].format, "VUID-VkAttachmentDescription2-format-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pAttachments[%i].samples", ParameterName::IndexVector{ attachmentIndex }), "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples, kRequiredSingleBit, "VUID-VkAttachmentDescription2-samples-parameter", "VUID-VkAttachmentDescription2-samples-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].loadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", pCreateInfo->pAttachments[attachmentIndex].loadOp, "VUID-VkAttachmentDescription2-loadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].storeOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", pCreateInfo->pAttachments[attachmentIndex].storeOp, "VUID-VkAttachmentDescription2-storeOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].stencilLoadOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentLoadOp", pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp, "VUID-VkAttachmentDescription2-stencilLoadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].stencilStoreOp", ParameterName::IndexVector{ attachmentIndex }), "VkAttachmentStoreOp", pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp, "VUID-VkAttachmentDescription2-stencilStoreOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].initialLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", pCreateInfo->pAttachments[attachmentIndex].initialLayout, "VUID-VkAttachmentDescription2-initialLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pAttachments[%i].finalLayout", ParameterName::IndexVector{ attachmentIndex }), "VkImageLayout", pCreateInfo->pAttachments[attachmentIndex].finalLayout, "VUID-VkAttachmentDescription2-finalLayout-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->subpassCount", "pCreateInfo->pSubpasses", "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2", pCreateInfo->subpassCount, pCreateInfo->pSubpasses, VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, true, true, "VUID-VkSubpassDescription2-sType-sType", "VUID-VkRenderPassCreateInfo2-pSubpasses-parameter", "VUID-VkRenderPassCreateInfo2-subpassCount-arraylength");

        if (pCreateInfo->pSubpasses != nullptr)
        {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex)
            {
                constexpr std::array allowed_structs_VkSubpassDescription2 = { VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pNext", ParameterName::IndexVector{ subpassIndex }), "VkFragmentShadingRateAttachmentInfoKHR, VkMultisampledRenderToSingleSampledInfoEXT, VkRenderPassCreationControlEXT, VkRenderPassSubpassFeedbackCreateInfoEXT, VkSubpassDescriptionDepthStencilResolve", pCreateInfo->pSubpasses[subpassIndex].pNext, allowed_structs_VkSubpassDescription2.size(), allowed_structs_VkSubpassDescription2.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassDescription2-pNext-pNext", "VUID-VkSubpassDescription2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pSubpasses[%i].flags", ParameterName::IndexVector{ subpassIndex }), "VkSubpassDescriptionFlagBits", AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags, kOptionalFlags, "VUID-VkSubpassDescription2-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pipelineBindPoint", ParameterName::IndexVector{ subpassIndex }), "VkPipelineBindPoint", pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint, "VUID-VkSubpassDescription2-pipelineBindPoint-parameter");

                skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].inputAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pInputAttachments-parameter", kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr)
                {
                    for (uint32_t inputAttachmentIndex = 0; inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount; ++inputAttachmentIndex)
                    {
                        constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                        skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments[%i].pNext", ParameterName::IndexVector{ subpassIndex, inputAttachmentIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pInputAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, inputAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout, "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].colorAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pColorAttachments-parameter", kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                        skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments[%i].pNext", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pColorAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout, "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].colorAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount, pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, false, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pResolveAttachments-parameter", kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr)
                {
                    for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount; ++colorAttachmentIndex)
                    {
                        constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                        skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments[%i].pNext", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                        skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pResolveAttachments[%i].layout", ParameterName::IndexVector{ subpassIndex, colorAttachmentIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout, "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= ValidateStructType(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment", ParameterName::IndexVector{ subpassIndex }), "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, "VUID-VkSubpassDescription2-pDepthStencilAttachment-parameter", "VUID-VkAttachmentReference2-sType-sType");

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr)
                {
                    constexpr std::array allowed_structs_VkAttachmentReference2 = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT };

                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment->pNext", ParameterName::IndexVector{ subpassIndex }), "VkAttachmentReferenceStencilLayout", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->pNext, allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(), GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext", "VUID-VkAttachmentReference2-sType-unique", false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pSubpasses[%i].pDepthStencilAttachment->layout", ParameterName::IndexVector{ subpassIndex }), "VkImageLayout", pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout, "VUID-VkAttachmentReference2-layout-parameter");
                }

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pSubpasses[%i].preserveAttachmentCount", ParameterName::IndexVector{ subpassIndex }), ParameterName("pCreateInfo->pSubpasses[%i].pPreserveAttachments", ParameterName::IndexVector{ subpassIndex }), pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount, &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true, kVUIDUndefined, "VUID-VkSubpassDescription2-pPreserveAttachments-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->dependencyCount", "pCreateInfo->pDependencies", "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2", pCreateInfo->dependencyCount, pCreateInfo->pDependencies, VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, false, true, "VUID-VkSubpassDependency2-sType-sType", "VUID-VkRenderPassCreateInfo2-pDependencies-parameter", kVUIDUndefined);

        if (pCreateInfo->pDependencies != nullptr)
        {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex)
            {
                constexpr std::array allowed_structs_VkSubpassDependency2 = { VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 };

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pDependencies[%i].pNext", ParameterName::IndexVector{ dependencyIndex }), "VkMemoryBarrier2", pCreateInfo->pDependencies[dependencyIndex].pNext, allowed_structs_VkSubpassDependency2.size(), allowed_structs_VkSubpassDependency2.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassDependency2-pNext-pNext", "VUID-VkSubpassDependency2-sType-unique", false, true);

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].srcStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask, kOptionalFlags, "VUID-VkSubpassDependency2-srcStageMask-parameter");
                }

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dstStageMask", ParameterName::IndexVector{ dependencyIndex }), "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask, kOptionalFlags, "VUID-VkSubpassDependency2-dstStageMask-parameter");
                }

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].srcAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask, kOptionalFlags, "VUID-VkSubpassDependency2-srcAccessMask-parameter");
                }

                if (!LvlFindInChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext))
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dstAccessMask", ParameterName::IndexVector{ dependencyIndex }), "VkAccessFlagBits", AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask, kOptionalFlags, "VUID-VkSubpassDependency2-dstAccessMask-parameter");
                }

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pDependencies[%i].dependencyFlags", ParameterName::IndexVector{ dependencyIndex }), "VkDependencyFlagBits", AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags, kOptionalFlags, "VUID-VkSubpassDependency2-dependencyFlags-parameter");
            }
        }

        skip |= ValidateArray(loc, "pCreateInfo->correlatedViewMaskCount", "pCreateInfo->pCorrelatedViewMasks", pCreateInfo->correlatedViewMaskCount, &pCreateInfo->pCorrelatedViewMasks, false, true, kVUIDUndefined, "VUID-VkRenderPassCreateInfo2-pCorrelatedViewMasks-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pRenderPass", pRenderPass, "VUID-vkCreateRenderPass2-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderPass2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkRenderPassBeginInfo*                pRenderPassBegin,
    const VkSubpassBeginInfo*                   pSubpassBeginInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2)) skip |= OutputExtensionError(loc, "VK_KHR_create_renderpass2");
    skip |= ValidateStructType(loc, "pRenderPassBegin", "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, true, "VUID-vkCmdBeginRenderPass2-pRenderPassBegin-parameter", "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO, VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pRenderPassBegin->pNext", "VkDeviceGroupRenderPassBeginInfo, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, VkRenderPassAttachmentBeginInfo, VkRenderPassSampleLocationsBeginInfoEXT, VkRenderPassTransformBeginInfoQCOM", pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(), allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pRenderPassBegin->renderPass", pRenderPassBegin->renderPass);

        skip |= ValidateRequiredHandle(loc, "pRenderPassBegin->framebuffer", pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |= ValidateStructType(loc, "pSubpassBeginInfo", "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true, "VUID-vkCmdBeginRenderPass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSubpassBeginInfo->pNext", nullptr, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pSubpassBeginInfo->contents", "VkSubpassContents", pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdNextSubpass2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassBeginInfo*                   pSubpassBeginInfo,
    const VkSubpassEndInfo*                     pSubpassEndInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2)) skip |= OutputExtensionError(loc, "VK_KHR_create_renderpass2");
    skip |= ValidateStructType(loc, "pSubpassBeginInfo", "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true, "VUID-vkCmdNextSubpass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSubpassBeginInfo->pNext", nullptr, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pSubpassBeginInfo->contents", "VkSubpassContents", pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter");
    }
    skip |= ValidateStructType(loc, "pSubpassEndInfo", "VK_STRUCTURE_TYPE_SUBPASS_END_INFO", pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true, "VUID-vkCmdNextSubpass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSubpassEndInfo = { VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pSubpassEndInfo->pNext", "VkSubpassFragmentDensityMapOffsetEndInfoQCOM", pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(), allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderPass2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkSubpassEndInfo*                     pSubpassEndInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2)) skip |= OutputExtensionError(loc, "VK_KHR_create_renderpass2");
    skip |= ValidateStructType(loc, "pSubpassEndInfo", "VK_STRUCTURE_TYPE_SUBPASS_END_INFO", pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true, "VUID-vkCmdEndRenderPass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSubpassEndInfo = { VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pSubpassEndInfo->pNext", "VkSubpassFragmentDensityMapOffsetEndInfoQCOM", pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(), allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetSwapchainStatusKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_shared_presentable_image)) skip |= OutputExtensionError(loc, "VK_KHR_shared_presentable_image");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceExternalFenceInfo*    pExternalFenceInfo,
    VkExternalFenceProperties*                  pExternalFenceProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_external_fence_capabilities) skip |= OutputExtensionError(loc, "VK_KHR_external_fence_capabilities");
    skip |= ValidateStructType(loc, "pExternalFenceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO", pExternalFenceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, true, "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter", "VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType");
    if (pExternalFenceInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalFenceInfo->pNext", nullptr, pExternalFenceInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateFlags(loc, "pExternalFenceInfo->handleType", "VkExternalFenceHandleTypeFlagBits", AllVkExternalFenceHandleTypeFlagBits, pExternalFenceInfo->handleType, kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter", "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc, "pExternalFenceProperties", "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES", pExternalFenceProperties, VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, true, "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter", "VUID-VkExternalFenceProperties-sType-sType");
    if (pExternalFenceProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExternalFenceProperties->pNext", nullptr, pExternalFenceProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkExternalFenceProperties-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateImportFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkImportFenceWin32HandleInfoKHR*      pImportFenceWin32HandleInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_win32)) skip |= OutputExtensionError(loc, "VK_KHR_external_fence_win32");
    skip |= ValidateStructType(loc, "pImportFenceWin32HandleInfo", "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR", pImportFenceWin32HandleInfo, VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR, true, "VUID-vkImportFenceWin32HandleKHR-pImportFenceWin32HandleInfo-parameter", "VUID-VkImportFenceWin32HandleInfoKHR-sType-sType");
    if (pImportFenceWin32HandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pImportFenceWin32HandleInfo->pNext", nullptr, pImportFenceWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImportFenceWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pImportFenceWin32HandleInfo->fence", pImportFenceWin32HandleInfo->fence);

        skip |= ValidateFlags(loc, "pImportFenceWin32HandleInfo->flags", "VkFenceImportFlagBits", AllVkFenceImportFlagBits, pImportFenceWin32HandleInfo->flags, kOptionalFlags, "VUID-VkImportFenceWin32HandleInfoKHR-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetFenceWin32HandleKHR(
    VkDevice                                    device,
    const VkFenceGetWin32HandleInfoKHR*         pGetWin32HandleInfo,
    HANDLE*                                     pHandle,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_win32)) skip |= OutputExtensionError(loc, "VK_KHR_external_fence_win32");
    skip |= ValidateStructType(loc, "pGetWin32HandleInfo", "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR", pGetWin32HandleInfo, VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR, true, "VUID-vkGetFenceWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkFenceGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetWin32HandleInfo->pNext", nullptr, pGetWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkFenceGetWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetWin32HandleInfo->fence", pGetWin32HandleInfo->fence);

        skip |= ValidateFlags(loc, "pGetWin32HandleInfo->handleType", "VkExternalFenceHandleTypeFlagBits", AllVkExternalFenceHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit, "VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter", "VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pHandle", pHandle, "VUID-vkGetFenceWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateImportFenceFdKHR(
    VkDevice                                    device,
    const VkImportFenceFdInfoKHR*               pImportFenceFdInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_fd)) skip |= OutputExtensionError(loc, "VK_KHR_external_fence_fd");
    skip |= ValidateStructType(loc, "pImportFenceFdInfo", "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR", pImportFenceFdInfo, VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR, true, "VUID-vkImportFenceFdKHR-pImportFenceFdInfo-parameter", "VUID-VkImportFenceFdInfoKHR-sType-sType");
    if (pImportFenceFdInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pImportFenceFdInfo->pNext", nullptr, pImportFenceFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImportFenceFdInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pImportFenceFdInfo->fence", pImportFenceFdInfo->fence);

        skip |= ValidateFlags(loc, "pImportFenceFdInfo->flags", "VkFenceImportFlagBits", AllVkFenceImportFlagBits, pImportFenceFdInfo->flags, kOptionalFlags, "VUID-VkImportFenceFdInfoKHR-flags-parameter");

        skip |= ValidateFlags(loc, "pImportFenceFdInfo->handleType", "VkExternalFenceHandleTypeFlagBits", AllVkExternalFenceHandleTypeFlagBits, pImportFenceFdInfo->handleType, kRequiredSingleBit, "VUID-VkImportFenceFdInfoKHR-handleType-parameter", "VUID-VkImportFenceFdInfoKHR-handleType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportFenceFdKHR(device, pImportFenceFdInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetFenceFdKHR(
    VkDevice                                    device,
    const VkFenceGetFdInfoKHR*                  pGetFdInfo,
    int*                                        pFd,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_fd)) skip |= OutputExtensionError(loc, "VK_KHR_external_fence_fd");
    skip |= ValidateStructType(loc, "pGetFdInfo", "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR", pGetFdInfo, VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, true, "VUID-vkGetFenceFdKHR-pGetFdInfo-parameter", "VUID-VkFenceGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetFdInfo->pNext", nullptr, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkFenceGetFdInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetFdInfo->fence", pGetFdInfo->fence);

        skip |= ValidateFlags(loc, "pGetFdInfo->handleType", "VkExternalFenceHandleTypeFlagBits", AllVkExternalFenceHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit, "VUID-VkFenceGetFdInfoKHR-handleType-parameter", "VUID-VkFenceGetFdInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pFd", pFd, "VUID-vkGetFenceFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetFenceFdKHR(device, pGetFdInfo, pFd, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint32_t*                                   pCounterCount,
    VkPerformanceCounterKHR*                    pCounters,
    VkPerformanceCounterDescriptionKHR*         pCounterDescriptions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "pCounterCount", "pCounters", "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR", pCounterCount, pCounters, VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR, true, false, false, "VUID-VkPerformanceCounterKHR-sType-sType", "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounters-parameter", kVUIDUndefined);
    if (pCounters != nullptr)
    {
        for (uint32_t pIndexerIndex = 0; pIndexerIndex < *pCounterCount; ++pIndexerIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pCounters[%i].pNext", ParameterName::IndexVector{ pIndexerIndex }), nullptr, pCounters[pIndexerIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPerformanceCounterKHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    skip |= ValidateStructTypeArray(loc, "pCounterCount", "pCounterDescriptions", "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR", pCounterCount, pCounterDescriptions, VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR, true, false, false, "VUID-VkPerformanceCounterDescriptionKHR-sType-sType", "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterDescriptions-parameter", kVUIDUndefined);
    if (pCounterDescriptions != nullptr)
    {
        for (uint32_t pIndexerIndex = 0; pIndexerIndex < *pCounterCount; ++pIndexerIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pCounterDescriptions[%i].pNext", ParameterName::IndexVector{ pIndexerIndex }), nullptr, pCounterDescriptions[pIndexerIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPerformanceCounterDescriptionKHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkQueryPoolPerformanceCreateInfoKHR*  pPerformanceQueryCreateInfo,
    uint32_t*                                   pNumPasses,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pPerformanceQueryCreateInfo", "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR", pPerformanceQueryCreateInfo, VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, true, "VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pPerformanceQueryCreateInfo-parameter", "VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType");
    if (pPerformanceQueryCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pPerformanceQueryCreateInfo->pNext", nullptr, pPerformanceQueryCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, true, true);

        skip |= ValidateArray(loc, "pPerformanceQueryCreateInfo->counterIndexCount", "pPerformanceQueryCreateInfo->pCounterIndices", pPerformanceQueryCreateInfo->counterIndexCount, &pPerformanceQueryCreateInfo->pCounterIndices, true, true, "VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength", "VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pNumPasses", pNumPasses, "VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pNumPasses-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireProfilingLockKHR(
    VkDevice                                    device,
    const VkAcquireProfilingLockInfoKHR*        pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_performance_query)) skip |= OutputExtensionError(loc, "VK_KHR_performance_query");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR, true, "VUID-vkAcquireProfilingLockKHR-pInfo-parameter", "VUID-VkAcquireProfilingLockInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAcquireProfilingLockInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pInfo->flags", pInfo->flags, "VUID-VkAcquireProfilingLockInfoKHR-flags-zerobitmask");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseProfilingLockKHR(
    VkDevice                                    device,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_performance_query)) skip |= OutputExtensionError(loc, "VK_KHR_performance_query");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    VkSurfaceCapabilities2KHR*                  pSurfaceCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_surface_capabilities2) skip |= OutputExtensionError(loc, "VK_KHR_get_surface_capabilities2");
    skip |= ValidateStructType(loc, "pSurfaceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR", pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = { VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT };

        skip |= ValidateStructPnext(loc, "pSurfaceInfo->pNext", "VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSurfacePresentModeEXT", pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(), allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", true, true);
    }
    skip |= ValidateStructType(loc, "pSurfaceCapabilities", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR", pSurfaceCapabilities, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR, true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter", "VUID-VkSurfaceCapabilities2KHR-sType-sType");
    if (pSurfaceCapabilities != nullptr)
    {
        constexpr std::array allowed_structs_VkSurfaceCapabilities2KHR = { VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD, VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT, VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR };

        skip |= ValidateStructPnext(loc, "pSurfaceCapabilities->pNext", "VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkSharedPresentSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesFullScreenExclusiveEXT, VkSurfaceCapabilitiesPresentBarrierNV, VkSurfacePresentModeCompatibilityEXT, VkSurfacePresentScalingCapabilitiesEXT, VkSurfaceProtectedCapabilitiesKHR", pSurfaceCapabilities->pNext, allowed_structs_VkSurfaceCapabilities2KHR.size(), allowed_structs_VkSurfaceCapabilities2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSurfaceCapabilities2KHR-pNext-pNext", "VUID-VkSurfaceCapabilities2KHR-sType-unique", true, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceFormats2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pSurfaceFormatCount,
    VkSurfaceFormat2KHR*                        pSurfaceFormats,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_surface_capabilities2) skip |= OutputExtensionError(loc, "VK_KHR_get_surface_capabilities2");
    skip |= ValidateStructType(loc, "pSurfaceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR", pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, true, "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = { VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT };

        skip |= ValidateStructPnext(loc, "pSurfaceInfo->pNext", "VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSurfacePresentModeEXT", pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(), allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", true, true);
    }
    skip |= ValidateStructTypeArray(loc, "pSurfaceFormatCount", "pSurfaceFormats", "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR", pSurfaceFormatCount, pSurfaceFormats, VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, true, false, false, "VUID-VkSurfaceFormat2KHR-sType-sType", "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormats-parameter", kVUIDUndefined);
    if (pSurfaceFormats != nullptr)
    {
        for (uint32_t pSurfaceFormatIndex = 0; pSurfaceFormatIndex < *pSurfaceFormatCount; ++pSurfaceFormatIndex)
        {
            constexpr std::array allowed_structs_VkSurfaceFormat2KHR = { VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pSurfaceFormats[%i].pNext", ParameterName::IndexVector{ pSurfaceFormatIndex }), "VkImageCompressionPropertiesEXT", pSurfaceFormats[pSurfaceFormatIndex].pNext, allowed_structs_VkSurfaceFormat2KHR.size(), allowed_structs_VkSurfaceFormat2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSurfaceFormat2KHR-pNext-pNext", "VUID-VkSurfaceFormat2KHR-sType-unique", true, false);
        }
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayProperties2KHR*                    pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_display_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_display_properties2");
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR, true, false, false, "VUID-VkDisplayProperties2KHR-sType-sType", "VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pProperties-parameter", kVUIDUndefined);
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pProperties[%i].pNext", ParameterName::IndexVector{ pPropertyIndex }), nullptr, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayProperties2KHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayPlaneProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkDisplayPlaneProperties2KHR*               pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_display_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_display_properties2");
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR, true, false, false, "VUID-VkDisplayPlaneProperties2KHR-sType-sType", "VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pProperties-parameter", kVUIDUndefined);
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pProperties[%i].pNext", ParameterName::IndexVector{ pPropertyIndex }), nullptr, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayPlaneProperties2KHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayModeProperties2KHR(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    uint32_t*                                   pPropertyCount,
    VkDisplayModeProperties2KHR*                pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_display_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_display_properties2");
    skip |= ValidateRequiredHandle(loc, "display", display);
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR, true, false, false, "VUID-VkDisplayModeProperties2KHR-sType-sType", "VUID-vkGetDisplayModeProperties2KHR-pProperties-parameter", kVUIDUndefined);
    if (pProperties != nullptr)
    {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pProperties[%i].pNext", ParameterName::IndexVector{ pPropertyIndex }), nullptr, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayModeProperties2KHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayPlaneCapabilities2KHR(
    VkPhysicalDevice                            physicalDevice,
    const VkDisplayPlaneInfo2KHR*               pDisplayPlaneInfo,
    VkDisplayPlaneCapabilities2KHR*             pCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_khr_get_display_properties2) skip |= OutputExtensionError(loc, "VK_KHR_get_display_properties2");
    skip |= ValidateStructType(loc, "pDisplayPlaneInfo", "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR", pDisplayPlaneInfo, VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR, true, "VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter", "VUID-VkDisplayPlaneInfo2KHR-sType-sType");
    if (pDisplayPlaneInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDisplayPlaneInfo->pNext", nullptr, pDisplayPlaneInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayPlaneInfo2KHR-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateRequiredHandle(loc, "pDisplayPlaneInfo->mode", pDisplayPlaneInfo->mode);
    }
    skip |= ValidateStructType(loc, "pCapabilities", "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR", pCapabilities, VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR, true, "VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter", "VUID-VkDisplayPlaneCapabilities2KHR-sType-sType");
    if (pCapabilities != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCapabilities->pNext", nullptr, pCapabilities->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageMemoryRequirementsInfo2*       pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_get_memory_requirements2)) skip |= OutputExtensionError(loc, "VK_KHR_get_memory_requirements2");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2", pInfo, VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, true, "VUID-vkGetImageMemoryRequirements2-pInfo-parameter", "VUID-VkImageMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkImageMemoryRequirementsInfo2 = { VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO };

        skip |= ValidateStructPnext(loc, "pInfo->pNext", "VkImagePlaneMemoryRequirementsInfo", pInfo->pNext, allowed_structs_VkImageMemoryRequirementsInfo2.size(), allowed_structs_VkImageMemoryRequirementsInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryRequirementsInfo2-pNext-pNext", "VUID-VkImageMemoryRequirementsInfo2-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->image", pInfo->image);
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkBufferMemoryRequirementsInfo2*      pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_get_memory_requirements2)) skip |= OutputExtensionError(loc, "VK_KHR_get_memory_requirements2");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2", pInfo, VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2, true, "VUID-vkGetBufferMemoryRequirements2-pInfo-parameter", "VUID-VkBufferMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSparseMemoryRequirements2KHR(
    VkDevice                                    device,
    const VkImageSparseMemoryRequirementsInfo2* pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_get_memory_requirements2)) skip |= OutputExtensionError(loc, "VK_KHR_get_memory_requirements2");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2", pInfo, VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2, true, "VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter", "VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->image", pInfo->image);
    }
    skip |= ValidateStructTypeArray(loc, "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2", pSparseMemoryRequirementCount, pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false, "VUID-VkSparseImageMemoryRequirements2-sType-sType", "VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirements-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr)
    {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount; ++pSparseMemoryRequirementIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pSparseMemoryRequirements[%i].pNext", ParameterName::IndexVector{ pSparseMemoryRequirementIndex }), nullptr, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSamplerYcbcrConversionKHR(
    VkDevice                                    device,
    const VkSamplerYcbcrConversionCreateInfo*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSamplerYcbcrConversion*                   pYcbcrConversion,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion)) skip |= OutputExtensionError(loc, "VK_KHR_sampler_ycbcr_conversion");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO, true, "VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter", "VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkSamplerYcbcrConversionCreateInfo = { VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkExternalFormatANDROID, VkExternalFormatQNX, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM", pCreateInfo->pNext, allowed_structs_VkSamplerYcbcrConversionCreateInfo.size(), allowed_structs_VkSamplerYcbcrConversionCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext", "VUID-VkSamplerYcbcrConversionCreateInfo-sType-unique", false, true);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->format", "VkFormat", pCreateInfo->format, "VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->ycbcrModel", "VkSamplerYcbcrModelConversion", pCreateInfo->ycbcrModel, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->ycbcrRange", "VkSamplerYcbcrRange", pCreateInfo->ycbcrRange, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.r", "VkComponentSwizzle", pCreateInfo->components.r, "VUID-VkComponentMapping-r-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.g", "VkComponentSwizzle", pCreateInfo->components.g, "VUID-VkComponentMapping-g-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.b", "VkComponentSwizzle", pCreateInfo->components.b, "VUID-VkComponentMapping-b-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->components.a", "VkComponentSwizzle", pCreateInfo->components.a, "VUID-VkComponentMapping-a-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->xChromaOffset", "VkChromaLocation", pCreateInfo->xChromaOffset, "VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->yChromaOffset", "VkChromaLocation", pCreateInfo->yChromaOffset, "VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->chromaFilter", "VkFilter", pCreateInfo->chromaFilter, "VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter");

        skip |= ValidateBool32(loc, "pCreateInfo->forceExplicitReconstruction", pCreateInfo->forceExplicitReconstruction);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pYcbcrConversion", pYcbcrConversion, "VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySamplerYcbcrConversionKHR(
    VkDevice                                    device,
    VkSamplerYcbcrConversion                    ycbcrConversion,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion)) skip |= OutputExtensionError(loc, "VK_KHR_sampler_ycbcr_conversion");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindBufferMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindBufferMemoryInfo*               pBindInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_bind_memory2)) skip |= OutputExtensionError(loc, "VK_KHR_bind_memory2");
    skip |= ValidateStructTypeArray(loc, "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO, true, true, "VUID-VkBindBufferMemoryInfo-sType-sType", "VUID-vkBindBufferMemory2-pBindInfos-parameter", "VUID-vkBindBufferMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            constexpr std::array allowed_structs_VkBindBufferMemoryInfo = { VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkBindBufferMemoryDeviceGroupInfo", pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindBufferMemoryInfo.size(), allowed_structs_VkBindBufferMemoryInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBindBufferMemoryInfo-pNext-pNext", "VUID-VkBindBufferMemoryInfo-sType-unique", false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].buffer", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].buffer);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].memory", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindImageMemory2KHR(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindImageMemoryInfo*                pBindInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_bind_memory2)) skip |= OutputExtensionError(loc, "VK_KHR_bind_memory2");
    skip |= ValidateStructTypeArray(loc, "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO, true, true, "VUID-VkBindImageMemoryInfo-sType-sType", "VUID-vkBindImageMemory2-pBindInfos-parameter", "VUID-vkBindImageMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            constexpr std::array allowed_structs_VkBindImageMemoryInfo = { VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR, VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), "VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, VkBindImagePlaneMemoryInfo", pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindImageMemoryInfo.size(), allowed_structs_VkBindImageMemoryInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBindImageMemoryInfo-pNext-pNext", "VUID-VkBindImageMemoryInfo-sType-unique", false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].image", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].image);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutSupportKHR(
    VkDevice                                    device,
    const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
    VkDescriptorSetLayoutSupport*               pSupport,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance3)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance3");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true, "VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter", "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO, VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkDescriptorSetLayoutBindingFlagsCreateInfo, VkMutableDescriptorTypeCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(), allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext", "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkDescriptorSetLayoutCreateFlagBits", AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(loc, "pCreateInfo->bindingCount", "pCreateInfo->pBindings", pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined, "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr)
        {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex)
            {
                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pBindings[%i].descriptorType", ParameterName::IndexVector{ bindingIndex }), "VkDescriptorType", pCreateInfo->pBindings[bindingIndex].descriptorType, "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter");
            }
        }
    }
    skip |= ValidateStructType(loc, "pSupport", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT", pSupport, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, true, "VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter", "VUID-VkDescriptorSetLayoutSupport-sType-sType");
    if (pSupport != nullptr)
    {
        constexpr std::array allowed_structs_VkDescriptorSetLayoutSupport = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT };

        skip |= ValidateStructPnext(loc, "pSupport->pNext", "VkDescriptorSetVariableDescriptorCountLayoutSupport", pSupport->pNext, allowed_structs_VkDescriptorSetLayoutSupport.size(), allowed_structs_VkDescriptorSetLayoutSupport.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetLayoutSupport-pNext-pNext", "VUID-VkDescriptorSetLayoutSupport-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectCountKHR(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_draw_indirect_count)) skip |= OutputExtensionError(loc, "VK_KHR_draw_indirect_count");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_draw_indirect_count)) skip |= OutputExtensionError(loc, "VK_KHR_draw_indirect_count");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreCounterValueKHR(
    VkDevice                                    device,
    VkSemaphore                                 semaphore,
    uint64_t*                                   pValue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore)) skip |= OutputExtensionError(loc, "VK_KHR_timeline_semaphore");
    skip |= ValidateRequiredHandle(loc, "semaphore", semaphore);
    skip |= ValidateRequiredPointer(loc, "pValue", pValue, "VUID-vkGetSemaphoreCounterValue-pValue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateWaitSemaphoresKHR(
    VkDevice                                    device,
    const VkSemaphoreWaitInfo*                  pWaitInfo,
    uint64_t                                    timeout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore)) skip |= OutputExtensionError(loc, "VK_KHR_timeline_semaphore");
    skip |= ValidateStructType(loc, "pWaitInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO", pWaitInfo, VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, true, "VUID-vkWaitSemaphores-pWaitInfo-parameter", "VUID-VkSemaphoreWaitInfo-sType-sType");
    if (pWaitInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pWaitInfo->pNext", nullptr, pWaitInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreWaitInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pWaitInfo->flags", "VkSemaphoreWaitFlagBits", AllVkSemaphoreWaitFlagBits, pWaitInfo->flags, kOptionalFlags, "VUID-VkSemaphoreWaitInfo-flags-parameter");

        skip |= ValidateHandleArray(loc, "pWaitInfo->semaphoreCount", "pWaitInfo->pSemaphores", pWaitInfo->semaphoreCount, pWaitInfo->pSemaphores, true, true, kVUIDUndefined);

        skip |= ValidateArray(loc, "pWaitInfo->semaphoreCount", "pWaitInfo->pValues", pWaitInfo->semaphoreCount, &pWaitInfo->pValues, true, true, "VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength", "VUID-VkSemaphoreWaitInfo-pValues-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSignalSemaphoreKHR(
    VkDevice                                    device,
    const VkSemaphoreSignalInfo*                pSignalInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore)) skip |= OutputExtensionError(loc, "VK_KHR_timeline_semaphore");
    skip |= ValidateStructType(loc, "pSignalInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO", pSignalInfo, VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, true, "VUID-vkSignalSemaphore-pSignalInfo-parameter", "VUID-VkSemaphoreSignalInfo-sType-sType");
    if (pSignalInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSignalInfo->pNext", nullptr, pSignalInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSignalInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pSignalInfo->semaphore", pSignalInfo->semaphore);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFragmentShadingRatesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pFragmentShadingRateCount,
    VkPhysicalDeviceFragmentShadingRateKHR*     pFragmentShadingRates,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "pFragmentShadingRateCount", "pFragmentShadingRates", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR", pFragmentShadingRateCount, pFragmentShadingRates, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR, true, false, false, "VUID-VkPhysicalDeviceFragmentShadingRateKHR-sType-sType", "VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-pFragmentShadingRates-parameter", kVUIDUndefined);
    if (pFragmentShadingRates != nullptr)
    {
        for (uint32_t pFragmentShadingRateIndex = 0; pFragmentShadingRateIndex < *pFragmentShadingRateCount; ++pFragmentShadingRateIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pFragmentShadingRates[%i].pNext", ParameterName::IndexVector{ pFragmentShadingRateIndex }), nullptr, pFragmentShadingRates[pFragmentShadingRateIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceFragmentShadingRateKHR-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFragmentShadingRateKHR(
    VkCommandBuffer                             commandBuffer,
    const VkExtent2D*                           pFragmentSize,
    const VkFragmentShadingRateCombinerOpKHR    combinerOps[2],
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_fragment_shading_rate)) skip |= OutputExtensionError(loc, "VK_KHR_fragment_shading_rate");
    skip |= ValidateRequiredPointer(loc, "pFragmentSize", pFragmentSize, "VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-parameter");
    if (pFragmentSize != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRangedEnumArray(loc, "None", "combinerOps", "VkFragmentShadingRateCombinerOpKHR", 2, combinerOps, false, true);
    return skip;
}

bool StatelessValidation::PreCallValidateWaitForPresentKHR(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint64_t                                    presentId,
    uint64_t                                    timeout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_present_wait)) skip |= OutputExtensionError(loc, "VK_KHR_present_wait");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferDeviceAddressKHR(
    VkDevice                                    device,
    const VkBufferDeviceAddressInfo*            pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address)) skip |= OutputExtensionError(loc, "VK_KHR_buffer_device_address");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true, "VUID-vkGetBufferDeviceAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferOpaqueCaptureAddressKHR(
    VkDevice                                    device,
    const VkBufferDeviceAddressInfo*            pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address)) skip |= OutputExtensionError(loc, "VK_KHR_buffer_device_address");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true, "VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice                                    device,
    const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address)) skip |= OutputExtensionError(loc, "VK_KHR_buffer_device_address");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO, true, "VUID-vkGetDeviceMemoryOpaqueCaptureAddress-pInfo-parameter", "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->memory", pInfo->memory);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDeferredOperationKHR(
    VkDevice                                    device,
    const VkAllocationCallbacks*                pAllocator,
    VkDeferredOperationKHR*                     pDeferredOperation,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations)) skip |= OutputExtensionError(loc, "VK_KHR_deferred_host_operations");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pDeferredOperation", pDeferredOperation, "VUID-vkCreateDeferredOperationKHR-pDeferredOperation-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDeferredOperationKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      operation,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations)) skip |= OutputExtensionError(loc, "VK_KHR_deferred_host_operations");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeferredOperationMaxConcurrencyKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      operation,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations)) skip |= OutputExtensionError(loc, "VK_KHR_deferred_host_operations");
    skip |= ValidateRequiredHandle(loc, "operation", operation);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeferredOperationResultKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      operation,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations)) skip |= OutputExtensionError(loc, "VK_KHR_deferred_host_operations");
    skip |= ValidateRequiredHandle(loc, "operation", operation);
    return skip;
}

bool StatelessValidation::PreCallValidateDeferredOperationJoinKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      operation,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations)) skip |= OutputExtensionError(loc, "VK_KHR_deferred_host_operations");
    skip |= ValidateRequiredHandle(loc, "operation", operation);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineExecutablePropertiesKHR(
    VkDevice                                    device,
    const VkPipelineInfoKHR*                    pPipelineInfo,
    uint32_t*                                   pExecutableCount,
    VkPipelineExecutablePropertiesKHR*          pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties)) skip |= OutputExtensionError(loc, "VK_KHR_pipeline_executable_properties");
    skip |= ValidateStructType(loc, "pPipelineInfo", "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR", pPipelineInfo, VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR, true, "VUID-vkGetPipelineExecutablePropertiesKHR-pPipelineInfo-parameter", "VUID-VkPipelineInfoKHR-sType-sType");
    if (pPipelineInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pPipelineInfo->pNext", nullptr, pPipelineInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pPipelineInfo->pipeline", pPipelineInfo->pipeline);
    }
    skip |= ValidateStructTypeArray(loc, "pExecutableCount", "pProperties", "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR", pExecutableCount, pProperties, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR, true, false, false, "VUID-VkPipelineExecutablePropertiesKHR-sType-sType", "VUID-vkGetPipelineExecutablePropertiesKHR-pProperties-parameter", kVUIDUndefined);
    if (pProperties != nullptr)
    {
        for (uint32_t pExecutableIndex = 0; pExecutableIndex < *pExecutableCount; ++pExecutableIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pProperties[%i].pNext", ParameterName::IndexVector{ pExecutableIndex }), nullptr, pProperties[pExecutableIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutablePropertiesKHR-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineExecutableStatisticsKHR(
    VkDevice                                    device,
    const VkPipelineExecutableInfoKHR*          pExecutableInfo,
    uint32_t*                                   pStatisticCount,
    VkPipelineExecutableStatisticKHR*           pStatistics,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties)) skip |= OutputExtensionError(loc, "VK_KHR_pipeline_executable_properties");
    skip |= ValidateStructType(loc, "pExecutableInfo", "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR", pExecutableInfo, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR, true, "VUID-vkGetPipelineExecutableStatisticsKHR-pExecutableInfo-parameter", "VUID-VkPipelineExecutableInfoKHR-sType-sType");
    if (pExecutableInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExecutableInfo->pNext", nullptr, pExecutableInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutableInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pExecutableInfo->pipeline", pExecutableInfo->pipeline);
    }
    skip |= ValidateStructTypeArray(loc, "pStatisticCount", "pStatistics", "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR", pStatisticCount, pStatistics, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR, true, false, false, "VUID-VkPipelineExecutableStatisticKHR-sType-sType", "VUID-vkGetPipelineExecutableStatisticsKHR-pStatistics-parameter", kVUIDUndefined);
    if (pStatistics != nullptr)
    {
        for (uint32_t pStatisticIndex = 0; pStatisticIndex < *pStatisticCount; ++pStatisticIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pStatistics[%i].pNext", ParameterName::IndexVector{ pStatisticIndex }), nullptr, pStatistics[pStatisticIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutableStatisticKHR-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice                                    device,
    const VkPipelineExecutableInfoKHR*          pExecutableInfo,
    uint32_t*                                   pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties)) skip |= OutputExtensionError(loc, "VK_KHR_pipeline_executable_properties");
    skip |= ValidateStructType(loc, "pExecutableInfo", "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR", pExecutableInfo, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR, true, "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pExecutableInfo-parameter", "VUID-VkPipelineExecutableInfoKHR-sType-sType");
    if (pExecutableInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExecutableInfo->pNext", nullptr, pExecutableInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutableInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pExecutableInfo->pipeline", pExecutableInfo->pipeline);
    }
    skip |= ValidateStructTypeArray(loc, "pInternalRepresentationCount", "pInternalRepresentations", "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR", pInternalRepresentationCount, pInternalRepresentations, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR, true, false, false, "VUID-VkPipelineExecutableInternalRepresentationKHR-sType-sType", "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pInternalRepresentations-parameter", kVUIDUndefined);
    if (pInternalRepresentations != nullptr)
    {
        for (uint32_t pInternalRepresentationIndex = 0; pInternalRepresentationIndex < *pInternalRepresentationCount; ++pInternalRepresentationIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pInternalRepresentations[%i].pNext", ParameterName::IndexVector{ pInternalRepresentationIndex }), nullptr, pInternalRepresentations[pInternalRepresentationIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutableInternalRepresentationKHR-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateMapMemory2KHR(
    VkDevice                                    device,
    const VkMemoryMapInfoKHR*                   pMemoryMapInfo,
    void**                                      ppData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_map_memory2)) skip |= OutputExtensionError(loc, "VK_KHR_map_memory2");
    skip |= ValidateStructType(loc, "pMemoryMapInfo", "VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR", pMemoryMapInfo, VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR, true, "VUID-vkMapMemory2KHR-pMemoryMapInfo-parameter", "VUID-VkMemoryMapInfoKHR-sType-sType");
    if (pMemoryMapInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryMapInfo->pNext", nullptr, pMemoryMapInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryMapInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pMemoryMapInfo->flags", pMemoryMapInfo->flags, "VUID-VkMemoryMapInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pMemoryMapInfo->memory", pMemoryMapInfo->memory);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUnmapMemory2KHR(
    VkDevice                                    device,
    const VkMemoryUnmapInfoKHR*                 pMemoryUnmapInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_map_memory2)) skip |= OutputExtensionError(loc, "VK_KHR_map_memory2");
    skip |= ValidateStructType(loc, "pMemoryUnmapInfo", "VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR", pMemoryUnmapInfo, VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR, true, "VUID-vkUnmapMemory2KHR-pMemoryUnmapInfo-parameter", "VUID-VkMemoryUnmapInfoKHR-sType-sType");
    if (pMemoryUnmapInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryUnmapInfo->pNext", nullptr, pMemoryUnmapInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryUnmapInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pMemoryUnmapInfo->flags", pMemoryUnmapInfo->flags, "VUID-VkMemoryUnmapInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pMemoryUnmapInfo->memory", pMemoryUnmapInfo->memory);
    }
    return skip;
}

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo,
    VkVideoEncodeQualityLevelPropertiesKHR*     pQualityLevelProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pQualityLevelInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR", pQualityLevelInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR, true, "VUID-vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR-pQualityLevelInfo-parameter", "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-sType-sType");
    if (pQualityLevelInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pQualityLevelInfo->pNext", nullptr, pQualityLevelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pNext-pNext", kVUIDUndefined, true, true);

        skip |= ValidateStructType(loc, "pQualityLevelInfo->pVideoProfile", "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR", pQualityLevelInfo->pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true, "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-parameter", "VUID-VkVideoProfileInfoKHR-sType-sType");

        if (pQualityLevelInfo->pVideoProfile != nullptr)
        {
            constexpr std::array allowed_structs_VkVideoProfileInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pQualityLevelInfo->pVideoProfile->pNext", "VkVideoDecodeH264ProfileInfoKHR, VkVideoDecodeH265ProfileInfoKHR, VkVideoDecodeUsageInfoKHR, VkVideoEncodeH264ProfileInfoEXT, VkVideoEncodeH265ProfileInfoEXT, VkVideoEncodeUsageInfoKHR", pQualityLevelInfo->pVideoProfile->pNext, allowed_structs_VkVideoProfileInfoKHR.size(), allowed_structs_VkVideoProfileInfoKHR.data(), GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, true, true);

            skip |= ValidateFlags(loc, "pQualityLevelInfo->pVideoProfile->videoCodecOperation", "VkVideoCodecOperationFlagBitsKHR", AllVkVideoCodecOperationFlagBitsKHR, pQualityLevelInfo->pVideoProfile->videoCodecOperation, kRequiredSingleBit, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

            skip |= ValidateFlags(loc, "pQualityLevelInfo->pVideoProfile->chromaSubsampling", "VkVideoChromaSubsamplingFlagBitsKHR", AllVkVideoChromaSubsamplingFlagBitsKHR, pQualityLevelInfo->pVideoProfile->chromaSubsampling, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter", "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

            skip |= ValidateFlags(loc, "pQualityLevelInfo->pVideoProfile->lumaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, pQualityLevelInfo->pVideoProfile->lumaBitDepth, kRequiredFlags, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

            skip |= ValidateFlags(loc, "pQualityLevelInfo->pVideoProfile->chromaBitDepth", "VkVideoComponentBitDepthFlagBitsKHR", AllVkVideoComponentBitDepthFlagBitsKHR, pQualityLevelInfo->pVideoProfile->chromaBitDepth, kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
        }
    }
    skip |= ValidateStructType(loc, "pQualityLevelProperties", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR", pQualityLevelProperties, VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR, true, "VUID-vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR-pQualityLevelProperties-parameter", "VUID-VkVideoEncodeQualityLevelPropertiesKHR-sType-sType");
    if (pQualityLevelProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT };

        skip |= ValidateStructPnext(loc, "pQualityLevelProperties->pNext", "VkVideoEncodeH264QualityLevelPropertiesEXT, VkVideoEncodeH265QualityLevelPropertiesEXT", pQualityLevelProperties->pNext, allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR.size(), allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeQualityLevelPropertiesKHR-pNext-pNext", "VUID-VkVideoEncodeQualityLevelPropertiesKHR-sType-unique", true, false);
    }
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateGetEncodedVideoSessionParametersKHR(
    VkDevice                                    device,
    const VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo,
    VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo,
    size_t*                                     pDataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_encode_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_encode_queue");
    skip |= ValidateStructType(loc, "pVideoSessionParametersInfo", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR", pVideoSessionParametersInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR, true, "VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-parameter", "VUID-VkVideoEncodeSessionParametersGetInfoKHR-sType-sType");
    if (pVideoSessionParametersInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pVideoSessionParametersInfo->pNext", "VkVideoEncodeH264SessionParametersGetInfoEXT, VkVideoEncodeH265SessionParametersGetInfoEXT", pVideoSessionParametersInfo->pNext, allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR.size(), allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeSessionParametersGetInfoKHR-pNext-pNext", "VUID-VkVideoEncodeSessionParametersGetInfoKHR-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pVideoSessionParametersInfo->videoSessionParameters", pVideoSessionParametersInfo->videoSessionParameters);
    }
    skip |= ValidateStructType(loc, "pFeedbackInfo", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR", pFeedbackInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR, false, "VUID-vkGetEncodedVideoSessionParametersKHR-pFeedbackInfo-parameter", "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-sType-sType");
    if (pFeedbackInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pFeedbackInfo->pNext", "VkVideoEncodeH264SessionParametersFeedbackInfoEXT, VkVideoEncodeH265SessionParametersFeedbackInfoEXT", pFeedbackInfo->pNext, allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR.size(), allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-pNext-pNext", "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-sType-unique", false, false);
    }
    skip |= ValidateArray(loc, "pDataSize", "pData", pDataSize, &pData, true, false, false, kVUIDUndefined, "VUID-vkGetEncodedVideoSessionParametersKHR-pData-parameter");
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCmdEncodeVideoKHR(
    VkCommandBuffer                             commandBuffer,
    const VkVideoEncodeInfoKHR*                 pEncodeInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_encode_queue)) skip |= OutputExtensionError(loc, "VK_KHR_video_encode_queue");
    skip |= ValidateStructType(loc, "pEncodeInfo", "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR", pEncodeInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR, true, "VUID-vkCmdEncodeVideoKHR-pEncodeInfo-parameter", "VUID-VkVideoEncodeInfoKHR-sType-sType");
    if (pEncodeInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkVideoEncodeInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pEncodeInfo->pNext", "VkVideoEncodeH264PictureInfoEXT, VkVideoEncodeH265PictureInfoEXT", pEncodeInfo->pNext, allowed_structs_VkVideoEncodeInfoKHR.size(), allowed_structs_VkVideoEncodeInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeInfoKHR-pNext-pNext", "VUID-VkVideoEncodeInfoKHR-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pEncodeInfo->flags", pEncodeInfo->flags, "VUID-VkVideoEncodeInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(loc, "pEncodeInfo->dstBuffer", pEncodeInfo->dstBuffer);

        skip |= ValidateStructType(loc, "pEncodeInfo->srcPictureResource", "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", &(pEncodeInfo->srcPictureResource), VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, kVUIDUndefined, "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

        skip |= ValidateStructPnext(loc, "pEncodeInfo->srcPictureResource.pNext", nullptr, pEncodeInfo->srcPictureResource.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateRequiredHandle(loc, "pEncodeInfo->srcPictureResource.imageViewBinding", pEncodeInfo->srcPictureResource.imageViewBinding);

        skip |= ValidateStructType(loc, "pEncodeInfo->pSetupReferenceSlot", "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR", pEncodeInfo->pSetupReferenceSlot, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, "VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-parameter", "VUID-VkVideoReferenceSlotInfoKHR-sType-sType");

        if (pEncodeInfo->pSetupReferenceSlot != nullptr)
        {
            constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT };

            skip |= ValidateStructPnext(loc, "pEncodeInfo->pSetupReferenceSlot->pNext", "VkVideoDecodeH264DpbSlotInfoKHR, VkVideoDecodeH265DpbSlotInfoKHR, VkVideoEncodeH264DpbSlotInfoEXT, VkVideoEncodeH265DpbSlotInfoEXT", pEncodeInfo->pSetupReferenceSlot->pNext, allowed_structs_VkVideoReferenceSlotInfoKHR.size(), allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext", "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", false, true);

            skip |= ValidateStructType(loc, "pEncodeInfo->pSetupReferenceSlot->pPictureResource", "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", pEncodeInfo->pSetupReferenceSlot->pPictureResource, VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

            if (pEncodeInfo->pSetupReferenceSlot->pPictureResource != nullptr)
            {
                skip |= ValidateStructPnext(loc, "pEncodeInfo->pSetupReferenceSlot->pPictureResource->pNext", nullptr, pEncodeInfo->pSetupReferenceSlot->pPictureResource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

                // No xml-driven validation

                // No xml-driven validation

                skip |= ValidateRequiredHandle(loc, "pEncodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding", pEncodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding);
            }
        }

        skip |= ValidateStructTypeArray(loc, "pEncodeInfo->referenceSlotCount", "pEncodeInfo->pReferenceSlots", "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR", pEncodeInfo->referenceSlotCount, pEncodeInfo->pReferenceSlots, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, true, "VUID-VkVideoReferenceSlotInfoKHR-sType-sType", "VUID-VkVideoEncodeInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pEncodeInfo->pReferenceSlots != nullptr)
        {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pEncodeInfo->referenceSlotCount; ++referenceSlotIndex)
            {
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = { VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pEncodeInfo->pReferenceSlots[%i].pNext", ParameterName::IndexVector{ referenceSlotIndex }), "VkVideoDecodeH264DpbSlotInfoKHR, VkVideoDecodeH265DpbSlotInfoKHR, VkVideoEncodeH264DpbSlotInfoEXT, VkVideoEncodeH265DpbSlotInfoEXT", pEncodeInfo->pReferenceSlots[referenceSlotIndex].pNext, allowed_structs_VkVideoReferenceSlotInfoKHR.size(), allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext", "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", false, true);

                skip |= ValidateStructType(loc, ParameterName("pEncodeInfo->pReferenceSlots[%i].pPictureResource", ParameterName::IndexVector{ referenceSlotIndex }), "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource, VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pEncodeInfo->pReferenceSlots[%i].pPictureResource->pNext", ParameterName::IndexVector{ referenceSlotIndex }), nullptr, pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |= ValidateRequiredHandle(loc, ParameterName("pEncodeInfo->pReferenceSlots[%i].pPictureResource->imageViewBinding", ParameterName::IndexVector{ referenceSlotIndex }), pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

bool StatelessValidation::PreCallValidateCmdSetEvent2KHR(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    const VkDependencyInfo*                     pDependencyInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateRequiredHandle(loc, "event", event);
    skip |= ValidateStructType(loc, "pDependencyInfo", "VK_STRUCTURE_TYPE_DEPENDENCY_INFO", pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, "VUID-vkCmdSetEvent2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDependencyInfo->pNext", nullptr, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pDependencyInfo->dependencyFlags", "VkDependencyFlagBits", AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags, "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->memoryBarrierCount", "pDependencyInfo->pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr)
        {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), nullptr, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->bufferMemoryBarrierCount", "pDependencyInfo->pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr)
        {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext", "VUID-VkBufferMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->imageMemoryBarrierCount", "pDependencyInfo->pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr)
        {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext", "VUID-VkImageMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetEvent2KHR(
    VkCommandBuffer                             commandBuffer,
    VkEvent                                     event,
    VkPipelineStageFlags2                       stageMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateRequiredHandle(loc, "event", event);
    skip |= ValidateFlags(loc, "stageMask", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, stageMask, kOptionalFlags, "VUID-vkCmdResetEvent2-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWaitEvents2KHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    const VkDependencyInfo*                     pDependencyInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateHandleArray(loc, "eventCount", "pEvents", eventCount, pEvents, true, true, "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    skip |= ValidateStructTypeArray(loc, "eventCount", "pDependencyInfos", "VK_STRUCTURE_TYPE_DEPENDENCY_INFO", eventCount, pDependencyInfos, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, true, "VUID-VkDependencyInfo-sType-sType", "VUID-vkCmdWaitEvents2-pDependencyInfos-parameter", "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    if (pDependencyInfos != nullptr)
    {
        for (uint32_t eventIndex = 0; eventIndex < eventCount; ++eventIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pNext", ParameterName::IndexVector{ eventIndex }), nullptr, pDependencyInfos[eventIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].dependencyFlags", ParameterName::IndexVector{ eventIndex }), "VkDependencyFlagBits", AllVkDependencyFlagBits, pDependencyInfos[eventIndex].dependencyFlags, kOptionalFlags, "VUID-VkDependencyInfo-dependencyFlags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pDependencyInfos[%i].memoryBarrierCount", ParameterName::IndexVector{ eventIndex }), ParameterName("pDependencyInfos[%i].pMemoryBarriers", ParameterName::IndexVector{ eventIndex }), "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", pDependencyInfos[eventIndex].memoryBarrierCount, pDependencyInfos[eventIndex].pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pMemoryBarriers != nullptr)
            {
                for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfos[eventIndex].memoryBarrierCount; ++memoryBarrierIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), nullptr, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ eventIndex, memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pDependencyInfos[%i].bufferMemoryBarrierCount", ParameterName::IndexVector{ eventIndex }), ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers", ParameterName::IndexVector{ eventIndex }), "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", pDependencyInfos[eventIndex].bufferMemoryBarrierCount, pDependencyInfos[eventIndex].pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pBufferMemoryBarriers != nullptr)
            {
                for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfos[eventIndex].bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
                {
                    constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext", "VUID-VkBufferMemoryBarrier2-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                    skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfos[%i].pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ eventIndex, bufferMemoryBarrierIndex }), pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pDependencyInfos[%i].imageMemoryBarrierCount", ParameterName::IndexVector{ eventIndex }), ParameterName("pDependencyInfos[%i].pImageMemoryBarriers", ParameterName::IndexVector{ eventIndex }), "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", pDependencyInfos[eventIndex].imageMemoryBarrierCount, pDependencyInfos[eventIndex].pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pImageMemoryBarriers != nullptr)
            {
                for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfos[eventIndex].imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
                {
                    constexpr std::array allowed_structs_VkImageMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext", "VUID-VkImageMemoryBarrier2-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                    skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                    skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                    skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                    skip |= ValidateFlags(loc, ParameterName("pDependencyInfos[%i].pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ eventIndex, imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPipelineBarrier2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkDependencyInfo*                     pDependencyInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateStructType(loc, "pDependencyInfo", "VK_STRUCTURE_TYPE_DEPENDENCY_INFO", pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, "VUID-vkCmdPipelineBarrier2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDependencyInfo->pNext", nullptr, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pDependencyInfo->dependencyFlags", "VkDependencyFlagBits", AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags, "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->memoryBarrierCount", "pDependencyInfo->pMemoryBarriers", "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr)
        {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].pNext", ParameterName::IndexVector{ memoryBarrierIndex }), nullptr, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ memoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->bufferMemoryBarrierCount", "pDependencyInfo->pBufferMemoryBarriers", "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr)
        {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].pNext", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT", pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext, allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext", "VUID-VkBufferMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pBufferMemoryBarriers[%i].buffer", ParameterName::IndexVector{ bufferMemoryBarrierIndex }), pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= ValidateStructTypeArray(loc, "pDependencyInfo->imageMemoryBarrierCount", "pDependencyInfo->pImageMemoryBarriers", "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr)
        {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount; ++imageMemoryBarrierIndex)
            {
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = { VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT };

                skip |= ValidateStructPnext(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].pNext", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkExternalMemoryAcquireUnmodifiedEXT, VkSampleLocationsInfoEXT", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext, allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext", "VUID-VkImageMemoryBarrier2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].srcAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstStageMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].dstAccessMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkAccessFlagBits2", AllVkAccessFlagBits2, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].oldLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout, "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].newLayout", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageLayout", pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout, "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                skip |= ValidateRequiredHandle(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].image", ParameterName::IndexVector{ imageMemoryBarrierIndex }), pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= ValidateFlags(loc, ParameterName("pDependencyInfo->pImageMemoryBarriers[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ imageMemoryBarrierIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteTimestamp2KHR(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags2                       stage,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateFlags(loc, "stage", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, stage, kOptionalFlags, "VUID-vkCmdWriteTimestamp2-stage-parameter");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSubmit2KHR(
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo2*                        pSubmits,
    VkFence                                     fence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateStructTypeArray(loc, "submitCount", "pSubmits", "VK_STRUCTURE_TYPE_SUBMIT_INFO_2", submitCount, pSubmits, VK_STRUCTURE_TYPE_SUBMIT_INFO_2, false, true, "VUID-VkSubmitInfo2-sType-sType", "VUID-vkQueueSubmit2-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr)
    {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex)
        {
            constexpr std::array allowed_structs_VkSubmitInfo2 = { VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV };

            skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pNext", ParameterName::IndexVector{ submitIndex }), "VkPerformanceQuerySubmitInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoNV", pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo2.size(), allowed_structs_VkSubmitInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubmitInfo2-pNext-pNext", "VUID-VkSubmitInfo2-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pSubmits[%i].flags", ParameterName::IndexVector{ submitIndex }), "VkSubmitFlagBits", AllVkSubmitFlagBits, pSubmits[submitIndex].flags, kOptionalFlags, "VUID-VkSubmitInfo2-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pSubmits[%i].waitSemaphoreInfoCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pWaitSemaphoreInfos", ParameterName::IndexVector{ submitIndex }), "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", pSubmits[submitIndex].waitSemaphoreInfoCount, pSubmits[submitIndex].pWaitSemaphoreInfos, VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType", "VUID-VkSubmitInfo2-pWaitSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pWaitSemaphoreInfos != nullptr)
            {
                for (uint32_t waitSemaphoreInfoIndex = 0; waitSemaphoreInfoIndex < pSubmits[submitIndex].waitSemaphoreInfoCount; ++waitSemaphoreInfoIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pWaitSemaphoreInfos[%i].pNext", ParameterName::IndexVector{ submitIndex, waitSemaphoreInfoIndex }), nullptr, pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRequiredHandle(loc, ParameterName("pSubmits[%i].pWaitSemaphoreInfos[%i].semaphore", ParameterName::IndexVector{ submitIndex, waitSemaphoreInfoIndex }), pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].semaphore);

                    skip |= ValidateFlags(loc, ParameterName("pSubmits[%i].pWaitSemaphoreInfos[%i].stageMask", ParameterName::IndexVector{ submitIndex, waitSemaphoreInfoIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].stageMask, kOptionalFlags, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pSubmits[%i].commandBufferInfoCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pCommandBufferInfos", ParameterName::IndexVector{ submitIndex }), "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO", pSubmits[submitIndex].commandBufferInfoCount, pSubmits[submitIndex].pCommandBufferInfos, VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO, false, true, "VUID-VkCommandBufferSubmitInfo-sType-sType", "VUID-VkSubmitInfo2-pCommandBufferInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pCommandBufferInfos != nullptr)
            {
                for (uint32_t commandBufferInfoIndex = 0; commandBufferInfoIndex < pSubmits[submitIndex].commandBufferInfoCount; ++commandBufferInfoIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pCommandBufferInfos[%i].pNext", ParameterName::IndexVector{ submitIndex, commandBufferInfoIndex }), nullptr, pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCommandBufferSubmitInfo-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRequiredHandle(loc, ParameterName("pSubmits[%i].pCommandBufferInfos[%i].commandBuffer", ParameterName::IndexVector{ submitIndex, commandBufferInfoIndex }), pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].commandBuffer);
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pSubmits[%i].signalSemaphoreInfoCount", ParameterName::IndexVector{ submitIndex }), ParameterName("pSubmits[%i].pSignalSemaphoreInfos", ParameterName::IndexVector{ submitIndex }), "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", pSubmits[submitIndex].signalSemaphoreInfoCount, pSubmits[submitIndex].pSignalSemaphoreInfos, VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType", "VUID-VkSubmitInfo2-pSignalSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pSignalSemaphoreInfos != nullptr)
            {
                for (uint32_t signalSemaphoreInfoIndex = 0; signalSemaphoreInfoIndex < pSubmits[submitIndex].signalSemaphoreInfoCount; ++signalSemaphoreInfoIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pSubmits[%i].pSignalSemaphoreInfos[%i].pNext", ParameterName::IndexVector{ submitIndex, signalSemaphoreInfoIndex }), nullptr, pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRequiredHandle(loc, ParameterName("pSubmits[%i].pSignalSemaphoreInfos[%i].semaphore", ParameterName::IndexVector{ submitIndex, signalSemaphoreInfoIndex }), pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].semaphore);

                    skip |= ValidateFlags(loc, ParameterName("pSubmits[%i].pSignalSemaphoreInfos[%i].stageMask", ParameterName::IndexVector{ submitIndex, signalSemaphoreInfoIndex }), "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].stageMask, kOptionalFlags, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteBufferMarker2AMD(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlags2                       stage,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateFlags(loc, "stage", "VkPipelineStageFlagBits2", AllVkPipelineStageFlagBits2, stage, kOptionalFlags, "VUID-vkCmdWriteBufferMarker2AMD-stage-parameter");
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateGetQueueCheckpointData2NV(
    VkQueue                                     queue,
    uint32_t*                                   pCheckpointDataCount,
    VkCheckpointData2NV*                        pCheckpointData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) skip |= OutputExtensionError(loc, "VK_KHR_synchronization2");
    skip |= ValidateStructTypeArray(loc, "pCheckpointDataCount", "pCheckpointData", "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV", pCheckpointDataCount, pCheckpointData, VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV, true, false, false, "VUID-VkCheckpointData2NV-sType-sType", "VUID-vkGetQueueCheckpointData2NV-pCheckpointData-parameter", kVUIDUndefined);
    if (pCheckpointData != nullptr)
    {
        for (uint32_t pCheckpointDataIndex = 0; pCheckpointDataIndex < *pCheckpointDataCount; ++pCheckpointDataIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pCheckpointData[%i].pNext", ParameterName::IndexVector{ pCheckpointDataIndex }), nullptr, pCheckpointData[pCheckpointDataIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCheckpointData2NV-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBuffer2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyBufferInfo2*                    pCopyBufferInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2)) skip |= OutputExtensionError(loc, "VK_KHR_copy_commands2");
    skip |= ValidateStructType(loc, "pCopyBufferInfo", "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2", pCopyBufferInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2, true, "VUID-vkCmdCopyBuffer2-pCopyBufferInfo-parameter", "VUID-VkCopyBufferInfo2-sType-sType");
    if (pCopyBufferInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyBufferInfo->pNext", nullptr, pCopyBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyBufferInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferInfo->srcBuffer", pCopyBufferInfo->srcBuffer);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferInfo->dstBuffer", pCopyBufferInfo->dstBuffer);

        skip |= ValidateStructTypeArray(loc, "pCopyBufferInfo->regionCount", "pCopyBufferInfo->pRegions", "VK_STRUCTURE_TYPE_BUFFER_COPY_2", pCopyBufferInfo->regionCount, pCopyBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_COPY_2, true, true, "VUID-VkBufferCopy2-sType-sType", "VUID-VkCopyBufferInfo2-pRegions-parameter", "VUID-VkCopyBufferInfo2-regionCount-arraylength");

        if (pCopyBufferInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyBufferInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyBufferInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferCopy2-pNext-pNext", kVUIDUndefined, false, true);
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImage2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyImageInfo2*                     pCopyImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2)) skip |= OutputExtensionError(loc, "VK_KHR_copy_commands2");
    skip |= ValidateStructType(loc, "pCopyImageInfo", "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2", pCopyImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2, true, "VUID-vkCmdCopyImage2-pCopyImageInfo-parameter", "VUID-VkCopyImageInfo2-sType-sType");
    if (pCopyImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyImageInfo->pNext", nullptr, pCopyImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyImageInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyImageInfo->srcImage", pCopyImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageInfo->srcImageLayout", "VkImageLayout", pCopyImageInfo->srcImageLayout, "VUID-VkCopyImageInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageInfo->dstImage", pCopyImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageInfo->dstImageLayout", "VkImageLayout", pCopyImageInfo->dstImageLayout, "VUID-VkCopyImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyImageInfo->regionCount", "pCopyImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_COPY_2", pCopyImageInfo->regionCount, pCopyImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true, true, "VUID-VkImageCopy2-sType-sType", "VUID-VkCopyImageInfo2-pRegions-parameter", "VUID-VkCopyImageInfo2-regionCount-arraylength");

        if (pCopyImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyImageInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(loc, ParameterName("pCopyImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBufferToImage2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyBufferToImageInfo2*             pCopyBufferToImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2)) skip |= OutputExtensionError(loc, "VK_KHR_copy_commands2");
    skip |= ValidateStructType(loc, "pCopyBufferToImageInfo", "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2", pCopyBufferToImageInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2, true, "VUID-vkCmdCopyBufferToImage2-pCopyBufferToImageInfo-parameter", "VUID-VkCopyBufferToImageInfo2-sType-sType");
    if (pCopyBufferToImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyBufferToImageInfo->pNext", nullptr, pCopyBufferToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyBufferToImageInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferToImageInfo->srcBuffer", pCopyBufferToImageInfo->srcBuffer);

        skip |= ValidateRequiredHandle(loc, "pCopyBufferToImageInfo->dstImage", pCopyBufferToImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pCopyBufferToImageInfo->dstImageLayout", "VkImageLayout", pCopyBufferToImageInfo->dstImageLayout, "VUID-VkCopyBufferToImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyBufferToImageInfo->regionCount", "pCopyBufferToImageInfo->pRegions", "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", pCopyBufferToImageInfo->regionCount, pCopyBufferToImageInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true, true, "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyBufferToImageInfo2-pRegions-parameter", "VUID-VkCopyBufferToImageInfo2-regionCount-arraylength");

        if (pCopyBufferToImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferToImageInfo->regionCount; ++regionIndex)
            {
                constexpr std::array allowed_structs_VkBufferImageCopy2 = { VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM };

                skip |= ValidateStructPnext(loc, ParameterName("pCopyBufferToImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), "VkCopyCommandTransformInfoQCOM", pCopyBufferToImageInfo->pRegions[regionIndex].pNext, allowed_structs_VkBufferImageCopy2.size(), allowed_structs_VkBufferImageCopy2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext", "VUID-VkBufferImageCopy2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyBufferToImageInfo->pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyBufferToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImageToBuffer2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyImageToBufferInfo2*             pCopyImageToBufferInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2)) skip |= OutputExtensionError(loc, "VK_KHR_copy_commands2");
    skip |= ValidateStructType(loc, "pCopyImageToBufferInfo", "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2", pCopyImageToBufferInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2, true, "VUID-vkCmdCopyImageToBuffer2-pCopyImageToBufferInfo-parameter", "VUID-VkCopyImageToBufferInfo2-sType-sType");
    if (pCopyImageToBufferInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyImageToBufferInfo->pNext", nullptr, pCopyImageToBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToBufferInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCopyImageToBufferInfo->srcImage", pCopyImageToBufferInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageToBufferInfo->srcImageLayout", "VkImageLayout", pCopyImageToBufferInfo->srcImageLayout, "VUID-VkCopyImageToBufferInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageToBufferInfo->dstBuffer", pCopyImageToBufferInfo->dstBuffer);

        skip |= ValidateStructTypeArray(loc, "pCopyImageToBufferInfo->regionCount", "pCopyImageToBufferInfo->pRegions", "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", pCopyImageToBufferInfo->regionCount, pCopyImageToBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true, true, "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyImageToBufferInfo2-pRegions-parameter", "VUID-VkCopyImageToBufferInfo2-regionCount-arraylength");

        if (pCopyImageToBufferInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToBufferInfo->regionCount; ++regionIndex)
            {
                constexpr std::array allowed_structs_VkBufferImageCopy2 = { VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM };

                skip |= ValidateStructPnext(loc, ParameterName("pCopyImageToBufferInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), "VkCopyCommandTransformInfoQCOM", pCopyImageToBufferInfo->pRegions[regionIndex].pNext, allowed_structs_VkBufferImageCopy2.size(), allowed_structs_VkBufferImageCopy2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext", "VUID-VkBufferImageCopy2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyImageToBufferInfo->pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageToBufferInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBlitImage2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkBlitImageInfo2*                     pBlitImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2)) skip |= OutputExtensionError(loc, "VK_KHR_copy_commands2");
    skip |= ValidateStructType(loc, "pBlitImageInfo", "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2", pBlitImageInfo, VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2, true, "VUID-vkCmdBlitImage2-pBlitImageInfo-parameter", "VUID-VkBlitImageInfo2-sType-sType");
    if (pBlitImageInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkBlitImageInfo2 = { VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM };

        skip |= ValidateStructPnext(loc, "pBlitImageInfo->pNext", "VkBlitImageCubicWeightsInfoQCOM", pBlitImageInfo->pNext, allowed_structs_VkBlitImageInfo2.size(), allowed_structs_VkBlitImageInfo2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBlitImageInfo2-pNext-pNext", "VUID-VkBlitImageInfo2-sType-unique", false, true);

        skip |= ValidateRequiredHandle(loc, "pBlitImageInfo->srcImage", pBlitImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pBlitImageInfo->srcImageLayout", "VkImageLayout", pBlitImageInfo->srcImageLayout, "VUID-VkBlitImageInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pBlitImageInfo->dstImage", pBlitImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pBlitImageInfo->dstImageLayout", "VkImageLayout", pBlitImageInfo->dstImageLayout, "VUID-VkBlitImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pBlitImageInfo->regionCount", "pBlitImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_BLIT_2", pBlitImageInfo->regionCount, pBlitImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_BLIT_2, true, true, "VUID-VkImageBlit2-sType-sType", "VUID-VkBlitImageInfo2-pRegions-parameter", "VUID-VkBlitImageInfo2-regionCount-arraylength");

        if (pBlitImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pBlitImageInfo->regionCount; ++regionIndex)
            {
                constexpr std::array allowed_structs_VkImageBlit2 = { VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM };

                skip |= ValidateStructPnext(loc, ParameterName("pBlitImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), "VkCopyCommandTransformInfoQCOM", pBlitImageInfo->pRegions[regionIndex].pNext, allowed_structs_VkImageBlit2.size(), allowed_structs_VkImageBlit2.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageBlit2-pNext-pNext", "VUID-VkImageBlit2-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pBlitImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                skip |= ValidateFlags(loc, ParameterName("pBlitImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
            }
        }

        skip |= ValidateRangedEnum(loc, "pBlitImageInfo->filter", "VkFilter", pBlitImageInfo->filter, "VUID-VkBlitImageInfo2-filter-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResolveImage2KHR(
    VkCommandBuffer                             commandBuffer,
    const VkResolveImageInfo2*                  pResolveImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2)) skip |= OutputExtensionError(loc, "VK_KHR_copy_commands2");
    skip |= ValidateStructType(loc, "pResolveImageInfo", "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2", pResolveImageInfo, VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2, true, "VUID-vkCmdResolveImage2-pResolveImageInfo-parameter", "VUID-VkResolveImageInfo2-sType-sType");
    if (pResolveImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pResolveImageInfo->pNext", nullptr, pResolveImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkResolveImageInfo2-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pResolveImageInfo->srcImage", pResolveImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pResolveImageInfo->srcImageLayout", "VkImageLayout", pResolveImageInfo->srcImageLayout, "VUID-VkResolveImageInfo2-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pResolveImageInfo->dstImage", pResolveImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pResolveImageInfo->dstImageLayout", "VkImageLayout", pResolveImageInfo->dstImageLayout, "VUID-VkResolveImageInfo2-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pResolveImageInfo->regionCount", "pResolveImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2", pResolveImageInfo->regionCount, pResolveImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2, true, true, "VUID-VkImageResolve2-sType-sType", "VUID-VkResolveImageInfo2-pRegions-parameter", "VUID-VkResolveImageInfo2-regionCount-arraylength");

        if (pResolveImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pResolveImageInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pResolveImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pResolveImageInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageResolve2-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pResolveImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pResolveImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(loc, ParameterName("pResolveImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pResolveImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysIndirect2KHR(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             indirectDeviceAddress,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_maintenance1)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_maintenance1");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceBufferMemoryRequirementsKHR(
    VkDevice                                    device,
    const VkDeviceBufferMemoryRequirements*     pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance4)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance4");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS", pInfo, VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS, true, "VUID-vkGetDeviceBufferMemoryRequirements-pInfo-parameter", "VUID-VkDeviceBufferMemoryRequirements-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceBufferMemoryRequirements-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true, "VUID-VkDeviceBufferMemoryRequirements-pCreateInfo-parameter", "VUID-VkBufferCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkBufferCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO, VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionBufferCreateInfoFUCHSIA, VkBufferDeviceAddressCreateInfoEXT, VkBufferOpaqueCaptureAddressCreateInfo, VkBufferUsageFlags2CreateInfoKHR, VkDedicatedAllocationBufferCreateInfoNV, VkExternalMemoryBufferCreateInfo, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(), allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkBufferCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter");
        }
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetDeviceBufferMemoryRequirements-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageMemoryRequirementsKHR(
    VkDevice                                    device,
    const VkDeviceImageMemoryRequirements*      pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance4)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance4");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS", pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true, "VUID-vkGetDeviceImageMemoryRequirements-pInfo-parameter", "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->imageType", "VkImageType", pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->format", "VkFormat", pInfo->pCreateInfo->format, "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->tiling", "VkImageTiling", pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->initialLayout", "VkImageLayout", pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= ValidateFlags(loc, "pInfo->planeAspect", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pInfo->planeAspect, kOptionalSingleBit, "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetDeviceImageMemoryRequirements-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageSparseMemoryRequirementsKHR(
    VkDevice                                    device,
    const VkDeviceImageMemoryRequirements*      pInfo,
    uint32_t*                                   pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2*           pSparseMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance4)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance4");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS", pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true, "VUID-vkGetDeviceImageSparseMemoryRequirements-pInfo-parameter", "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->imageType", "VkImageType", pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->format", "VkFormat", pInfo->pCreateInfo->format, "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->tiling", "VkImageTiling", pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->initialLayout", "VkImageLayout", pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= ValidateFlags(loc, "pInfo->planeAspect", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pInfo->planeAspect, kOptionalSingleBit, "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= ValidateStructTypeArray(loc, "pSparseMemoryRequirementCount", "pSparseMemoryRequirements", "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2", pSparseMemoryRequirementCount, pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false, "VUID-VkSparseImageMemoryRequirements2-sType-sType", "VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr)
    {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount; ++pSparseMemoryRequirementIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pSparseMemoryRequirements[%i].pNext", ParameterName::IndexVector{ pSparseMemoryRequirementIndex }), nullptr, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindIndexBuffer2KHR(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkIndexType                                 indexType,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance5");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRangedEnum(loc, "indexType", "VkIndexType", indexType, "VUID-vkCmdBindIndexBuffer2KHR-indexType-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRenderingAreaGranularityKHR(
    VkDevice                                    device,
    const VkRenderingAreaInfoKHR*               pRenderingAreaInfo,
    VkExtent2D*                                 pGranularity,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance5");
    skip |= ValidateStructType(loc, "pRenderingAreaInfo", "VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR", pRenderingAreaInfo, VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR, true, "VUID-vkGetRenderingAreaGranularityKHR-pRenderingAreaInfo-parameter", "VUID-VkRenderingAreaInfoKHR-sType-sType");
    if (pRenderingAreaInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pRenderingAreaInfo->pNext", nullptr, pRenderingAreaInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAreaInfoKHR-pNext-pNext", kVUIDUndefined, false, true);
    }
    skip |= ValidateRequiredPointer(loc, "pGranularity", pGranularity, "VUID-vkGetRenderingAreaGranularityKHR-pGranularity-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageSubresourceLayoutKHR(
    VkDevice                                    device,
    const VkDeviceImageSubresourceInfoKHR*      pInfo,
    VkSubresourceLayout2KHR*                    pLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance5");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR, true, "VUID-vkGetDeviceImageSubresourceLayoutKHR-pInfo-parameter", "VUID-VkDeviceImageSubresourceInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceImageSubresourceInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pInfo->pCreateInfo", "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true, "VUID-VkDeviceImageSubresourceInfoKHR-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr)
        {
            constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

            skip |= ValidateStructPnext(loc, "pInfo->pCreateInfo->pNext", "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->imageType", "VkImageType", pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->format", "VkFormat", pInfo->pCreateInfo->format, "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->tiling", "VkImageTiling", pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= ValidateFlags(loc, "pInfo->pCreateInfo->usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->sharingMode", "VkSharingMode", pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= ValidateRangedEnum(loc, "pInfo->pCreateInfo->initialLayout", "VkImageLayout", pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= ValidateStructType(loc, "pInfo->pSubresource", "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR", pInfo->pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, true, "VUID-VkDeviceImageSubresourceInfoKHR-pSubresource-parameter", "VUID-VkImageSubresource2KHR-sType-sType");

        if (pInfo->pSubresource != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pInfo->pSubresource->pNext", nullptr, pInfo->pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageSubresource2KHR-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateFlags(loc, "pInfo->pSubresource->imageSubresource.aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pInfo->pSubresource->imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");
        }
    }
    skip |= ValidateStructType(loc, "pLayout", "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR", pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, true, "VUID-vkGetDeviceImageSubresourceLayoutKHR-pLayout-parameter", "VUID-VkSubresourceLayout2KHR-sType-sType");
    if (pLayout != nullptr)
    {
        constexpr std::array allowed_structs_VkSubresourceLayout2KHR = { VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT };

        skip |= ValidateStructPnext(loc, "pLayout->pNext", "VkImageCompressionPropertiesEXT, VkSubresourceHostMemcpySizeEXT", pLayout->pNext, allowed_structs_VkSubresourceLayout2KHR.size(), allowed_structs_VkSubresourceLayout2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubresourceLayout2KHR-pNext-pNext", "VUID-VkSubresourceLayout2KHR-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSubresourceLayout2KHR(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource2KHR*               pSubresource,
    VkSubresourceLayout2KHR*                    pLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, "VK_KHR_maintenance5");
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateStructType(loc, "pSubresource", "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR", pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, true, "VUID-vkGetImageSubresourceLayout2KHR-pSubresource-parameter", "VUID-VkImageSubresource2KHR-sType-sType");
    if (pSubresource != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSubresource->pNext", nullptr, pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageSubresource2KHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pSubresource->imageSubresource.aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pSubresource->imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |= ValidateStructType(loc, "pLayout", "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR", pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, true, "VUID-vkGetImageSubresourceLayout2KHR-pLayout-parameter", "VUID-VkSubresourceLayout2KHR-sType-sType");
    if (pLayout != nullptr)
    {
        constexpr std::array allowed_structs_VkSubresourceLayout2KHR = { VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT };

        skip |= ValidateStructPnext(loc, "pLayout->pNext", "VkImageCompressionPropertiesEXT, VkSubresourceHostMemcpySizeEXT", pLayout->pNext, allowed_structs_VkSubresourceLayout2KHR.size(), allowed_structs_VkSubresourceLayout2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubresourceLayout2KHR-pNext-pNext", "VUID-VkSubresourceLayout2KHR-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCooperativeMatrixPropertiesKHR(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkCooperativeMatrixPropertiesKHR*           pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR, true, false, false, "VUID-VkCooperativeMatrixPropertiesKHR-sType-sType", "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR-pProperties-parameter", kVUIDUndefined);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDebugReportCallbackEXT(
    VkInstance                                  instance,
    const VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugReportCallbackEXT*                   pCallback,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_report) skip |= OutputExtensionError(loc, "VK_EXT_debug_report");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, true, "VUID-vkCreateDebugReportCallbackEXT-pCreateInfo-parameter", "VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkDebugReportFlagBitsEXT", AllVkDebugReportFlagBitsEXT, pCreateInfo->flags, kOptionalFlags, "VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter");

        skip |= ValidateRequiredPointer(loc, "pCreateInfo->pfnCallback", reinterpret_cast<const void*>(pCreateInfo->pfnCallback), "VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pCallback", pCallback, "VUID-vkCreateDebugReportCallbackEXT-pCallback-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDebugReportCallbackEXT(
    VkInstance                                  instance,
    VkDebugReportCallbackEXT                    callback,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_report) skip |= OutputExtensionError(loc, "VK_EXT_debug_report");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDebugReportMessageEXT(
    VkInstance                                  instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    const char*                                 pLayerPrefix,
    const char*                                 pMessage,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_report) skip |= OutputExtensionError(loc, "VK_EXT_debug_report");
    skip |= ValidateFlags(loc, "flags", "VkDebugReportFlagBitsEXT", AllVkDebugReportFlagBitsEXT, flags, kRequiredFlags, "VUID-vkDebugReportMessageEXT-flags-parameter", "VUID-vkDebugReportMessageEXT-flags-requiredbitmask");
    skip |= ValidateRangedEnum(loc, "objectType", "VkDebugReportObjectTypeEXT", objectType, "VUID-vkDebugReportMessageEXT-objectType-parameter");
    skip |= ValidateRequiredPointer(loc, "pLayerPrefix", pLayerPrefix, "VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter");
    skip |= ValidateRequiredPointer(loc, "pMessage", pMessage, "VUID-vkDebugReportMessageEXT-pMessage-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDebugMarkerSetObjectTagEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectTagInfoEXT*        pTagInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, "VK_EXT_debug_marker");
    skip |= ValidateStructType(loc, "pTagInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT", pTagInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT, true, "VUID-vkDebugMarkerSetObjectTagEXT-pTagInfo-parameter", "VUID-VkDebugMarkerObjectTagInfoEXT-sType-sType");
    if (pTagInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pTagInfo->pNext", nullptr, pTagInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugMarkerObjectTagInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pTagInfo->objectType", "VkDebugReportObjectTypeEXT", pTagInfo->objectType, "VUID-VkDebugMarkerObjectTagInfoEXT-objectType-parameter");

        skip |= ValidateArray(loc, "pTagInfo->tagSize", "pTagInfo->pTag", pTagInfo->tagSize, &pTagInfo->pTag, true, true, "VUID-VkDebugMarkerObjectTagInfoEXT-tagSize-arraylength", "VUID-VkDebugMarkerObjectTagInfoEXT-pTag-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDebugMarkerSetObjectNameEXT(
    VkDevice                                    device,
    const VkDebugMarkerObjectNameInfoEXT*       pNameInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, "VK_EXT_debug_marker");
    skip |= ValidateStructType(loc, "pNameInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT", pNameInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT, true, "VUID-vkDebugMarkerSetObjectNameEXT-pNameInfo-parameter", "VUID-VkDebugMarkerObjectNameInfoEXT-sType-sType");
    if (pNameInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pNameInfo->pNext", nullptr, pNameInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugMarkerObjectNameInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pNameInfo->objectType", "VkDebugReportObjectTypeEXT", pNameInfo->objectType, "VUID-VkDebugMarkerObjectNameInfoEXT-objectType-parameter");

        skip |= ValidateRequiredPointer(loc, "pNameInfo->pObjectName", pNameInfo->pObjectName, "VUID-VkDebugMarkerObjectNameInfoEXT-pObjectName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDebugMarkerBeginEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, "VK_EXT_debug_marker");
    skip |= ValidateStructType(loc, "pMarkerInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT", pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, true, "VUID-vkCmdDebugMarkerBeginEXT-pMarkerInfo-parameter", "VUID-VkDebugMarkerMarkerInfoEXT-sType-sType");
    if (pMarkerInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMarkerInfo->pNext", nullptr, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pMarkerInfo->pMarkerName", pMarkerInfo->pMarkerName, "VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDebugMarkerEndEXT(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, "VK_EXT_debug_marker");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDebugMarkerInsertEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, "VK_EXT_debug_marker");
    skip |= ValidateStructType(loc, "pMarkerInfo", "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT", pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, true, "VUID-vkCmdDebugMarkerInsertEXT-pMarkerInfo-parameter", "VUID-VkDebugMarkerMarkerInfoEXT-sType-sType");
    if (pMarkerInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMarkerInfo->pNext", nullptr, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pMarkerInfo->pMarkerName", pMarkerInfo->pMarkerName, "VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindTransformFeedbackBuffersEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets,
    const VkDeviceSize*                         pSizes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) skip |= OutputExtensionError(loc, "VK_EXT_transform_feedback");
    skip |= ValidateHandleArray(loc, "bindingCount", "pBuffers", bindingCount, pBuffers, true, true, "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength");
    skip |= ValidateArray(loc, "bindingCount", "pOffsets", bindingCount, &pOffsets, true, true, "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength", "VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-parameter");
    skip |= ValidateArray(loc, "bindingCount", "", bindingCount, &pSizes, true, false, "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength", kVUIDUndefined);
    if (!skip) skip |= manual_PreCallValidateCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginTransformFeedbackEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const VkBuffer*                             pCounterBuffers,
    const VkDeviceSize*                         pCounterBufferOffsets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) skip |= OutputExtensionError(loc, "VK_EXT_transform_feedback");
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndTransformFeedbackEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    const VkBuffer*                             pCounterBuffers,
    const VkDeviceSize*                         pCounterBufferOffsets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) skip |= OutputExtensionError(loc, "VK_EXT_transform_feedback");
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginQueryIndexedEXT(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    uint32_t                                    index,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) skip |= OutputExtensionError(loc, "VK_EXT_transform_feedback");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    skip |= ValidateFlags(loc, "flags", "VkQueryControlFlagBits", AllVkQueryControlFlagBits, flags, kOptionalFlags, "VUID-vkCmdBeginQueryIndexedEXT-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndQueryIndexedEXT(
    VkCommandBuffer                             commandBuffer,
    VkQueryPool                                 queryPool,
    uint32_t                                    query,
    uint32_t                                    index,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) skip |= OutputExtensionError(loc, "VK_EXT_transform_feedback");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectByteCountEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    VkBuffer                                    counterBuffer,
    VkDeviceSize                                counterBufferOffset,
    uint32_t                                    counterOffset,
    uint32_t                                    vertexStride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) skip |= OutputExtensionError(loc, "VK_EXT_transform_feedback");
    skip |= ValidateRequiredHandle(loc, "counterBuffer", counterBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCuModuleNVX(
    VkDevice                                    device,
    const VkCuModuleCreateInfoNVX*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCuModuleNVX*                              pModule,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, "VK_NVX_binary_import");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX", pCreateInfo, VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX, true, "VUID-vkCreateCuModuleNVX-pCreateInfo-parameter", "VUID-VkCuModuleCreateInfoNVX-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCuModuleCreateInfoNVX-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateArray(loc, "pCreateInfo->dataSize", "pCreateInfo->pData", pCreateInfo->dataSize, &pCreateInfo->pData, true, true, "VUID-VkCuModuleCreateInfoNVX-dataSize-arraylength", "VUID-VkCuModuleCreateInfoNVX-pData-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pModule", pModule, "VUID-vkCreateCuModuleNVX-pModule-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCuFunctionNVX(
    VkDevice                                    device,
    const VkCuFunctionCreateInfoNVX*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCuFunctionNVX*                            pFunction,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, "VK_NVX_binary_import");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX", pCreateInfo, VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX, true, "VUID-vkCreateCuFunctionNVX-pCreateInfo-parameter", "VUID-VkCuFunctionCreateInfoNVX-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCuFunctionCreateInfoNVX-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->module", pCreateInfo->module);

        skip |= ValidateRequiredPointer(loc, "pCreateInfo->pName", pCreateInfo->pName, "VUID-VkCuFunctionCreateInfoNVX-pName-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pFunction", pFunction, "VUID-vkCreateCuFunctionNVX-pFunction-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCuModuleNVX(
    VkDevice                                    device,
    VkCuModuleNVX                               module,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, "VK_NVX_binary_import");
    skip |= ValidateRequiredHandle(loc, "module", module);
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCuFunctionNVX(
    VkDevice                                    device,
    VkCuFunctionNVX                             function,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, "VK_NVX_binary_import");
    skip |= ValidateRequiredHandle(loc, "function", function);
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCuLaunchKernelNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCuLaunchInfoNVX*                    pLaunchInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, "VK_NVX_binary_import");
    skip |= ValidateStructType(loc, "pLaunchInfo", "VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX", pLaunchInfo, VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX, true, "VUID-vkCmdCuLaunchKernelNVX-pLaunchInfo-parameter", "VUID-VkCuLaunchInfoNVX-sType-sType");
    if (pLaunchInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pLaunchInfo->pNext", nullptr, pLaunchInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCuLaunchInfoNVX-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pLaunchInfo->function", pLaunchInfo->function);

        skip |= ValidateArray(loc, "pLaunchInfo->paramCount", "pLaunchInfo->pParams", pLaunchInfo->paramCount, &pLaunchInfo->pParams, false, true, kVUIDUndefined, "VUID-VkCuLaunchInfoNVX-pParams-parameter");

        skip |= ValidateArray(loc, "pLaunchInfo->extraCount", "pLaunchInfo->pExtras", pLaunchInfo->extraCount, &pLaunchInfo->pExtras, false, true, kVUIDUndefined, "VUID-VkCuLaunchInfoNVX-pExtras-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageViewHandleNVX(
    VkDevice                                    device,
    const VkImageViewHandleInfoNVX*             pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_image_view_handle)) skip |= OutputExtensionError(loc, "VK_NVX_image_view_handle");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX", pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX, true, "VUID-vkGetImageViewHandleNVX-pInfo-parameter", "VUID-VkImageViewHandleInfoNVX-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageViewHandleInfoNVX-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->imageView", pInfo->imageView);

        skip |= ValidateRangedEnum(loc, "pInfo->descriptorType", "VkDescriptorType", pInfo->descriptorType, "VUID-VkImageViewHandleInfoNVX-descriptorType-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageViewAddressNVX(
    VkDevice                                    device,
    VkImageView                                 imageView,
    VkImageViewAddressPropertiesNVX*            pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_image_view_handle)) skip |= OutputExtensionError(loc, "VK_NVX_image_view_handle");
    skip |= ValidateRequiredHandle(loc, "imageView", imageView);
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX", pProperties, VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX, true, "VUID-vkGetImageViewAddressNVX-pProperties-parameter", "VUID-VkImageViewAddressPropertiesNVX-sType-sType");
    if (pProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pProperties->pNext", nullptr, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageViewAddressPropertiesNVX-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_draw_indirect_count)) skip |= OutputExtensionError(loc, "VK_AMD_draw_indirect_count");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_draw_indirect_count)) skip |= OutputExtensionError(loc, "VK_AMD_draw_indirect_count");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderInfoAMD(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    size_t*                                     pInfoSize,
    void*                                       pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_shader_info)) skip |= OutputExtensionError(loc, "VK_AMD_shader_info");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    skip |= ValidateFlags(loc, "shaderStage", "VkShaderStageFlagBits", AllVkShaderStageFlagBits, shaderStage, kRequiredSingleBit, "VUID-vkGetShaderInfoAMD-shaderStage-parameter", "VUID-vkGetShaderInfoAMD-shaderStage-parameter");
    skip |= ValidateRangedEnum(loc, "infoType", "VkShaderInfoTypeAMD", infoType, "VUID-vkGetShaderInfoAMD-infoType-parameter");
    skip |= ValidateArray(loc, "pInfoSize", "pInfo", pInfoSize, &pInfo, true, false, false, kVUIDUndefined, "VUID-vkGetShaderInfoAMD-pInfo-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_GGP
bool StatelessValidation::PreCallValidateCreateStreamDescriptorSurfaceGGP(
    VkInstance                                  instance,
    const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ggp_stream_descriptor_surface) skip |= OutputExtensionError(loc, "VK_GGP_stream_descriptor_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP", pCreateInfo, VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP, true, "VUID-vkCreateStreamDescriptorSurfaceGGP-pCreateInfo-parameter", "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateStreamDescriptorSurfaceGGP-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_GGP

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_nv_external_memory_capabilities) skip |= OutputExtensionError(loc, "VK_NV_external_memory_capabilities");
    skip |= ValidateRangedEnum(loc, "format", "VkFormat", format, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-format-parameter");
    skip |= ValidateRangedEnum(loc, "type", "VkImageType", type, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-type-parameter");
    skip |= ValidateRangedEnum(loc, "tiling", "VkImageTiling", tiling, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-tiling-parameter");
    skip |= ValidateFlags(loc, "usage", "VkImageUsageFlagBits", AllVkImageUsageFlagBits, usage, kRequiredFlags, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-parameter", "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-requiredbitmask");
    skip |= ValidateFlags(loc, "flags", "VkImageCreateFlagBits", AllVkImageCreateFlagBits, flags, kOptionalFlags, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-flags-parameter");
    skip |= ValidateFlags(loc, "externalHandleType", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, externalHandleType, kOptionalFlags, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-externalHandleType-parameter");
    skip |= ValidateRequiredPointer(loc, "pExternalImageFormatProperties", pExternalImageFormatProperties, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-pExternalImageFormatProperties-parameter");
    if (pExternalImageFormatProperties != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetMemoryWin32HandleNV(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    HANDLE*                                     pHandle,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_external_memory_win32)) skip |= OutputExtensionError(loc, "VK_NV_external_memory_win32");
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBitsNV", AllVkExternalMemoryHandleTypeFlagBitsNV, handleType, kRequiredFlags, "VUID-vkGetMemoryWin32HandleNV-handleType-parameter", "VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask");
    skip |= ValidateRequiredPointer(loc, "pHandle", pHandle, "VUID-vkGetMemoryWin32HandleNV-pHandle-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_VI_NN
bool StatelessValidation::PreCallValidateCreateViSurfaceNN(
    VkInstance                                  instance,
    const VkViSurfaceCreateInfoNN*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_nn_vi_surface) skip |= OutputExtensionError(loc, "VK_NN_vi_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN", pCreateInfo, VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN, true, "VUID-vkCreateViSurfaceNN-pCreateInfo-parameter", "VUID-VkViSurfaceCreateInfoNN-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkViSurfaceCreateInfoNN-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateViSurfaceNN-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_VI_NN

bool StatelessValidation::PreCallValidateCmdBeginConditionalRenderingEXT(
    VkCommandBuffer                             commandBuffer,
    const VkConditionalRenderingBeginInfoEXT*   pConditionalRenderingBegin,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_conditional_rendering)) skip |= OutputExtensionError(loc, "VK_EXT_conditional_rendering");
    skip |= ValidateStructType(loc, "pConditionalRenderingBegin", "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT", pConditionalRenderingBegin, VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT, true, "VUID-vkCmdBeginConditionalRenderingEXT-pConditionalRenderingBegin-parameter", "VUID-VkConditionalRenderingBeginInfoEXT-sType-sType");
    if (pConditionalRenderingBegin != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pConditionalRenderingBegin->pNext", nullptr, pConditionalRenderingBegin->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkConditionalRenderingBeginInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pConditionalRenderingBegin->buffer", pConditionalRenderingBegin->buffer);

        skip |= ValidateFlags(loc, "pConditionalRenderingBegin->flags", "VkConditionalRenderingFlagBitsEXT", AllVkConditionalRenderingFlagBitsEXT, pConditionalRenderingBegin->flags, kOptionalFlags, "VUID-VkConditionalRenderingBeginInfoEXT-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndConditionalRenderingEXT(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_conditional_rendering)) skip |= OutputExtensionError(loc, "VK_EXT_conditional_rendering");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWScalingNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewportWScalingNV*                 pViewportWScalings,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_clip_space_w_scaling)) skip |= OutputExtensionError(loc, "VK_NV_clip_space_w_scaling");
    skip |= ValidateArray(loc, "viewportCount", "pViewportWScalings", viewportCount, &pViewportWScalings, true, true, "VUID-vkCmdSetViewportWScalingNV-viewportCount-arraylength", "VUID-vkCmdSetViewportWScalingNV-pViewportWScalings-parameter");
    if (pViewportWScalings != nullptr)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_direct_mode_display) skip |= OutputExtensionError(loc, "VK_EXT_direct_mode_display");
    skip |= ValidateRequiredHandle(loc, "display", display);
    return skip;
}

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
bool StatelessValidation::PreCallValidateAcquireXlibDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    VkDisplayKHR                                display,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_acquire_xlib_display) skip |= OutputExtensionError(loc, "VK_EXT_acquire_xlib_display");
    skip |= ValidateRequiredPointer(loc, "dpy", dpy, "VUID-vkAcquireXlibDisplayEXT-dpy-parameter");
    skip |= ValidateRequiredHandle(loc, "display", display);
    return skip;
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
bool StatelessValidation::PreCallValidateGetRandROutputDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    Display*                                    dpy,
    RROutput                                    rrOutput,
    VkDisplayKHR*                               pDisplay,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_acquire_xlib_display) skip |= OutputExtensionError(loc, "VK_EXT_acquire_xlib_display");
    skip |= ValidateRequiredPointer(loc, "dpy", dpy, "VUID-vkGetRandROutputDisplayEXT-dpy-parameter");
    skip |= ValidateRequiredPointer(loc, "pDisplay", pDisplay, "VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceCapabilities2EXT(
    VkPhysicalDevice                            physicalDevice,
    VkSurfaceKHR                                surface,
    VkSurfaceCapabilities2EXT*                  pSurfaceCapabilities,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_display_surface_counter) skip |= OutputExtensionError(loc, "VK_EXT_display_surface_counter");
    skip |= ValidateRequiredHandle(loc, "surface", surface);
    skip |= ValidateStructType(loc, "pSurfaceCapabilities", "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT", pSurfaceCapabilities, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT, true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter", "VUID-VkSurfaceCapabilities2EXT-sType-sType");
    if (pSurfaceCapabilities != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSurfaceCapabilities->pNext", nullptr, pSurfaceCapabilities->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSurfaceCapabilities2EXT-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDisplayPowerControlEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayPowerInfoEXT*                pDisplayPowerInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control)) skip |= OutputExtensionError(loc, "VK_EXT_display_control");
    skip |= ValidateRequiredHandle(loc, "display", display);
    skip |= ValidateStructType(loc, "pDisplayPowerInfo", "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT", pDisplayPowerInfo, VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT, true, "VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter", "VUID-VkDisplayPowerInfoEXT-sType-sType");
    if (pDisplayPowerInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDisplayPowerInfo->pNext", nullptr, pDisplayPowerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayPowerInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pDisplayPowerInfo->powerState", "VkDisplayPowerStateEXT", pDisplayPowerInfo->powerState, "VUID-VkDisplayPowerInfoEXT-powerState-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateRegisterDeviceEventEXT(
    VkDevice                                    device,
    const VkDeviceEventInfoEXT*                 pDeviceEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control)) skip |= OutputExtensionError(loc, "VK_EXT_display_control");
    skip |= ValidateStructType(loc, "pDeviceEventInfo", "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT", pDeviceEventInfo, VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT, true, "VUID-vkRegisterDeviceEventEXT-pDeviceEventInfo-parameter", "VUID-VkDeviceEventInfoEXT-sType-sType");
    if (pDeviceEventInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDeviceEventInfo->pNext", nullptr, pDeviceEventInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDeviceEventInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pDeviceEventInfo->deviceEvent", "VkDeviceEventTypeEXT", pDeviceEventInfo->deviceEvent, "VUID-VkDeviceEventInfoEXT-deviceEvent-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pFence", pFence, "VUID-vkRegisterDeviceEventEXT-pFence-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateRegisterDisplayEventEXT(
    VkDevice                                    device,
    VkDisplayKHR                                display,
    const VkDisplayEventInfoEXT*                pDisplayEventInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkFence*                                    pFence,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control)) skip |= OutputExtensionError(loc, "VK_EXT_display_control");
    skip |= ValidateRequiredHandle(loc, "display", display);
    skip |= ValidateStructType(loc, "pDisplayEventInfo", "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT", pDisplayEventInfo, VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT, true, "VUID-vkRegisterDisplayEventEXT-pDisplayEventInfo-parameter", "VUID-VkDisplayEventInfoEXT-sType-sType");
    if (pDisplayEventInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDisplayEventInfo->pNext", nullptr, pDisplayEventInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDisplayEventInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pDisplayEventInfo->displayEvent", "VkDisplayEventTypeEXT", pDisplayEventInfo->displayEvent, "VUID-VkDisplayEventInfoEXT-displayEvent-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pFence", pFence, "VUID-vkRegisterDisplayEventEXT-pFence-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetSwapchainCounterEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    uint64_t*                                   pCounterValue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control)) skip |= OutputExtensionError(loc, "VK_EXT_display_control");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    skip |= ValidateFlags(loc, "counter", "VkSurfaceCounterFlagBitsEXT", AllVkSurfaceCounterFlagBitsEXT, counter, kRequiredSingleBit, "VUID-vkGetSwapchainCounterEXT-counter-parameter", "VUID-vkGetSwapchainCounterEXT-counter-parameter");
    skip |= ValidateRequiredPointer(loc, "pCounterValue", pCounterValue, "VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetRefreshCycleDurationGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkRefreshCycleDurationGOOGLE*               pDisplayTimingProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_google_display_timing)) skip |= OutputExtensionError(loc, "VK_GOOGLE_display_timing");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    skip |= ValidateRequiredPointer(loc, "pDisplayTimingProperties", pDisplayTimingProperties, "VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter");
    if (pDisplayTimingProperties != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPastPresentationTimingGOOGLE(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t*                                   pPresentationTimingCount,
    VkPastPresentationTimingGOOGLE*             pPresentationTimings,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_google_display_timing)) skip |= OutputExtensionError(loc, "VK_GOOGLE_display_timing");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    skip |= ValidateArray(loc, "pPresentationTimingCount", "pPresentationTimings", pPresentationTimingCount, &pPresentationTimings, true, false, false, kVUIDUndefined, "VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter");
    if (pPresentationTimings != nullptr)
    {
        for (uint32_t pPresentationTimingIndex = 0; pPresentationTimingIndex < *pPresentationTimingCount; ++pPresentationTimingIndex)
        {
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDiscardRectangleEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    const VkRect2D*                             pDiscardRectangles,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles)) skip |= OutputExtensionError(loc, "VK_EXT_discard_rectangles");
    skip |= ValidateArray(loc, "discardRectangleCount", "pDiscardRectangles", discardRectangleCount, &pDiscardRectangles, true, true, "VUID-vkCmdSetDiscardRectangleEXT-discardRectangleCount-arraylength", "VUID-vkCmdSetDiscardRectangleEXT-pDiscardRectangles-parameter");
    if (pDiscardRectangles != nullptr)
    {
        for (uint32_t discardRectangleIndex = 0; discardRectangleIndex < discardRectangleCount; ++discardRectangleIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDiscardRectangleEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    discardRectangleEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles)) skip |= OutputExtensionError(loc, "VK_EXT_discard_rectangles");
    skip |= ValidateBool32(loc, "discardRectangleEnable", discardRectangleEnable);
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDiscardRectangleModeEXT(
    VkCommandBuffer                             commandBuffer,
    VkDiscardRectangleModeEXT                   discardRectangleMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles)) skip |= OutputExtensionError(loc, "VK_EXT_discard_rectangles");
    skip |= ValidateRangedEnum(loc, "discardRectangleMode", "VkDiscardRectangleModeEXT", discardRectangleMode, "VUID-vkCmdSetDiscardRectangleModeEXT-discardRectangleMode-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateSetHdrMetadataEXT(
    VkDevice                                    device,
    uint32_t                                    swapchainCount,
    const VkSwapchainKHR*                       pSwapchains,
    const VkHdrMetadataEXT*                     pMetadata,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_hdr_metadata)) skip |= OutputExtensionError(loc, "VK_EXT_hdr_metadata");
    skip |= ValidateHandleArray(loc, "swapchainCount", "pSwapchains", swapchainCount, pSwapchains, true, true, "VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength");
    skip |= ValidateStructTypeArray(loc, "swapchainCount", "pMetadata", "VK_STRUCTURE_TYPE_HDR_METADATA_EXT", swapchainCount, pMetadata, VK_STRUCTURE_TYPE_HDR_METADATA_EXT, true, true, "VUID-VkHdrMetadataEXT-sType-sType", "VUID-vkSetHdrMetadataEXT-pMetadata-parameter", "VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength");
    if (pMetadata != nullptr)
    {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pMetadata[%i].pNext", ParameterName::IndexVector{ swapchainIndex }), nullptr, pMetadata[swapchainIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkHdrMetadataEXT-pNext-pNext", kVUIDUndefined, false, true);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_IOS_MVK
bool StatelessValidation::PreCallValidateCreateIOSSurfaceMVK(
    VkInstance                                  instance,
    const VkIOSSurfaceCreateInfoMVK*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_mvk_ios_surface) skip |= OutputExtensionError(loc, "VK_MVK_ios_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK", pCreateInfo, VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK, true, "VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter", "VUID-VkIOSSurfaceCreateInfoMVK-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateIOSSurfaceMVK-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
bool StatelessValidation::PreCallValidateCreateMacOSSurfaceMVK(
    VkInstance                                  instance,
    const VkMacOSSurfaceCreateInfoMVK*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_mvk_macos_surface) skip |= OutputExtensionError(loc, "VK_MVK_macos_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK", pCreateInfo, VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK, true, "VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter", "VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_MACOS_MVK

bool StatelessValidation::PreCallValidateSetDebugUtilsObjectNameEXT(
    VkDevice                                    device,
    const VkDebugUtilsObjectNameInfoEXT*        pNameInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pNameInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT", pNameInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, true, "VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-parameter", "VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType");
    if (pNameInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pNameInfo->pNext", nullptr, pNameInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pNameInfo->objectType", "VkObjectType", pNameInfo->objectType, "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateSetDebugUtilsObjectNameEXT(device, pNameInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateSetDebugUtilsObjectTagEXT(
    VkDevice                                    device,
    const VkDebugUtilsObjectTagInfoEXT*         pTagInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pTagInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT", pTagInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT, true, "VUID-vkSetDebugUtilsObjectTagEXT-pTagInfo-parameter", "VUID-VkDebugUtilsObjectTagInfoEXT-sType-sType");
    if (pTagInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pTagInfo->pNext", nullptr, pTagInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsObjectTagInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pTagInfo->objectType", "VkObjectType", pTagInfo->objectType, "VUID-VkDebugUtilsObjectTagInfoEXT-objectType-parameter");

        skip |= ValidateArray(loc, "pTagInfo->tagSize", "pTagInfo->pTag", pTagInfo->tagSize, &pTagInfo->pTag, true, true, "VUID-VkDebugUtilsObjectTagInfoEXT-tagSize-arraylength", "VUID-VkDebugUtilsObjectTagInfoEXT-pTag-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateSetDebugUtilsObjectTagEXT(device, pTagInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateQueueBeginDebugUtilsLabelEXT(
    VkQueue                                     queue,
    const VkDebugUtilsLabelEXT*                 pLabelInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pLabelInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true, "VUID-vkQueueBeginDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pLabelInfo->pNext", nullptr, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pLabelInfo->pLabelName", pLabelInfo->pLabelName, "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateQueueEndDebugUtilsLabelEXT(
    VkQueue                                     queue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateQueueInsertDebugUtilsLabelEXT(
    VkQueue                                     queue,
    const VkDebugUtilsLabelEXT*                 pLabelInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pLabelInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true, "VUID-vkQueueInsertDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pLabelInfo->pNext", nullptr, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pLabelInfo->pLabelName", pLabelInfo->pLabelName, "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugUtilsLabelEXT*                 pLabelInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pLabelInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true, "VUID-vkCmdBeginDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pLabelInfo->pNext", nullptr, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pLabelInfo->pLabelName", pLabelInfo->pLabelName, "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndDebugUtilsLabelEXT(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer                             commandBuffer,
    const VkDebugUtilsLabelEXT*                 pLabelInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pLabelInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true, "VUID-vkCmdInsertDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pLabelInfo->pNext", nullptr, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pLabelInfo->pLabelName", pLabelInfo->pLabelName, "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDebugUtilsMessengerEXT(
    VkInstance                                  instance,
    const VkDebugUtilsMessengerCreateInfoEXT*   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDebugUtilsMessengerEXT*                   pMessenger,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, true, "VUID-vkCreateDebugUtilsMessengerEXT-pCreateInfo-parameter", "VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask");

        skip |= ValidateFlags(loc, "pCreateInfo->messageSeverity", "VkDebugUtilsMessageSeverityFlagBitsEXT", AllVkDebugUtilsMessageSeverityFlagBitsEXT, pCreateInfo->messageSeverity, kRequiredFlags, "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter", "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask");

        skip |= ValidateFlags(loc, "pCreateInfo->messageType", "VkDebugUtilsMessageTypeFlagBitsEXT", AllVkDebugUtilsMessageTypeFlagBitsEXT, pCreateInfo->messageType, kRequiredFlags, "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter", "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask");

        skip |= ValidateRequiredPointer(loc, "pCreateInfo->pfnUserCallback", reinterpret_cast<const void*>(pCreateInfo->pfnUserCallback), "VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pMessenger", pMessenger, "VUID-vkCreateDebugUtilsMessengerEXT-pMessenger-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDebugUtilsMessengerEXT(
    VkInstance                                  instance,
    VkDebugUtilsMessengerEXT                    messenger,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSubmitDebugUtilsMessageEXT(
    VkInstance                                  instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_debug_utils) skip |= OutputExtensionError(loc, "VK_EXT_debug_utils");
    skip |= ValidateFlags(loc, "messageSeverity", "VkDebugUtilsMessageSeverityFlagBitsEXT", AllVkDebugUtilsMessageSeverityFlagBitsEXT, messageSeverity, kRequiredSingleBit, "VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter", "VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter");
    skip |= ValidateFlags(loc, "messageTypes", "VkDebugUtilsMessageTypeFlagBitsEXT", AllVkDebugUtilsMessageTypeFlagBitsEXT, messageTypes, kRequiredFlags, "VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-parameter", "VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask");
    skip |= ValidateStructType(loc, "pCallbackData", "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT", pCallbackData, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, true, "VUID-vkSubmitDebugUtilsMessageEXT-pCallbackData-parameter", "VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-sType");
    if (pCallbackData != nullptr)
    {
        constexpr std::array allowed_structs_VkDebugUtilsMessengerCallbackDataEXT = { VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT };

        skip |= ValidateStructPnext(loc, "pCallbackData->pNext", "VkDeviceAddressBindingCallbackDataEXT", pCallbackData->pNext, allowed_structs_VkDebugUtilsMessengerCallbackDataEXT.size(), allowed_structs_VkDebugUtilsMessengerCallbackDataEXT.data(), GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsMessengerCallbackDataEXT-pNext-pNext", "VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-unique", false, true);

        skip |= ValidateReservedFlags(loc, "pCallbackData->flags", pCallbackData->flags, "VUID-VkDebugUtilsMessengerCallbackDataEXT-flags-zerobitmask");

        skip |= ValidateRequiredPointer(loc, "pCallbackData->pMessage", pCallbackData->pMessage, "VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessage-parameter");

        skip |= ValidateStructTypeArray(loc, "pCallbackData->queueLabelCount", "pCallbackData->pQueueLabels", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", pCallbackData->queueLabelCount, pCallbackData->pQueueLabels, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, false, true, "VUID-VkDebugUtilsLabelEXT-sType-sType", "VUID-VkDebugUtilsMessengerCallbackDataEXT-pQueueLabels-parameter", kVUIDUndefined);

        if (pCallbackData->pQueueLabels != nullptr)
        {
            for (uint32_t queueLabelIndex = 0; queueLabelIndex < pCallbackData->queueLabelCount; ++queueLabelIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCallbackData->pQueueLabels[%i].pNext", ParameterName::IndexVector{ queueLabelIndex }), nullptr, pCallbackData->pQueueLabels[queueLabelIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRequiredPointer(loc, ParameterName("pCallbackData->pQueueLabels[%i].pLabelName", ParameterName::IndexVector{ queueLabelIndex }), pCallbackData->pQueueLabels[queueLabelIndex].pLabelName, "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pCallbackData->cmdBufLabelCount", "pCallbackData->pCmdBufLabels", "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", pCallbackData->cmdBufLabelCount, pCallbackData->pCmdBufLabels, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, false, true, "VUID-VkDebugUtilsLabelEXT-sType-sType", "VUID-VkDebugUtilsMessengerCallbackDataEXT-pCmdBufLabels-parameter", kVUIDUndefined);

        if (pCallbackData->pCmdBufLabels != nullptr)
        {
            for (uint32_t cmdBufLabelIndex = 0; cmdBufLabelIndex < pCallbackData->cmdBufLabelCount; ++cmdBufLabelIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCallbackData->pCmdBufLabels[%i].pNext", ParameterName::IndexVector{ cmdBufLabelIndex }), nullptr, pCallbackData->pCmdBufLabels[cmdBufLabelIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRequiredPointer(loc, ParameterName("pCallbackData->pCmdBufLabels[%i].pLabelName", ParameterName::IndexVector{ cmdBufLabelIndex }), pCallbackData->pCmdBufLabels[cmdBufLabelIndex].pLabelName, "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
            }
        }

        skip |= ValidateStructTypeArray(loc, "pCallbackData->objectCount", "pCallbackData->pObjects", "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT", pCallbackData->objectCount, pCallbackData->pObjects, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, false, true, "VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType", "VUID-VkDebugUtilsMessengerCallbackDataEXT-pObjects-parameter", kVUIDUndefined);

        if (pCallbackData->pObjects != nullptr)
        {
            for (uint32_t objectIndex = 0; objectIndex < pCallbackData->objectCount; ++objectIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCallbackData->pObjects[%i].pNext", ParameterName::IndexVector{ objectIndex }), nullptr, pCallbackData->pObjects[objectIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pCallbackData->pObjects[%i].objectType", ParameterName::IndexVector{ objectIndex }), "VkObjectType", pCallbackData->pObjects[objectIndex].objectType, "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter");
            }
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool StatelessValidation::PreCallValidateGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice                                    device,
    const struct AHardwareBuffer*               buffer,
    VkAndroidHardwareBufferPropertiesANDROID*   pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_android_external_memory_android_hardware_buffer)) skip |= OutputExtensionError(loc, "VK_ANDROID_external_memory_android_hardware_buffer");
    skip |= ValidateRequiredPointer(loc, "buffer", buffer, "VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-parameter");
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID", pProperties, VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID, true, "VUID-vkGetAndroidHardwareBufferPropertiesANDROID-pProperties-parameter", "VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-sType");
    if (pProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkAndroidHardwareBufferPropertiesANDROID = { VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID, VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID };

        skip |= ValidateStructPnext(loc, "pProperties->pNext", "VkAndroidHardwareBufferFormatProperties2ANDROID, VkAndroidHardwareBufferFormatPropertiesANDROID", pProperties->pNext, allowed_structs_VkAndroidHardwareBufferPropertiesANDROID.size(), allowed_structs_VkAndroidHardwareBufferPropertiesANDROID.data(), GeneratedVulkanHeaderVersion, "VUID-VkAndroidHardwareBufferPropertiesANDROID-pNext-pNext", "VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-unique", false, false);
    }
    return skip;
}
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool StatelessValidation::PreCallValidateGetMemoryAndroidHardwareBufferANDROID(
    VkDevice                                    device,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
    struct AHardwareBuffer**                    pBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_android_external_memory_android_hardware_buffer)) skip |= OutputExtensionError(loc, "VK_ANDROID_external_memory_android_hardware_buffer");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID", pInfo, VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID, true, "VUID-vkGetMemoryAndroidHardwareBufferANDROID-pInfo-parameter", "VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->memory", pInfo->memory);
    }
    skip |= ValidateRequiredPointer(loc, "pBuffer", pBuffer, "VUID-vkGetMemoryAndroidHardwareBufferANDROID-pBuffer-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCreateExecutionGraphPipelinesAMDX(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    skip |= ValidateStructTypeArray(loc, "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX, true, true, "VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-sType", "VUID-vkCreateExecutionGraphPipelinesAMDX-pCreateInfos-parameter", "VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            constexpr std::array allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX = { VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreationFeedbackCreateInfo", pCreateInfos[createInfoIndex].pNext, allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX.size(), allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX.data(), GeneratedVulkanHeaderVersion, "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pNext-pNext", "VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, kOptionalFlags, "VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfos[%i].stageCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pStages", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, false, "VUID-VkPipelineShaderStageCreateInfo-sType-sType", "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pStages-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pStages != nullptr)
            {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex)
                {
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = { VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pStages[%i].pNext", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkDebugUtilsObjectNameInfoEXT, VkPipelineRobustnessCreateInfoEXT, VkPipelineShaderStageModuleIdentifierCreateInfoEXT, VkPipelineShaderStageNodeCreateInfoAMDX, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, VkShaderModuleCreateInfo, VkShaderModuleValidationCacheCreateInfoEXT", pCreateInfos[createInfoIndex].pStages[stageIndex].pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(), allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pStages[%i].flags", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkPipelineShaderStageCreateFlagBits", AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].flags, kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pStages[%i].stage", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= ValidateRequiredPointer(loc, ParameterName("pCreateInfos[%i].pStages[%i].pName", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr)
                    {
                        skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->mapEntryCount", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pMapEntries", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount, &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr)
                        {
                            for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                            {
                                // No xml-driven validation
                            }
                        }

                        skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize, &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= ValidateStructType(loc, ParameterName("pCreateInfos[%i].pLibraryInfo", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR", pCreateInfos[createInfoIndex].pLibraryInfo, VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, false, "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-parameter", "VUID-VkPipelineLibraryCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInfo != nullptr)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pLibraryInfo->pNext", ParameterName::IndexVector{ createInfoIndex }), nullptr, pCreateInfos[createInfoIndex].pLibraryInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pLibraryInfo->libraryCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pLibraryInfo->pLibraries", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pLibraryInfo->libraryCount, &pCreateInfos[createInfoIndex].pLibraryInfo->pLibraries, false, true, kVUIDUndefined, "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }

            skip |= ValidateRequiredHandle(loc, ParameterName("pCreateInfos[%i].layout", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "createInfoCount", "pPipelines", createInfoCount, &pPipelines, true, true, "VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength", "VUID-vkCreateExecutionGraphPipelinesAMDX-pPipelines-parameter");
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateGetExecutionGraphPipelineScratchSizeAMDX(
    VkDevice                                    device,
    VkPipeline                                  executionGraph,
    VkExecutionGraphPipelineScratchSizeAMDX*    pSizeInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    skip |= ValidateRequiredHandle(loc, "executionGraph", executionGraph);
    skip |= ValidateStructType(loc, "pSizeInfo", "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX", pSizeInfo, VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX, true, "VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-pSizeInfo-parameter", "VUID-VkExecutionGraphPipelineScratchSizeAMDX-sType-sType");
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateGetExecutionGraphPipelineNodeIndexAMDX(
    VkDevice                                    device,
    VkPipeline                                  executionGraph,
    const VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo,
    uint32_t*                                   pNodeIndex,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    skip |= ValidateRequiredHandle(loc, "executionGraph", executionGraph);
    skip |= ValidateStructType(loc, "pNodeInfo", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX", pNodeInfo, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, true, "VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeInfo-parameter", "VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType");
    if (pNodeInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pNodeInfo->pNext", nullptr, pNodeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);
    }
    skip |= ValidateRequiredPointer(loc, "pNodeIndex", pNodeIndex, "VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeIndex-parameter");
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCmdInitializeGraphScratchMemoryAMDX(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             scratch,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    // No xml-driven validation
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCmdDispatchGraphAMDX(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             scratch,
    const VkDispatchGraphCountInfoAMDX*         pCountInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    skip |= ValidateRequiredPointer(loc, "pCountInfo", pCountInfo, "VUID-vkCmdDispatchGraphAMDX-pCountInfo-parameter");
    if (pCountInfo != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCmdDispatchGraphIndirectAMDX(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             scratch,
    const VkDispatchGraphCountInfoAMDX*         pCountInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    skip |= ValidateRequiredPointer(loc, "pCountInfo", pCountInfo, "VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-parameter");
    if (pCountInfo != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCmdDispatchGraphIndirectCountAMDX(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             scratch,
    VkDeviceAddress                             countInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) skip |= OutputExtensionError(loc, "VK_AMDX_shader_enqueue");
    // No xml-driven validation
    return skip;
}
#endif // VK_ENABLE_BETA_EXTENSIONS

bool StatelessValidation::PreCallValidateCmdSetSampleLocationsEXT(
    VkCommandBuffer                             commandBuffer,
    const VkSampleLocationsInfoEXT*             pSampleLocationsInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_sample_locations)) skip |= OutputExtensionError(loc, "VK_EXT_sample_locations");
    skip |= ValidateStructType(loc, "pSampleLocationsInfo", "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", pSampleLocationsInfo, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, true, "VUID-vkCmdSetSampleLocationsEXT-pSampleLocationsInfo-parameter", "VUID-VkSampleLocationsInfoEXT-sType-sType");
    if (pSampleLocationsInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSampleLocationsInfo->pNext", nullptr, pSampleLocationsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

        // No xml-driven validation

        skip |= ValidateArray(loc, "pSampleLocationsInfo->sampleLocationsCount", "pSampleLocationsInfo->pSampleLocations", pSampleLocationsInfo->sampleLocationsCount, &pSampleLocationsInfo->pSampleLocations, false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

        if (pSampleLocationsInfo->pSampleLocations != nullptr)
        {
            for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < pSampleLocationsInfo->sampleLocationsCount; ++sampleLocationsIndex)
            {
                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    VkMultisamplePropertiesEXT*                 pMultisampleProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateFlags(loc, "samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, samples, kRequiredSingleBit, "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter", "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter");
    skip |= ValidateStructType(loc, "pMultisampleProperties", "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT", pMultisampleProperties, VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, true, "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-pMultisampleProperties-parameter", "VUID-VkMultisamplePropertiesEXT-sType-sType");
    if (pMultisampleProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMultisampleProperties->pNext", nullptr, pMultisampleProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMultisamplePropertiesEXT-pNext-pNext", kVUIDUndefined, true, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageDrmFormatModifierPropertiesEXT(
    VkDevice                                    device,
    VkImage                                     image,
    VkImageDrmFormatModifierPropertiesEXT*      pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_image_drm_format_modifier)) skip |= OutputExtensionError(loc, "VK_EXT_image_drm_format_modifier");
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT", pProperties, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT, true, "VUID-vkGetImageDrmFormatModifierPropertiesEXT-pProperties-parameter", "VUID-VkImageDrmFormatModifierPropertiesEXT-sType-sType");
    if (pProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pProperties->pNext", nullptr, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageDrmFormatModifierPropertiesEXT-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateValidationCacheEXT(
    VkDevice                                    device,
    const VkValidationCacheCreateInfoEXT*       pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkValidationCacheEXT*                       pValidationCache,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache)) skip |= OutputExtensionError(loc, "VK_EXT_validation_cache");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT, true, "VUID-vkCreateValidationCacheEXT-pCreateInfo-parameter", "VUID-VkValidationCacheCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkValidationCacheCreateInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkValidationCacheCreateInfoEXT-flags-zerobitmask");

        skip |= ValidateArray(loc, "pCreateInfo->initialDataSize", "pCreateInfo->pInitialData", pCreateInfo->initialDataSize, &pCreateInfo->pInitialData, false, true, kVUIDUndefined, "VUID-VkValidationCacheCreateInfoEXT-pInitialData-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pValidationCache", pValidationCache, "VUID-vkCreateValidationCacheEXT-pValidationCache-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyValidationCacheEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache)) skip |= OutputExtensionError(loc, "VK_EXT_validation_cache");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateMergeValidationCachesEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        dstCache,
    uint32_t                                    srcCacheCount,
    const VkValidationCacheEXT*                 pSrcCaches,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache)) skip |= OutputExtensionError(loc, "VK_EXT_validation_cache");
    skip |= ValidateRequiredHandle(loc, "dstCache", dstCache);
    skip |= ValidateHandleArray(loc, "srcCacheCount", "pSrcCaches", srcCacheCount, pSrcCaches, true, true, "VUID-vkMergeValidationCachesEXT-srcCacheCount-arraylength");
    return skip;
}

bool StatelessValidation::PreCallValidateGetValidationCacheDataEXT(
    VkDevice                                    device,
    VkValidationCacheEXT                        validationCache,
    size_t*                                     pDataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache)) skip |= OutputExtensionError(loc, "VK_EXT_validation_cache");
    skip |= ValidateRequiredHandle(loc, "validationCache", validationCache);
    skip |= ValidateArray(loc, "pDataSize", "pData", pDataSize, &pData, true, false, false, kVUIDUndefined, "VUID-vkGetValidationCacheDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindShadingRateImageNV(
    VkCommandBuffer                             commandBuffer,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image)) skip |= OutputExtensionError(loc, "VK_NV_shading_rate_image");
    skip |= ValidateRangedEnum(loc, "imageLayout", "VkImageLayout", imageLayout, "VUID-vkCmdBindShadingRateImageNV-imageLayout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportShadingRatePaletteNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkShadingRatePaletteNV*               pShadingRatePalettes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image)) skip |= OutputExtensionError(loc, "VK_NV_shading_rate_image");
    skip |= ValidateArray(loc, "viewportCount", "pShadingRatePalettes", viewportCount, &pShadingRatePalettes, true, true, "VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-arraylength", "VUID-vkCmdSetViewportShadingRatePaletteNV-pShadingRatePalettes-parameter");
    if (pShadingRatePalettes != nullptr)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            skip |= ValidateRangedEnumArray(loc, ParameterName("pShadingRatePalettes[%i].shadingRatePaletteEntryCount", ParameterName::IndexVector{ viewportIndex }), ParameterName("pShadingRatePalettes[%i].pShadingRatePaletteEntries", ParameterName::IndexVector{ viewportIndex }), "VkShadingRatePaletteEntryNV", pShadingRatePalettes[viewportIndex].shadingRatePaletteEntryCount, pShadingRatePalettes[viewportIndex].pShadingRatePaletteEntries, true, true);
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoarseSampleOrderNV(
    VkCommandBuffer                             commandBuffer,
    VkCoarseSampleOrderTypeNV                   sampleOrderType,
    uint32_t                                    customSampleOrderCount,
    const VkCoarseSampleOrderCustomNV*          pCustomSampleOrders,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image)) skip |= OutputExtensionError(loc, "VK_NV_shading_rate_image");
    skip |= ValidateRangedEnum(loc, "sampleOrderType", "VkCoarseSampleOrderTypeNV", sampleOrderType, "VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-parameter");
    skip |= ValidateArray(loc, "customSampleOrderCount", "pCustomSampleOrders", customSampleOrderCount, &pCustomSampleOrders, false, true, kVUIDUndefined, "VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-parameter");
    if (pCustomSampleOrders != nullptr)
    {
        for (uint32_t customSampleOrderIndex = 0; customSampleOrderIndex < customSampleOrderCount; ++customSampleOrderIndex)
        {
            skip |= ValidateRangedEnum(loc, ParameterName("pCustomSampleOrders[%i].shadingRate", ParameterName::IndexVector{ customSampleOrderIndex }), "VkShadingRatePaletteEntryNV", pCustomSampleOrders[customSampleOrderIndex].shadingRate, "VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter");

            skip |= ValidateArray(loc, ParameterName("pCustomSampleOrders[%i].sampleLocationCount", ParameterName::IndexVector{ customSampleOrderIndex }), ParameterName("pCustomSampleOrders[%i].pSampleLocations", ParameterName::IndexVector{ customSampleOrderIndex }), pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount, &pCustomSampleOrders[customSampleOrderIndex].pSampleLocations, true, true, "VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength", "VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter");

            if (pCustomSampleOrders[customSampleOrderIndex].pSampleLocations != nullptr)
            {
                for (uint32_t sampleLocationIndex = 0; sampleLocationIndex < pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount; ++sampleLocationIndex)
                {
                    // No xml-driven validation
                }
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateAccelerationStructureNV(
    VkDevice                                    device,
    const VkAccelerationStructureCreateInfoNV*  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkAccelerationStructureNV*                  pAccelerationStructure,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV", pCreateInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV, true, "VUID-vkCreateAccelerationStructureNV-pCreateInfo-parameter", "VUID-VkAccelerationStructureCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkAccelerationStructureCreateInfoNV = { VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkOpaqueCaptureDescriptorDataCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkAccelerationStructureCreateInfoNV.size(), allowed_structs_VkAccelerationStructureCreateInfoNV.data(), GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureCreateInfoNV-pNext-pNext", "VUID-VkAccelerationStructureCreateInfoNV-sType-unique", false, true);

        skip |= ValidateStructType(loc, "pCreateInfo->info", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV", &(pCreateInfo->info), VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, false, kVUIDUndefined, "VUID-VkAccelerationStructureInfoNV-sType-sType");

        skip |= ValidateStructPnext(loc, "pCreateInfo->info.pNext", nullptr, pCreateInfo->info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->info.geometryCount", "pCreateInfo->info.pGeometries", "VK_STRUCTURE_TYPE_GEOMETRY_NV", pCreateInfo->info.geometryCount, pCreateInfo->info.pGeometries, VK_STRUCTURE_TYPE_GEOMETRY_NV, false, true, "VUID-VkGeometryNV-sType-sType", "VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", kVUIDUndefined);

        if (pCreateInfo->info.pGeometries != nullptr)
        {
            for (uint32_t geometryIndex = 0; geometryIndex < pCreateInfo->info.geometryCount; ++geometryIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->info.pGeometries[%i].pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pCreateInfo->info.pGeometries[geometryIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometryType", ParameterName::IndexVector{ geometryIndex }), "VkGeometryTypeKHR", pCreateInfo->info.pGeometries[geometryIndex].geometryType, "VUID-VkGeometryNV-geometryType-parameter");

                skip |= ValidateStructType(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometry.triangles", ParameterName::IndexVector{ geometryIndex }), "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV", &(pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles), VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, false, kVUIDUndefined, "VUID-VkGeometryTrianglesNV-sType-sType");

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometry.triangles.pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryTrianglesNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometry.triangles.vertexFormat", ParameterName::IndexVector{ geometryIndex }), "VkFormat", pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.vertexFormat, "VUID-VkGeometryTrianglesNV-vertexFormat-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometry.triangles.indexType", ParameterName::IndexVector{ geometryIndex }), "VkIndexType", pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.indexType, "VUID-VkGeometryTrianglesNV-indexType-parameter");

                skip |= ValidateStructType(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometry.aabbs", ParameterName::IndexVector{ geometryIndex }), "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV", &(pCreateInfo->info.pGeometries[geometryIndex].geometry.aabbs), VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, false, kVUIDUndefined, "VUID-VkGeometryAABBNV-sType-sType");

                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->info.pGeometries[%i].geometry.aabbs.pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pCreateInfo->info.pGeometries[geometryIndex].geometry.aabbs.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryAABBNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->info.pGeometries[%i].flags", ParameterName::IndexVector{ geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pCreateInfo->info.pGeometries[geometryIndex].flags, kOptionalFlags, "VUID-VkGeometryNV-flags-parameter");
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pAccelerationStructure", pAccelerationStructure, "VUID-vkCreateAccelerationStructureNV-pAccelerationStructure-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyAccelerationStructureNV(
    VkDevice                                    device,
    VkAccelerationStructureNV                   accelerationStructure,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureMemoryRequirementsNV(
    VkDevice                                    device,
    const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2KHR*                   pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV", pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV, true, "VUID-vkGetAccelerationStructureMemoryRequirementsNV-pInfo-parameter", "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pInfo->type", "VkAccelerationStructureMemoryRequirementsTypeNV", pInfo->type, "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-type-parameter");

        skip |= ValidateRequiredHandle(loc, "pInfo->accelerationStructure", pInfo->accelerationStructure);
    }
    skip |= ValidateRequiredPointer(loc, "pMemoryRequirements", pMemoryRequirements, "VUID-vkGetAccelerationStructureMemoryRequirementsNV-pMemoryRequirements-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateBindAccelerationStructureMemoryNV(
    VkDevice                                    device,
    uint32_t                                    bindInfoCount,
    const VkBindAccelerationStructureMemoryInfoNV* pBindInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateStructTypeArray(loc, "bindInfoCount", "pBindInfos", "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV", bindInfoCount, pBindInfos, VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV, true, true, "VUID-VkBindAccelerationStructureMemoryInfoNV-sType-sType", "VUID-vkBindAccelerationStructureMemoryNV-pBindInfos-parameter", "VUID-vkBindAccelerationStructureMemoryNV-bindInfoCount-arraylength");
    if (pBindInfos != nullptr)
    {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pBindInfos[%i].pNext", ParameterName::IndexVector{ bindInfoIndex }), nullptr, pBindInfos[bindInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBindAccelerationStructureMemoryInfoNV-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].accelerationStructure", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].accelerationStructure);

            skip |= ValidateRequiredHandle(loc, ParameterName("pBindInfos[%i].memory", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].memory);

            skip |= ValidateArray(loc, ParameterName("pBindInfos[%i].deviceIndexCount", ParameterName::IndexVector{ bindInfoIndex }), ParameterName("pBindInfos[%i].pDeviceIndices", ParameterName::IndexVector{ bindInfoIndex }), pBindInfos[bindInfoIndex].deviceIndexCount, &pBindInfos[bindInfoIndex].pDeviceIndices, false, true, kVUIDUndefined, "VUID-VkBindAccelerationStructureMemoryInfoNV-pDeviceIndices-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildAccelerationStructureNV(
    VkCommandBuffer                             commandBuffer,
    const VkAccelerationStructureInfoNV*        pInfo,
    VkBuffer                                    instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    VkAccelerationStructureNV                   dst,
    VkAccelerationStructureNV                   src,
    VkBuffer                                    scratch,
    VkDeviceSize                                scratchOffset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV", pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, true, "VUID-vkCmdBuildAccelerationStructureNV-pInfo-parameter", "VUID-VkAccelerationStructureInfoNV-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructTypeArray(loc, "pInfo->geometryCount", "pInfo->pGeometries", "VK_STRUCTURE_TYPE_GEOMETRY_NV", pInfo->geometryCount, pInfo->pGeometries, VK_STRUCTURE_TYPE_GEOMETRY_NV, false, true, "VUID-VkGeometryNV-sType-sType", "VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", kVUIDUndefined);

        if (pInfo->pGeometries != nullptr)
        {
            for (uint32_t geometryIndex = 0; geometryIndex < pInfo->geometryCount; ++geometryIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pInfo->pGeometries[%i].pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pInfo->pGeometries[geometryIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pInfo->pGeometries[%i].geometryType", ParameterName::IndexVector{ geometryIndex }), "VkGeometryTypeKHR", pInfo->pGeometries[geometryIndex].geometryType, "VUID-VkGeometryNV-geometryType-parameter");

                skip |= ValidateStructType(loc, ParameterName("pInfo->pGeometries[%i].geometry.triangles", ParameterName::IndexVector{ geometryIndex }), "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV", &(pInfo->pGeometries[geometryIndex].geometry.triangles), VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, false, kVUIDUndefined, "VUID-VkGeometryTrianglesNV-sType-sType");

                skip |= ValidateStructPnext(loc, ParameterName("pInfo->pGeometries[%i].geometry.triangles.pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pInfo->pGeometries[geometryIndex].geometry.triangles.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryTrianglesNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pInfo->pGeometries[%i].geometry.triangles.vertexFormat", ParameterName::IndexVector{ geometryIndex }), "VkFormat", pInfo->pGeometries[geometryIndex].geometry.triangles.vertexFormat, "VUID-VkGeometryTrianglesNV-vertexFormat-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pInfo->pGeometries[%i].geometry.triangles.indexType", ParameterName::IndexVector{ geometryIndex }), "VkIndexType", pInfo->pGeometries[geometryIndex].geometry.triangles.indexType, "VUID-VkGeometryTrianglesNV-indexType-parameter");

                skip |= ValidateStructType(loc, ParameterName("pInfo->pGeometries[%i].geometry.aabbs", ParameterName::IndexVector{ geometryIndex }), "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV", &(pInfo->pGeometries[geometryIndex].geometry.aabbs), VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, false, kVUIDUndefined, "VUID-VkGeometryAABBNV-sType-sType");

                skip |= ValidateStructPnext(loc, ParameterName("pInfo->pGeometries[%i].geometry.aabbs.pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pInfo->pGeometries[geometryIndex].geometry.aabbs.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryAABBNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pInfo->pGeometries[%i].flags", ParameterName::IndexVector{ geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfo->pGeometries[geometryIndex].flags, kOptionalFlags, "VUID-VkGeometryNV-flags-parameter");
            }
        }
    }
    skip |= ValidateBool32(loc, "update", update);
    skip |= ValidateRequiredHandle(loc, "dst", dst);
    skip |= ValidateRequiredHandle(loc, "scratch", scratch);
    if (!skip) skip |= manual_PreCallValidateCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyAccelerationStructureNV(
    VkCommandBuffer                             commandBuffer,
    VkAccelerationStructureNV                   dst,
    VkAccelerationStructureNV                   src,
    VkCopyAccelerationStructureModeKHR          mode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateRequiredHandle(loc, "dst", dst);
    skip |= ValidateRequiredHandle(loc, "src", src);
    skip |= ValidateRangedEnum(loc, "mode", "VkCopyAccelerationStructureModeKHR", mode, "VUID-vkCmdCopyAccelerationStructureNV-mode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    VkBuffer                                    missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    VkBuffer                                    hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    VkBuffer                                    callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateRequiredHandle(loc, "raygenShaderBindingTableBuffer", raygenShaderBindingTableBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRayTracingPipelinesNV(
    VkDevice                                    device,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkRayTracingPipelineCreateInfoNV*     pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateStructTypeArray(loc, "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV, true, true, "VUID-VkRayTracingPipelineCreateInfoNV-sType-sType", "VUID-vkCreateRayTracingPipelinesNV-pCreateInfos-parameter", "VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            constexpr std::array allowed_structs_VkRayTracingPipelineCreateInfoNV = { VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlags2CreateInfoKHR, VkPipelineCreationFeedbackCreateInfo", pCreateInfos[createInfoIndex].pNext, allowed_structs_VkRayTracingPipelineCreateInfoNV.size(), allowed_structs_VkRayTracingPipelineCreateInfoNV.data(), GeneratedVulkanHeaderVersion, "VUID-VkRayTracingPipelineCreateInfoNV-pNext-pNext", "VUID-VkRayTracingPipelineCreateInfoNV-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, kOptionalFlags, "VUID-VkRayTracingPipelineCreateInfoNV-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfos[%i].stageCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pStages", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true, "VUID-VkPipelineShaderStageCreateInfo-sType-sType", "VUID-VkRayTracingPipelineCreateInfoNV-pStages-parameter", "VUID-VkRayTracingPipelineCreateInfoNV-stageCount-arraylength");

            if (pCreateInfos[createInfoIndex].pStages != nullptr)
            {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex)
                {
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = { VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pStages[%i].pNext", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkDebugUtilsObjectNameInfoEXT, VkPipelineRobustnessCreateInfoEXT, VkPipelineShaderStageModuleIdentifierCreateInfoEXT, VkPipelineShaderStageNodeCreateInfoAMDX, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, VkShaderModuleCreateInfo, VkShaderModuleValidationCacheCreateInfoEXT", pCreateInfos[createInfoIndex].pStages[stageIndex].pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(), allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pStages[%i].flags", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkPipelineShaderStageCreateFlagBits", AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].flags, kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pStages[%i].stage", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= ValidateRequiredPointer(loc, ParameterName("pCreateInfos[%i].pStages[%i].pName", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr)
                    {
                        skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->mapEntryCount", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pMapEntries", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount, &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr)
                        {
                            for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                            {
                                // No xml-driven validation
                            }
                        }

                        skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize, &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfos[%i].groupCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pGroups", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV", pCreateInfos[createInfoIndex].groupCount, pCreateInfos[createInfoIndex].pGroups, VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV, true, true, "VUID-VkRayTracingShaderGroupCreateInfoNV-sType-sType", "VUID-VkRayTracingPipelineCreateInfoNV-pGroups-parameter", "VUID-VkRayTracingPipelineCreateInfoNV-groupCount-arraylength");

            if (pCreateInfos[createInfoIndex].pGroups != nullptr)
            {
                for (uint32_t groupIndex = 0; groupIndex < pCreateInfos[createInfoIndex].groupCount; ++groupIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pGroups[%i].pNext", ParameterName::IndexVector{ createInfoIndex, groupIndex }), nullptr, pCreateInfos[createInfoIndex].pGroups[groupIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRayTracingShaderGroupCreateInfoNV-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].pGroups[%i].type", ParameterName::IndexVector{ createInfoIndex, groupIndex }), "VkRayTracingShaderGroupTypeKHR", pCreateInfos[createInfoIndex].pGroups[groupIndex].type, "VUID-VkRayTracingShaderGroupCreateInfoNV-type-parameter");
                }
            }

            skip |= ValidateRequiredHandle(loc, ParameterName("pCreateInfos[%i].layout", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "createInfoCount", "pPipelines", createInfoCount, &pPipelines, true, true, "VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength", "VUID-vkCreateRayTracingPipelinesNV-pPipelines-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingShaderGroupHandlesKHR(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-arraylength", "VUID-vkGetRayTracingShaderGroupHandlesKHR-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingShaderGroupHandlesNV(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-arraylength", "VUID-vkGetRayTracingShaderGroupHandlesKHR-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureHandleNV(
    VkDevice                                    device,
    VkAccelerationStructureNV                   accelerationStructure,
    size_t                                      dataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateRequiredHandle(loc, "accelerationStructure", accelerationStructure);
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkGetAccelerationStructureHandleNV-dataSize-arraylength", "VUID-vkGetAccelerationStructureHandleNV-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const VkAccelerationStructureNV*            pAccelerationStructures,
    VkQueryType                                 queryType,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateHandleArray(loc, "accelerationStructureCount", "pAccelerationStructures", accelerationStructureCount, pAccelerationStructures, true, true, "VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructureCount-arraylength");
    skip |= ValidateRangedEnum(loc, "queryType", "VkQueryType", queryType, "VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-parameter");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    if (!skip) skip |= manual_PreCallValidateCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCompileDeferredNV(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    shader,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, "VK_NV_ray_tracing");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryHostPointerPropertiesEXT(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    const void*                                 pHostPointer,
    VkMemoryHostPointerPropertiesEXT*           pMemoryHostPointerProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_external_memory_host)) skip |= OutputExtensionError(loc, "VK_EXT_external_memory_host");
    skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, "VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter", "VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter");
    skip |= ValidateRequiredPointer(loc, "pHostPointer", pHostPointer, "VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-parameter");
    skip |= ValidateStructType(loc, "pMemoryHostPointerProperties", "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT", pMemoryHostPointerProperties, VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, true, "VUID-vkGetMemoryHostPointerPropertiesEXT-pMemoryHostPointerProperties-parameter", "VUID-VkMemoryHostPointerPropertiesEXT-sType-sType");
    if (pMemoryHostPointerProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryHostPointerProperties->pNext", nullptr, pMemoryHostPointerProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryHostPointerPropertiesEXT-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteBufferMarkerAMD(
    VkCommandBuffer                             commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    VkBuffer                                    dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_buffer_marker)) skip |= OutputExtensionError(loc, "VK_AMD_buffer_marker");
    skip |= ValidateFlags(loc, "pipelineStage", "VkPipelineStageFlagBits", AllVkPipelineStageFlagBits, pipelineStage, kOptionalSingleBit, "VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-parameter");
    skip |= ValidateRequiredHandle(loc, "dstBuffer", dstBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pTimeDomainCount,
    VkTimeDomainEXT*                            pTimeDomains,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateArray(loc, "pTimeDomainCount", "pTimeDomains", pTimeDomainCount, &pTimeDomains, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-pTimeDomains-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetCalibratedTimestampsEXT(
    VkDevice                                    device,
    uint32_t                                    timestampCount,
    const VkCalibratedTimestampInfoEXT*         pTimestampInfos,
    uint64_t*                                   pTimestamps,
    uint64_t*                                   pMaxDeviation,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_calibrated_timestamps)) skip |= OutputExtensionError(loc, "VK_EXT_calibrated_timestamps");
    skip |= ValidateStructTypeArray(loc, "timestampCount", "pTimestampInfos", "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT", timestampCount, pTimestampInfos, VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT, true, true, "VUID-VkCalibratedTimestampInfoEXT-sType-sType", "VUID-vkGetCalibratedTimestampsEXT-pTimestampInfos-parameter", "VUID-vkGetCalibratedTimestampsEXT-timestampCount-arraylength");
    if (pTimestampInfos != nullptr)
    {
        for (uint32_t timestampIndex = 0; timestampIndex < timestampCount; ++timestampIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pTimestampInfos[%i].pNext", ParameterName::IndexVector{ timestampIndex }), nullptr, pTimestampInfos[timestampIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCalibratedTimestampInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pTimestampInfos[%i].timeDomain", ParameterName::IndexVector{ timestampIndex }), "VkTimeDomainEXT", pTimestampInfos[timestampIndex].timeDomain, "VUID-VkCalibratedTimestampInfoEXT-timeDomain-parameter");
        }
    }
    skip |= ValidateArray(loc, "timestampCount", "pTimestamps", timestampCount, &pTimestamps, true, true, "VUID-vkGetCalibratedTimestampsEXT-timestampCount-arraylength", "VUID-vkGetCalibratedTimestampsEXT-pTimestamps-parameter");
    skip |= ValidateRequiredPointer(loc, "pMaxDeviation", pMaxDeviation, "VUID-vkGetCalibratedTimestampsEXT-pMaxDeviation-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, "VK_NV_mesh_shader");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, "VK_NV_mesh_shader");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectCountNV(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, "VK_NV_mesh_shader");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetExclusiveScissorEnableNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    const VkBool32*                             pExclusiveScissorEnables,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_scissor_exclusive)) skip |= OutputExtensionError(loc, "VK_NV_scissor_exclusive");
    skip |= ValidateBool32Array(loc, "exclusiveScissorCount", "pExclusiveScissorEnables", exclusiveScissorCount, pExclusiveScissorEnables, true, true);
    if (!skip) skip |= manual_PreCallValidateCmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetExclusiveScissorNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    const VkRect2D*                             pExclusiveScissors,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_scissor_exclusive)) skip |= OutputExtensionError(loc, "VK_NV_scissor_exclusive");
    skip |= ValidateArray(loc, "exclusiveScissorCount", "pExclusiveScissors", exclusiveScissorCount, &pExclusiveScissors, true, true, "VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-arraylength", "VUID-vkCmdSetExclusiveScissorNV-pExclusiveScissors-parameter");
    if (pExclusiveScissors != nullptr)
    {
        for (uint32_t exclusiveScissorIndex = 0; exclusiveScissorIndex < exclusiveScissorCount; ++exclusiveScissorIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCheckpointNV(
    VkCommandBuffer                             commandBuffer,
    const void*                                 pCheckpointMarker,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_diagnostic_checkpoints)) skip |= OutputExtensionError(loc, "VK_NV_device_diagnostic_checkpoints");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetQueueCheckpointDataNV(
    VkQueue                                     queue,
    uint32_t*                                   pCheckpointDataCount,
    VkCheckpointDataNV*                         pCheckpointData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_diagnostic_checkpoints)) skip |= OutputExtensionError(loc, "VK_NV_device_diagnostic_checkpoints");
    skip |= ValidateStructTypeArray(loc, "pCheckpointDataCount", "pCheckpointData", "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV", pCheckpointDataCount, pCheckpointData, VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV, true, false, false, "VUID-VkCheckpointDataNV-sType-sType", "VUID-vkGetQueueCheckpointDataNV-pCheckpointData-parameter", kVUIDUndefined);
    if (pCheckpointData != nullptr)
    {
        for (uint32_t pCheckpointDataIndex = 0; pCheckpointDataIndex < *pCheckpointDataCount; ++pCheckpointDataIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pCheckpointData[%i].pNext", ParameterName::IndexVector{ pCheckpointDataIndex }), nullptr, pCheckpointData[pCheckpointDataIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCheckpointDataNV-pNext-pNext", kVUIDUndefined, false, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateInitializePerformanceApiINTEL(
    VkDevice                                    device,
    const VkInitializePerformanceApiInfoINTEL*  pInitializeInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateStructType(loc, "pInitializeInfo", "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL", pInitializeInfo, VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL, true, "VUID-vkInitializePerformanceApiINTEL-pInitializeInfo-parameter", "VUID-VkInitializePerformanceApiInfoINTEL-sType-sType");
    if (pInitializeInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInitializeInfo->pNext", nullptr, pInitializeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkInitializePerformanceApiInfoINTEL-pNext-pNext", kVUIDUndefined, false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUninitializePerformanceApiINTEL(
    VkDevice                                    device,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPerformanceMarkerINTEL(
    VkCommandBuffer                             commandBuffer,
    const VkPerformanceMarkerInfoINTEL*         pMarkerInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateStructType(loc, "pMarkerInfo", "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL", pMarkerInfo, VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL, true, "VUID-vkCmdSetPerformanceMarkerINTEL-pMarkerInfo-parameter", "VUID-VkPerformanceMarkerInfoINTEL-sType-sType");
    if (pMarkerInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMarkerInfo->pNext", nullptr, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPerformanceMarkerInfoINTEL-pNext-pNext", kVUIDUndefined, false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPerformanceStreamMarkerINTEL(
    VkCommandBuffer                             commandBuffer,
    const VkPerformanceStreamMarkerInfoINTEL*   pMarkerInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateStructType(loc, "pMarkerInfo", "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL", pMarkerInfo, VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL, true, "VUID-vkCmdSetPerformanceStreamMarkerINTEL-pMarkerInfo-parameter", "VUID-VkPerformanceStreamMarkerInfoINTEL-sType-sType");
    if (pMarkerInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMarkerInfo->pNext", nullptr, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPerformanceStreamMarkerInfoINTEL-pNext-pNext", kVUIDUndefined, false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPerformanceOverrideINTEL(
    VkCommandBuffer                             commandBuffer,
    const VkPerformanceOverrideInfoINTEL*       pOverrideInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateStructType(loc, "pOverrideInfo", "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL", pOverrideInfo, VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL, true, "VUID-vkCmdSetPerformanceOverrideINTEL-pOverrideInfo-parameter", "VUID-VkPerformanceOverrideInfoINTEL-sType-sType");
    if (pOverrideInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pOverrideInfo->pNext", nullptr, pOverrideInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPerformanceOverrideInfoINTEL-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pOverrideInfo->type", "VkPerformanceOverrideTypeINTEL", pOverrideInfo->type, "VUID-VkPerformanceOverrideInfoINTEL-type-parameter");

        skip |= ValidateBool32(loc, "pOverrideInfo->enable", pOverrideInfo->enable);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateAcquirePerformanceConfigurationINTEL(
    VkDevice                                    device,
    const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo,
    VkPerformanceConfigurationINTEL*            pConfiguration,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateStructType(loc, "pAcquireInfo", "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL", pAcquireInfo, VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL, true, "VUID-vkAcquirePerformanceConfigurationINTEL-pAcquireInfo-parameter", "VUID-VkPerformanceConfigurationAcquireInfoINTEL-sType-sType");
    if (pAcquireInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pAcquireInfo->pNext", nullptr, pAcquireInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPerformanceConfigurationAcquireInfoINTEL-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pAcquireInfo->type", "VkPerformanceConfigurationTypeINTEL", pAcquireInfo->type, "VUID-VkPerformanceConfigurationAcquireInfoINTEL-type-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pConfiguration", pConfiguration, "VUID-vkAcquirePerformanceConfigurationINTEL-pConfiguration-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateReleasePerformanceConfigurationINTEL(
    VkDevice                                    device,
    VkPerformanceConfigurationINTEL             configuration,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSetPerformanceConfigurationINTEL(
    VkQueue                                     queue,
    VkPerformanceConfigurationINTEL             configuration,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateRequiredHandle(loc, "configuration", configuration);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPerformanceParameterINTEL(
    VkDevice                                    device,
    VkPerformanceParameterTypeINTEL             parameter,
    VkPerformanceValueINTEL*                    pValue,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) skip |= OutputExtensionError(loc, "VK_INTEL_performance_query");
    skip |= ValidateRangedEnum(loc, "parameter", "VkPerformanceParameterTypeINTEL", parameter, "VUID-vkGetPerformanceParameterINTEL-parameter-parameter");
    skip |= ValidateRequiredPointer(loc, "pValue", pValue, "VUID-vkGetPerformanceParameterINTEL-pValue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateSetLocalDimmingAMD(
    VkDevice                                    device,
    VkSwapchainKHR                              swapChain,
    VkBool32                                    localDimmingEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_display_native_hdr)) skip |= OutputExtensionError(loc, "VK_AMD_display_native_hdr");
    skip |= ValidateRequiredHandle(loc, "swapChain", swapChain);
    skip |= ValidateBool32(loc, "localDimmingEnable", localDimmingEnable);
    return skip;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateCreateImagePipeSurfaceFUCHSIA(
    VkInstance                                  instance,
    const VkImagePipeSurfaceCreateInfoFUCHSIA*  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_fuchsia_imagepipe_surface) skip |= OutputExtensionError(loc, "VK_FUCHSIA_imagepipe_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA", pCreateInfo, VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA, true, "VUID-vkCreateImagePipeSurfaceFUCHSIA-pCreateInfo-parameter", "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_METAL_EXT
bool StatelessValidation::PreCallValidateCreateMetalSurfaceEXT(
    VkInstance                                  instance,
    const VkMetalSurfaceCreateInfoEXT*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_metal_surface) skip |= OutputExtensionError(loc, "VK_EXT_metal_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT, true, "VUID-vkCreateMetalSurfaceEXT-pCreateInfo-parameter", "VUID-VkMetalSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMetalSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkMetalSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateMetalSurfaceEXT-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_METAL_EXT

bool StatelessValidation::PreCallValidateGetBufferDeviceAddressEXT(
    VkDevice                                    device,
    const VkBufferDeviceAddressInfo*            pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_buffer_device_address)) skip |= OutputExtensionError(loc, "VK_EXT_buffer_device_address");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true, "VUID-vkGetBufferDeviceAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceToolPropertiesEXT(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pToolCount,
    VkPhysicalDeviceToolProperties*             pToolProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "pToolCount", "pToolProperties", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES", pToolCount, pToolProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, true, false, false, "VUID-VkPhysicalDeviceToolProperties-sType-sType", "VUID-vkGetPhysicalDeviceToolProperties-pToolProperties-parameter", kVUIDUndefined);
    if (pToolProperties != nullptr)
    {
        for (uint32_t pToolIndex = 0; pToolIndex < *pToolCount; ++pToolIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pToolProperties[%i].pNext", ParameterName::IndexVector{ pToolIndex }), nullptr, pToolProperties[pToolIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceToolProperties-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pPropertyCount,
    VkCooperativeMatrixPropertiesNV*            pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "pPropertyCount", "pProperties", "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV", pPropertyCount, pProperties, VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV, true, false, false, "VUID-VkCooperativeMatrixPropertiesNV-sType-sType", "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pProperties-parameter", kVUIDUndefined);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkPhysicalDevice                            physicalDevice,
    uint32_t*                                   pCombinationCount,
    VkFramebufferMixedSamplesCombinationNV*     pCombinations,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc, "pCombinationCount", "pCombinations", "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV", pCombinationCount, pCombinations, VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV, true, false, false, "VUID-VkFramebufferMixedSamplesCombinationNV-sType-sType", "VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-pCombinations-parameter", kVUIDUndefined);
    if (pCombinations != nullptr)
    {
        for (uint32_t pCombinationIndex = 0; pCombinationIndex < *pCombinationCount; ++pCombinationIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pCombinations[%i].pNext", ParameterName::IndexVector{ pCombinationIndex }), nullptr, pCombinations[pCombinationIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkFramebufferMixedSamplesCombinationNV-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfacePresentModes2EXT(
    VkPhysicalDevice                            physicalDevice,
    const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
    uint32_t*                                   pPresentModeCount,
    VkPresentModeKHR*                           pPresentModes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pSurfaceInfo", "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR", pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, true, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-parameter", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = { VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT };

        skip |= ValidateStructPnext(loc, "pSurfaceInfo->pNext", "VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSurfacePresentModeEXT", pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(), allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", true, true);
    }
    skip |= ValidateArray(loc, "pPresentModeCount", "pPresentModes", pPresentModeCount, &pPresentModes, true, false, false, kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModes-parameter");
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateAcquireFullScreenExclusiveModeEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_full_screen_exclusive)) skip |= OutputExtensionError(loc, "VK_EXT_full_screen_exclusive");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateReleaseFullScreenExclusiveModeEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_full_screen_exclusive)) skip |= OutputExtensionError(loc, "VK_EXT_full_screen_exclusive");
    skip |= ValidateRequiredHandle(loc, "swapchain", swapchain);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateCreateHeadlessSurfaceEXT(
    VkInstance                                  instance,
    const VkHeadlessSurfaceCreateInfoEXT*       pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_headless_surface) skip |= OutputExtensionError(loc, "VK_EXT_headless_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, true, "VUID-vkCreateHeadlessSurfaceEXT-pCreateInfo-parameter", "VUID-VkHeadlessSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkHeadlessSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkHeadlessSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateHeadlessSurfaceEXT-pSurface-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineStippleEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    lineStippleFactor,
    uint16_t                                    lineStipplePattern,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_line_rasterization)) skip |= OutputExtensionError(loc, "VK_EXT_line_rasterization");
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateResetQueryPoolEXT(
    VkDevice                                    device,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_query_reset)) skip |= OutputExtensionError(loc, "VK_EXT_host_query_reset");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCullModeEXT(
    VkCommandBuffer                             commandBuffer,
    VkCullModeFlags                             cullMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateFlags(loc, "cullMode", "VkCullModeFlagBits", AllVkCullModeFlagBits, cullMode, kOptionalFlags, "VUID-vkCmdSetCullMode-cullMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFrontFaceEXT(
    VkCommandBuffer                             commandBuffer,
    VkFrontFace                                 frontFace,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "frontFace", "VkFrontFace", frontFace, "VUID-vkCmdSetFrontFace-frontFace-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveTopologyEXT(
    VkCommandBuffer                             commandBuffer,
    VkPrimitiveTopology                         primitiveTopology,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "primitiveTopology", "VkPrimitiveTopology", primitiveTopology, "VUID-vkCmdSetPrimitiveTopology-primitiveTopology-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWithCountEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    viewportCount,
    const VkViewport*                           pViewports,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateArray(loc, "viewportCount", "pViewports", viewportCount, &pViewports, true, true, "VUID-vkCmdSetViewportWithCount-viewportCount-arraylength", "VUID-vkCmdSetViewportWithCount-pViewports-parameter");
    if (pViewports != nullptr)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetScissorWithCountEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    scissorCount,
    const VkRect2D*                             pScissors,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateArray(loc, "scissorCount", "pScissors", scissorCount, &pScissors, true, true, "VUID-vkCmdSetScissorWithCount-scissorCount-arraylength", "VUID-vkCmdSetScissorWithCount-pScissors-parameter");
    if (pScissors != nullptr)
    {
        for (uint32_t scissorIndex = 0; scissorIndex < scissorCount; ++scissorIndex)
        {
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindVertexBuffers2EXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    const VkBuffer*                             pBuffers,
    const VkDeviceSize*                         pOffsets,
    const VkDeviceSize*                         pSizes,
    const VkDeviceSize*                         pStrides,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthTestEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "depthTestEnable", depthTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthWriteEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthWriteEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "depthWriteEnable", depthWriteEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthCompareOpEXT(
    VkCommandBuffer                             commandBuffer,
    VkCompareOp                                 depthCompareOp,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "depthCompareOp", "VkCompareOp", depthCompareOp, "VUID-vkCmdSetDepthCompareOp-depthCompareOp-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBoundsTestEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthBoundsTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "depthBoundsTestEnable", depthBoundsTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilTestEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    stencilTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "stencilTestEnable", stencilTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilOpEXT(
    VkCommandBuffer                             commandBuffer,
    VkStencilFaceFlags                          faceMask,
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateFlags(loc, "faceMask", "VkStencilFaceFlagBits", AllVkStencilFaceFlagBits, faceMask, kRequiredFlags, "VUID-vkCmdSetStencilOp-faceMask-parameter", "VUID-vkCmdSetStencilOp-faceMask-requiredbitmask");
    skip |= ValidateRangedEnum(loc, "failOp", "VkStencilOp", failOp, "VUID-vkCmdSetStencilOp-failOp-parameter");
    skip |= ValidateRangedEnum(loc, "passOp", "VkStencilOp", passOp, "VUID-vkCmdSetStencilOp-passOp-parameter");
    skip |= ValidateRangedEnum(loc, "depthFailOp", "VkStencilOp", depthFailOp, "VUID-vkCmdSetStencilOp-depthFailOp-parameter");
    skip |= ValidateRangedEnum(loc, "compareOp", "VkCompareOp", compareOp, "VUID-vkCmdSetStencilOp-compareOp-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMemoryToImageEXT(
    VkDevice                                    device,
    const VkCopyMemoryToImageInfoEXT*           pCopyMemoryToImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy)) skip |= OutputExtensionError(loc, "VK_EXT_host_image_copy");
    skip |= ValidateStructType(loc, "pCopyMemoryToImageInfo", "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT", pCopyMemoryToImageInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT, true, "VUID-vkCopyMemoryToImageEXT-pCopyMemoryToImageInfo-parameter", "VUID-VkCopyMemoryToImageInfoEXT-sType-sType");
    if (pCopyMemoryToImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyMemoryToImageInfo->pNext", nullptr, pCopyMemoryToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMemoryToImageInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCopyMemoryToImageInfo->flags", "VkHostImageCopyFlagBitsEXT", AllVkHostImageCopyFlagBitsEXT, pCopyMemoryToImageInfo->flags, kOptionalFlags, "VUID-VkCopyMemoryToImageInfoEXT-flags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyMemoryToImageInfo->dstImage", pCopyMemoryToImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pCopyMemoryToImageInfo->dstImageLayout", "VkImageLayout", pCopyMemoryToImageInfo->dstImageLayout, "VUID-VkCopyMemoryToImageInfoEXT-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyMemoryToImageInfo->regionCount", "pCopyMemoryToImageInfo->pRegions", "VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT", pCopyMemoryToImageInfo->regionCount, pCopyMemoryToImageInfo->pRegions, VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT, true, true, "VUID-VkMemoryToImageCopyEXT-sType-sType", "VUID-VkCopyMemoryToImageInfoEXT-pRegions-parameter", "VUID-VkCopyMemoryToImageInfoEXT-regionCount-arraylength");

        if (pCopyMemoryToImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyMemoryToImageInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyMemoryToImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyMemoryToImageInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryToImageCopyEXT-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRequiredPointer(loc, ParameterName("pCopyMemoryToImageInfo->pRegions[%i].pHostPointer", ParameterName::IndexVector{ regionIndex }), pCopyMemoryToImageInfo->pRegions[regionIndex].pHostPointer, "VUID-VkMemoryToImageCopyEXT-pHostPointer-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCopyMemoryToImageInfo->pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyMemoryToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyImageToMemoryEXT(
    VkDevice                                    device,
    const VkCopyImageToMemoryInfoEXT*           pCopyImageToMemoryInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy)) skip |= OutputExtensionError(loc, "VK_EXT_host_image_copy");
    skip |= ValidateStructType(loc, "pCopyImageToMemoryInfo", "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT", pCopyImageToMemoryInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT, true, "VUID-vkCopyImageToMemoryEXT-pCopyImageToMemoryInfo-parameter", "VUID-VkCopyImageToMemoryInfoEXT-sType-sType");
    if (pCopyImageToMemoryInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyImageToMemoryInfo->pNext", nullptr, pCopyImageToMemoryInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCopyImageToMemoryInfo->flags", "VkHostImageCopyFlagBitsEXT", AllVkHostImageCopyFlagBitsEXT, pCopyImageToMemoryInfo->flags, kOptionalFlags, "VUID-VkCopyImageToMemoryInfoEXT-flags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageToMemoryInfo->srcImage", pCopyImageToMemoryInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageToMemoryInfo->srcImageLayout", "VkImageLayout", pCopyImageToMemoryInfo->srcImageLayout, "VUID-VkCopyImageToMemoryInfoEXT-srcImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyImageToMemoryInfo->regionCount", "pCopyImageToMemoryInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT", pCopyImageToMemoryInfo->regionCount, pCopyImageToMemoryInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT, true, true, "VUID-VkImageToMemoryCopyEXT-sType-sType", "VUID-VkCopyImageToMemoryInfoEXT-pRegions-parameter", "VUID-VkCopyImageToMemoryInfoEXT-regionCount-arraylength");

        if (pCopyImageToMemoryInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToMemoryInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyImageToMemoryInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyImageToMemoryInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageToMemoryCopyEXT-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRequiredPointer(loc, ParameterName("pCopyImageToMemoryInfo->pRegions[%i].pHostPointer", ParameterName::IndexVector{ regionIndex }), pCopyImageToMemoryInfo->pRegions[regionIndex].pHostPointer, "VUID-VkImageToMemoryCopyEXT-pHostPointer-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCopyImageToMemoryInfo->pRegions[%i].imageSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageToMemoryInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyImageToImageEXT(
    VkDevice                                    device,
    const VkCopyImageToImageInfoEXT*            pCopyImageToImageInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy)) skip |= OutputExtensionError(loc, "VK_EXT_host_image_copy");
    skip |= ValidateStructType(loc, "pCopyImageToImageInfo", "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT", pCopyImageToImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT, true, "VUID-vkCopyImageToImageEXT-pCopyImageToImageInfo-parameter", "VUID-VkCopyImageToImageInfoEXT-sType-sType");
    if (pCopyImageToImageInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCopyImageToImageInfo->pNext", nullptr, pCopyImageToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToImageInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCopyImageToImageInfo->flags", "VkHostImageCopyFlagBitsEXT", AllVkHostImageCopyFlagBitsEXT, pCopyImageToImageInfo->flags, kOptionalFlags, "VUID-VkCopyImageToImageInfoEXT-flags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageToImageInfo->srcImage", pCopyImageToImageInfo->srcImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageToImageInfo->srcImageLayout", "VkImageLayout", pCopyImageToImageInfo->srcImageLayout, "VUID-VkCopyImageToImageInfoEXT-srcImageLayout-parameter");

        skip |= ValidateRequiredHandle(loc, "pCopyImageToImageInfo->dstImage", pCopyImageToImageInfo->dstImage);

        skip |= ValidateRangedEnum(loc, "pCopyImageToImageInfo->dstImageLayout", "VkImageLayout", pCopyImageToImageInfo->dstImageLayout, "VUID-VkCopyImageToImageInfoEXT-dstImageLayout-parameter");

        skip |= ValidateStructTypeArray(loc, "pCopyImageToImageInfo->regionCount", "pCopyImageToImageInfo->pRegions", "VK_STRUCTURE_TYPE_IMAGE_COPY_2", pCopyImageToImageInfo->regionCount, pCopyImageToImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true, true, "VUID-VkImageCopy2-sType-sType", "VUID-VkCopyImageToImageInfoEXT-pRegions-parameter", "VUID-VkCopyImageToImageInfoEXT-regionCount-arraylength");

        if (pCopyImageToImageInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToImageInfo->regionCount; ++regionIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCopyImageToImageInfo->pRegions[%i].pNext", ParameterName::IndexVector{ regionIndex }), nullptr, pCopyImageToImageInfo->pRegions[regionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateFlags(loc, ParameterName("pCopyImageToImageInfo->pRegions[%i].srcSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageToImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(loc, ParameterName("pCopyImageToImageInfo->pRegions[%i].dstSubresource.aspectMask", ParameterName::IndexVector{ regionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pCopyImageToImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateTransitionImageLayoutEXT(
    VkDevice                                    device,
    uint32_t                                    transitionCount,
    const VkHostImageLayoutTransitionInfoEXT*   pTransitions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy)) skip |= OutputExtensionError(loc, "VK_EXT_host_image_copy");
    skip |= ValidateStructTypeArray(loc, "transitionCount", "pTransitions", "VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT", transitionCount, pTransitions, VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT, true, true, "VUID-VkHostImageLayoutTransitionInfoEXT-sType-sType", "VUID-vkTransitionImageLayoutEXT-pTransitions-parameter", "VUID-vkTransitionImageLayoutEXT-transitionCount-arraylength");
    if (pTransitions != nullptr)
    {
        for (uint32_t transitionIndex = 0; transitionIndex < transitionCount; ++transitionIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pTransitions[%i].pNext", ParameterName::IndexVector{ transitionIndex }), nullptr, pTransitions[transitionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkHostImageLayoutTransitionInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRequiredHandle(loc, ParameterName("pTransitions[%i].image", ParameterName::IndexVector{ transitionIndex }), pTransitions[transitionIndex].image);

            skip |= ValidateRangedEnum(loc, ParameterName("pTransitions[%i].oldLayout", ParameterName::IndexVector{ transitionIndex }), "VkImageLayout", pTransitions[transitionIndex].oldLayout, "VUID-VkHostImageLayoutTransitionInfoEXT-oldLayout-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pTransitions[%i].newLayout", ParameterName::IndexVector{ transitionIndex }), "VkImageLayout", pTransitions[transitionIndex].newLayout, "VUID-VkHostImageLayoutTransitionInfoEXT-newLayout-parameter");

            skip |= ValidateFlags(loc, ParameterName("pTransitions[%i].subresourceRange.aspectMask", ParameterName::IndexVector{ transitionIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pTransitions[transitionIndex].subresourceRange.aspectMask, kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSubresourceLayout2EXT(
    VkDevice                                    device,
    VkImage                                     image,
    const VkImageSubresource2KHR*               pSubresource,
    VkSubresourceLayout2KHR*                    pLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_host_image_copy) || IsExtEnabled(device_extensions.vk_ext_image_compression_control))) skip |= OutputExtensionError(loc, "VK_EXT_host_image_copy || VK_EXT_image_compression_control");
    skip |= ValidateRequiredHandle(loc, "image", image);
    skip |= ValidateStructType(loc, "pSubresource", "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR", pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, true, "VUID-vkGetImageSubresourceLayout2KHR-pSubresource-parameter", "VUID-VkImageSubresource2KHR-sType-sType");
    if (pSubresource != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pSubresource->pNext", nullptr, pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageSubresource2KHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pSubresource->imageSubresource.aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pSubresource->imageSubresource.aspectMask, kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |= ValidateStructType(loc, "pLayout", "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR", pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, true, "VUID-vkGetImageSubresourceLayout2KHR-pLayout-parameter", "VUID-VkSubresourceLayout2KHR-sType-sType");
    if (pLayout != nullptr)
    {
        constexpr std::array allowed_structs_VkSubresourceLayout2KHR = { VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT };

        skip |= ValidateStructPnext(loc, "pLayout->pNext", "VkImageCompressionPropertiesEXT, VkSubresourceHostMemcpySizeEXT", pLayout->pNext, allowed_structs_VkSubresourceLayout2KHR.size(), allowed_structs_VkSubresourceLayout2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSubresourceLayout2KHR-pNext-pNext", "VUID-VkSubresourceLayout2KHR-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseSwapchainImagesEXT(
    VkDevice                                    device,
    const VkReleaseSwapchainImagesInfoEXT*      pReleaseInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1)) skip |= OutputExtensionError(loc, "VK_EXT_swapchain_maintenance1");
    skip |= ValidateStructType(loc, "pReleaseInfo", "VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT", pReleaseInfo, VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT, true, "VUID-vkReleaseSwapchainImagesEXT-pReleaseInfo-parameter", "VUID-VkReleaseSwapchainImagesInfoEXT-sType-sType");
    if (pReleaseInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pReleaseInfo->pNext", nullptr, pReleaseInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkReleaseSwapchainImagesInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pReleaseInfo->swapchain", pReleaseInfo->swapchain);

        skip |= ValidateArray(loc, "pReleaseInfo->imageIndexCount", "pReleaseInfo->pImageIndices", pReleaseInfo->imageIndexCount, &pReleaseInfo->pImageIndices, true, true, "VUID-VkReleaseSwapchainImagesInfoEXT-imageIndexCount-arraylength", "VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetGeneratedCommandsMemoryRequirementsNV(
    VkDevice                                    device,
    const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV", pInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV, true, "VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-parameter", "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pInfo->pipelineBindPoint", "VkPipelineBindPoint", pInfo->pipelineBindPoint, "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-parameter");

        skip |= ValidateRequiredHandle(loc, "pInfo->indirectCommandsLayout", pInfo->indirectCommandsLayout);
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPreprocessGeneratedCommandsNV(
    VkCommandBuffer                             commandBuffer,
    const VkGeneratedCommandsInfoNV*            pGeneratedCommandsInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands");
    skip |= ValidateStructType(loc, "pGeneratedCommandsInfo", "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV", pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, true, "VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoNV-sType-sType");
    if (pGeneratedCommandsInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGeneratedCommandsInfo->pNext", nullptr, pGeneratedCommandsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeneratedCommandsInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pGeneratedCommandsInfo->pipelineBindPoint", "VkPipelineBindPoint", pGeneratedCommandsInfo->pipelineBindPoint, "VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter");

        skip |= ValidateRequiredHandle(loc, "pGeneratedCommandsInfo->pipeline", pGeneratedCommandsInfo->pipeline);

        skip |= ValidateRequiredHandle(loc, "pGeneratedCommandsInfo->indirectCommandsLayout", pGeneratedCommandsInfo->indirectCommandsLayout);

        skip |= ValidateArray(loc, "pGeneratedCommandsInfo->streamCount", "pGeneratedCommandsInfo->pStreams", pGeneratedCommandsInfo->streamCount, &pGeneratedCommandsInfo->pStreams, true, true, "VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength", "VUID-VkGeneratedCommandsInfoNV-pStreams-parameter");

        if (pGeneratedCommandsInfo->pStreams != nullptr)
        {
            for (uint32_t streamIndex = 0; streamIndex < pGeneratedCommandsInfo->streamCount; ++streamIndex)
            {
                skip |= ValidateRequiredHandle(loc, ParameterName("pGeneratedCommandsInfo->pStreams[%i].buffer", ParameterName::IndexVector{ streamIndex }), pGeneratedCommandsInfo->pStreams[streamIndex].buffer);
            }
        }

        skip |= ValidateRequiredHandle(loc, "pGeneratedCommandsInfo->preprocessBuffer", pGeneratedCommandsInfo->preprocessBuffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdExecuteGeneratedCommandsNV(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    isPreprocessed,
    const VkGeneratedCommandsInfoNV*            pGeneratedCommandsInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands");
    skip |= ValidateBool32(loc, "isPreprocessed", isPreprocessed);
    skip |= ValidateStructType(loc, "pGeneratedCommandsInfo", "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV", pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, true, "VUID-vkCmdExecuteGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoNV-sType-sType");
    if (pGeneratedCommandsInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGeneratedCommandsInfo->pNext", nullptr, pGeneratedCommandsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeneratedCommandsInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pGeneratedCommandsInfo->pipelineBindPoint", "VkPipelineBindPoint", pGeneratedCommandsInfo->pipelineBindPoint, "VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter");

        skip |= ValidateRequiredHandle(loc, "pGeneratedCommandsInfo->pipeline", pGeneratedCommandsInfo->pipeline);

        skip |= ValidateRequiredHandle(loc, "pGeneratedCommandsInfo->indirectCommandsLayout", pGeneratedCommandsInfo->indirectCommandsLayout);

        skip |= ValidateArray(loc, "pGeneratedCommandsInfo->streamCount", "pGeneratedCommandsInfo->pStreams", pGeneratedCommandsInfo->streamCount, &pGeneratedCommandsInfo->pStreams, true, true, "VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength", "VUID-VkGeneratedCommandsInfoNV-pStreams-parameter");

        if (pGeneratedCommandsInfo->pStreams != nullptr)
        {
            for (uint32_t streamIndex = 0; streamIndex < pGeneratedCommandsInfo->streamCount; ++streamIndex)
            {
                skip |= ValidateRequiredHandle(loc, ParameterName("pGeneratedCommandsInfo->pStreams[%i].buffer", ParameterName::IndexVector{ streamIndex }), pGeneratedCommandsInfo->pStreams[streamIndex].buffer);
            }
        }

        skip |= ValidateRequiredHandle(loc, "pGeneratedCommandsInfo->preprocessBuffer", pGeneratedCommandsInfo->preprocessBuffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindPipelineShaderGroupNV(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline,
    uint32_t                                    groupIndex,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands");
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateIndirectCommandsLayoutNV(
    VkDevice                                    device,
    const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkIndirectCommandsLayoutNV*                 pIndirectCommandsLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV", pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV, true, "VUID-vkCreateIndirectCommandsLayoutNV-pCreateInfo-parameter", "VUID-VkIndirectCommandsLayoutCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkIndirectCommandsLayoutCreateInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkIndirectCommandsLayoutUsageFlagBitsNV", AllVkIndirectCommandsLayoutUsageFlagBitsNV, pCreateInfo->flags, kOptionalFlags, "VUID-VkIndirectCommandsLayoutCreateInfoNV-flags-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->pipelineBindPoint", "VkPipelineBindPoint", pCreateInfo->pipelineBindPoint, "VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-parameter");

        skip |= ValidateStructTypeArray(loc, "pCreateInfo->tokenCount", "pCreateInfo->pTokens", "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV", pCreateInfo->tokenCount, pCreateInfo->pTokens, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV, true, true, "VUID-VkIndirectCommandsLayoutTokenNV-sType-sType", "VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-parameter", "VUID-VkIndirectCommandsLayoutCreateInfoNV-tokenCount-arraylength");

        if (pCreateInfo->pTokens != nullptr)
        {
            for (uint32_t tokenIndex = 0; tokenIndex < pCreateInfo->tokenCount; ++tokenIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfo->pTokens[%i].pNext", ParameterName::IndexVector{ tokenIndex }), nullptr, pCreateInfo->pTokens[tokenIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkIndirectCommandsLayoutTokenNV-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfo->pTokens[%i].tokenType", ParameterName::IndexVector{ tokenIndex }), "VkIndirectCommandsTokenTypeNV", pCreateInfo->pTokens[tokenIndex].tokenType, "VUID-VkIndirectCommandsLayoutTokenNV-tokenType-parameter");

                skip |= ValidateBool32(loc, ParameterName("pCreateInfo->pTokens[%i].vertexDynamicStride", ParameterName::IndexVector{ tokenIndex }), pCreateInfo->pTokens[tokenIndex].vertexDynamicStride);

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pTokens[%i].pushconstantShaderStageFlags", ParameterName::IndexVector{ tokenIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfo->pTokens[tokenIndex].pushconstantShaderStageFlags, kOptionalFlags, "VUID-VkIndirectCommandsLayoutTokenNV-pushconstantShaderStageFlags-parameter");

                skip |= ValidateFlags(loc, ParameterName("pCreateInfo->pTokens[%i].indirectStateFlags", ParameterName::IndexVector{ tokenIndex }), "VkIndirectStateFlagBitsNV", AllVkIndirectStateFlagBitsNV, pCreateInfo->pTokens[tokenIndex].indirectStateFlags, kOptionalFlags, "VUID-VkIndirectCommandsLayoutTokenNV-indirectStateFlags-parameter");

                skip |= ValidateRangedEnumArray(loc, ParameterName("pCreateInfo->pTokens[%i].indexTypeCount", ParameterName::IndexVector{ tokenIndex }), ParameterName("pCreateInfo->pTokens[%i].pIndexTypes", ParameterName::IndexVector{ tokenIndex }), "VkIndexType", pCreateInfo->pTokens[tokenIndex].indexTypeCount, pCreateInfo->pTokens[tokenIndex].pIndexTypes, false, true);

                skip |= ValidateArray(loc, ParameterName("pCreateInfo->pTokens[%i].indexTypeCount", ParameterName::IndexVector{ tokenIndex }), ParameterName("pCreateInfo->pTokens[%i].pIndexTypeValues", ParameterName::IndexVector{ tokenIndex }), pCreateInfo->pTokens[tokenIndex].indexTypeCount, &pCreateInfo->pTokens[tokenIndex].pIndexTypeValues, false, true, kVUIDUndefined, "VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypeValues-parameter");
            }
        }

        skip |= ValidateArray(loc, "pCreateInfo->streamCount", "pCreateInfo->pStreamStrides", pCreateInfo->streamCount, &pCreateInfo->pStreamStrides, true, true, "VUID-VkIndirectCommandsLayoutCreateInfoNV-streamCount-arraylength", "VUID-VkIndirectCommandsLayoutCreateInfoNV-pStreamStrides-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pIndirectCommandsLayout", pIndirectCommandsLayout, "VUID-vkCreateIndirectCommandsLayoutNV-pIndirectCommandsLayout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyIndirectCommandsLayoutNV(
    VkDevice                                    device,
    VkIndirectCommandsLayoutNV                  indirectCommandsLayout,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBias2EXT(
    VkCommandBuffer                             commandBuffer,
    const VkDepthBiasInfoEXT*                   pDepthBiasInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_depth_bias_control)) skip |= OutputExtensionError(loc, "VK_EXT_depth_bias_control");
    skip |= ValidateStructType(loc, "pDepthBiasInfo", "VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT", pDepthBiasInfo, VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT, true, "VUID-vkCmdSetDepthBias2EXT-pDepthBiasInfo-parameter", "VUID-VkDepthBiasInfoEXT-sType-sType");
    if (pDepthBiasInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkDepthBiasInfoEXT = { VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pDepthBiasInfo->pNext", "VkDepthBiasRepresentationInfoEXT", pDepthBiasInfo->pNext, allowed_structs_VkDepthBiasInfoEXT.size(), allowed_structs_VkDepthBiasInfoEXT.data(), GeneratedVulkanHeaderVersion, "VUID-VkDepthBiasInfoEXT-pNext-pNext", "VUID-VkDepthBiasInfoEXT-sType-unique", false, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireDrmDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    int32_t                                     drmFd,
    VkDisplayKHR                                display,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_acquire_drm_display) skip |= OutputExtensionError(loc, "VK_EXT_acquire_drm_display");
    skip |= ValidateRequiredHandle(loc, "display", display);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDrmDisplayEXT(
    VkPhysicalDevice                            physicalDevice,
    int32_t                                     drmFd,
    uint32_t                                    connectorId,
    VkDisplayKHR*                               display,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_acquire_drm_display) skip |= OutputExtensionError(loc, "VK_EXT_acquire_drm_display");
    skip |= ValidateRequiredPointer(loc, "display", display, "VUID-vkGetDrmDisplayEXT-display-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePrivateDataSlotEXT(
    VkDevice                                    device,
    const VkPrivateDataSlotCreateInfo*          pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkPrivateDataSlot*                          pPrivateDataSlot,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, "VK_EXT_private_data");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO, true, "VUID-vkCreatePrivateDataSlot-pCreateInfo-parameter", "VUID-VkPrivateDataSlotCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPrivateDataSlotCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkPrivateDataSlotCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pPrivateDataSlot", pPrivateDataSlot, "VUID-vkCreatePrivateDataSlot-pPrivateDataSlot-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPrivateDataSlotEXT(
    VkDevice                                    device,
    VkPrivateDataSlot                           privateDataSlot,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, "VK_EXT_private_data");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSetPrivateDataEXT(
    VkDevice                                    device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    VkPrivateDataSlot                           privateDataSlot,
    uint64_t                                    data,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, "VK_EXT_private_data");
    skip |= ValidateRangedEnum(loc, "objectType", "VkObjectType", objectType, "VUID-vkSetPrivateData-objectType-parameter");
    skip |= ValidateRequiredHandle(loc, "privateDataSlot", privateDataSlot);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPrivateDataEXT(
    VkDevice                                    device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    VkPrivateDataSlot                           privateDataSlot,
    uint64_t*                                   pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, "VK_EXT_private_data");
    skip |= ValidateRangedEnum(loc, "objectType", "VkObjectType", objectType, "VUID-vkGetPrivateData-objectType-parameter");
    skip |= ValidateRequiredHandle(loc, "privateDataSlot", privateDataSlot);
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetPrivateData-pData-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_METAL_EXT
bool StatelessValidation::PreCallValidateExportMetalObjectsEXT(
    VkDevice                                    device,
    VkExportMetalObjectsInfoEXT*                pMetalObjectsInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) skip |= OutputExtensionError(loc, "VK_EXT_metal_objects");
    skip |= ValidateStructType(loc, "pMetalObjectsInfo", "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT", pMetalObjectsInfo, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT, true, "VUID-vkExportMetalObjectsEXT-pMetalObjectsInfo-parameter", "VUID-VkExportMetalObjectsInfoEXT-sType-sType");
    if (!skip) skip |= manual_PreCallValidateExportMetalObjectsEXT(device, pMetalObjectsInfo, error_obj);
    return skip;
}
#endif // VK_USE_PLATFORM_METAL_EXT

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutSizeEXT(
    VkDevice                                    device,
    VkDescriptorSetLayout                       layout,
    VkDeviceSize*                               pLayoutSizeInBytes,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    skip |= ValidateRequiredPointer(loc, "pLayoutSizeInBytes", pLayoutSizeInBytes, "VUID-vkGetDescriptorSetLayoutSizeEXT-pLayoutSizeInBytes-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutBindingOffsetEXT(
    VkDevice                                    device,
    VkDescriptorSetLayout                       layout,
    uint32_t                                    binding,
    VkDeviceSize*                               pOffset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    skip |= ValidateRequiredPointer(loc, "pOffset", pOffset, "VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-pOffset-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorEXT(
    VkDevice                                    device,
    const VkDescriptorGetInfoEXT*               pDescriptorInfo,
    size_t                                      dataSize,
    void*                                       pDescriptor,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructType(loc, "pDescriptorInfo", "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT", pDescriptorInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT, true, "VUID-vkGetDescriptorEXT-pDescriptorInfo-parameter", "VUID-VkDescriptorGetInfoEXT-sType-sType");
    if (pDescriptorInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pDescriptorInfo->pNext", nullptr, pDescriptorInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDescriptorGetInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pDescriptorInfo->type", "VkDescriptorType", pDescriptorInfo->type, "VUID-VkDescriptorGetInfoEXT-type-parameter");
    }
    skip |= ValidateArray(loc, "dataSize", "pDescriptor", dataSize, &pDescriptor, true, true, "VUID-vkGetDescriptorEXT-dataSize-arraylength", "VUID-vkGetDescriptorEXT-pDescriptor-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorBuffersEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    bufferCount,
    const VkDescriptorBufferBindingInfoEXT*     pBindingInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructTypeArray(loc, "bufferCount", "pBindingInfos", "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT", bufferCount, pBindingInfos, VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT, true, true, "VUID-VkDescriptorBufferBindingInfoEXT-sType-sType", "VUID-vkCmdBindDescriptorBuffersEXT-pBindingInfos-parameter", "VUID-vkCmdBindDescriptorBuffersEXT-bufferCount-arraylength");
    if (pBindingInfos != nullptr)
    {
        for (uint32_t bufferIndex = 0; bufferIndex < bufferCount; ++bufferIndex)
        {
            constexpr std::array allowed_structs_VkDescriptorBufferBindingInfoEXT = { VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pBindingInfos[%i].pNext", ParameterName::IndexVector{ bufferIndex }), "VkBufferUsageFlags2CreateInfoKHR, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT", pBindingInfos[bufferIndex].pNext, allowed_structs_VkDescriptorBufferBindingInfoEXT.size(), allowed_structs_VkDescriptorBufferBindingInfoEXT.data(), GeneratedVulkanHeaderVersion, "VUID-VkDescriptorBufferBindingInfoEXT-pNext-pNext", "VUID-VkDescriptorBufferBindingInfoEXT-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pBindingInfos[%i].usage", ParameterName::IndexVector{ bufferIndex }), "VkBufferUsageFlagBits", AllVkBufferUsageFlagBits, pBindingInfos[bufferIndex].usage, kRequiredFlags, "VUID-VkDescriptorBufferBindingInfoEXT-usage-parameter", "VUID-VkDescriptorBufferBindingInfoEXT-usage-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDescriptorBufferOffsetsEXT(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    setCount,
    const uint32_t*                             pBufferIndices,
    const VkDeviceSize*                         pOffsets,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    skip |= ValidateArray(loc, "setCount", "pBufferIndices", setCount, &pBufferIndices, true, true, "VUID-vkCmdSetDescriptorBufferOffsetsEXT-setCount-arraylength", "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pBufferIndices-parameter");
    skip |= ValidateArray(loc, "setCount", "pOffsets", setCount, &pOffsets, true, true, "VUID-vkCmdSetDescriptorBufferOffsetsEXT-setCount-arraylength", "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pOffsets-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorBufferEmbeddedSamplersEXT(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipelineLayout                            layout,
    uint32_t                                    set,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdBindDescriptorBufferEmbeddedSamplersEXT-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "layout", layout);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferOpaqueCaptureDescriptorDataEXT(
    VkDevice                                    device,
    const VkBufferCaptureDescriptorDataInfoEXT* pInfo,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true, "VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pInfo-parameter", "VUID-VkBufferCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->buffer", pInfo->buffer);
    }
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageOpaqueCaptureDescriptorDataEXT(
    VkDevice                                    device,
    const VkImageCaptureDescriptorDataInfoEXT*  pInfo,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true, "VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pInfo-parameter", "VUID-VkImageCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->image", pInfo->image);
    }
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageViewOpaqueCaptureDescriptorDataEXT(
    VkDevice                                    device,
    const VkImageViewCaptureDescriptorDataInfoEXT* pInfo,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true, "VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-pInfo-parameter", "VUID-VkImageViewCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageViewCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->imageView", pInfo->imageView);
    }
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetSamplerOpaqueCaptureDescriptorDataEXT(
    VkDevice                                    device,
    const VkSamplerCaptureDescriptorDataInfoEXT* pInfo,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true, "VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-pInfo-parameter", "VUID-VkSamplerCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSamplerCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->sampler", pInfo->sampler);
    }
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(
    VkDevice                                    device,
    const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) skip |= OutputExtensionError(loc, "VK_EXT_descriptor_buffer");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true, "VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-pInfo-parameter", "VUID-VkAccelerationStructureCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, false, true);
    }
    skip |= ValidateRequiredPointer(loc, "pData", pData, "VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFragmentShadingRateEnumNV(
    VkCommandBuffer                             commandBuffer,
    VkFragmentShadingRateNV                     shadingRate,
    const VkFragmentShadingRateCombinerOpKHR    combinerOps[2],
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_fragment_shading_rate_enums)) skip |= OutputExtensionError(loc, "VK_NV_fragment_shading_rate_enums");
    skip |= ValidateRangedEnum(loc, "shadingRate", "VkFragmentShadingRateNV", shadingRate, "VUID-vkCmdSetFragmentShadingRateEnumNV-shadingRate-parameter");
    skip |= ValidateRangedEnumArray(loc, "None", "combinerOps", "VkFragmentShadingRateCombinerOpKHR", 2, combinerOps, false, true);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceFaultInfoEXT(
    VkDevice                                    device,
    VkDeviceFaultCountsEXT*                     pFaultCounts,
    VkDeviceFaultInfoEXT*                       pFaultInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_fault)) skip |= OutputExtensionError(loc, "VK_EXT_device_fault");
    skip |= ValidateStructType(loc, "pFaultCounts", "VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT", pFaultCounts, VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT, true, "VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-parameter", "VUID-VkDeviceFaultCountsEXT-sType-sType");
    skip |= ValidateStructType(loc, "pFaultInfo", "VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT", pFaultInfo, VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT, false, "VUID-vkGetDeviceFaultInfoEXT-pFaultInfo-parameter", "VUID-VkDeviceFaultInfoEXT-sType-sType");
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateAcquireWinrtDisplayNV(
    VkPhysicalDevice                            physicalDevice,
    VkDisplayKHR                                display,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc, "display", display);
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetWinrtDisplayNV(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    deviceRelativeId,
    VkDisplayKHR*                               pDisplay,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc, "pDisplay", pDisplay, "VUID-vkGetWinrtDisplayNV-pDisplay-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
bool StatelessValidation::PreCallValidateCreateDirectFBSurfaceEXT(
    VkInstance                                  instance,
    const VkDirectFBSurfaceCreateInfoEXT*       pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_directfb_surface) skip |= OutputExtensionError(loc, "VK_EXT_directfb_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT, true, "VUID-vkCreateDirectFBSurfaceEXT-pCreateInfo-parameter", "VUID-VkDirectFBSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDirectFBSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkDirectFBSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateDirectFBSurfaceEXT-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
bool StatelessValidation::PreCallValidateGetPhysicalDeviceDirectFBPresentationSupportEXT(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    IDirectFB*                                  dfb,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_ext_directfb_surface) skip |= OutputExtensionError(loc, "VK_EXT_directfb_surface");
    skip |= ValidateRequiredPointer(loc, "dfb", dfb, "VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-dfb-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_DIRECTFB_EXT

bool StatelessValidation::PreCallValidateCmdSetVertexInputEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexBindingDescriptionCount,
    const VkVertexInputBindingDescription2EXT*  pVertexBindingDescriptions,
    uint32_t                                    vertexAttributeDescriptionCount,
    const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_vertex_input_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_vertex_input_dynamic_state || VK_EXT_shader_object");
    skip |= ValidateStructTypeArray(loc, "vertexBindingDescriptionCount", "pVertexBindingDescriptions", "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT", vertexBindingDescriptionCount, pVertexBindingDescriptions, VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT, false, true, "VUID-VkVertexInputBindingDescription2EXT-sType-sType", "VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-parameter", kVUIDUndefined);
    if (pVertexBindingDescriptions != nullptr)
    {
        for (uint32_t vertexBindingDescriptionIndex = 0; vertexBindingDescriptionIndex < vertexBindingDescriptionCount; ++vertexBindingDescriptionIndex)
        {
            skip |= ValidateRangedEnum(loc, ParameterName("pVertexBindingDescriptions[%i].inputRate", ParameterName::IndexVector{ vertexBindingDescriptionIndex }), "VkVertexInputRate", pVertexBindingDescriptions[vertexBindingDescriptionIndex].inputRate, "VUID-VkVertexInputBindingDescription2EXT-inputRate-parameter");
        }
    }
    skip |= ValidateStructTypeArray(loc, "vertexAttributeDescriptionCount", "pVertexAttributeDescriptions", "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT", vertexAttributeDescriptionCount, pVertexAttributeDescriptions, VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT, false, true, "VUID-VkVertexInputAttributeDescription2EXT-sType-sType", "VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-parameter", kVUIDUndefined);
    if (pVertexAttributeDescriptions != nullptr)
    {
        for (uint32_t vertexAttributeDescriptionIndex = 0; vertexAttributeDescriptionIndex < vertexAttributeDescriptionCount; ++vertexAttributeDescriptionIndex)
        {
            skip |= ValidateRangedEnum(loc, ParameterName("pVertexAttributeDescriptions[%i].format", ParameterName::IndexVector{ vertexAttributeDescriptionIndex }), "VkFormat", pVertexAttributeDescriptions[vertexAttributeDescriptionIndex].format, "VUID-VkVertexInputAttributeDescription2EXT-format-parameter");
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateGetMemoryZirconHandleFUCHSIA(
    VkDevice                                    device,
    const VkMemoryGetZirconHandleInfoFUCHSIA*   pGetZirconHandleInfo,
    zx_handle_t*                                pZirconHandle,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_memory)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_external_memory");
    skip |= ValidateStructType(loc, "pGetZirconHandleInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA", pGetZirconHandleInfo, VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA, true, "VUID-vkGetMemoryZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter", "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-sType-sType");
    if (pGetZirconHandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetZirconHandleInfo->pNext", nullptr, pGetZirconHandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetZirconHandleInfo->memory", pGetZirconHandleInfo->memory);

        skip |= ValidateFlags(loc, "pGetZirconHandleInfo->handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, pGetZirconHandleInfo->handleType, kRequiredSingleBit, "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter", "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pZirconHandle", pZirconHandle, "VUID-vkGetMemoryZirconHandleFUCHSIA-pZirconHandle-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateGetMemoryZirconHandlePropertiesFUCHSIA(
    VkDevice                                    device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    zx_handle_t                                 zirconHandle,
    VkMemoryZirconHandlePropertiesFUCHSIA*      pMemoryZirconHandleProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_memory)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_external_memory");
    skip |= ValidateFlags(loc, "handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter", "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter");
    skip |= ValidateStructType(loc, "pMemoryZirconHandleProperties", "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA", pMemoryZirconHandleProperties, VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA, true, "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-pMemoryZirconHandleProperties-parameter", "VUID-VkMemoryZirconHandlePropertiesFUCHSIA-sType-sType");
    if (pMemoryZirconHandleProperties != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryZirconHandleProperties->pNext", nullptr, pMemoryZirconHandleProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryZirconHandlePropertiesFUCHSIA-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateImportSemaphoreZirconHandleFUCHSIA(
    VkDevice                                    device,
    const VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_semaphore)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_external_semaphore");
    skip |= ValidateStructType(loc, "pImportSemaphoreZirconHandleInfo", "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA", pImportSemaphoreZirconHandleInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA, true, "VUID-vkImportSemaphoreZirconHandleFUCHSIA-pImportSemaphoreZirconHandleInfo-parameter", "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-sType-sType");
    if (pImportSemaphoreZirconHandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pImportSemaphoreZirconHandleInfo->pNext", nullptr, pImportSemaphoreZirconHandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pImportSemaphoreZirconHandleInfo->semaphore", pImportSemaphoreZirconHandleInfo->semaphore);

        skip |= ValidateFlags(loc, "pImportSemaphoreZirconHandleInfo->flags", "VkSemaphoreImportFlagBits", AllVkSemaphoreImportFlagBits, pImportSemaphoreZirconHandleInfo->flags, kOptionalFlags, "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-flags-parameter");

        skip |= ValidateFlags(loc, "pImportSemaphoreZirconHandleInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pImportSemaphoreZirconHandleInfo->handleType, kRequiredSingleBit, "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter", "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateGetSemaphoreZirconHandleFUCHSIA(
    VkDevice                                    device,
    const VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo,
    zx_handle_t*                                pZirconHandle,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_semaphore)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_external_semaphore");
    skip |= ValidateStructType(loc, "pGetZirconHandleInfo", "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA", pGetZirconHandleInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA, true, "VUID-vkGetSemaphoreZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter", "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-sType-sType");
    if (pGetZirconHandleInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pGetZirconHandleInfo->pNext", nullptr, pGetZirconHandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pGetZirconHandleInfo->semaphore", pGetZirconHandleInfo->semaphore);

        skip |= ValidateFlags(loc, "pGetZirconHandleInfo->handleType", "VkExternalSemaphoreHandleTypeFlagBits", AllVkExternalSemaphoreHandleTypeFlagBits, pGetZirconHandleInfo->handleType, kRequiredSingleBit, "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter", "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pZirconHandle", pZirconHandle, "VUID-vkGetSemaphoreZirconHandleFUCHSIA-pZirconHandle-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateCreateBufferCollectionFUCHSIA(
    VkDevice                                    device,
    const VkBufferCollectionCreateInfoFUCHSIA*  pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkBufferCollectionFUCHSIA*                  pCollection,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_buffer_collection");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA", pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA, true, "VUID-vkCreateBufferCollectionFUCHSIA-pCreateInfo-parameter", "VUID-VkBufferCollectionCreateInfoFUCHSIA-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferCollectionCreateInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pCollection", pCollection, "VUID-vkCreateBufferCollectionFUCHSIA-pCollection-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateSetBufferCollectionImageConstraintsFUCHSIA(
    VkDevice                                    device,
    VkBufferCollectionFUCHSIA                   collection,
    const VkImageConstraintsInfoFUCHSIA*        pImageConstraintsInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_buffer_collection");
    skip |= ValidateRequiredHandle(loc, "collection", collection);
    skip |= ValidateStructType(loc, "pImageConstraintsInfo", "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA", pImageConstraintsInfo, VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA, true, "VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-pImageConstraintsInfo-parameter", "VUID-VkImageConstraintsInfoFUCHSIA-sType-sType");
    if (pImageConstraintsInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pImageConstraintsInfo->pNext", nullptr, pImageConstraintsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructTypeArray(loc, "pImageConstraintsInfo->formatConstraintsCount", "pImageConstraintsInfo->pFormatConstraints", "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA", pImageConstraintsInfo->formatConstraintsCount, pImageConstraintsInfo->pFormatConstraints, VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA, true, true, "VUID-VkImageFormatConstraintsInfoFUCHSIA-sType-sType", "VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-parameter", "VUID-VkImageConstraintsInfoFUCHSIA-formatConstraintsCount-arraylength");

        if (pImageConstraintsInfo->pFormatConstraints != nullptr)
        {
            for (uint32_t formatConstraintsIndex = 0; formatConstraintsIndex < pImageConstraintsInfo->formatConstraintsCount; ++formatConstraintsIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].pNext", ParameterName::IndexVector{ formatConstraintsIndex }), nullptr, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkImageFormatConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateStructType(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo", ParameterName::IndexVector{ formatConstraintsIndex }), "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", &(pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo), VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, false, kVUIDUndefined, "VUID-VkImageCreateInfo-sType-sType");

                constexpr std::array allowed_structs_VkImageCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT, VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

                skip |= ValidateStructPnext(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.pNext", ParameterName::IndexVector{ formatConstraintsIndex }), "VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalFormatQNX, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkOpticalFlowImageFormatInfoNV, VkVideoProfileListInfoKHR", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.pNext, allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", false, true);

                skip |= ValidateFlags(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.flags", ParameterName::IndexVector{ formatConstraintsIndex }), "VkImageCreateFlagBits", AllVkImageCreateFlagBits, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.flags, kOptionalFlags, "VUID-VkImageCreateInfo-flags-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.imageType", ParameterName::IndexVector{ formatConstraintsIndex }), "VkImageType", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.imageType, "VUID-VkImageCreateInfo-imageType-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.format", ParameterName::IndexVector{ formatConstraintsIndex }), "VkFormat", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.format, "VUID-VkImageCreateInfo-format-parameter");

                // No xml-driven validation

                skip |= ValidateFlags(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.samples", ParameterName::IndexVector{ formatConstraintsIndex }), "VkSampleCountFlagBits", AllVkSampleCountFlagBits, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.samples, kRequiredSingleBit, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.tiling", ParameterName::IndexVector{ formatConstraintsIndex }), "VkImageTiling", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.tiling, "VUID-VkImageCreateInfo-tiling-parameter");

                skip |= ValidateFlags(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.usage", ParameterName::IndexVector{ formatConstraintsIndex }), "VkImageUsageFlagBits", AllVkImageUsageFlagBits, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.usage, kRequiredFlags, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

                skip |= ValidateRangedEnum(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.sharingMode", ParameterName::IndexVector{ formatConstraintsIndex }), "VkSharingMode", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].imageCreateInfo.initialLayout", ParameterName::IndexVector{ formatConstraintsIndex }), "VkImageLayout", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");

                skip |= ValidateFlags(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].requiredFormatFeatures", ParameterName::IndexVector{ formatConstraintsIndex }), "VkFormatFeatureFlagBits", AllVkFormatFeatureFlagBits, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].requiredFormatFeatures, kRequiredFlags, "VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter", "VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-requiredbitmask");

                skip |= ValidateReservedFlags(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].flags", ParameterName::IndexVector{ formatConstraintsIndex }), pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].flags, "VUID-VkImageFormatConstraintsInfoFUCHSIA-flags-zerobitmask");

                skip |= ValidateStructTypeArray(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].colorSpaceCount", ParameterName::IndexVector{ formatConstraintsIndex }), ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].pColorSpaces", ParameterName::IndexVector{ formatConstraintsIndex }), "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA", pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].colorSpaceCount, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces, VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA, true, true, "VUID-VkSysmemColorSpaceFUCHSIA-sType-sType", "VUID-VkImageFormatConstraintsInfoFUCHSIA-pColorSpaces-parameter", "VUID-VkImageFormatConstraintsInfoFUCHSIA-colorSpaceCount-arraylength");

                if (pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces != nullptr)
                {
                    for (uint32_t colorSpaceIndex = 0; colorSpaceIndex < pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].colorSpaceCount; ++colorSpaceIndex)
                    {
                        skip |= ValidateStructPnext(loc, ParameterName("pImageConstraintsInfo->pFormatConstraints[%i].pColorSpaces[%i].pNext", ParameterName::IndexVector{ formatConstraintsIndex, colorSpaceIndex }), nullptr, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces[colorSpaceIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSysmemColorSpaceFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);
                    }
                }
            }
        }

        skip |= ValidateStructType(loc, "pImageConstraintsInfo->bufferCollectionConstraints", "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA", &(pImageConstraintsInfo->bufferCollectionConstraints), VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA, false, kVUIDUndefined, "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType");

        skip |= ValidateStructPnext(loc, "pImageConstraintsInfo->bufferCollectionConstraints.pNext", nullptr, pImageConstraintsInfo->bufferCollectionConstraints.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pImageConstraintsInfo->flags", "VkImageConstraintsInfoFlagBitsFUCHSIA", AllVkImageConstraintsInfoFlagBitsFUCHSIA, pImageConstraintsInfo->flags, kOptionalFlags, "VUID-VkImageConstraintsInfoFUCHSIA-flags-parameter");
    }
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateSetBufferCollectionBufferConstraintsFUCHSIA(
    VkDevice                                    device,
    VkBufferCollectionFUCHSIA                   collection,
    const VkBufferConstraintsInfoFUCHSIA*       pBufferConstraintsInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_buffer_collection");
    skip |= ValidateRequiredHandle(loc, "collection", collection);
    skip |= ValidateStructType(loc, "pBufferConstraintsInfo", "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA", pBufferConstraintsInfo, VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA, true, "VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-pBufferConstraintsInfo-parameter", "VUID-VkBufferConstraintsInfoFUCHSIA-sType-sType");
    if (pBufferConstraintsInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pBufferConstraintsInfo->pNext", nullptr, pBufferConstraintsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateStructType(loc, "pBufferConstraintsInfo->createInfo", "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", &(pBufferConstraintsInfo->createInfo), VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, false, kVUIDUndefined, "VUID-VkBufferCreateInfo-sType-sType");

        constexpr std::array allowed_structs_VkBufferCreateInfo = { VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO, VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pBufferConstraintsInfo->createInfo.pNext", "VkBufferCollectionBufferCreateInfoFUCHSIA, VkBufferDeviceAddressCreateInfoEXT, VkBufferOpaqueCaptureAddressCreateInfo, VkBufferUsageFlags2CreateInfoKHR, VkDedicatedAllocationBufferCreateInfoNV, VkExternalMemoryBufferCreateInfo, VkOpaqueCaptureDescriptorDataCreateInfoEXT, VkVideoProfileListInfoKHR", pBufferConstraintsInfo->createInfo.pNext, allowed_structs_VkBufferCreateInfo.size(), allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pBufferConstraintsInfo->createInfo.flags", "VkBufferCreateFlagBits", AllVkBufferCreateFlagBits, pBufferConstraintsInfo->createInfo.flags, kOptionalFlags, "VUID-VkBufferCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(loc, "pBufferConstraintsInfo->createInfo.sharingMode", "VkSharingMode", pBufferConstraintsInfo->createInfo.sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter");

        skip |= ValidateFlags(loc, "pBufferConstraintsInfo->requiredFormatFeatures", "VkFormatFeatureFlagBits", AllVkFormatFeatureFlagBits, pBufferConstraintsInfo->requiredFormatFeatures, kOptionalFlags, "VUID-VkBufferConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter");

        skip |= ValidateStructType(loc, "pBufferConstraintsInfo->bufferCollectionConstraints", "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA", &(pBufferConstraintsInfo->bufferCollectionConstraints), VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA, false, kVUIDUndefined, "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType");

        skip |= ValidateStructPnext(loc, "pBufferConstraintsInfo->bufferCollectionConstraints.pNext", nullptr, pBufferConstraintsInfo->bufferCollectionConstraints.pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, false, true);
    }
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateDestroyBufferCollectionFUCHSIA(
    VkDevice                                    device,
    VkBufferCollectionFUCHSIA                   collection,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_buffer_collection");
    skip |= ValidateRequiredHandle(loc, "collection", collection);
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateGetBufferCollectionPropertiesFUCHSIA(
    VkDevice                                    device,
    VkBufferCollectionFUCHSIA                   collection,
    VkBufferCollectionPropertiesFUCHSIA*        pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) skip |= OutputExtensionError(loc, "VK_FUCHSIA_buffer_collection");
    skip |= ValidateRequiredHandle(loc, "collection", collection);
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA", pProperties, VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA, true, "VUID-vkGetBufferCollectionPropertiesFUCHSIA-pProperties-parameter", "VUID-VkBufferCollectionPropertiesFUCHSIA-sType-sType");
    return skip;
}
#endif // VK_USE_PLATFORM_FUCHSIA

bool StatelessValidation::PreCallValidateGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(
    VkDevice                                    device,
    VkRenderPass                                renderpass,
    VkExtent2D*                                 pMaxWorkgroupSize,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_subpass_shading)) skip |= OutputExtensionError(loc, "VK_HUAWEI_subpass_shading");
    skip |= ValidateRequiredHandle(loc, "renderpass", renderpass);
    skip |= ValidateRequiredPointer(loc, "pMaxWorkgroupSize", pMaxWorkgroupSize, "VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-pMaxWorkgroupSize-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSubpassShadingHUAWEI(
    VkCommandBuffer                             commandBuffer,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_subpass_shading)) skip |= OutputExtensionError(loc, "VK_HUAWEI_subpass_shading");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindInvocationMaskHUAWEI(
    VkCommandBuffer                             commandBuffer,
    VkImageView                                 imageView,
    VkImageLayout                               imageLayout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_invocation_mask)) skip |= OutputExtensionError(loc, "VK_HUAWEI_invocation_mask");
    skip |= ValidateRangedEnum(loc, "imageLayout", "VkImageLayout", imageLayout, "VUID-vkCmdBindInvocationMaskHUAWEI-imageLayout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryRemoteAddressNV(
    VkDevice                                    device,
    const VkMemoryGetRemoteAddressInfoNV*       pMemoryGetRemoteAddressInfo,
    VkRemoteAddressNV*                          pAddress,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_external_memory_rdma)) skip |= OutputExtensionError(loc, "VK_NV_external_memory_rdma");
    skip |= ValidateStructType(loc, "pMemoryGetRemoteAddressInfo", "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV", pMemoryGetRemoteAddressInfo, VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV, true, "VUID-vkGetMemoryRemoteAddressNV-pMemoryGetRemoteAddressInfo-parameter", "VUID-VkMemoryGetRemoteAddressInfoNV-sType-sType");
    if (pMemoryGetRemoteAddressInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pMemoryGetRemoteAddressInfo->pNext", nullptr, pMemoryGetRemoteAddressInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetRemoteAddressInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pMemoryGetRemoteAddressInfo->memory", pMemoryGetRemoteAddressInfo->memory);

        skip |= ValidateFlags(loc, "pMemoryGetRemoteAddressInfo->handleType", "VkExternalMemoryHandleTypeFlagBits", AllVkExternalMemoryHandleTypeFlagBits, pMemoryGetRemoteAddressInfo->handleType, kRequiredSingleBit, "VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter", "VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pAddress", pAddress, "VUID-vkGetMemoryRemoteAddressNV-pAddress-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelinePropertiesEXT(
    VkDevice                                    device,
    const VkPipelineInfoEXT*                    pPipelineInfo,
    VkBaseOutStructure*                         pPipelineProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_pipeline_properties)) skip |= OutputExtensionError(loc, "VK_EXT_pipeline_properties");
    skip |= ValidateRequiredPointer(loc, "pPipelineInfo", pPipelineInfo, "VUID-vkGetPipelinePropertiesEXT-pPipelineInfo-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPatchControlPointsEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    patchControlPoints,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state2 || VK_EXT_shader_object");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizerDiscardEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    rasterizerDiscardEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state2 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "rasterizerDiscardEnable", rasterizerDiscardEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBiasEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthBiasEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state2 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "depthBiasEnable", depthBiasEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLogicOpEXT(
    VkCommandBuffer                             commandBuffer,
    VkLogicOp                                   logicOp,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state2 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "logicOp", "VkLogicOp", logicOp, "VUID-vkCmdSetLogicOpEXT-logicOp-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveRestartEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    primitiveRestartEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state2 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "primitiveRestartEnable", primitiveRestartEnable);
    return skip;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool StatelessValidation::PreCallValidateCreateScreenSurfaceQNX(
    VkInstance                                  instance,
    const VkScreenSurfaceCreateInfoQNX*         pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkSurfaceKHR*                               pSurface,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_qnx_screen_surface) skip |= OutputExtensionError(loc, "VK_QNX_screen_surface");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX", pCreateInfo, VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX, true, "VUID-vkCreateScreenSurfaceQNX-pCreateInfo-parameter", "VUID-VkScreenSurfaceCreateInfoQNX-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkScreenSurfaceCreateInfoQNX-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkScreenSurfaceCreateInfoQNX-flags-zerobitmask");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSurface", pSurface, "VUID-vkCreateScreenSurfaceQNX-pSurface-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool StatelessValidation::PreCallValidateGetPhysicalDeviceScreenPresentationSupportQNX(
    VkPhysicalDevice                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    struct _screen_window*                      window,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!instance_extensions.vk_qnx_screen_surface) skip |= OutputExtensionError(loc, "VK_QNX_screen_surface");
    skip |= ValidateRequiredPointer(loc, "window", window, "VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-window-parameter");
    return skip;
}
#endif // VK_USE_PLATFORM_SCREEN_QNX

bool StatelessValidation::PreCallValidateCmdSetColorWriteEnableEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    attachmentCount,
    const VkBool32*                             pColorWriteEnables,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_color_write_enable)) skip |= OutputExtensionError(loc, "VK_EXT_color_write_enable");
    skip |= ValidateBool32Array(loc, "attachmentCount", "pColorWriteEnables", attachmentCount, pColorWriteEnables, true, true);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMultiEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    drawCount,
    const VkMultiDrawInfoEXT*                   pVertexInfo,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_multi_draw)) skip |= OutputExtensionError(loc, "VK_EXT_multi_draw");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMultiIndexedEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    drawCount,
    const VkMultiDrawIndexedInfoEXT*            pIndexInfo,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    uint32_t                                    stride,
    const int32_t*                              pVertexOffset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_multi_draw)) skip |= OutputExtensionError(loc, "VK_EXT_multi_draw");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCreateMicromapEXT(
    VkDevice                                    device,
    const VkMicromapCreateInfoEXT*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkMicromapEXT*                              pMicromap,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT", pCreateInfo, VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT, true, "VUID-vkCreateMicromapEXT-pCreateInfo-parameter", "VUID-VkMicromapCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", nullptr, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMicromapCreateInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->createFlags", "VkMicromapCreateFlagBitsEXT", AllVkMicromapCreateFlagBitsEXT, pCreateInfo->createFlags, kOptionalFlags, "VUID-VkMicromapCreateInfoEXT-createFlags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->buffer", pCreateInfo->buffer);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->type", "VkMicromapTypeEXT", pCreateInfo->type, "VUID-VkMicromapCreateInfoEXT-type-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pMicromap", pMicromap, "VUID-vkCreateMicromapEXT-pMicromap-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyMicromapEXT(
    VkDevice                                    device,
    VkMicromapEXT                               micromap,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildMicromapsEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    infoCount,
    const VkMicromapBuildInfoEXT*               pInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructTypeArray(loc, "infoCount", "pInfos", "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT", infoCount, pInfos, VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, true, "VUID-VkMicromapBuildInfoEXT-sType-sType", "VUID-vkCmdBuildMicromapsEXT-pInfos-parameter", "VUID-vkCmdBuildMicromapsEXT-infoCount-arraylength");
    if (pInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pNext", ParameterName::IndexVector{ infoIndex }), nullptr, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].type", ParameterName::IndexVector{ infoIndex }), "VkMicromapTypeEXT", pInfos[infoIndex].type, "VUID-VkMicromapBuildInfoEXT-type-parameter");

            skip |= ValidateFlags(loc, ParameterName("pInfos[%i].flags", ParameterName::IndexVector{ infoIndex }), "VkBuildMicromapFlagBitsEXT", AllVkBuildMicromapFlagBitsEXT, pInfos[infoIndex].flags, kOptionalFlags, "VUID-VkMicromapBuildInfoEXT-flags-parameter");

            if (pInfos[infoIndex].pUsageCounts != nullptr)
            {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex)
                {
                    // No xml-driven validation
                }
            }

            if (pInfos[infoIndex].ppUsageCounts != nullptr)
            {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex)
                {
                    // No xml-driven validation
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBuildMicromapsEXT(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    uint32_t                                    infoCount,
    const VkMicromapBuildInfoEXT*               pInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructTypeArray(loc, "infoCount", "pInfos", "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT", infoCount, pInfos, VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, true, "VUID-VkMicromapBuildInfoEXT-sType-sType", "VUID-vkBuildMicromapsEXT-pInfos-parameter", "VUID-vkBuildMicromapsEXT-infoCount-arraylength");
    if (pInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pNext", ParameterName::IndexVector{ infoIndex }), nullptr, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].type", ParameterName::IndexVector{ infoIndex }), "VkMicromapTypeEXT", pInfos[infoIndex].type, "VUID-VkMicromapBuildInfoEXT-type-parameter");

            skip |= ValidateFlags(loc, ParameterName("pInfos[%i].flags", ParameterName::IndexVector{ infoIndex }), "VkBuildMicromapFlagBitsEXT", AllVkBuildMicromapFlagBitsEXT, pInfos[infoIndex].flags, kOptionalFlags, "VUID-VkMicromapBuildInfoEXT-flags-parameter");

            if (pInfos[infoIndex].pUsageCounts != nullptr)
            {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex)
                {
                    // No xml-driven validation
                }
            }

            if (pInfos[infoIndex].ppUsageCounts != nullptr)
            {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex)
                {
                    // No xml-driven validation
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMicromapEXT(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    const VkCopyMicromapInfoEXT*                pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, true, "VUID-vkCopyMicromapEXT-pInfo-parameter", "VUID-VkCopyMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMicromapInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyMicromapModeEXT", pInfo->mode, "VUID-VkCopyMicromapInfoEXT-mode-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMicromapToMemoryEXT(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    const VkCopyMicromapToMemoryInfoEXT*        pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, true, "VUID-vkCopyMicromapToMemoryEXT-pInfo-parameter", "VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyMicromapModeEXT", pInfo->mode, "VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMemoryToMicromapEXT(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    const VkCopyMemoryToMicromapInfoEXT*        pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, true, "VUID-vkCopyMemoryToMicromapEXT-pInfo-parameter", "VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyMicromapModeEXT", pInfo->mode, "VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateWriteMicromapsPropertiesEXT(
    VkDevice                                    device,
    uint32_t                                    micromapCount,
    const VkMicromapEXT*                        pMicromaps,
    VkQueryType                                 queryType,
    size_t                                      dataSize,
    void*                                       pData,
    size_t                                      stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateHandleArray(loc, "micromapCount", "pMicromaps", micromapCount, pMicromaps, true, true, "VUID-vkWriteMicromapsPropertiesEXT-micromapCount-arraylength");
    skip |= ValidateRangedEnum(loc, "queryType", "VkQueryType", queryType, "VUID-vkWriteMicromapsPropertiesEXT-queryType-parameter");
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkWriteMicromapsPropertiesEXT-dataSize-arraylength", "VUID-vkWriteMicromapsPropertiesEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMicromapEXT(
    VkCommandBuffer                             commandBuffer,
    const VkCopyMicromapInfoEXT*                pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, true, "VUID-vkCmdCopyMicromapEXT-pInfo-parameter", "VUID-VkCopyMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMicromapInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyMicromapModeEXT", pInfo->mode, "VUID-VkCopyMicromapInfoEXT-mode-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMicromapToMemoryEXT(
    VkCommandBuffer                             commandBuffer,
    const VkCopyMicromapToMemoryInfoEXT*        pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, true, "VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-parameter", "VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyMicromapModeEXT", pInfo->mode, "VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryToMicromapEXT(
    VkCommandBuffer                             commandBuffer,
    const VkCopyMemoryToMicromapInfoEXT*        pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT", pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, true, "VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-parameter", "VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyMicromapModeEXT", pInfo->mode, "VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteMicromapsPropertiesEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    micromapCount,
    const VkMicromapEXT*                        pMicromaps,
    VkQueryType                                 queryType,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateHandleArray(loc, "micromapCount", "pMicromaps", micromapCount, pMicromaps, true, true, "VUID-vkCmdWriteMicromapsPropertiesEXT-micromapCount-arraylength");
    skip |= ValidateRangedEnum(loc, "queryType", "VkQueryType", queryType, "VUID-vkCmdWriteMicromapsPropertiesEXT-queryType-parameter");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMicromapCompatibilityEXT(
    VkDevice                                    device,
    const VkMicromapVersionInfoEXT*             pVersionInfo,
    VkAccelerationStructureCompatibilityKHR*    pCompatibility,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateStructType(loc, "pVersionInfo", "VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT", pVersionInfo, VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT, true, "VUID-vkGetDeviceMicromapCompatibilityEXT-pVersionInfo-parameter", "VUID-VkMicromapVersionInfoEXT-sType-sType");
    if (pVersionInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pVersionInfo->pNext", nullptr, pVersionInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMicromapVersionInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pVersionInfo->pVersionData", pVersionInfo->pVersionData, "VUID-VkMicromapVersionInfoEXT-pVersionData-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pCompatibility", pCompatibility, "VUID-vkGetDeviceMicromapCompatibilityEXT-pCompatibility-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetMicromapBuildSizesEXT(
    VkDevice                                    device,
    VkAccelerationStructureBuildTypeKHR         buildType,
    const VkMicromapBuildInfoEXT*               pBuildInfo,
    VkMicromapBuildSizesInfoEXT*                pSizeInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) skip |= OutputExtensionError(loc, "VK_EXT_opacity_micromap");
    skip |= ValidateRangedEnum(loc, "buildType", "VkAccelerationStructureBuildTypeKHR", buildType, "VUID-vkGetMicromapBuildSizesEXT-buildType-parameter");
    skip |= ValidateStructType(loc, "pBuildInfo", "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT", pBuildInfo, VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, "VUID-vkGetMicromapBuildSizesEXT-pBuildInfo-parameter", "VUID-VkMicromapBuildInfoEXT-sType-sType");
    if (pBuildInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pBuildInfo->pNext", nullptr, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pBuildInfo->type", "VkMicromapTypeEXT", pBuildInfo->type, "VUID-VkMicromapBuildInfoEXT-type-parameter");

        skip |= ValidateFlags(loc, "pBuildInfo->flags", "VkBuildMicromapFlagBitsEXT", AllVkBuildMicromapFlagBitsEXT, pBuildInfo->flags, kOptionalFlags, "VUID-VkMicromapBuildInfoEXT-flags-parameter");

        if (pBuildInfo->pUsageCounts != nullptr)
        {
            for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pBuildInfo->usageCountsCount; ++usageIndexsIndex)
            {
                // No xml-driven validation
            }
        }

        if (pBuildInfo->ppUsageCounts != nullptr)
        {
            for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pBuildInfo->usageCountsCount; ++usageIndexsIndex)
            {
                // No xml-driven validation
            }
        }
    }
    skip |= ValidateStructType(loc, "pSizeInfo", "VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT", pSizeInfo, VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT, true, "VUID-vkGetMicromapBuildSizesEXT-pSizeInfo-parameter", "VUID-VkMicromapBuildSizesInfoEXT-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawClusterHUAWEI(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_cluster_culling_shader)) skip |= OutputExtensionError(loc, "VK_HUAWEI_cluster_culling_shader");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawClusterIndirectHUAWEI(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_cluster_culling_shader)) skip |= OutputExtensionError(loc, "VK_HUAWEI_cluster_culling_shader");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateSetDeviceMemoryPriorityEXT(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    float                                       priority,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_pageable_device_local_memory)) skip |= OutputExtensionError(loc, "VK_EXT_pageable_device_local_memory");
    skip |= ValidateRequiredHandle(loc, "memory", memory);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutHostMappingInfoVALVE(
    VkDevice                                    device,
    const VkDescriptorSetBindingReferenceVALVE* pBindingReference,
    VkDescriptorSetLayoutHostMappingInfoVALVE*  pHostMapping,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_valve_descriptor_set_host_mapping)) skip |= OutputExtensionError(loc, "VK_VALVE_descriptor_set_host_mapping");
    skip |= ValidateStructType(loc, "pBindingReference", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE", pBindingReference, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE, true, "VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter", "VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType");
    if (pBindingReference != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pBindingReference->pNext", nullptr, pBindingReference->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pBindingReference->descriptorSetLayout", pBindingReference->descriptorSetLayout);
    }
    skip |= ValidateStructType(loc, "pHostMapping", "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE", pHostMapping, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE, true, "VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter", "VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetHostMappingVALVE(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    void**                                      ppData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_valve_descriptor_set_host_mapping)) skip |= OutputExtensionError(loc, "VK_VALVE_descriptor_set_host_mapping");
    skip |= ValidateRequiredHandle(loc, "descriptorSet", descriptorSet);
    skip |= ValidateRequiredPointer(loc, "ppData", ppData, "VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryIndirectNV(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             copyBufferAddress,
    uint32_t                                    copyCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_copy_memory_indirect)) skip |= OutputExtensionError(loc, "VK_NV_copy_memory_indirect");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryToImageIndirectNV(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             copyBufferAddress,
    uint32_t                                    copyCount,
    uint32_t                                    stride,
    VkImage                                     dstImage,
    VkImageLayout                               dstImageLayout,
    const VkImageSubresourceLayers*             pImageSubresources,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_copy_memory_indirect)) skip |= OutputExtensionError(loc, "VK_NV_copy_memory_indirect");
    skip |= ValidateRequiredHandle(loc, "dstImage", dstImage);
    skip |= ValidateRangedEnum(loc, "dstImageLayout", "VkImageLayout", dstImageLayout, "VUID-vkCmdCopyMemoryToImageIndirectNV-dstImageLayout-parameter");
    skip |= ValidateArray(loc, "copyCount", "pImageSubresources", copyCount, &pImageSubresources, true, true, "VUID-vkCmdCopyMemoryToImageIndirectNV-copyCount-arraylength", "VUID-vkCmdCopyMemoryToImageIndirectNV-pImageSubresources-parameter");
    if (pImageSubresources != nullptr)
    {
        for (uint32_t copyIndex = 0; copyIndex < copyCount; ++copyIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pImageSubresources[%i].aspectMask", ParameterName::IndexVector{ copyIndex }), "VkImageAspectFlagBits", AllVkImageAspectFlagBits, pImageSubresources[copyIndex].aspectMask, kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter", "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDecompressMemoryNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    decompressRegionCount,
    const VkDecompressMemoryRegionNV*           pDecompressMemoryRegions,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_memory_decompression)) skip |= OutputExtensionError(loc, "VK_NV_memory_decompression");
    skip |= ValidateArray(loc, "decompressRegionCount", "pDecompressMemoryRegions", decompressRegionCount, &pDecompressMemoryRegions, true, true, "VUID-vkCmdDecompressMemoryNV-decompressRegionCount-arraylength", "VUID-vkCmdDecompressMemoryNV-pDecompressMemoryRegions-parameter");
    if (pDecompressMemoryRegions != nullptr)
    {
        for (uint32_t decompressRegionIndex = 0; decompressRegionIndex < decompressRegionCount; ++decompressRegionIndex)
        {
            skip |= ValidateFlags(loc, ParameterName("pDecompressMemoryRegions[%i].decompressionMethod", ParameterName::IndexVector{ decompressRegionIndex }), "VkMemoryDecompressionMethodFlagBitsNV", AllVkMemoryDecompressionMethodFlagBitsNV, pDecompressMemoryRegions[decompressRegionIndex].decompressionMethod, kRequiredFlags, "VUID-VkDecompressMemoryRegionNV-decompressionMethod-parameter", "VUID-VkDecompressMemoryRegionNV-decompressionMethod-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDecompressMemoryIndirectCountNV(
    VkCommandBuffer                             commandBuffer,
    VkDeviceAddress                             indirectCommandsAddress,
    VkDeviceAddress                             indirectCommandsCountAddress,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_memory_decompression)) skip |= OutputExtensionError(loc, "VK_NV_memory_decompression");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineIndirectMemoryRequirementsNV(
    VkDevice                                    device,
    const VkComputePipelineCreateInfo*          pCreateInfo,
    VkMemoryRequirements2*                      pMemoryRequirements,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands_compute");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, true, "VUID-vkGetPipelineIndirectMemoryRequirementsNV-pCreateInfo-parameter", "VUID-VkComputePipelineCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkComputePipelineCreateInfo = { VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreateFlags2CreateInfoKHR, VkPipelineCreationFeedbackCreateInfo, VkPipelineRobustnessCreateInfoEXT, VkSubpassShadingPipelineCreateInfoHUAWEI", pCreateInfo->pNext, allowed_structs_VkComputePipelineCreateInfo.size(), allowed_structs_VkComputePipelineCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkComputePipelineCreateInfo-pNext-pNext", "VUID-VkComputePipelineCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfo->flags, kOptionalFlags, "VUID-VkComputePipelineCreateInfo-flags-parameter");

        skip |= ValidateStructType(loc, "pCreateInfo->stage", "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", &(pCreateInfo->stage), VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, kVUIDUndefined, "VUID-VkPipelineShaderStageCreateInfo-sType-sType");

        constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = { VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->stage.pNext", "VkDebugUtilsObjectNameInfoEXT, VkPipelineRobustnessCreateInfoEXT, VkPipelineShaderStageModuleIdentifierCreateInfoEXT, VkPipelineShaderStageNodeCreateInfoAMDX, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, VkShaderModuleCreateInfo, VkShaderModuleValidationCacheCreateInfoEXT", pCreateInfo->stage.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(), allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->stage.flags", "VkPipelineShaderStageCreateFlagBits", AllVkPipelineShaderStageCreateFlagBits, pCreateInfo->stage.flags, kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->stage.stage", "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfo->stage.stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

        skip |= ValidateRequiredPointer(loc, "pCreateInfo->stage.pName", pCreateInfo->stage.pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

        if (pCreateInfo->stage.pSpecializationInfo != nullptr)
        {
            skip |= ValidateArray(loc, "pCreateInfo->stage.pSpecializationInfo->mapEntryCount", "pCreateInfo->stage.pSpecializationInfo->pMapEntries", pCreateInfo->stage.pSpecializationInfo->mapEntryCount, &pCreateInfo->stage.pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

            if (pCreateInfo->stage.pSpecializationInfo->pMapEntries != nullptr)
            {
                for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfo->stage.pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                {
                    // No xml-driven validation
                }
            }

            skip |= ValidateArray(loc, "pCreateInfo->stage.pSpecializationInfo->dataSize", "pCreateInfo->stage.pSpecializationInfo->pData", pCreateInfo->stage.pSpecializationInfo->dataSize, &pCreateInfo->stage.pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
        }

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->layout", pCreateInfo->layout);
    }
    skip |= ValidateStructType(loc, "pMemoryRequirements", "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true, "VUID-vkGetPipelineIndirectMemoryRequirementsNV-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr)
    {
        constexpr std::array allowed_structs_VkMemoryRequirements2 = { VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS };

        skip |= ValidateStructPnext(loc, "pMemoryRequirements->pNext", "VkMemoryDedicatedRequirements", pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext", "VUID-VkMemoryRequirements2-sType-unique", false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdUpdatePipelineIndirectBufferNV(
    VkCommandBuffer                             commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    VkPipeline                                  pipeline,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands_compute");
    skip |= ValidateRangedEnum(loc, "pipelineBindPoint", "VkPipelineBindPoint", pipelineBindPoint, "VUID-vkCmdUpdatePipelineIndirectBufferNV-pipelineBindPoint-parameter");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineIndirectDeviceAddressNV(
    VkDevice                                    device,
    const VkPipelineIndirectDeviceAddressInfoNV* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute)) skip |= OutputExtensionError(loc, "VK_NV_device_generated_commands_compute");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV", pInfo, VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV, true, "VUID-vkGetPipelineIndirectDeviceAddressNV-pInfo-parameter", "VUID-VkPipelineIndirectDeviceAddressInfoNV-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineIndirectDeviceAddressInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pInfo->pipelineBindPoint", "VkPipelineBindPoint", pInfo->pipelineBindPoint, "VUID-VkPipelineIndirectDeviceAddressInfoNV-pipelineBindPoint-parameter");

        skip |= ValidateRequiredHandle(loc, "pInfo->pipeline", pInfo->pipeline);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetTessellationDomainOriginEXT(
    VkCommandBuffer                             commandBuffer,
    VkTessellationDomainOrigin                  domainOrigin,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "domainOrigin", "VkTessellationDomainOrigin", domainOrigin, "VUID-vkCmdSetTessellationDomainOriginEXT-domainOrigin-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClampEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthClampEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "depthClampEnable", depthClampEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPolygonModeEXT(
    VkCommandBuffer                             commandBuffer,
    VkPolygonMode                               polygonMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "polygonMode", "VkPolygonMode", polygonMode, "VUID-vkCmdSetPolygonModeEXT-polygonMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizationSamplesEXT(
    VkCommandBuffer                             commandBuffer,
    VkSampleCountFlagBits                       rasterizationSamples,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateFlags(loc, "rasterizationSamples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, rasterizationSamples, kRequiredSingleBit, "VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter", "VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetSampleMaskEXT(
    VkCommandBuffer                             commandBuffer,
    VkSampleCountFlagBits                       samples,
    const VkSampleMask*                         pSampleMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateFlags(loc, "samples", "VkSampleCountFlagBits", AllVkSampleCountFlagBits, samples, kRequiredSingleBit, "VUID-vkCmdSetSampleMaskEXT-samples-parameter", "VUID-vkCmdSetSampleMaskEXT-samples-parameter");
    skip |= ValidateArray(loc, "(samples + 31) / 32", "pSampleMask", (samples + 31) / 32, &pSampleMask, true, true, kVUIDUndefined, "VUID-vkCmdSetSampleMaskEXT-pSampleMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetAlphaToCoverageEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    alphaToCoverageEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "alphaToCoverageEnable", alphaToCoverageEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetAlphaToOneEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    alphaToOneEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "alphaToOneEnable", alphaToOneEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLogicOpEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    logicOpEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "logicOpEnable", logicOpEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorBlendEnableEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    const VkBool32*                             pColorBlendEnables,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32Array(loc, "attachmentCount", "pColorBlendEnables", attachmentCount, pColorBlendEnables, true, true);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorBlendEquationEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    const VkColorBlendEquationEXT*              pColorBlendEquations,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateArray(loc, "attachmentCount", "pColorBlendEquations", attachmentCount, &pColorBlendEquations, true, true, "VUID-vkCmdSetColorBlendEquationEXT-attachmentCount-arraylength", "VUID-vkCmdSetColorBlendEquationEXT-pColorBlendEquations-parameter");
    if (pColorBlendEquations != nullptr)
    {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex)
        {
            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendEquations[%i].srcColorBlendFactor", ParameterName::IndexVector{ attachmentIndex }), "VkBlendFactor", pColorBlendEquations[attachmentIndex].srcColorBlendFactor, "VUID-VkColorBlendEquationEXT-srcColorBlendFactor-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendEquations[%i].dstColorBlendFactor", ParameterName::IndexVector{ attachmentIndex }), "VkBlendFactor", pColorBlendEquations[attachmentIndex].dstColorBlendFactor, "VUID-VkColorBlendEquationEXT-dstColorBlendFactor-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendEquations[%i].colorBlendOp", ParameterName::IndexVector{ attachmentIndex }), "VkBlendOp", pColorBlendEquations[attachmentIndex].colorBlendOp, "VUID-VkColorBlendEquationEXT-colorBlendOp-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendEquations[%i].srcAlphaBlendFactor", ParameterName::IndexVector{ attachmentIndex }), "VkBlendFactor", pColorBlendEquations[attachmentIndex].srcAlphaBlendFactor, "VUID-VkColorBlendEquationEXT-srcAlphaBlendFactor-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendEquations[%i].dstAlphaBlendFactor", ParameterName::IndexVector{ attachmentIndex }), "VkBlendFactor", pColorBlendEquations[attachmentIndex].dstAlphaBlendFactor, "VUID-VkColorBlendEquationEXT-dstAlphaBlendFactor-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendEquations[%i].alphaBlendOp", ParameterName::IndexVector{ attachmentIndex }), "VkBlendOp", pColorBlendEquations[attachmentIndex].alphaBlendOp, "VUID-VkColorBlendEquationEXT-alphaBlendOp-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorWriteMaskEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    const VkColorComponentFlags*                pColorWriteMasks,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateFlagsArray(loc, "attachmentCount", "pColorWriteMasks", "VkColorComponentFlagBits", AllVkColorComponentFlagBits, attachmentCount, pColorWriteMasks, true, "VUID-vkCmdSetColorWriteMaskEXT-pColorWriteMasks-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizationStreamEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    rasterizationStream,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetConservativeRasterizationModeEXT(
    VkCommandBuffer                             commandBuffer,
    VkConservativeRasterizationModeEXT          conservativeRasterizationMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "conservativeRasterizationMode", "VkConservativeRasterizationModeEXT", conservativeRasterizationMode, "VUID-vkCmdSetConservativeRasterizationModeEXT-conservativeRasterizationMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetExtraPrimitiveOverestimationSizeEXT(
    VkCommandBuffer                             commandBuffer,
    float                                       extraPrimitiveOverestimationSize,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClipEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    depthClipEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "depthClipEnable", depthClipEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetSampleLocationsEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    sampleLocationsEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "sampleLocationsEnable", sampleLocationsEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorBlendAdvancedEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    const VkColorBlendAdvancedEXT*              pColorBlendAdvanced,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateArray(loc, "attachmentCount", "pColorBlendAdvanced", attachmentCount, &pColorBlendAdvanced, true, true, "VUID-vkCmdSetColorBlendAdvancedEXT-attachmentCount-arraylength", "VUID-vkCmdSetColorBlendAdvancedEXT-pColorBlendAdvanced-parameter");
    if (pColorBlendAdvanced != nullptr)
    {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex)
        {
            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendAdvanced[%i].advancedBlendOp", ParameterName::IndexVector{ attachmentIndex }), "VkBlendOp", pColorBlendAdvanced[attachmentIndex].advancedBlendOp, "VUID-VkColorBlendAdvancedEXT-advancedBlendOp-parameter");

            skip |= ValidateBool32(loc, ParameterName("pColorBlendAdvanced[%i].srcPremultiplied", ParameterName::IndexVector{ attachmentIndex }), pColorBlendAdvanced[attachmentIndex].srcPremultiplied);

            skip |= ValidateBool32(loc, ParameterName("pColorBlendAdvanced[%i].dstPremultiplied", ParameterName::IndexVector{ attachmentIndex }), pColorBlendAdvanced[attachmentIndex].dstPremultiplied);

            skip |= ValidateRangedEnum(loc, ParameterName("pColorBlendAdvanced[%i].blendOverlap", ParameterName::IndexVector{ attachmentIndex }), "VkBlendOverlapEXT", pColorBlendAdvanced[attachmentIndex].blendOverlap, "VUID-VkColorBlendAdvancedEXT-blendOverlap-parameter");

            skip |= ValidateBool32(loc, ParameterName("pColorBlendAdvanced[%i].clampResults", ParameterName::IndexVector{ attachmentIndex }), pColorBlendAdvanced[attachmentIndex].clampResults);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetProvokingVertexModeEXT(
    VkCommandBuffer                             commandBuffer,
    VkProvokingVertexModeEXT                    provokingVertexMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "provokingVertexMode", "VkProvokingVertexModeEXT", provokingVertexMode, "VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineRasterizationModeEXT(
    VkCommandBuffer                             commandBuffer,
    VkLineRasterizationModeEXT                  lineRasterizationMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "lineRasterizationMode", "VkLineRasterizationModeEXT", lineRasterizationMode, "VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineStippleEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    stippledLineEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "stippledLineEnable", stippledLineEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClipNegativeOneToOneEXT(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    negativeOneToOne,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "negativeOneToOne", negativeOneToOne);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWScalingEnableNV(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    viewportWScalingEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "viewportWScalingEnable", viewportWScalingEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportSwizzleNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    const VkViewportSwizzleNV*                  pViewportSwizzles,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateArray(loc, "viewportCount", "pViewportSwizzles", viewportCount, &pViewportSwizzles, true, true, "VUID-vkCmdSetViewportSwizzleNV-viewportCount-arraylength", "VUID-vkCmdSetViewportSwizzleNV-pViewportSwizzles-parameter");
    if (pViewportSwizzles != nullptr)
    {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex)
        {
            skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].x", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", pViewportSwizzles[viewportIndex].x, "VUID-VkViewportSwizzleNV-x-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].y", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", pViewportSwizzles[viewportIndex].y, "VUID-VkViewportSwizzleNV-y-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].z", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", pViewportSwizzles[viewportIndex].z, "VUID-VkViewportSwizzleNV-z-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pViewportSwizzles[%i].w", ParameterName::IndexVector{ viewportIndex }), "VkViewportCoordinateSwizzleNV", pViewportSwizzles[viewportIndex].w, "VUID-VkViewportSwizzleNV-w-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageToColorEnableNV(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    coverageToColorEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "coverageToColorEnable", coverageToColorEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageToColorLocationNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    coverageToColorLocation,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageModulationModeNV(
    VkCommandBuffer                             commandBuffer,
    VkCoverageModulationModeNV                  coverageModulationMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "coverageModulationMode", "VkCoverageModulationModeNV", coverageModulationMode, "VUID-vkCmdSetCoverageModulationModeNV-coverageModulationMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageModulationTableEnableNV(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    coverageModulationTableEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "coverageModulationTableEnable", coverageModulationTableEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageModulationTableNV(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    coverageModulationTableCount,
    const float*                                pCoverageModulationTable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateArray(loc, "coverageModulationTableCount", "pCoverageModulationTable", coverageModulationTableCount, &pCoverageModulationTable, true, true, "VUID-vkCmdSetCoverageModulationTableNV-coverageModulationTableCount-arraylength", "VUID-vkCmdSetCoverageModulationTableNV-pCoverageModulationTable-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetShadingRateImageEnableNV(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    shadingRateImageEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "shadingRateImageEnable", shadingRateImageEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRepresentativeFragmentTestEnableNV(
    VkCommandBuffer                             commandBuffer,
    VkBool32                                    representativeFragmentTestEnable,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateBool32(loc, "representativeFragmentTestEnable", representativeFragmentTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageReductionModeNV(
    VkCommandBuffer                             commandBuffer,
    VkCoverageReductionModeNV                   coverageReductionMode,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object))) skip |= OutputExtensionError(loc, "VK_EXT_extended_dynamic_state3 || VK_EXT_shader_object");
    skip |= ValidateRangedEnum(loc, "coverageReductionMode", "VkCoverageReductionModeNV", coverageReductionMode, "VUID-vkCmdSetCoverageReductionModeNV-coverageReductionMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderModuleIdentifierEXT(
    VkDevice                                    device,
    VkShaderModule                              shaderModule,
    VkShaderModuleIdentifierEXT*                pIdentifier,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_module_identifier)) skip |= OutputExtensionError(loc, "VK_EXT_shader_module_identifier");
    skip |= ValidateRequiredHandle(loc, "shaderModule", shaderModule);
    skip |= ValidateStructType(loc, "pIdentifier", "VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT", pIdentifier, VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, true, "VUID-vkGetShaderModuleIdentifierEXT-pIdentifier-parameter", "VUID-VkShaderModuleIdentifierEXT-sType-sType");
    if (pIdentifier != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pIdentifier->pNext", nullptr, pIdentifier->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkShaderModuleIdentifierEXT-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderModuleCreateInfoIdentifierEXT(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    VkShaderModuleIdentifierEXT*                pIdentifier,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_module_identifier)) skip |= OutputExtensionError(loc, "VK_EXT_shader_module_identifier");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true, "VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pCreateInfo-parameter", "VUID-VkShaderModuleCreateInfo-sType-sType");
    if (pCreateInfo != nullptr)
    {
        skip |= ValidateReservedFlags(loc, "pCreateInfo->flags", pCreateInfo->flags, "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(loc, "pCreateInfo->codeSize / 4", "pCreateInfo->pCode", pCreateInfo->codeSize / 4, &pCreateInfo->pCode, true, true, kVUIDUndefined, "VUID-VkShaderModuleCreateInfo-pCode-parameter");
    }
    skip |= ValidateStructType(loc, "pIdentifier", "VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT", pIdentifier, VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, true, "VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pIdentifier-parameter", "VUID-VkShaderModuleIdentifierEXT-sType-sType");
    if (pIdentifier != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pIdentifier->pNext", nullptr, pIdentifier->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkShaderModuleIdentifierEXT-pNext-pNext", kVUIDUndefined, false, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceOpticalFlowImageFormatsNV(
    VkPhysicalDevice                            physicalDevice,
    const VkOpticalFlowImageFormatInfoNV*       pOpticalFlowImageFormatInfo,
    uint32_t*                                   pFormatCount,
    VkOpticalFlowImageFormatPropertiesNV*       pImageFormatProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    skip |= ValidateStructType(loc, "pOpticalFlowImageFormatInfo", "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV", pOpticalFlowImageFormatInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, true, "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pOpticalFlowImageFormatInfo-parameter", "VUID-VkOpticalFlowImageFormatInfoNV-sType-sType");
    if (pOpticalFlowImageFormatInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pOpticalFlowImageFormatInfo->pNext", nullptr, pOpticalFlowImageFormatInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, true, true);

        skip |= ValidateFlags(loc, "pOpticalFlowImageFormatInfo->usage", "VkOpticalFlowUsageFlagBitsNV", AllVkOpticalFlowUsageFlagBitsNV, pOpticalFlowImageFormatInfo->usage, kRequiredFlags, "VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter", "VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask");
    }
    skip |= ValidateStructTypeArray(loc, "pFormatCount", "pImageFormatProperties", "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV", pFormatCount, pImageFormatProperties, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV, true, false, false, "VUID-VkOpticalFlowImageFormatPropertiesNV-sType-sType", "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pImageFormatProperties-parameter", kVUIDUndefined);
    if (pImageFormatProperties != nullptr)
    {
        for (uint32_t pFormatIndex = 0; pFormatIndex < *pFormatCount; ++pFormatIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pImageFormatProperties[%i].pNext", ParameterName::IndexVector{ pFormatIndex }), nullptr, pImageFormatProperties[pFormatIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkOpticalFlowImageFormatPropertiesNV-pNext-pNext", kVUIDUndefined, true, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateOpticalFlowSessionNV(
    VkDevice                                    device,
    const VkOpticalFlowSessionCreateInfoNV*     pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkOpticalFlowSessionNV*                     pSession,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, "VK_NV_optical_flow");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV", pCreateInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV, true, "VUID-vkCreateOpticalFlowSessionNV-pCreateInfo-parameter", "VUID-VkOpticalFlowSessionCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkOpticalFlowSessionCreateInfoNV = { VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkOpticalFlowSessionCreatePrivateDataInfoNV", pCreateInfo->pNext, allowed_structs_VkOpticalFlowSessionCreateInfoNV.size(), allowed_structs_VkOpticalFlowSessionCreateInfoNV.data(), GeneratedVulkanHeaderVersion, "VUID-VkOpticalFlowSessionCreateInfoNV-pNext-pNext", "VUID-VkOpticalFlowSessionCreateInfoNV-sType-unique", false, true);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->imageFormat", "VkFormat", pCreateInfo->imageFormat, "VUID-VkOpticalFlowSessionCreateInfoNV-imageFormat-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->flowVectorFormat", "VkFormat", pCreateInfo->flowVectorFormat, "VUID-VkOpticalFlowSessionCreateInfoNV-flowVectorFormat-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->costFormat", "VkFormat", pCreateInfo->costFormat, "VUID-VkOpticalFlowSessionCreateInfoNV-costFormat-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->outputGridSize", "VkOpticalFlowGridSizeFlagBitsNV", AllVkOpticalFlowGridSizeFlagBitsNV, pCreateInfo->outputGridSize, kRequiredFlags, "VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-parameter", "VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-requiredbitmask");

        skip |= ValidateFlags(loc, "pCreateInfo->hintGridSize", "VkOpticalFlowGridSizeFlagBitsNV", AllVkOpticalFlowGridSizeFlagBitsNV, pCreateInfo->hintGridSize, kOptionalFlags, "VUID-VkOpticalFlowSessionCreateInfoNV-hintGridSize-parameter");

        skip |= ValidateRangedEnum(loc, "pCreateInfo->performanceLevel", "VkOpticalFlowPerformanceLevelNV", pCreateInfo->performanceLevel, "VUID-VkOpticalFlowSessionCreateInfoNV-performanceLevel-parameter");

        skip |= ValidateFlags(loc, "pCreateInfo->flags", "VkOpticalFlowSessionCreateFlagBitsNV", AllVkOpticalFlowSessionCreateFlagBitsNV, pCreateInfo->flags, kOptionalFlags, "VUID-VkOpticalFlowSessionCreateInfoNV-flags-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pSession", pSession, "VUID-vkCreateOpticalFlowSessionNV-pSession-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyOpticalFlowSessionNV(
    VkDevice                                    device,
    VkOpticalFlowSessionNV                      session,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, "VK_NV_optical_flow");
    skip |= ValidateRequiredHandle(loc, "session", session);
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindOpticalFlowSessionImageNV(
    VkDevice                                    device,
    VkOpticalFlowSessionNV                      session,
    VkOpticalFlowSessionBindingPointNV          bindingPoint,
    VkImageView                                 view,
    VkImageLayout                               layout,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, "VK_NV_optical_flow");
    skip |= ValidateRequiredHandle(loc, "session", session);
    skip |= ValidateRangedEnum(loc, "bindingPoint", "VkOpticalFlowSessionBindingPointNV", bindingPoint, "VUID-vkBindOpticalFlowSessionImageNV-bindingPoint-parameter");
    skip |= ValidateRangedEnum(loc, "layout", "VkImageLayout", layout, "VUID-vkBindOpticalFlowSessionImageNV-layout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdOpticalFlowExecuteNV(
    VkCommandBuffer                             commandBuffer,
    VkOpticalFlowSessionNV                      session,
    const VkOpticalFlowExecuteInfoNV*           pExecuteInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, "VK_NV_optical_flow");
    skip |= ValidateRequiredHandle(loc, "session", session);
    skip |= ValidateStructType(loc, "pExecuteInfo", "VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV", pExecuteInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV, true, "VUID-vkCmdOpticalFlowExecuteNV-pExecuteInfo-parameter", "VUID-VkOpticalFlowExecuteInfoNV-sType-sType");
    if (pExecuteInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pExecuteInfo->pNext", nullptr, pExecuteInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkOpticalFlowExecuteInfoNV-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateFlags(loc, "pExecuteInfo->flags", "VkOpticalFlowExecuteFlagBitsNV", AllVkOpticalFlowExecuteFlagBitsNV, pExecuteInfo->flags, kOptionalFlags, "VUID-VkOpticalFlowExecuteInfoNV-flags-parameter");

        skip |= ValidateArray(loc, "pExecuteInfo->regionCount", "pExecuteInfo->pRegions", pExecuteInfo->regionCount, &pExecuteInfo->pRegions, false, true, kVUIDUndefined, "VUID-VkOpticalFlowExecuteInfoNV-pRegions-parameter");

        if (pExecuteInfo->pRegions != nullptr)
        {
            for (uint32_t regionIndex = 0; regionIndex < pExecuteInfo->regionCount; ++regionIndex)
            {
                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateShadersEXT(
    VkDevice                                    device,
    uint32_t                                    createInfoCount,
    const VkShaderCreateInfoEXT*                pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderEXT*                                pShaders,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, "VK_EXT_shader_object");
    skip |= ValidateStructTypeArray(loc, "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT, true, true, "VUID-VkShaderCreateInfoEXT-sType-sType", "VUID-vkCreateShadersEXT-pCreateInfos-parameter", "VUID-vkCreateShadersEXT-createInfoCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            constexpr std::array allowed_structs_VkShaderCreateInfoEXT = { VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo", pCreateInfos[createInfoIndex].pNext, allowed_structs_VkShaderCreateInfoEXT.size(), allowed_structs_VkShaderCreateInfoEXT.data(), GeneratedVulkanHeaderVersion, "VUID-VkShaderCreateInfoEXT-pNext-pNext", "VUID-VkShaderCreateInfoEXT-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkShaderCreateFlagBitsEXT", AllVkShaderCreateFlagBitsEXT, pCreateInfos[createInfoIndex].flags, kOptionalFlags, "VUID-VkShaderCreateInfoEXT-flags-parameter");

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].stage", ParameterName::IndexVector{ createInfoIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage, kRequiredSingleBit, "VUID-VkShaderCreateInfoEXT-stage-parameter", "VUID-VkShaderCreateInfoEXT-stage-parameter");

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].nextStage", ParameterName::IndexVector{ createInfoIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].nextStage, kOptionalFlags, "VUID-VkShaderCreateInfoEXT-nextStage-parameter");

            skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].codeType", ParameterName::IndexVector{ createInfoIndex }), "VkShaderCodeTypeEXT", pCreateInfos[createInfoIndex].codeType, "VUID-VkShaderCreateInfoEXT-codeType-parameter");

            skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].codeSize", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pCode", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].codeSize, &pCreateInfos[createInfoIndex].pCode, true, true, "VUID-VkShaderCreateInfoEXT-codeSize-arraylength", "VUID-VkShaderCreateInfoEXT-pCode-parameter");

            if (pCreateInfos[createInfoIndex].pPushConstantRanges != nullptr)
            {
                for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < pCreateInfos[createInfoIndex].pushConstantRangeCount; ++pushConstantRangeIndex)
                {
                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pPushConstantRanges[%i].stageFlags", ParameterName::IndexVector{ createInfoIndex, pushConstantRangeIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pPushConstantRanges[pushConstantRangeIndex].stageFlags, kRequiredFlags, "VUID-VkPushConstantRange-stageFlags-parameter", "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
                }
            }

            if (pCreateInfos[createInfoIndex].pSpecializationInfo != nullptr)
            {
                skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pSpecializationInfo->mapEntryCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pSpecializationInfo->pMapEntries", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pSpecializationInfo->mapEntryCount, &pCreateInfos[createInfoIndex].pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                if (pCreateInfos[createInfoIndex].pSpecializationInfo->pMapEntries != nullptr)
                {
                    for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfos[createInfoIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                    {
                        // No xml-driven validation
                    }
                }

                skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pSpecializationInfo->dataSize, &pCreateInfos[createInfoIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
            }
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "createInfoCount", "pShaders", createInfoCount, &pShaders, true, true, "VUID-vkCreateShadersEXT-createInfoCount-arraylength", "VUID-vkCreateShadersEXT-pShaders-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyShaderEXT(
    VkDevice                                    device,
    VkShaderEXT                                 shader,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, "VK_EXT_shader_object");
    skip |= ValidateRequiredHandle(loc, "shader", shader);
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderBinaryDataEXT(
    VkDevice                                    device,
    VkShaderEXT                                 shader,
    size_t*                                     pDataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, "VK_EXT_shader_object");
    skip |= ValidateRequiredHandle(loc, "shader", shader);
    skip |= ValidateArray(loc, "pDataSize", "pData", pDataSize, &pData, true, false, false, kVUIDUndefined, "VUID-vkGetShaderBinaryDataEXT-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateGetShaderBinaryDataEXT(device, shader, pDataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindShadersEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    stageCount,
    const VkShaderStageFlagBits*                pStages,
    const VkShaderEXT*                          pShaders,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, "VK_EXT_shader_object");
    skip |= ValidateArray(loc, "stageCount", "pStages", stageCount, &pStages, true, true, "VUID-vkCmdBindShadersEXT-stageCount-arraylength", "VUID-vkCmdBindShadersEXT-pStages-parameter");
    skip |= ValidateArray(loc, "stageCount", "pShaders", stageCount, &pShaders, true, false, "VUID-vkCmdBindShadersEXT-stageCount-arraylength", "VUID-vkCmdBindShadersEXT-pShaders-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetFramebufferTilePropertiesQCOM(
    VkDevice                                    device,
    VkFramebuffer                               framebuffer,
    uint32_t*                                   pPropertiesCount,
    VkTilePropertiesQCOM*                       pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_qcom_tile_properties)) skip |= OutputExtensionError(loc, "VK_QCOM_tile_properties");
    skip |= ValidateRequiredHandle(loc, "framebuffer", framebuffer);
    skip |= ValidateStructTypeArray(loc, "pPropertiesCount", "pProperties", "VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM", pPropertiesCount, pProperties, VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, true, false, false, "VUID-VkTilePropertiesQCOM-sType-sType", "VUID-vkGetFramebufferTilePropertiesQCOM-pProperties-parameter", kVUIDUndefined);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDynamicRenderingTilePropertiesQCOM(
    VkDevice                                    device,
    const VkRenderingInfo*                      pRenderingInfo,
    VkTilePropertiesQCOM*                       pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_qcom_tile_properties)) skip |= OutputExtensionError(loc, "VK_QCOM_tile_properties");
    skip |= ValidateStructType(loc, "pRenderingInfo", "VK_STRUCTURE_TYPE_RENDERING_INFO", pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true, "VUID-vkGetDynamicRenderingTilePropertiesQCOM-pRenderingInfo-parameter", "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkRenderingInfo = { VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX, VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT, VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR };

        skip |= ValidateStructPnext(loc, "pRenderingInfo->pNext", "VkDeviceGroupRenderPassBeginInfo, VkMultisampledRenderToSingleSampledInfoEXT, VkMultiviewPerViewAttributesInfoNVX, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM, VkRenderingFragmentDensityMapAttachmentInfoEXT, VkRenderingFragmentShadingRateAttachmentInfoKHR", pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(), allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pRenderingInfo->flags", "VkRenderingFlagBits", AllVkRenderingFlagBits, pRenderingInfo->flags, kOptionalFlags, "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateStructTypeArray(loc, "pRenderingInfo->colorAttachmentCount", "pRenderingInfo->pColorAttachments", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->colorAttachmentCount, pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, true, "VUID-VkRenderingAttachmentInfo-sType-sType", "VUID-VkRenderingInfo-pColorAttachments-parameter", kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr)
        {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount; ++colorAttachmentIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].pNext", ParameterName::IndexVector{ colorAttachmentIndex }), nullptr, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].imageLayout", ParameterName::IndexVector{ colorAttachmentIndex }), "VkImageLayout", pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

                skip |= ValidateFlags(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].resolveMode", ParameterName::IndexVector{ colorAttachmentIndex }), "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].resolveImageLayout", ParameterName::IndexVector{ colorAttachmentIndex }), "VkImageLayout", pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].loadOp", ParameterName::IndexVector{ colorAttachmentIndex }), "VkAttachmentLoadOp", pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

                skip |= ValidateRangedEnum(loc, ParameterName("pRenderingInfo->pColorAttachments[%i].storeOp", ParameterName::IndexVector{ colorAttachmentIndex }), "VkAttachmentStoreOp", pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

                // No xml-driven validation
            }
        }

        skip |= ValidateStructType(loc, "pRenderingInfo->pDepthAttachment", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->pDepthAttachment, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, "VUID-VkRenderingInfo-pDepthAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pRenderingInfo->pDepthAttachment->pNext", nullptr, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->imageLayout", "VkImageLayout", pRenderingInfo->pDepthAttachment->imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= ValidateFlags(loc, "pRenderingInfo->pDepthAttachment->resolveMode", "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->resolveImageLayout", "VkImageLayout", pRenderingInfo->pDepthAttachment->resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->loadOp", "VkAttachmentLoadOp", pRenderingInfo->pDepthAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pDepthAttachment->storeOp", "VkAttachmentStoreOp", pRenderingInfo->pDepthAttachment->storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }

        skip |= ValidateStructType(loc, "pRenderingInfo->pStencilAttachment", "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", pRenderingInfo->pStencilAttachment, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, "VUID-VkRenderingInfo-pStencilAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr)
        {
            skip |= ValidateStructPnext(loc, "pRenderingInfo->pStencilAttachment->pNext", nullptr, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->imageLayout", "VkImageLayout", pRenderingInfo->pStencilAttachment->imageLayout, "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= ValidateFlags(loc, "pRenderingInfo->pStencilAttachment->resolveMode", "VkResolveModeFlagBits", AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode, kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->resolveImageLayout", "VkImageLayout", pRenderingInfo->pStencilAttachment->resolveImageLayout, "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->loadOp", "VkAttachmentLoadOp", pRenderingInfo->pStencilAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= ValidateRangedEnum(loc, "pRenderingInfo->pStencilAttachment->storeOp", "VkAttachmentStoreOp", pRenderingInfo->pStencilAttachment->storeOp, "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }
    }
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM", pProperties, VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, true, "VUID-vkGetDynamicRenderingTilePropertiesQCOM-pProperties-parameter", "VUID-VkTilePropertiesQCOM-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetAttachmentFeedbackLoopEnableEXT(
    VkCommandBuffer                             commandBuffer,
    VkImageAspectFlags                          aspectMask,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_attachment_feedback_loop_dynamic_state)) skip |= OutputExtensionError(loc, "VK_EXT_attachment_feedback_loop_dynamic_state");
    skip |= ValidateFlags(loc, "aspectMask", "VkImageAspectFlagBits", AllVkImageAspectFlagBits, aspectMask, kOptionalFlags, "VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-aspectMask-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool StatelessValidation::PreCallValidateGetScreenBufferPropertiesQNX(
    VkDevice                                    device,
    const struct _screen_buffer*                buffer,
    VkScreenBufferPropertiesQNX*                pProperties,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_qnx_external_memory_screen_buffer)) skip |= OutputExtensionError(loc, "VK_QNX_external_memory_screen_buffer");
    skip |= ValidateRequiredPointer(loc, "buffer", buffer, "VUID-vkGetScreenBufferPropertiesQNX-buffer-parameter");
    skip |= ValidateStructType(loc, "pProperties", "VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX", pProperties, VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX, true, "VUID-vkGetScreenBufferPropertiesQNX-pProperties-parameter", "VUID-VkScreenBufferPropertiesQNX-sType-sType");
    if (pProperties != nullptr)
    {
        constexpr std::array allowed_structs_VkScreenBufferPropertiesQNX = { VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX };

        skip |= ValidateStructPnext(loc, "pProperties->pNext", "VkScreenBufferFormatPropertiesQNX", pProperties->pNext, allowed_structs_VkScreenBufferPropertiesQNX.size(), allowed_structs_VkScreenBufferPropertiesQNX.data(), GeneratedVulkanHeaderVersion, "VUID-VkScreenBufferPropertiesQNX-pNext-pNext", "VUID-VkScreenBufferPropertiesQNX-sType-unique", false, false);
    }
    return skip;
}
#endif // VK_USE_PLATFORM_SCREEN_QNX

bool StatelessValidation::PreCallValidateCreateAccelerationStructureKHR(
    VkDevice                                    device,
    const VkAccelerationStructureCreateInfoKHR* pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkAccelerationStructureKHR*                 pAccelerationStructure,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pCreateInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR", pCreateInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR, true, "VUID-vkCreateAccelerationStructureKHR-pCreateInfo-parameter", "VUID-VkAccelerationStructureCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr)
    {
        constexpr std::array allowed_structs_VkAccelerationStructureCreateInfoKHR = { VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV, VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT };

        skip |= ValidateStructPnext(loc, "pCreateInfo->pNext", "VkAccelerationStructureMotionInfoNV, VkOpaqueCaptureDescriptorDataCreateInfoEXT", pCreateInfo->pNext, allowed_structs_VkAccelerationStructureCreateInfoKHR.size(), allowed_structs_VkAccelerationStructureCreateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureCreateInfoKHR-pNext-pNext", "VUID-VkAccelerationStructureCreateInfoKHR-sType-unique", false, true);

        skip |= ValidateFlags(loc, "pCreateInfo->createFlags", "VkAccelerationStructureCreateFlagBitsKHR", AllVkAccelerationStructureCreateFlagBitsKHR, pCreateInfo->createFlags, kOptionalFlags, "VUID-VkAccelerationStructureCreateInfoKHR-createFlags-parameter");

        skip |= ValidateRequiredHandle(loc, "pCreateInfo->buffer", pCreateInfo->buffer);

        skip |= ValidateRangedEnum(loc, "pCreateInfo->type", "VkAccelerationStructureTypeKHR", pCreateInfo->type, "VUID-VkAccelerationStructureCreateInfoKHR-type-parameter");
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateRequiredPointer(loc, "pAccelerationStructure", pAccelerationStructure, "VUID-vkCreateAccelerationStructureKHR-pAccelerationStructure-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyAccelerationStructureKHR(
    VkDevice                                    device,
    VkAccelerationStructureKHR                  accelerationStructure,
    const VkAllocationCallbacks*                pAllocator,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildAccelerationStructuresKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructTypeArray(loc, "infoCount", "pInfos", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR", infoCount, pInfos, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType", "VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-parameter", "VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength");
    if (pInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pNext", ParameterName::IndexVector{ infoIndex }), nullptr, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].type", ParameterName::IndexVector{ infoIndex }), "VkAccelerationStructureTypeKHR", pInfos[infoIndex].type, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

            skip |= ValidateFlags(loc, ParameterName("pInfos[%i].flags", ParameterName::IndexVector{ infoIndex }), "VkBuildAccelerationStructureFlagBitsKHR", AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pInfos[%i].geometryCount", ParameterName::IndexVector{ infoIndex }), ParameterName("pInfos[%i].pGeometries", ParameterName::IndexVector{ infoIndex }), "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pInfos[infoIndex].geometryCount, pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr)
            {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pGeometries[%i].pNext", ParameterName::IndexVector{ infoIndex, geometryIndex }), nullptr, pInfos[infoIndex].pGeometries[geometryIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].pGeometries[%i].geometryType", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryTypeKHR", pInfos[infoIndex].pGeometries[geometryIndex].geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pInfos[%i].pGeometries[%i].flags", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= ValidateStructPointerTypeArray(loc, ParameterName("pInfos[%i].geometryCount", ParameterName::IndexVector{ infoIndex }), ParameterName("pInfos[%i].ppGeometries", ParameterName::IndexVector{ infoIndex }), "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pInfos[infoIndex].geometryCount, pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr)
            {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].ppGeometries[%i]->pNext", ParameterName::IndexVector{ infoIndex, geometryIndex }), nullptr, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].ppGeometries[%i]->geometryType", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryTypeKHR", pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pInfos[%i].ppGeometries[%i]->flags", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= ValidateArray(loc, "infoCount", "ppBuildRangeInfos", infoCount, &ppBuildRangeInfos, true, true, "VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength", "VUID-vkCmdBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter");
    if (ppBuildRangeInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildAccelerationStructuresIndirectKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkDeviceAddress*                      pIndirectDeviceAddresses,
    const uint32_t*                             pIndirectStrides,
    const uint32_t* const*                      ppMaxPrimitiveCounts,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructTypeArray(loc, "infoCount", "pInfos", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR", infoCount, pInfos, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType", "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-parameter", "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength");
    if (pInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pNext", ParameterName::IndexVector{ infoIndex }), nullptr, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].type", ParameterName::IndexVector{ infoIndex }), "VkAccelerationStructureTypeKHR", pInfos[infoIndex].type, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

            skip |= ValidateFlags(loc, ParameterName("pInfos[%i].flags", ParameterName::IndexVector{ infoIndex }), "VkBuildAccelerationStructureFlagBitsKHR", AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pInfos[%i].geometryCount", ParameterName::IndexVector{ infoIndex }), ParameterName("pInfos[%i].pGeometries", ParameterName::IndexVector{ infoIndex }), "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pInfos[infoIndex].geometryCount, pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr)
            {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pGeometries[%i].pNext", ParameterName::IndexVector{ infoIndex, geometryIndex }), nullptr, pInfos[infoIndex].pGeometries[geometryIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].pGeometries[%i].geometryType", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryTypeKHR", pInfos[infoIndex].pGeometries[geometryIndex].geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pInfos[%i].pGeometries[%i].flags", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= ValidateStructPointerTypeArray(loc, ParameterName("pInfos[%i].geometryCount", ParameterName::IndexVector{ infoIndex }), ParameterName("pInfos[%i].ppGeometries", ParameterName::IndexVector{ infoIndex }), "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pInfos[infoIndex].geometryCount, pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr)
            {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].ppGeometries[%i]->pNext", ParameterName::IndexVector{ infoIndex, geometryIndex }), nullptr, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].ppGeometries[%i]->geometryType", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryTypeKHR", pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pInfos[%i].ppGeometries[%i]->flags", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= ValidateArray(loc, "infoCount", "pIndirectDeviceAddresses", infoCount, &pIndirectDeviceAddresses, true, true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength", "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-parameter");
    skip |= ValidateArray(loc, "infoCount", "pIndirectStrides", infoCount, &pIndirectStrides, true, true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength", "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-parameter");
    skip |= ValidateArray(loc, "infoCount", "ppMaxPrimitiveCounts", infoCount, &ppMaxPrimitiveCounts, true, true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength", "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateBuildAccelerationStructuresKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    uint32_t                                    infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructTypeArray(loc, "infoCount", "pInfos", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR", infoCount, pInfos, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType", "VUID-vkBuildAccelerationStructuresKHR-pInfos-parameter", "VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength");
    if (pInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pNext", ParameterName::IndexVector{ infoIndex }), nullptr, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

            skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].type", ParameterName::IndexVector{ infoIndex }), "VkAccelerationStructureTypeKHR", pInfos[infoIndex].type, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

            skip |= ValidateFlags(loc, ParameterName("pInfos[%i].flags", ParameterName::IndexVector{ infoIndex }), "VkBuildAccelerationStructureFlagBitsKHR", AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pInfos[%i].geometryCount", ParameterName::IndexVector{ infoIndex }), ParameterName("pInfos[%i].pGeometries", ParameterName::IndexVector{ infoIndex }), "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pInfos[infoIndex].geometryCount, pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr)
            {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].pGeometries[%i].pNext", ParameterName::IndexVector{ infoIndex, geometryIndex }), nullptr, pInfos[infoIndex].pGeometries[geometryIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].pGeometries[%i].geometryType", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryTypeKHR", pInfos[infoIndex].pGeometries[geometryIndex].geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pInfos[%i].pGeometries[%i].flags", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= ValidateStructPointerTypeArray(loc, ParameterName("pInfos[%i].geometryCount", ParameterName::IndexVector{ infoIndex }), ParameterName("pInfos[%i].ppGeometries", ParameterName::IndexVector{ infoIndex }), "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pInfos[infoIndex].geometryCount, pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr)
            {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pInfos[%i].ppGeometries[%i]->pNext", ParameterName::IndexVector{ infoIndex, geometryIndex }), nullptr, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pInfos[%i].ppGeometries[%i]->geometryType", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryTypeKHR", pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pInfos[%i].ppGeometries[%i]->flags", ParameterName::IndexVector{ infoIndex, geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= ValidateArray(loc, "infoCount", "ppBuildRangeInfos", infoCount, &ppBuildRangeInfos, true, true, "VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength", "VUID-vkBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter");
    if (ppBuildRangeInfos != nullptr)
    {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex)
        {
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyAccelerationStructureKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    const VkCopyAccelerationStructureInfoKHR*   pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, true, "VUID-vkCopyAccelerationStructureKHR-pInfo-parameter", "VUID-VkCopyAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyAccelerationStructureModeKHR", pInfo->mode, "VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyAccelerationStructureKHR(device, deferredOperation, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyAccelerationStructureToMemoryKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR, true, "VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-parameter", "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyAccelerationStructureModeKHR", pInfo->mode, "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMemoryToAccelerationStructureKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR, true, "VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-parameter", "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyAccelerationStructureModeKHR", pInfo->mode, "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateWriteAccelerationStructuresPropertiesKHR(
    VkDevice                                    device,
    uint32_t                                    accelerationStructureCount,
    const VkAccelerationStructureKHR*           pAccelerationStructures,
    VkQueryType                                 queryType,
    size_t                                      dataSize,
    void*                                       pData,
    size_t                                      stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateHandleArray(loc, "accelerationStructureCount", "pAccelerationStructures", accelerationStructureCount, pAccelerationStructures, true, true, "VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength");
    skip |= ValidateRangedEnum(loc, "queryType", "VkQueryType", queryType, "VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-parameter");
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-arraylength", "VUID-vkWriteAccelerationStructuresPropertiesKHR-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyAccelerationStructureKHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyAccelerationStructureInfoKHR*   pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, true, "VUID-vkCmdCopyAccelerationStructureKHR-pInfo-parameter", "VUID-VkCopyAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyAccelerationStructureModeKHR", pInfo->mode, "VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyAccelerationStructureKHR(commandBuffer, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyAccelerationStructureToMemoryKHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR, true, "VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-parameter", "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->src", pInfo->src);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyAccelerationStructureModeKHR", pInfo->mode, "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryToAccelerationStructureKHR(
    VkCommandBuffer                             commandBuffer,
    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR, true, "VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-parameter", "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->dst", pInfo->dst);

        skip |= ValidateRangedEnum(loc, "pInfo->mode", "VkCopyAccelerationStructureModeKHR", pInfo->mode, "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureDeviceAddressKHR(
    VkDevice                                    device,
    const VkAccelerationStructureDeviceAddressInfoKHR* pInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR", pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR, true, "VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-parameter", "VUID-VkAccelerationStructureDeviceAddressInfoKHR-sType-sType");
    if (pInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pInfo->pNext", nullptr, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureDeviceAddressInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredHandle(loc, "pInfo->accelerationStructure", pInfo->accelerationStructure);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteAccelerationStructuresPropertiesKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    accelerationStructureCount,
    const VkAccelerationStructureKHR*           pAccelerationStructures,
    VkQueryType                                 queryType,
    VkQueryPool                                 queryPool,
    uint32_t                                    firstQuery,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateHandleArray(loc, "accelerationStructureCount", "pAccelerationStructures", accelerationStructureCount, pAccelerationStructures, true, true, "VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength");
    skip |= ValidateRangedEnum(loc, "queryType", "VkQueryType", queryType, "VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-parameter");
    skip |= ValidateRequiredHandle(loc, "queryPool", queryPool);
    if (!skip) skip |= manual_PreCallValidateCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice                                    device,
    const VkAccelerationStructureVersionInfoKHR* pVersionInfo,
    VkAccelerationStructureCompatibilityKHR*    pCompatibility,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateStructType(loc, "pVersionInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR", pVersionInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR, true, "VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pVersionInfo-parameter", "VUID-VkAccelerationStructureVersionInfoKHR-sType-sType");
    if (pVersionInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pVersionInfo->pNext", nullptr, pVersionInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureVersionInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRequiredPointer(loc, "pVersionInfo->pVersionData", pVersionInfo->pVersionData, "VUID-VkAccelerationStructureVersionInfoKHR-pVersionData-parameter");
    }
    skip |= ValidateRequiredPointer(loc, "pCompatibility", pCompatibility, "VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pCompatibility-parameter");
    if (!skip) skip |= manual_PreCallValidateGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureBuildSizesKHR(
    VkDevice                                    device,
    VkAccelerationStructureBuildTypeKHR         buildType,
    const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,
    const uint32_t*                             pMaxPrimitiveCounts,
    VkAccelerationStructureBuildSizesInfoKHR*   pSizeInfo,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) skip |= OutputExtensionError(loc, "VK_KHR_acceleration_structure");
    skip |= ValidateRangedEnum(loc, "buildType", "VkAccelerationStructureBuildTypeKHR", buildType, "VUID-vkGetAccelerationStructureBuildSizesKHR-buildType-parameter");
    skip |= ValidateStructType(loc, "pBuildInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR", pBuildInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, "VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-parameter", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType");
    if (pBuildInfo != nullptr)
    {
        skip |= ValidateStructPnext(loc, "pBuildInfo->pNext", nullptr, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

        skip |= ValidateRangedEnum(loc, "pBuildInfo->type", "VkAccelerationStructureTypeKHR", pBuildInfo->type, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

        skip |= ValidateFlags(loc, "pBuildInfo->flags", "VkBuildAccelerationStructureFlagBitsKHR", AllVkBuildAccelerationStructureFlagBitsKHR, pBuildInfo->flags, kOptionalFlags, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

        skip |= ValidateStructTypeArray(loc, "pBuildInfo->geometryCount", "pBuildInfo->pGeometries", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pBuildInfo->geometryCount, pBuildInfo->pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

        if (pBuildInfo->pGeometries != nullptr)
        {
            for (uint32_t geometryIndex = 0; geometryIndex < pBuildInfo->geometryCount; ++geometryIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pBuildInfo->pGeometries[%i].pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pBuildInfo->pGeometries[geometryIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pBuildInfo->pGeometries[%i].geometryType", ParameterName::IndexVector{ geometryIndex }), "VkGeometryTypeKHR", pBuildInfo->pGeometries[geometryIndex].geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                skip |= ValidateFlags(loc, ParameterName("pBuildInfo->pGeometries[%i].flags", ParameterName::IndexVector{ geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pBuildInfo->pGeometries[geometryIndex].flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
            }
        }

        skip |= ValidateStructPointerTypeArray(loc, "pBuildInfo->geometryCount", "pBuildInfo->ppGeometries", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", pBuildInfo->geometryCount, pBuildInfo->ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false, "VUID-VkAccelerationStructureGeometryKHR-sType-sType", "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

        if (pBuildInfo->ppGeometries != nullptr)
        {
            for (uint32_t geometryIndex = 0; geometryIndex < pBuildInfo->geometryCount; ++geometryIndex)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pBuildInfo->ppGeometries[%i]->pNext", ParameterName::IndexVector{ geometryIndex }), nullptr, pBuildInfo->ppGeometries[geometryIndex]->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateRangedEnum(loc, ParameterName("pBuildInfo->ppGeometries[%i]->geometryType", ParameterName::IndexVector{ geometryIndex }), "VkGeometryTypeKHR", pBuildInfo->ppGeometries[geometryIndex]->geometryType, "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                skip |= ValidateFlags(loc, ParameterName("pBuildInfo->ppGeometries[%i]->flags", ParameterName::IndexVector{ geometryIndex }), "VkGeometryFlagBitsKHR", AllVkGeometryFlagBitsKHR, pBuildInfo->ppGeometries[geometryIndex]->flags, kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
            }
        }
    }
    skip |= ValidateStructType(loc, "pSizeInfo", "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR", pSizeInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, true, "VUID-vkGetAccelerationStructureBuildSizesKHR-pSizeInfo-parameter", "VUID-VkAccelerationStructureBuildSizesInfoKHR-sType-sType");
    if (!skip) skip |= manual_PreCallValidateGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysKHR(
    VkCommandBuffer                             commandBuffer,
    const VkStridedDeviceAddressRegionKHR*      pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR*      pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR*      pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR*      pCallableShaderBindingTable,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    skip |= ValidateRequiredPointer(loc, "pRaygenShaderBindingTable", pRaygenShaderBindingTable, "VUID-vkCmdTraceRaysKHR-pRaygenShaderBindingTable-parameter");
    if (pRaygenShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc, "pMissShaderBindingTable", pMissShaderBindingTable, "VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-parameter");
    if (pMissShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc, "pHitShaderBindingTable", pHitShaderBindingTable, "VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-parameter");
    if (pHitShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc, "pCallableShaderBindingTable", pCallableShaderBindingTable, "VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-parameter");
    if (pCallableShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRayTracingPipelinesKHR(
    VkDevice                                    device,
    VkDeferredOperationKHR                      deferredOperation,
    VkPipelineCache                             pipelineCache,
    uint32_t                                    createInfoCount,
    const VkRayTracingPipelineCreateInfoKHR*    pCreateInfos,
    const VkAllocationCallbacks*                pAllocator,
    VkPipeline*                                 pPipelines,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    skip |= ValidateStructTypeArray(loc, "createInfoCount", "pCreateInfos", "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR", createInfoCount, pCreateInfos, VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR, true, true, "VUID-VkRayTracingPipelineCreateInfoKHR-sType-sType", "VUID-vkCreateRayTracingPipelinesKHR-pCreateInfos-parameter", "VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength");
    if (pCreateInfos != nullptr)
    {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex)
        {
            constexpr std::array allowed_structs_VkRayTracingPipelineCreateInfoKHR = { VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT };

            skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pNext", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlags2CreateInfoKHR, VkPipelineCreationFeedbackCreateInfo, VkPipelineRobustnessCreateInfoEXT", pCreateInfos[createInfoIndex].pNext, allowed_structs_VkRayTracingPipelineCreateInfoKHR.size(), allowed_structs_VkRayTracingPipelineCreateInfoKHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkRayTracingPipelineCreateInfoKHR-pNext-pNext", "VUID-VkRayTracingPipelineCreateInfoKHR-sType-unique", false, true);

            skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].flags", ParameterName::IndexVector{ createInfoIndex }), "VkPipelineCreateFlagBits", AllVkPipelineCreateFlagBits, pCreateInfos[createInfoIndex].flags, kOptionalFlags, "VUID-VkRayTracingPipelineCreateInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfos[%i].stageCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pStages", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, true, "VUID-VkPipelineShaderStageCreateInfo-sType-sType", "VUID-VkRayTracingPipelineCreateInfoKHR-pStages-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pStages != nullptr)
            {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex)
                {
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = { VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT };

                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pStages[%i].pNext", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkDebugUtilsObjectNameInfoEXT, VkPipelineRobustnessCreateInfoEXT, VkPipelineShaderStageModuleIdentifierCreateInfoEXT, VkPipelineShaderStageNodeCreateInfoAMDX, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, VkShaderModuleCreateInfo, VkShaderModuleValidationCacheCreateInfoEXT", pCreateInfos[createInfoIndex].pStages[stageIndex].pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(), allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", false, true);

                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pStages[%i].flags", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkPipelineShaderStageCreateFlagBits", AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].flags, kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |= ValidateFlags(loc, ParameterName("pCreateInfos[%i].pStages[%i].stage", ParameterName::IndexVector{ createInfoIndex, stageIndex }), "VkShaderStageFlagBits", AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= ValidateRequiredPointer(loc, ParameterName("pCreateInfos[%i].pStages[%i].pName", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr)
                    {
                        skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->mapEntryCount", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pMapEntries", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount, &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr)
                        {
                            for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex)
                            {
                                // No xml-driven validation
                            }
                        }

                        skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->dataSize", ParameterName::IndexVector{ createInfoIndex, stageIndex }), ParameterName("pCreateInfos[%i].pStages[%i].pSpecializationInfo->pData", ParameterName::IndexVector{ createInfoIndex, stageIndex }), pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize, &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= ValidateStructTypeArray(loc, ParameterName("pCreateInfos[%i].groupCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pGroups", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR", pCreateInfos[createInfoIndex].groupCount, pCreateInfos[createInfoIndex].pGroups, VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR, false, true, "VUID-VkRayTracingShaderGroupCreateInfoKHR-sType-sType", "VUID-VkRayTracingPipelineCreateInfoKHR-pGroups-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pGroups != nullptr)
            {
                for (uint32_t groupIndex = 0; groupIndex < pCreateInfos[createInfoIndex].groupCount; ++groupIndex)
                {
                    skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pGroups[%i].pNext", ParameterName::IndexVector{ createInfoIndex, groupIndex }), nullptr, pCreateInfos[createInfoIndex].pGroups[groupIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRayTracingShaderGroupCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);

                    skip |= ValidateRangedEnum(loc, ParameterName("pCreateInfos[%i].pGroups[%i].type", ParameterName::IndexVector{ createInfoIndex, groupIndex }), "VkRayTracingShaderGroupTypeKHR", pCreateInfos[createInfoIndex].pGroups[groupIndex].type, "VUID-VkRayTracingShaderGroupCreateInfoKHR-type-parameter");
                }
            }

            skip |= ValidateStructType(loc, ParameterName("pCreateInfos[%i].pLibraryInfo", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR", pCreateInfos[createInfoIndex].pLibraryInfo, VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, false, "VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-parameter", "VUID-VkPipelineLibraryCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInfo != nullptr)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pLibraryInfo->pNext", ParameterName::IndexVector{ createInfoIndex }), nullptr, pCreateInfos[createInfoIndex].pLibraryInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, false, true);

                skip |= ValidateArray(loc, ParameterName("pCreateInfos[%i].pLibraryInfo->libraryCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pLibraryInfo->pLibraries", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pLibraryInfo->libraryCount, &pCreateInfos[createInfoIndex].pLibraryInfo->pLibraries, false, true, kVUIDUndefined, "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }

            skip |= ValidateStructType(loc, ParameterName("pCreateInfos[%i].pLibraryInterface", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR", pCreateInfos[createInfoIndex].pLibraryInterface, VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR, false, "VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInterface-parameter", "VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInterface != nullptr)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pLibraryInterface->pNext", ParameterName::IndexVector{ createInfoIndex }), nullptr, pCreateInfos[createInfoIndex].pLibraryInterface->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, false, true);
            }

            skip |= ValidateStructType(loc, ParameterName("pCreateInfos[%i].pDynamicState", ParameterName::IndexVector{ createInfoIndex }), "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", pCreateInfos[createInfoIndex].pDynamicState, VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false, "VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicState-parameter", "VUID-VkPipelineDynamicStateCreateInfo-sType-sType");

            if (pCreateInfos[createInfoIndex].pDynamicState != nullptr)
            {
                skip |= ValidateStructPnext(loc, ParameterName("pCreateInfos[%i].pDynamicState->pNext", ParameterName::IndexVector{ createInfoIndex }), nullptr, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext", kVUIDUndefined, false, true);

                skip |= ValidateReservedFlags(loc, ParameterName("pCreateInfos[%i].pDynamicState->flags", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].pDynamicState->flags, "VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask");

                skip |= ValidateRangedEnumArray(loc, ParameterName("pCreateInfos[%i].pDynamicState->dynamicStateCount", ParameterName::IndexVector{ createInfoIndex }), ParameterName("pCreateInfos[%i].pDynamicState->pDynamicStates", ParameterName::IndexVector{ createInfoIndex }), "VkDynamicState", pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount, pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, false, true);
            }

            skip |= ValidateRequiredHandle(loc, ParameterName("pCreateInfos[%i].layout", ParameterName::IndexVector{ createInfoIndex }), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr)
    {
        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnAllocation", reinterpret_cast<const void*>(pAllocator->pfnAllocation), "VUID-VkAllocationCallbacks-pfnAllocation-00632");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnReallocation", reinterpret_cast<const void*>(pAllocator->pfnReallocation), "VUID-VkAllocationCallbacks-pfnReallocation-00633");

        skip |= ValidateRequiredPointer(loc, "pAllocator->pfnFree", reinterpret_cast<const void*>(pAllocator->pfnFree), "VUID-VkAllocationCallbacks-pfnFree-00634");

        if (pAllocator->pfnInternalAllocation != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalFree", reinterpret_cast<const void*>(pAllocator->pfnInternalFree), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }

        if (pAllocator->pfnInternalFree != nullptr)
        {
            skip |= ValidateRequiredPointer(loc, "pAllocator->pfnInternalAllocation", reinterpret_cast<const void*>(pAllocator->pfnInternalAllocation), "VUID-VkAllocationCallbacks-pfnInternalAllocation-00635");

        }
    }
    skip |= ValidateArray(loc, "createInfoCount", "pPipelines", createInfoCount, &pPipelines, true, true, "VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength", "VUID-vkCreateRayTracingPipelinesKHR-pPipelines-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingCaptureReplayShaderGroupHandlesKHR(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    void*                                       pData,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    skip |= ValidateArray(loc, "dataSize", "pData", dataSize, &pData, true, true, "VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-arraylength", "VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysIndirectKHR(
    VkCommandBuffer                             commandBuffer,
    const VkStridedDeviceAddressRegionKHR*      pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR*      pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR*      pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR*      pCallableShaderBindingTable,
    VkDeviceAddress                             indirectDeviceAddress,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    skip |= ValidateRequiredPointer(loc, "pRaygenShaderBindingTable", pRaygenShaderBindingTable, "VUID-vkCmdTraceRaysIndirectKHR-pRaygenShaderBindingTable-parameter");
    if (pRaygenShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc, "pMissShaderBindingTable", pMissShaderBindingTable, "VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-parameter");
    if (pMissShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc, "pHitShaderBindingTable", pHitShaderBindingTable, "VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-parameter");
    if (pHitShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc, "pCallableShaderBindingTable", pCallableShaderBindingTable, "VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-parameter");
    if (pCallableShaderBindingTable != nullptr)
    {
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingShaderGroupStackSizeKHR(
    VkDevice                                    device,
    VkPipeline                                  pipeline,
    uint32_t                                    group,
    VkShaderGroupShaderKHR                      groupShader,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    skip |= ValidateRequiredHandle(loc, "pipeline", pipeline);
    skip |= ValidateRangedEnum(loc, "groupShader", "VkShaderGroupShaderKHR", groupShader, "VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRayTracingPipelineStackSizeKHR(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    pipelineStackSize,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) skip |= OutputExtensionError(loc, "VK_KHR_ray_tracing_pipeline");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksEXT(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader)) skip |= OutputExtensionError(loc, "VK_EXT_mesh_shader");
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectEXT(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader)) skip |= OutputExtensionError(loc, "VK_EXT_mesh_shader");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectCountEXT(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkBuffer                                    countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride,
    const ErrorObject&                          error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location& loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader)) skip |= OutputExtensionError(loc, "VK_EXT_mesh_shader");
    skip |= ValidateRequiredHandle(loc, "buffer", buffer);
    skip |= ValidateRequiredHandle(loc, "countBuffer", countBuffer);
    return skip;
}


// NOLINTEND
