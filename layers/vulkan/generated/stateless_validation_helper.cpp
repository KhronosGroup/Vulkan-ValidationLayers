// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See stateless_validation_helper_generator.py for modifications

/***************************************************************************
 *
 * Copyright (c) 2015-2025 The Khronos Group Inc.
 * Copyright (c) 2015-2025 Valve Corporation
 * Copyright (c) 2015-2025 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ****************************************************************************/

// NOLINTBEGIN

#include "stateless/stateless_validation.h"
#include "generated/enum_flag_bits.h"
#include "generated/dispatch_functions.h"

namespace stateless {

bool Context::IsDuplicatePnext(VkStructureType input_value) const {
    switch (input_value) {
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        case VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT:
        case VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT:
        case VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT:
        case VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT:
        case VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT:
        case VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT:
        case VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT:
        case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
            return true;
        default:
            return false;
    }
}

bool Context::ValidatePnextFeatureStructContents(const Location& loc, const VkBaseOutStructure* header, const char* pnext_vuid,
                                                 bool is_const_param) const {
    bool skip = false;
    switch (header->sType) {
        // Validation code for VkPhysicalDevice16BitStorageFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {  // Covers
                                                                          // VUID-VkPhysicalDevice16BitStorageFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_16bit_storage)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES), but its parent extension "
                                     "VK_KHR_16bit_storage has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevice16BitStorageFeatures);
                VkPhysicalDevice16BitStorageFeatures* structure = (VkPhysicalDevice16BitStorageFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer16BitAccess), structure->storageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer16BitAccess),
                                       structure->uniformAndStorageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant16), structure->storagePushConstant16);

                skip |= ValidateBool32(pNext_loc.dot(Field::storageInputOutput16), structure->storageInputOutput16);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {  // Covers VUID-VkPhysicalDeviceMultiviewFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_multiview)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES), but its parent extension "
                                     "VK_KHR_multiview has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMultiviewFeatures);
                VkPhysicalDeviceMultiviewFeatures* structure = (VkPhysicalDeviceMultiviewFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiview), structure->multiview);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewGeometryShader), structure->multiviewGeometryShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewTessellationShader), structure->multiviewTessellationShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceVariablePointersFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {  // Covers
                                                                              // VUID-VkPhysicalDeviceVariablePointersFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_variable_pointers)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES), but its parent extension "
                                     "VK_KHR_variable_pointers has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVariablePointersFeatures);
                VkPhysicalDeviceVariablePointersFeatures* structure = (VkPhysicalDeviceVariablePointersFeatures*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::variablePointersStorageBuffer), structure->variablePointersStorageBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::variablePointers), structure->variablePointers);
            }
        } break;

        // Validation code for VkPhysicalDeviceProtectedMemoryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceProtectedMemoryFeatures-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_1) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES) which "
                    "was added in VK_API_VERSION_1_1 but the "
                    "current effective API version is %s.",
                    StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceProtectedMemoryFeatures);
                VkPhysicalDeviceProtectedMemoryFeatures* structure = (VkPhysicalDeviceProtectedMemoryFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::protectedMemory), structure->protectedMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceSamplerYcbcrConversionFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceSamplerYcbcrConversionFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES), but its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSamplerYcbcrConversionFeatures);
                VkPhysicalDeviceSamplerYcbcrConversionFeatures* structure = (VkPhysicalDeviceSamplerYcbcrConversionFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::samplerYcbcrConversion), structure->samplerYcbcrConversion);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderDrawParametersFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceShaderDrawParametersFeatures-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_1) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES) "
                    "which was added in VK_API_VERSION_1_1 but the "
                    "current effective API version is %s.",
                    StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderDrawParametersFeatures);
                VkPhysicalDeviceShaderDrawParametersFeatures* structure = (VkPhysicalDeviceShaderDrawParametersFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderDrawParameters), structure->shaderDrawParameters);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan11Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan11Features-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_2) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES) "
                                 "which was added in VK_API_VERSION_1_2 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan11Features);
                VkPhysicalDeviceVulkan11Features* structure = (VkPhysicalDeviceVulkan11Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer16BitAccess), structure->storageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer16BitAccess),
                                       structure->uniformAndStorageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant16), structure->storagePushConstant16);

                skip |= ValidateBool32(pNext_loc.dot(Field::storageInputOutput16), structure->storageInputOutput16);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiview), structure->multiview);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewGeometryShader), structure->multiviewGeometryShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewTessellationShader), structure->multiviewTessellationShader);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::variablePointersStorageBuffer), structure->variablePointersStorageBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::variablePointers), structure->variablePointers);

                skip |= ValidateBool32(pNext_loc.dot(Field::protectedMemory), structure->protectedMemory);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerYcbcrConversion), structure->samplerYcbcrConversion);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderDrawParameters), structure->shaderDrawParameters);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan12Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan12Features-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_2) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES) "
                                 "which was added in VK_API_VERSION_1_2 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan12Features);
                VkPhysicalDeviceVulkan12Features* structure = (VkPhysicalDeviceVulkan12Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::samplerMirrorClampToEdge), structure->samplerMirrorClampToEdge);

                skip |= ValidateBool32(pNext_loc.dot(Field::drawIndirectCount), structure->drawIndirectCount);

                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer8BitAccess), structure->storageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer8BitAccess),
                                       structure->uniformAndStorageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant8), structure->storagePushConstant8);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferInt64Atomics), structure->shaderBufferInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedInt64Atomics), structure->shaderSharedInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat16), structure->shaderFloat16);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt8), structure->shaderInt8);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorIndexing), structure->descriptorIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayDynamicIndexing),
                                       structure->shaderInputAttachmentArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayDynamicIndexing),
                                       structure->shaderUniformTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayDynamicIndexing),
                                       structure->shaderStorageTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformBufferArrayNonUniformIndexing),
                                       structure->shaderUniformBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampledImageArrayNonUniformIndexing),
                                       structure->shaderSampledImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageBufferArrayNonUniformIndexing),
                                       structure->shaderStorageBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageArrayNonUniformIndexing),
                                       structure->shaderStorageImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayNonUniformIndexing),
                                       structure->shaderInputAttachmentArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayNonUniformIndexing),
                                       structure->shaderUniformTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayNonUniformIndexing),
                                       structure->shaderStorageTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingSampledImageUpdateAfterBind),
                                       structure->descriptorBindingSampledImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageImageUpdateAfterBind),
                                       structure->descriptorBindingStorageImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUpdateUnusedWhilePending),
                                       structure->descriptorBindingUpdateUnusedWhilePending);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingPartiallyBound),
                                       structure->descriptorBindingPartiallyBound);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingVariableDescriptorCount),
                                       structure->descriptorBindingVariableDescriptorCount);

                skip |= ValidateBool32(pNext_loc.dot(Field::runtimeDescriptorArray), structure->runtimeDescriptorArray);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerFilterMinmax), structure->samplerFilterMinmax);

                skip |= ValidateBool32(pNext_loc.dot(Field::scalarBlockLayout), structure->scalarBlockLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::imagelessFramebuffer), structure->imagelessFramebuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformBufferStandardLayout), structure->uniformBufferStandardLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupExtendedTypes), structure->shaderSubgroupExtendedTypes);

                skip |= ValidateBool32(pNext_loc.dot(Field::separateDepthStencilLayouts), structure->separateDepthStencilLayouts);

                skip |= ValidateBool32(pNext_loc.dot(Field::hostQueryReset), structure->hostQueryReset);

                skip |= ValidateBool32(pNext_loc.dot(Field::timelineSemaphore), structure->timelineSemaphore);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddress), structure->bufferDeviceAddress);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressCaptureReplay),
                                       structure->bufferDeviceAddressCaptureReplay);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressMultiDevice), structure->bufferDeviceAddressMultiDevice);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModel), structure->vulkanMemoryModel);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelDeviceScope), structure->vulkanMemoryModelDeviceScope);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelAvailabilityVisibilityChains),
                                       structure->vulkanMemoryModelAvailabilityVisibilityChains);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderOutputViewportIndex), structure->shaderOutputViewportIndex);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderOutputLayer), structure->shaderOutputLayer);

                skip |= ValidateBool32(pNext_loc.dot(Field::subgroupBroadcastDynamicId), structure->subgroupBroadcastDynamicId);
            }
        } break;

        // Validation code for VkPhysicalDevice8BitStorageFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {  // Covers
                                                                         // VUID-VkPhysicalDevice8BitStorageFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_8bit_storage)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES), but its parent extension "
                                     "VK_KHR_8bit_storage has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevice8BitStorageFeatures);
                VkPhysicalDevice8BitStorageFeatures* structure = (VkPhysicalDevice8BitStorageFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer8BitAccess), structure->storageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer8BitAccess),
                                       structure->uniformAndStorageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant8), structure->storagePushConstant8);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicInt64Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceShaderAtomicInt64Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_atomic_int64)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES), but its parent extension "
                                     "VK_KHR_shader_atomic_int64 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicInt64Features);
                VkPhysicalDeviceShaderAtomicInt64Features* structure = (VkPhysicalDeviceShaderAtomicInt64Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferInt64Atomics), structure->shaderBufferInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedInt64Atomics), structure->shaderSharedInt64Atomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderFloat16Int8Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceShaderFloat16Int8Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_float16_int8)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES), but its parent extension "
                                     "VK_KHR_shader_float16_int8 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderFloat16Int8Features);
                VkPhysicalDeviceShaderFloat16Int8Features* structure = (VkPhysicalDeviceShaderFloat16Int8Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat16), structure->shaderFloat16);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt8), structure->shaderInt8);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorIndexingFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceDescriptorIndexingFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_indexing)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES), but its parent extension "
                                     "VK_EXT_descriptor_indexing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDescriptorIndexingFeatures);
                VkPhysicalDeviceDescriptorIndexingFeatures* structure = (VkPhysicalDeviceDescriptorIndexingFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayDynamicIndexing),
                                       structure->shaderInputAttachmentArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayDynamicIndexing),
                                       structure->shaderUniformTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayDynamicIndexing),
                                       structure->shaderStorageTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformBufferArrayNonUniformIndexing),
                                       structure->shaderUniformBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampledImageArrayNonUniformIndexing),
                                       structure->shaderSampledImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageBufferArrayNonUniformIndexing),
                                       structure->shaderStorageBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageArrayNonUniformIndexing),
                                       structure->shaderStorageImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayNonUniformIndexing),
                                       structure->shaderInputAttachmentArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayNonUniformIndexing),
                                       structure->shaderUniformTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayNonUniformIndexing),
                                       structure->shaderStorageTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingSampledImageUpdateAfterBind),
                                       structure->descriptorBindingSampledImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageImageUpdateAfterBind),
                                       structure->descriptorBindingStorageImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUpdateUnusedWhilePending),
                                       structure->descriptorBindingUpdateUnusedWhilePending);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingPartiallyBound),
                                       structure->descriptorBindingPartiallyBound);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingVariableDescriptorCount),
                                       structure->descriptorBindingVariableDescriptorCount);

                skip |= ValidateBool32(pNext_loc.dot(Field::runtimeDescriptorArray), structure->runtimeDescriptorArray);
            }
        } break;

        // Validation code for VkPhysicalDeviceScalarBlockLayoutFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceScalarBlockLayoutFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_scalar_block_layout)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES), but its parent extension "
                                     "VK_EXT_scalar_block_layout has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceScalarBlockLayoutFeatures);
                VkPhysicalDeviceScalarBlockLayoutFeatures* structure = (VkPhysicalDeviceScalarBlockLayoutFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::scalarBlockLayout), structure->scalarBlockLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkanMemoryModelFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceVulkanMemoryModelFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_vulkan_memory_model)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES), but its parent extension "
                                     "VK_KHR_vulkan_memory_model has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkanMemoryModelFeatures);
                VkPhysicalDeviceVulkanMemoryModelFeatures* structure = (VkPhysicalDeviceVulkanMemoryModelFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModel), structure->vulkanMemoryModel);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelDeviceScope), structure->vulkanMemoryModelDeviceScope);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelAvailabilityVisibilityChains),
                                       structure->vulkanMemoryModelAvailabilityVisibilityChains);
            }
        } break;

        // Validation code for VkPhysicalDeviceImagelessFramebufferFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceImagelessFramebufferFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_imageless_framebuffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES), but its parent extension "
                                     "VK_KHR_imageless_framebuffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImagelessFramebufferFeatures);
                VkPhysicalDeviceImagelessFramebufferFeatures* structure = (VkPhysicalDeviceImagelessFramebufferFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imagelessFramebuffer), structure->imagelessFramebuffer);
            }
        } break;

        // Validation code for VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceUniformBufferStandardLayoutFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_uniform_buffer_standard_layout)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES), but its parent extension "
                    "VK_KHR_uniform_buffer_standard_layout has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
                VkPhysicalDeviceUniformBufferStandardLayoutFeatures* structure =
                    (VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::uniformBufferStandardLayout), structure->uniformBufferStandardLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_subgroup_extended_types)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES), but its parent extension "
                    "VK_KHR_shader_subgroup_extended_types has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_separate_depth_stencil_layouts)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES), but its parent extension "
                    "VK_KHR_separate_depth_stencil_layouts has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
                VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* structure =
                    (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::separateDepthStencilLayouts), structure->separateDepthStencilLayouts);
            }
        } break;

        // Validation code for VkPhysicalDeviceHostQueryResetFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceHostQueryResetFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_host_query_reset)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES), but its parent extension "
                                     "VK_EXT_host_query_reset has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceHostQueryResetFeatures);
                VkPhysicalDeviceHostQueryResetFeatures* structure = (VkPhysicalDeviceHostQueryResetFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::hostQueryReset), structure->hostQueryReset);
            }
        } break;

        // Validation code for VkPhysicalDeviceTimelineSemaphoreFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {  // Covers
                                                                               // VUID-VkPhysicalDeviceTimelineSemaphoreFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_timeline_semaphore)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES), but its parent extension "
                                     "VK_KHR_timeline_semaphore has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTimelineSemaphoreFeatures);
                VkPhysicalDeviceTimelineSemaphoreFeatures* structure = (VkPhysicalDeviceTimelineSemaphoreFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::timelineSemaphore), structure->timelineSemaphore);
            }
        } break;

        // Validation code for VkPhysicalDeviceBufferDeviceAddressFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceBufferDeviceAddressFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_buffer_device_address)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES), but its parent extension "
                                     "VK_KHR_buffer_device_address has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBufferDeviceAddressFeatures);
                VkPhysicalDeviceBufferDeviceAddressFeatures* structure = (VkPhysicalDeviceBufferDeviceAddressFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddress), structure->bufferDeviceAddress);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressCaptureReplay),
                                       structure->bufferDeviceAddressCaptureReplay);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressMultiDevice), structure->bufferDeviceAddressMultiDevice);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan13Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan13Features-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_3) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES) "
                                 "which was added in VK_API_VERSION_1_3 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan13Features);
                VkPhysicalDeviceVulkan13Features* structure = (VkPhysicalDeviceVulkan13Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustImageAccess), structure->robustImageAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::inlineUniformBlock), structure->inlineUniformBlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingInlineUniformBlockUpdateAfterBind),
                                       structure->descriptorBindingInlineUniformBlockUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineCreationCacheControl), structure->pipelineCreationCacheControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::privateData), structure->privateData);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderDemoteToHelperInvocation), structure->shaderDemoteToHelperInvocation);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTerminateInvocation), structure->shaderTerminateInvocation);

                skip |= ValidateBool32(pNext_loc.dot(Field::subgroupSizeControl), structure->subgroupSizeControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::computeFullSubgroups), structure->computeFullSubgroups);

                skip |= ValidateBool32(pNext_loc.dot(Field::synchronization2), structure->synchronization2);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionASTC_HDR), structure->textureCompressionASTC_HDR);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderZeroInitializeWorkgroupMemory),
                                       structure->shaderZeroInitializeWorkgroupMemory);

                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRendering), structure->dynamicRendering);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderIntegerDotProduct), structure->shaderIntegerDotProduct);

                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance4), structure->maintenance4);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderTerminateInvocationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceShaderTerminateInvocationFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_terminate_invocation)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES), but its parent extension "
                    "VK_KHR_shader_terminate_invocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderTerminateInvocationFeatures);
                VkPhysicalDeviceShaderTerminateInvocationFeatures* structure =
                    (VkPhysicalDeviceShaderTerminateInvocationFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTerminateInvocation), structure->shaderTerminateInvocation);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {  // Covers
                                                                                               // VUID-VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_demote_to_helper_invocation)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES), but its parent extension "
                    "VK_EXT_shader_demote_to_helper_invocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures);
                VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* structure =
                    (VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderDemoteToHelperInvocation), structure->shaderDemoteToHelperInvocation);
            }
        } break;

        // Validation code for VkPhysicalDevicePrivateDataFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {  // Covers
                                                                         // VUID-VkPhysicalDevicePrivateDataFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_private_data)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES), but its parent extension "
                                     "VK_EXT_private_data has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePrivateDataFeatures);
                VkPhysicalDevicePrivateDataFeatures* structure = (VkPhysicalDevicePrivateDataFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::privateData), structure->privateData);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineCreationCacheControlFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {  // Covers
                                                                                            // VUID-VkPhysicalDevicePipelineCreationCacheControlFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_creation_cache_control)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES), but its parent extension "
                    "VK_EXT_pipeline_creation_cache_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineCreationCacheControlFeatures);
                VkPhysicalDevicePipelineCreationCacheControlFeatures* structure =
                    (VkPhysicalDevicePipelineCreationCacheControlFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineCreationCacheControl), structure->pipelineCreationCacheControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceSynchronization2Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {  // Covers
                                                                              // VUID-VkPhysicalDeviceSynchronization2Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_synchronization2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES), but its parent extension "
                                     "VK_KHR_synchronization2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSynchronization2Features);
                VkPhysicalDeviceSynchronization2Features* structure = (VkPhysicalDeviceSynchronization2Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::synchronization2), structure->synchronization2);
            }
        } break;

        // Validation code for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_zero_initialize_workgroup_memory)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES), but its parent extension "
                    "VK_KHR_zero_initialize_workgroup_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures);
                VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* structure =
                    (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderZeroInitializeWorkgroupMemory),
                                       structure->shaderZeroInitializeWorkgroupMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageRobustnessFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceImageRobustnessFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_robustness)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES), but its parent extension "
                                     "VK_EXT_image_robustness has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageRobustnessFeatures);
                VkPhysicalDeviceImageRobustnessFeatures* structure = (VkPhysicalDeviceImageRobustnessFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustImageAccess), structure->robustImageAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubgroupSizeControlFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceSubgroupSizeControlFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_subgroup_size_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES), but its parent extension "
                                     "VK_EXT_subgroup_size_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSubgroupSizeControlFeatures);
                VkPhysicalDeviceSubgroupSizeControlFeatures* structure = (VkPhysicalDeviceSubgroupSizeControlFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::subgroupSizeControl), structure->subgroupSizeControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::computeFullSubgroups), structure->computeFullSubgroups);
            }
        } break;

        // Validation code for VkPhysicalDeviceInlineUniformBlockFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceInlineUniformBlockFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_inline_uniform_block)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES), but its parent extension "
                                     "VK_EXT_inline_uniform_block has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceInlineUniformBlockFeatures);
                VkPhysicalDeviceInlineUniformBlockFeatures* structure = (VkPhysicalDeviceInlineUniformBlockFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::inlineUniformBlock), structure->inlineUniformBlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingInlineUniformBlockUpdateAfterBind),
                                       structure->descriptorBindingInlineUniformBlockUpdateAfterBind);
            }
        } break;

        // Validation code for VkPhysicalDeviceTextureCompressionASTCHDRFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceTextureCompressionASTCHDRFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_texture_compression_astc_hdr)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES), but its parent extension "
                    "VK_EXT_texture_compression_astc_hdr has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTextureCompressionASTCHDRFeatures);
                VkPhysicalDeviceTextureCompressionASTCHDRFeatures* structure =
                    (VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionASTC_HDR), structure->textureCompressionASTC_HDR);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {  // Covers
                                                                              // VUID-VkPhysicalDeviceDynamicRenderingFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES), but its parent extension "
                                     "VK_KHR_dynamic_rendering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDynamicRenderingFeatures);
                VkPhysicalDeviceDynamicRenderingFeatures* structure = (VkPhysicalDeviceDynamicRenderingFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRendering), structure->dynamicRendering);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerDotProductFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceShaderIntegerDotProductFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_integer_dot_product)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES), but its parent extension "
                    "VK_KHR_shader_integer_dot_product has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderIntegerDotProductFeatures);
                VkPhysicalDeviceShaderIntegerDotProductFeatures* structure =
                    (VkPhysicalDeviceShaderIntegerDotProductFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderIntegerDotProduct), structure->shaderIntegerDotProduct);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance4Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {  // Covers
                                                                          // VUID-VkPhysicalDeviceMaintenance4Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance4)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES), but its parent extension "
                                     "VK_KHR_maintenance4 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance4Features);
                VkPhysicalDeviceMaintenance4Features* structure = (VkPhysicalDeviceMaintenance4Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance4), structure->maintenance4);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan14Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan14Features-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_4) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES) "
                                 "which was added in VK_API_VERSION_1_4 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan14Features);
                VkPhysicalDeviceVulkan14Features* structure = (VkPhysicalDeviceVulkan14Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::globalPriorityQuery), structure->globalPriorityQuery);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupRotate), structure->shaderSubgroupRotate);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderSubgroupRotateClustered), structure->shaderSubgroupRotateClustered);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloatControls2), structure->shaderFloatControls2);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderExpectAssume), structure->shaderExpectAssume);

                skip |= ValidateBool32(pNext_loc.dot(Field::rectangularLines), structure->rectangularLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::bresenhamLines), structure->bresenhamLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::smoothLines), structure->smoothLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledRectangularLines), structure->stippledRectangularLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledBresenhamLines), structure->stippledBresenhamLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledSmoothLines), structure->stippledSmoothLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeInstanceRateDivisor),
                                       structure->vertexAttributeInstanceRateDivisor);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeInstanceRateZeroDivisor),
                                       structure->vertexAttributeInstanceRateZeroDivisor);

                skip |= ValidateBool32(pNext_loc.dot(Field::indexTypeUint8), structure->indexTypeUint8);

                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRenderingLocalRead), structure->dynamicRenderingLocalRead);

                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance5), structure->maintenance5);

                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance6), structure->maintenance6);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineProtectedAccess), structure->pipelineProtectedAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineRobustness), structure->pipelineRobustness);

                skip |= ValidateBool32(pNext_loc.dot(Field::hostImageCopy), structure->hostImageCopy);

                skip |= ValidateBool32(pNext_loc.dot(Field::pushDescriptor), structure->pushDescriptor);
            }
        } break;

        // Validation code for VkPhysicalDeviceGlobalPriorityQueryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceGlobalPriorityQueryFeatures-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_global_priority_query)) && (!IsExtEnabled(extensions.vk_khr_global_priority))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES), but its parent extension "
                                     "VK_EXT_global_priority_query, or VK_KHR_global_priority has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceGlobalPriorityQueryFeatures);
                VkPhysicalDeviceGlobalPriorityQueryFeatures* structure = (VkPhysicalDeviceGlobalPriorityQueryFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::globalPriorityQuery), structure->globalPriorityQuery);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupRotateFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceShaderSubgroupRotateFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_subgroup_rotate)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES), but its parent extension "
                                 "VK_KHR_shader_subgroup_rotate has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderSubgroupRotateFeatures);
                VkPhysicalDeviceShaderSubgroupRotateFeatures* structure = (VkPhysicalDeviceShaderSubgroupRotateFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupRotate), structure->shaderSubgroupRotate);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderSubgroupRotateClustered), structure->shaderSubgroupRotateClustered);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderFloatControls2Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceShaderFloatControls2Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_float_controls2)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES), but its parent extension "
                                 "VK_KHR_shader_float_controls2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderFloatControls2Features);
                VkPhysicalDeviceShaderFloatControls2Features* structure = (VkPhysicalDeviceShaderFloatControls2Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloatControls2), structure->shaderFloatControls2);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderExpectAssumeFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceShaderExpectAssumeFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_expect_assume)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES), but its parent extension "
                                     "VK_KHR_shader_expect_assume has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderExpectAssumeFeatures);
                VkPhysicalDeviceShaderExpectAssumeFeatures* structure = (VkPhysicalDeviceShaderExpectAssumeFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderExpectAssume), structure->shaderExpectAssume);
            }
        } break;

        // Validation code for VkPhysicalDeviceLineRasterizationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES: {  // Covers
                                                                               // VUID-VkPhysicalDeviceLineRasterizationFeatures-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_line_rasterization)) && (!IsExtEnabled(extensions.vk_khr_line_rasterization))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES), but its parent extension "
                                     "VK_EXT_line_rasterization, or VK_KHR_line_rasterization has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeatures);
                VkPhysicalDeviceLineRasterizationFeatures* structure = (VkPhysicalDeviceLineRasterizationFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rectangularLines), structure->rectangularLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::bresenhamLines), structure->bresenhamLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::smoothLines), structure->smoothLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledRectangularLines), structure->stippledRectangularLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledBresenhamLines), structure->stippledBresenhamLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledSmoothLines), structure->stippledSmoothLines);
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexAttributeDivisorFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceVertexAttributeDivisorFeatures-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_vertex_attribute_divisor)) &&
                (!IsExtEnabled(extensions.vk_khr_vertex_attribute_divisor))) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES), but its parent extension "
                                 "VK_EXT_vertex_attribute_divisor, or VK_KHR_vertex_attribute_divisor has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVertexAttributeDivisorFeatures);
                VkPhysicalDeviceVertexAttributeDivisorFeatures* structure = (VkPhysicalDeviceVertexAttributeDivisorFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeInstanceRateDivisor),
                                       structure->vertexAttributeInstanceRateDivisor);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeInstanceRateZeroDivisor),
                                       structure->vertexAttributeInstanceRateZeroDivisor);
            }
        } break;

        // Validation code for VkPhysicalDeviceIndexTypeUint8Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceIndexTypeUint8Features-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_index_type_uint8)) && (!IsExtEnabled(extensions.vk_khr_index_type_uint8))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES), but its parent extension "
                                     "VK_EXT_index_type_uint8, or VK_KHR_index_type_uint8 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceIndexTypeUint8Features);
                VkPhysicalDeviceIndexTypeUint8Features* structure = (VkPhysicalDeviceIndexTypeUint8Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::indexTypeUint8), structure->indexTypeUint8);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance5Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES: {  // Covers
                                                                          // VUID-VkPhysicalDeviceMaintenance5Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance5)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES), but its parent extension "
                                     "VK_KHR_maintenance5 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance5Features);
                VkPhysicalDeviceMaintenance5Features* structure = (VkPhysicalDeviceMaintenance5Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance5), structure->maintenance5);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingLocalReadFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceDynamicRenderingLocalReadFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering_local_read)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES), but its parent extension "
                    "VK_KHR_dynamic_rendering_local_read has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDynamicRenderingLocalReadFeatures);
                VkPhysicalDeviceDynamicRenderingLocalReadFeatures* structure =
                    (VkPhysicalDeviceDynamicRenderingLocalReadFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRenderingLocalRead), structure->dynamicRenderingLocalRead);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance6Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES: {  // Covers
                                                                          // VUID-VkPhysicalDeviceMaintenance6Features-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance6)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES), but its parent extension "
                                     "VK_KHR_maintenance6 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance6Features);
                VkPhysicalDeviceMaintenance6Features* structure = (VkPhysicalDeviceMaintenance6Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance6), structure->maintenance6);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineProtectedAccessFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES: {  // Covers
                                                                                      // VUID-VkPhysicalDevicePipelineProtectedAccessFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_protected_access)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES), but its parent extension "
                                 "VK_EXT_pipeline_protected_access has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineProtectedAccessFeatures);
                VkPhysicalDevicePipelineProtectedAccessFeatures* structure =
                    (VkPhysicalDevicePipelineProtectedAccessFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineProtectedAccess), structure->pipelineProtectedAccess);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineRobustnessFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDevicePipelineRobustnessFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_robustness)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES), but its parent extension "
                                     "VK_EXT_pipeline_robustness has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineRobustnessFeatures);
                VkPhysicalDevicePipelineRobustnessFeatures* structure = (VkPhysicalDevicePipelineRobustnessFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineRobustness), structure->pipelineRobustness);
            }
        } break;

        // Validation code for VkPhysicalDeviceHostImageCopyFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES: {  // Covers
                                                                            // VUID-VkPhysicalDeviceHostImageCopyFeatures-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_host_image_copy)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES), but its parent extension "
                                     "VK_EXT_host_image_copy has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceHostImageCopyFeatures);
                VkPhysicalDeviceHostImageCopyFeatures* structure = (VkPhysicalDeviceHostImageCopyFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::hostImageCopy), structure->hostImageCopy);
            }
        } break;

        // Validation code for VkPhysicalDevicePerformanceQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {  // Covers
                                                                                  // VUID-VkPhysicalDevicePerformanceQueryFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_performance_query)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_performance_query has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePerformanceQueryFeaturesKHR);
                VkPhysicalDevicePerformanceQueryFeaturesKHR* structure = (VkPhysicalDevicePerformanceQueryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::performanceCounterQueryPools), structure->performanceCounterQueryPools);

                skip |= ValidateBool32(pNext_loc.dot(Field::performanceCounterMultipleQueryPools),
                                       structure->performanceCounterMultipleQueryPools);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDevicePortabilitySubsetFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: {  // Covers
                                                                                   // VUID-VkPhysicalDevicePortabilitySubsetFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_portability_subset)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_portability_subset has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePortabilitySubsetFeaturesKHR);
                VkPhysicalDevicePortabilitySubsetFeaturesKHR* structure = (VkPhysicalDevicePortabilitySubsetFeaturesKHR*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::constantAlphaColorBlendFactors), structure->constantAlphaColorBlendFactors);

                skip |= ValidateBool32(pNext_loc.dot(Field::events), structure->events);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageViewFormatReinterpretation),
                                       structure->imageViewFormatReinterpretation);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageViewFormatSwizzle), structure->imageViewFormatSwizzle);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageView2DOn3DImage), structure->imageView2DOn3DImage);

                skip |= ValidateBool32(pNext_loc.dot(Field::multisampleArrayImage), structure->multisampleArrayImage);

                skip |= ValidateBool32(pNext_loc.dot(Field::mutableComparisonSamplers), structure->mutableComparisonSamplers);

                skip |= ValidateBool32(pNext_loc.dot(Field::pointPolygons), structure->pointPolygons);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerMipLodBias), structure->samplerMipLodBias);

                skip |= ValidateBool32(pNext_loc.dot(Field::separateStencilMaskRef), structure->separateStencilMaskRef);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampleRateInterpolationFunctions),
                                       structure->shaderSampleRateInterpolationFunctions);

                skip |= ValidateBool32(pNext_loc.dot(Field::tessellationIsolines), structure->tessellationIsolines);

                skip |= ValidateBool32(pNext_loc.dot(Field::tessellationPointMode), structure->tessellationPointMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::triangleFans), structure->triangleFans);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeAccessBeyondStride),
                                       structure->vertexAttributeAccessBeyondStride);
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceShaderClockFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {  // Covers
                                                                             // VUID-VkPhysicalDeviceShaderClockFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_clock)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_shader_clock has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderClockFeaturesKHR);
                VkPhysicalDeviceShaderClockFeaturesKHR* structure = (VkPhysicalDeviceShaderClockFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupClock), structure->shaderSubgroupClock);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderDeviceClock), structure->shaderDeviceClock);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceFragmentShadingRateFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_fragment_shading_rate)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_fragment_shading_rate has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
                VkPhysicalDeviceFragmentShadingRateFeaturesKHR* structure = (VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineFragmentShadingRate), structure->pipelineFragmentShadingRate);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveFragmentShadingRate), structure->primitiveFragmentShadingRate);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::attachmentFragmentShadingRate), structure->attachmentFragmentShadingRate);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderQuadControlFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceShaderQuadControlFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_quad_control)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_shader_quad_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderQuadControlFeaturesKHR);
                VkPhysicalDeviceShaderQuadControlFeaturesKHR* structure = (VkPhysicalDeviceShaderQuadControlFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderQuadControl), structure->shaderQuadControl);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentWaitFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {  // Covers
                                                                             // VUID-VkPhysicalDevicePresentWaitFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_present_wait)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_present_wait has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentWaitFeaturesKHR);
                VkPhysicalDevicePresentWaitFeaturesKHR* structure = (VkPhysicalDevicePresentWaitFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentWait), structure->presentWait);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {  // Covers
                                                                                               // VUID-VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_pipeline_executable_properties)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR), but its parent extension "
                    "VK_KHR_pipeline_executable_properties has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
                VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* structure =
                    (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineExecutableInfo), structure->pipelineExecutableInfo);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentIdFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {  // Covers
                                                                           // VUID-VkPhysicalDevicePresentIdFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_present_id)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_present_id has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentIdFeaturesKHR);
                VkPhysicalDevicePresentIdFeaturesKHR* structure = (VkPhysicalDevicePresentIdFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentId), structure->presentId);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_khr_fragment_shader_barycentric)) &&
                (!IsExtEnabled(extensions.vk_nv_fragment_shader_barycentric))) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR), but its parent extension "
                    "VK_KHR_fragment_shader_barycentric, or VK_NV_fragment_shader_barycentric has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR);
                VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* structure =
                    (VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShaderBarycentric), structure->fragmentShaderBarycentric);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {  // Covers
                                                                                                     // VUID-VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_subgroup_uniform_control_flow)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_shader_subgroup_uniform_control_flow has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
                VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupUniformControlFlow),
                                       structure->shaderSubgroupUniformControlFlow);
            }
        } break;

        // Validation code for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {  // Covers
                                                                                                 // VUID-VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_workgroup_memory_explicit_layout)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR), but its parent extension "
                    "VK_KHR_workgroup_memory_explicit_layout has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
                VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* structure =
                    (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayout), structure->workgroupMemoryExplicitLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayoutScalarBlockLayout),
                                       structure->workgroupMemoryExplicitLayoutScalarBlockLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayout8BitAccess),
                                       structure->workgroupMemoryExplicitLayout8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayout16BitAccess),
                                       structure->workgroupMemoryExplicitLayout16BitAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_ray_tracing_maintenance1)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR), but its parent extension "
                    "VK_KHR_ray_tracing_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR);
                VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* structure =
                    (VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingMaintenance1), structure->rayTracingMaintenance1);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineTraceRaysIndirect2),
                                       structure->rayTracingPipelineTraceRaysIndirect2);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_maximal_reconvergence)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR), but its parent extension "
                    "VK_KHR_shader_maximal_reconvergence has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR);
                VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderMaximalReconvergence), structure->shaderMaximalReconvergence);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_ray_tracing_position_fetch)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR), but its parent extension "
                    "VK_KHR_ray_tracing_position_fetch has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR);
                VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* structure =
                    (VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPositionFetch), structure->rayTracingPositionFetch);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineBinaryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR: {  // Covers
                                                                                // VUID-VkPhysicalDevicePipelineBinaryFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_pipeline_binary)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_pipeline_binary has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineBinaryFeaturesKHR);
                VkPhysicalDevicePipelineBinaryFeaturesKHR* structure = (VkPhysicalDevicePipelineBinaryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaries), structure->pipelineBinaries);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrixFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceCooperativeMatrixFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_cooperative_matrix)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_cooperative_matrix has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCooperativeMatrixFeaturesKHR);
                VkPhysicalDeviceCooperativeMatrixFeaturesKHR* structure = (VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrix), structure->cooperativeMatrix);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixRobustBufferAccess),
                                       structure->cooperativeMatrixRobustBufferAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_khr_compute_shader_derivatives)) &&
                (!IsExtEnabled(extensions.vk_nv_compute_shader_derivatives))) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR), but its parent extension "
                    "VK_KHR_compute_shader_derivatives, or VK_NV_compute_shader_derivatives has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR);
                VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* structure =
                    (VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::computeDerivativeGroupQuads), structure->computeDerivativeGroupQuads);

                skip |= ValidateBool32(pNext_loc.dot(Field::computeDerivativeGroupLinear), structure->computeDerivativeGroupLinear);
            }
        } break;

        // Validation code for VkPhysicalDeviceVideoEncodeAV1FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceVideoEncodeAV1FeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVideoEncodeAV1FeaturesKHR);
                VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* structure = (VkPhysicalDeviceVideoEncodeAV1FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::videoEncodeAV1), structure->videoEncodeAV1);
            }
        } break;

        // Validation code for VkPhysicalDeviceVideoMaintenance1FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceVideoMaintenance1FeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_maintenance1)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_video_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVideoMaintenance1FeaturesKHR);
                VkPhysicalDeviceVideoMaintenance1FeaturesKHR* structure = (VkPhysicalDeviceVideoMaintenance1FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::videoMaintenance1), structure->videoMaintenance1);
            }
        } break;

        // Validation code for VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR), but its parent extension "
                    "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR);
                VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* structure =
                    (VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::videoEncodeQuantizationMap), structure->videoEncodeQuantizationMap);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR: {  // Covers
                                                                                                    // VUID-VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shader_relaxed_extended_instruction)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_shader_relaxed_extended_instruction has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR);
                VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderRelaxedExtendedInstruction),
                                       structure->shaderRelaxedExtendedInstruction);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance7FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR: {  // Covers
                                                                              // VUID-VkPhysicalDeviceMaintenance7FeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance7)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_maintenance7 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance7FeaturesKHR);
                VkPhysicalDeviceMaintenance7FeaturesKHR* structure = (VkPhysicalDeviceMaintenance7FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance7), structure->maintenance7);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance8FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR: {  // Covers
                                                                              // VUID-VkPhysicalDeviceMaintenance8FeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance8)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_maintenance8 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance8FeaturesKHR);
                VkPhysicalDeviceMaintenance8FeaturesKHR* structure = (VkPhysicalDeviceMaintenance8FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance8), structure->maintenance8);
            }
        } break;

        // Validation code for VkPhysicalDeviceVideoMaintenance2FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceVideoMaintenance2FeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_maintenance2)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_video_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVideoMaintenance2FeaturesKHR);
                VkPhysicalDeviceVideoMaintenance2FeaturesKHR* structure = (VkPhysicalDeviceVideoMaintenance2FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::videoMaintenance2), structure->videoMaintenance2);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClampZeroOneFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceDepthClampZeroOneFeaturesKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_depth_clamp_zero_one)) &&
                (!IsExtEnabled(extensions.vk_khr_depth_clamp_zero_one))) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR), but its parent extension "
                                 "VK_EXT_depth_clamp_zero_one, or VK_KHR_depth_clamp_zero_one has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClampZeroOneFeaturesKHR);
                VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* structure = (VkPhysicalDeviceDepthClampZeroOneFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClampZeroOne), structure->depthClampZeroOne);
            }
        } break;

        // Validation code for VkPhysicalDeviceTransformFeedbackFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceTransformFeedbackFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_transform_feedback)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_transform_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTransformFeedbackFeaturesEXT);
                VkPhysicalDeviceTransformFeedbackFeaturesEXT* structure = (VkPhysicalDeviceTransformFeedbackFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::transformFeedback), structure->transformFeedback);

                skip |= ValidateBool32(pNext_loc.dot(Field::geometryStreams), structure->geometryStreams);
            }
        } break;

        // Validation code for VkPhysicalDeviceCornerSampledImageFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCornerSampledImageFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_corner_sampled_image)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV), but its parent extension "
                                 "VK_NV_corner_sampled_image has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCornerSampledImageFeaturesNV);
                VkPhysicalDeviceCornerSampledImageFeaturesNV* structure = (VkPhysicalDeviceCornerSampledImageFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cornerSampledImage), structure->cornerSampledImage);
            }
        } break;

        // Validation code for VkPhysicalDeviceASTCDecodeFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {  // Covers
                                                                            // VUID-VkPhysicalDeviceASTCDecodeFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_astc_decode_mode)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_astc_decode_mode has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceASTCDecodeFeaturesEXT);
                VkPhysicalDeviceASTCDecodeFeaturesEXT* structure = (VkPhysicalDeviceASTCDecodeFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::decodeModeSharedExponent), structure->decodeModeSharedExponent);
            }
        } break;

        // Validation code for VkPhysicalDeviceConditionalRenderingFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceConditionalRenderingFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_conditional_rendering)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_conditional_rendering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceConditionalRenderingFeaturesEXT);
                VkPhysicalDeviceConditionalRenderingFeaturesEXT* structure =
                    (VkPhysicalDeviceConditionalRenderingFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::conditionalRendering), structure->conditionalRendering);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::inheritedConditionalRendering), structure->inheritedConditionalRendering);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClipEnableFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDepthClipEnableFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_clip_enable)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_depth_clip_enable has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClipEnableFeaturesEXT);
                VkPhysicalDeviceDepthClipEnableFeaturesEXT* structure = (VkPhysicalDeviceDepthClipEnableFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClipEnable), structure->depthClipEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG-sType-sType

            if (!IsExtEnabled(extensions.vk_img_relaxed_line_rasterization)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG), but its parent extension "
                    "VK_IMG_relaxed_line_rasterization has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG);
                VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* structure =
                    (VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::relaxedLineRasterization), structure->relaxedLineRasterization);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceShaderEnqueueFeaturesAMDX structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX: {  // Covers
                                                                                // VUID-VkPhysicalDeviceShaderEnqueueFeaturesAMDX-sType-sType

            if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX), but its parent extension "
                                     "VK_AMDX_shader_enqueue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderEnqueueFeaturesAMDX);
                VkPhysicalDeviceShaderEnqueueFeaturesAMDX* structure = (VkPhysicalDeviceShaderEnqueueFeaturesAMDX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderEnqueue), structure->shaderEnqueue);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderMeshEnqueue), structure->shaderMeshEnqueue);
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_blend_operation_advanced)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT), but its parent extension "
                    "VK_EXT_blend_operation_advanced has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structure =
                    (VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::advancedBlendCoherentOperations),
                                       structure->advancedBlendCoherentOperations);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceShaderSMBuiltinsFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_shader_sm_builtins)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV), but its parent extension "
                                     "VK_NV_shader_sm_builtins has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);
                VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* structure = (VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSMBuiltins), structure->shaderSMBuiltins);
            }
        } break;

        // Validation code for VkPhysicalDeviceShadingRateImageFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceShadingRateImageFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_shading_rate_image)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV), but its parent extension "
                                     "VK_NV_shading_rate_image has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShadingRateImageFeaturesNV);
                VkPhysicalDeviceShadingRateImageFeaturesNV* structure = (VkPhysicalDeviceShadingRateImageFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shadingRateImage), structure->shadingRateImage);

                skip |= ValidateBool32(pNext_loc.dot(Field::shadingRateCoarseSampleOrder), structure->shadingRateCoarseSampleOrder);
            }
        } break;

        // Validation code for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_representative_fragment_test)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV), but its parent extension "
                    "VK_NV_representative_fragment_test has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
                VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* structure =
                    (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::representativeFragmentTest), structure->representativeFragmentTest);
            }
        } break;

        // Validation code for VkPhysicalDeviceMeshShaderFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {  // Covers
                                                                           // VUID-VkPhysicalDeviceMeshShaderFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_mesh_shader)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV), but its parent extension "
                                     "VK_NV_mesh_shader has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMeshShaderFeaturesNV);
                VkPhysicalDeviceMeshShaderFeaturesNV* structure = (VkPhysicalDeviceMeshShaderFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::taskShader), structure->taskShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::meshShader), structure->meshShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderImageFootprintFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceShaderImageFootprintFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_shader_image_footprint)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV), but its parent extension "
                                 "VK_NV_shader_image_footprint has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderImageFootprintFeaturesNV);
                VkPhysicalDeviceShaderImageFootprintFeaturesNV* structure = (VkPhysicalDeviceShaderImageFootprintFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageFootprint), structure->imageFootprint);
            }
        } break;

        // Validation code for VkPhysicalDeviceExclusiveScissorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceExclusiveScissorFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_scissor_exclusive)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV), but its parent extension "
                                     "VK_NV_scissor_exclusive has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExclusiveScissorFeaturesNV);
                VkPhysicalDeviceExclusiveScissorFeaturesNV* structure = (VkPhysicalDeviceExclusiveScissorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::exclusiveScissor), structure->exclusiveScissor);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL-sType-sType

            if (!IsExtEnabled(extensions.vk_intel_shader_integer_functions2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL), but its parent extension "
                    "VK_INTEL_shader_integer_functions2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
                VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* structure =
                    (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderIntegerFunctions2), structure->shaderIntegerFunctions2);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceFragmentDensityMapFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_fragment_density_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_fragment_density_map has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
                VkPhysicalDeviceFragmentDensityMapFeaturesEXT* structure = (VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMap), structure->fragmentDensityMap);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapDynamic), structure->fragmentDensityMapDynamic);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapNonSubsampledImages),
                                       structure->fragmentDensityMapNonSubsampledImages);
            }
        } break;

        // Validation code for VkPhysicalDeviceCoherentMemoryFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {  // Covers
                                                                                // VUID-VkPhysicalDeviceCoherentMemoryFeaturesAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_device_coherent_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD), but its parent extension "
                                     "VK_AMD_device_coherent_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCoherentMemoryFeaturesAMD);
                VkPhysicalDeviceCoherentMemoryFeaturesAMD* structure = (VkPhysicalDeviceCoherentMemoryFeaturesAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceCoherentMemory), structure->deviceCoherentMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_image_atomic_int64)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT), but its parent extension "
                    "VK_EXT_shader_image_atomic_int64 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
                VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* structure =
                    (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderImageInt64Atomics), structure->shaderImageInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseImageInt64Atomics), structure->sparseImageInt64Atomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceMemoryPriorityFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {  // Covers
                                                                                // VUID-VkPhysicalDeviceMemoryPriorityFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_memory_priority)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_memory_priority has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMemoryPriorityFeaturesEXT);
                VkPhysicalDeviceMemoryPriorityFeaturesEXT* structure = (VkPhysicalDeviceMemoryPriorityFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::memoryPriority), structure->memoryPriority);
            }
        } break;

        // Validation code for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {  // Covers
                                                                                                   // VUID-VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_dedicated_allocation_image_aliasing)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV), but its parent extension "
                    "VK_NV_dedicated_allocation_image_aliasing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
                VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* structure =
                    (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dedicatedAllocationImageAliasing),
                                       structure->dedicatedAllocationImageAliasing);
            }
        } break;

        // Validation code for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceBufferDeviceAddressFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_buffer_device_address)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_buffer_device_address has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
                VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* structure = (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddress), structure->bufferDeviceAddress);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressCaptureReplay),
                                       structure->bufferDeviceAddressCaptureReplay);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressMultiDevice), structure->bufferDeviceAddressMultiDevice);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrixFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceCooperativeMatrixFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_cooperative_matrix)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV), but its parent extension "
                                     "VK_NV_cooperative_matrix has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCooperativeMatrixFeaturesNV);
                VkPhysicalDeviceCooperativeMatrixFeaturesNV* structure = (VkPhysicalDeviceCooperativeMatrixFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrix), structure->cooperativeMatrix);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixRobustBufferAccess),
                                       structure->cooperativeMatrixRobustBufferAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceCoverageReductionModeFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceCoverageReductionModeFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_coverage_reduction_mode)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV), but its parent extension "
                    "VK_NV_coverage_reduction_mode has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCoverageReductionModeFeaturesNV);
                VkPhysicalDeviceCoverageReductionModeFeaturesNV* structure =
                    (VkPhysicalDeviceCoverageReductionModeFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::coverageReductionMode), structure->coverageReductionMode);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_fragment_shader_interlock)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT), but its parent extension "
                    "VK_EXT_fragment_shader_interlock has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
                VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* structure =
                    (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::fragmentShaderSampleInterlock), structure->fragmentShaderSampleInterlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShaderPixelInterlock), structure->fragmentShaderPixelInterlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShaderShadingRateInterlock),
                                       structure->fragmentShaderShadingRateInterlock);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceYcbcrImageArraysFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_ycbcr_image_arrays)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_ycbcr_image_arrays has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
                VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* structure = (VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::ycbcrImageArrays), structure->ycbcrImageArrays);
            }
        } break;

        // Validation code for VkPhysicalDeviceProvokingVertexFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceProvokingVertexFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_provoking_vertex)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_provoking_vertex has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceProvokingVertexFeaturesEXT);
                VkPhysicalDeviceProvokingVertexFeaturesEXT* structure = (VkPhysicalDeviceProvokingVertexFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::provokingVertexLast), structure->provokingVertexLast);

                skip |= ValidateBool32(pNext_loc.dot(Field::transformFeedbackPreservesProvokingVertex),
                                       structure->transformFeedbackPreservesProvokingVertex);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceShaderAtomicFloatFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_atomic_float)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_shader_atomic_float has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
                VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* structure = (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat32Atomics), structure->shaderBufferFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat32AtomicAdd), structure->shaderBufferFloat32AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat64Atomics), structure->shaderBufferFloat64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat64AtomicAdd), structure->shaderBufferFloat64AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat32Atomics), structure->shaderSharedFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat32AtomicAdd), structure->shaderSharedFloat32AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat64Atomics), structure->shaderSharedFloat64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat64AtomicAdd), structure->shaderSharedFloat64AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderImageFloat32Atomics), structure->shaderImageFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderImageFloat32AtomicAdd), structure->shaderImageFloat32AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseImageFloat32Atomics), structure->sparseImageFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseImageFloat32AtomicAdd), structure->sparseImageFloat32AtomicAdd);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceExtendedDynamicStateFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_extended_dynamic_state)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT), but its parent extension "
                    "VK_EXT_extended_dynamic_state has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
                VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState), structure->extendedDynamicState);
            }
        } break;

        // Validation code for VkPhysicalDeviceMapMemoryPlacedFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceMapMemoryPlacedFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_map_memory_placed)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_map_memory_placed has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMapMemoryPlacedFeaturesEXT);
                VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* structure = (VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::memoryMapPlaced), structure->memoryMapPlaced);

                skip |= ValidateBool32(pNext_loc.dot(Field::memoryMapRangePlaced), structure->memoryMapRangePlaced);

                skip |= ValidateBool32(pNext_loc.dot(Field::memoryUnmapReserve), structure->memoryUnmapReserve);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_atomic_float2)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_shader_atomic_float2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
                VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* structure = (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat16Atomics), structure->shaderBufferFloat16Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat16AtomicAdd), structure->shaderBufferFloat16AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat16AtomicMinMax),
                                       structure->shaderBufferFloat16AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat32AtomicMinMax),
                                       structure->shaderBufferFloat32AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat64AtomicMinMax),
                                       structure->shaderBufferFloat64AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat16Atomics), structure->shaderSharedFloat16Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat16AtomicAdd), structure->shaderSharedFloat16AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat16AtomicMinMax),
                                       structure->shaderSharedFloat16AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat32AtomicMinMax),
                                       structure->shaderSharedFloat32AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat64AtomicMinMax),
                                       structure->shaderSharedFloat64AtomicMinMax);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderImageFloat32AtomicMinMax), structure->shaderImageFloat32AtomicMinMax);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::sparseImageFloat32AtomicMinMax), structure->sparseImageFloat32AtomicMinMax);
            }
        } break;

        // Validation code for VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_swapchain_maintenance1)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT), but its parent extension "
                    "VK_EXT_swapchain_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT);
                VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* structure =
                    (VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::swapchainMaintenance1), structure->swapchainMaintenance1);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_generated_commands)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV), but its parent extension "
                    "VK_NV_device_generated_commands has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);
                VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* structure =
                    (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedCommands), structure->deviceGeneratedCommands);
            }
        } break;

        // Validation code for VkPhysicalDeviceInheritedViewportScissorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceInheritedViewportScissorFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_inherited_viewport_scissor)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV), but its parent extension "
                    "VK_NV_inherited_viewport_scissor has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceInheritedViewportScissorFeaturesNV);
                VkPhysicalDeviceInheritedViewportScissorFeaturesNV* structure =
                    (VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::inheritedViewportScissor2D), structure->inheritedViewportScissor2D);
            }
        } break;

        // Validation code for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_texel_buffer_alignment)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT), but its parent extension "
                    "VK_EXT_texel_buffer_alignment has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
                VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* structure =
                    (VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::texelBufferAlignment), structure->texelBufferAlignment);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthBiasControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceDepthBiasControlFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_bias_control)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_depth_bias_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthBiasControlFeaturesEXT);
                VkPhysicalDeviceDepthBiasControlFeaturesEXT* structure = (VkPhysicalDeviceDepthBiasControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasControl), structure->depthBiasControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::leastRepresentableValueForceUnormRepresentation),
                                       structure->leastRepresentableValueForceUnormRepresentation);

                skip |= ValidateBool32(pNext_loc.dot(Field::floatRepresentation), structure->floatRepresentation);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasExact), structure->depthBiasExact);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceDeviceMemoryReportFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_memory_report)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_device_memory_report has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
                VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* structure = (VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceMemoryReport), structure->deviceMemoryReport);
            }
        } break;

        // Validation code for VkPhysicalDeviceRobustness2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {  // Covers
                                                                             // VUID-VkPhysicalDeviceRobustness2FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_robustness2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_robustness2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRobustness2FeaturesEXT);
                VkPhysicalDeviceRobustness2FeaturesEXT* structure = (VkPhysicalDeviceRobustness2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustBufferAccess2), structure->robustBufferAccess2);

                skip |= ValidateBool32(pNext_loc.dot(Field::robustImageAccess2), structure->robustImageAccess2);

                skip |= ValidateBool32(pNext_loc.dot(Field::nullDescriptor), structure->nullDescriptor);
            }
        } break;

        // Validation code for VkPhysicalDeviceCustomBorderColorFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCustomBorderColorFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_custom_border_color)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_custom_border_color has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCustomBorderColorFeaturesEXT);
                VkPhysicalDeviceCustomBorderColorFeaturesEXT* structure = (VkPhysicalDeviceCustomBorderColorFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::customBorderColors), structure->customBorderColors);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::customBorderColorWithoutFormat), structure->customBorderColorWithoutFormat);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentBarrierFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: {  // Covers
                                                                               // VUID-VkPhysicalDevicePresentBarrierFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_present_barrier)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV), but its parent extension "
                                     "VK_NV_present_barrier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentBarrierFeaturesNV);
                VkPhysicalDevicePresentBarrierFeaturesNV* structure = (VkPhysicalDevicePresentBarrierFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentBarrier), structure->presentBarrier);
            }
        } break;

        // Validation code for VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDiagnosticsConfigFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_diagnostics_config)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV), but its parent extension "
                                     "VK_NV_device_diagnostics_config has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDiagnosticsConfigFeaturesNV);
                VkPhysicalDeviceDiagnosticsConfigFeaturesNV* structure = (VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::diagnosticsConfig), structure->diagnosticsConfig);
            }
        } break;

        // Validation code for VkPhysicalDeviceCudaKernelLaunchFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceCudaKernelLaunchFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV), but its parent extension "
                                     "VK_NV_cuda_kernel_launch has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCudaKernelLaunchFeaturesNV);
                VkPhysicalDeviceCudaKernelLaunchFeaturesNV* structure = (VkPhysicalDeviceCudaKernelLaunchFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cudaKernelLaunchFeatures), structure->cudaKernelLaunchFeatures);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorBufferFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDescriptorBufferFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_descriptor_buffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDescriptorBufferFeaturesEXT);
                VkPhysicalDeviceDescriptorBufferFeaturesEXT* structure = (VkPhysicalDeviceDescriptorBufferFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBuffer), structure->descriptorBuffer);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::descriptorBufferCaptureReplay), structure->descriptorBufferCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBufferImageLayoutIgnored),
                                       structure->descriptorBufferImageLayoutIgnored);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBufferPushDescriptors),
                                       structure->descriptorBufferPushDescriptors);
            }
        } break;

        // Validation code for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_graphics_pipeline_library)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT), but its parent extension "
                    "VK_EXT_graphics_pipeline_library has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT);
                VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* structure =
                    (VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::graphicsPipelineLibrary), structure->graphicsPipelineLibrary);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: {  // Covers
                                                                                                     // VUID-VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_shader_early_and_late_fragment_tests)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD), but "
                                     "its parent extension "
                                     "VK_AMD_shader_early_and_late_fragment_tests has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD);
                VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* structure =
                    (VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderEarlyAndLateFragmentTests),
                                       structure->shaderEarlyAndLateFragmentTests);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_fragment_shading_rate_enums)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV), but its parent extension "
                    "VK_NV_fragment_shading_rate_enums has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);
                VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* structure =
                    (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShadingRateEnums), structure->fragmentShadingRateEnums);

                skip |= ValidateBool32(pNext_loc.dot(Field::supersampleFragmentShadingRates),
                                       structure->supersampleFragmentShadingRates);

                skip |= ValidateBool32(pNext_loc.dot(Field::noInvocationFragmentShadingRates),
                                       structure->noInvocationFragmentShadingRates);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceRayTracingMotionBlurFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_motion_blur)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV), but its parent extension "
                    "VK_NV_ray_tracing_motion_blur has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingMotionBlurFeaturesNV);
                VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* structure = (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingMotionBlur), structure->rayTracingMotionBlur);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingMotionBlurPipelineTraceRaysIndirect),
                                       structure->rayTracingMotionBlurPipelineTraceRaysIndirect);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_ycbcr_2plane_444_formats)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT), but its parent extension "
                    "VK_EXT_ycbcr_2plane_444_formats has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
                VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* structure =
                    (VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::ycbcr2plane444Formats), structure->ycbcr2plane444Formats);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceFragmentDensityMap2FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_fragment_density_map2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT), but its parent extension "
                    "VK_EXT_fragment_density_map2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
                VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* structure = (VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapDeferred), structure->fragmentDensityMapDeferred);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageCompressionControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceImageCompressionControlFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_compression_control)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT), but its parent extension "
                    "VK_EXT_image_compression_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageCompressionControlFeaturesEXT);
                VkPhysicalDeviceImageCompressionControlFeaturesEXT* structure =
                    (VkPhysicalDeviceImageCompressionControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageCompressionControl), structure->imageCompressionControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT: {  // Covers
                                                                                                // VUID-VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_attachment_feedback_loop_layout)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT), but its parent extension "
                    "VK_EXT_attachment_feedback_loop_layout has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT);
                VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* structure =
                    (VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::attachmentFeedbackLoopLayout), structure->attachmentFeedbackLoopLayout);
            }
        } break;

        // Validation code for VkPhysicalDevice4444FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {  // Covers
                                                                             // VUID-VkPhysicalDevice4444FormatsFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_4444_formats)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_4444_formats has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevice4444FormatsFeaturesEXT);
                VkPhysicalDevice4444FormatsFeaturesEXT* structure = (VkPhysicalDevice4444FormatsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::formatA4R4G4B4), structure->formatA4R4G4B4);

                skip |= ValidateBool32(pNext_loc.dot(Field::formatA4B4G4R4), structure->formatA4B4G4R4);
            }
        } break;

        // Validation code for VkPhysicalDeviceFaultFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: {  // Covers VUID-VkPhysicalDeviceFaultFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_fault)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_device_fault has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFaultFeaturesEXT);
                VkPhysicalDeviceFaultFeaturesEXT* structure = (VkPhysicalDeviceFaultFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceFault), structure->deviceFault);

                skip |= ValidateBool32(pNext_loc.dot(Field::deviceFaultVendorBinary), structure->deviceFaultVendorBinary);
            }
        } break;

        // Validation code for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT: {  // Covers
                                                                                                      // VUID-VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT-sType-sType

            if ((!IsExtEnabled(extensions.vk_arm_rasterization_order_attachment_access)) &&
                (!IsExtEnabled(extensions.vk_ext_rasterization_order_attachment_access))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT), but "
                                     "its parent extension "
                                     "VK_ARM_rasterization_order_attachment_access, or "
                                     "VK_EXT_rasterization_order_attachment_access has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT);
                VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* structure =
                    (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rasterizationOrderColorAttachmentAccess),
                                       structure->rasterizationOrderColorAttachmentAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::rasterizationOrderDepthAttachmentAccess),
                                       structure->rasterizationOrderDepthAttachmentAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::rasterizationOrderStencilAttachmentAccess),
                                       structure->rasterizationOrderStencilAttachmentAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_rgba10x6_formats)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_rgba10x6_formats has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
                VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* structure = (VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::formatRgba10x6WithoutYCbCrSampler),
                                       structure->formatRgba10x6WithoutYCbCrSampler);
            }
        } break;

        // Validation code for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_mutable_descriptor_type)) &&
                (!IsExtEnabled(extensions.vk_valve_mutable_descriptor_type))) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT), but its parent extension "
                    "VK_EXT_mutable_descriptor_type, or VK_VALVE_mutable_descriptor_type has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT);
                VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* structure =
                    (VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::mutableDescriptorType), structure->mutableDescriptorType);
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_vertex_input_dynamic_state)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT), but its parent extension "
                    "VK_EXT_vertex_input_dynamic_state has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
                VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* structure =
                    (VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vertexInputDynamicState), structure->vertexInputDynamicState);
            }
        } break;

        // Validation code for VkPhysicalDeviceAddressBindingReportFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceAddressBindingReportFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_address_binding_report)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT), but its parent extension "
                    "VK_EXT_device_address_binding_report has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAddressBindingReportFeaturesEXT);
                VkPhysicalDeviceAddressBindingReportFeaturesEXT* structure =
                    (VkPhysicalDeviceAddressBindingReportFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::reportAddressBinding), structure->reportAddressBinding);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClipControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceDepthClipControlFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_clip_control)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_depth_clip_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClipControlFeaturesEXT);
                VkPhysicalDeviceDepthClipControlFeaturesEXT* structure = (VkPhysicalDeviceDepthClipControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClipControl), structure->depthClipControl);
            }
        } break;

        // Validation code for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {  // Covers
                                                                                                // VUID-VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_primitive_topology_list_restart)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT), but its parent extension "
                    "VK_EXT_primitive_topology_list_restart has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
                VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* structure =
                    (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveTopologyListRestart), structure->primitiveTopologyListRestart);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveTopologyPatchListRestart),
                                       structure->primitiveTopologyPatchListRestart);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT: {  // Covers
                                                                                               // VUID-VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_present_mode_fifo_latest_ready)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT), but its parent extension "
                    "VK_EXT_present_mode_fifo_latest_ready has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT);
                VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT* structure =
                    (VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentModeFifoLatestReady), structure->presentModeFifoLatestReady);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceSubpassShadingFeaturesHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_subpass_shading)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI), but its parent extension "
                                 "VK_HUAWEI_subpass_shading has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSubpassShadingFeaturesHUAWEI);
                VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* structure = (VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::subpassShading), structure->subpassShading);
            }
        } break;

        // Validation code for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceInvocationMaskFeaturesHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_invocation_mask)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI), but its parent extension "
                                 "VK_HUAWEI_invocation_mask has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceInvocationMaskFeaturesHUAWEI);
                VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* structure = (VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::invocationMask), structure->invocationMask);
            }
        } break;

        // Validation code for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceExternalMemoryRDMAFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_external_memory_rdma)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV), but its parent extension "
                                 "VK_NV_external_memory_rdma has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExternalMemoryRDMAFeaturesNV);
                VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* structure = (VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::externalMemoryRDMA), structure->externalMemoryRDMA);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelinePropertiesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDevicePipelinePropertiesFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_properties)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_pipeline_properties has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelinePropertiesFeaturesEXT);
                VkPhysicalDevicePipelinePropertiesFeaturesEXT* structure = (VkPhysicalDevicePipelinePropertiesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelinePropertiesIdentifier), structure->pipelinePropertiesIdentifier);
            }
        } break;

        // Validation code for VkPhysicalDeviceFrameBoundaryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT: {  // Covers
                                                                               // VUID-VkPhysicalDeviceFrameBoundaryFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_frame_boundary)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_frame_boundary has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFrameBoundaryFeaturesEXT);
                VkPhysicalDeviceFrameBoundaryFeaturesEXT* structure = (VkPhysicalDeviceFrameBoundaryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::frameBoundary), structure->frameBoundary);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT: {  // Covers
                                                                                                      // VUID-VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_multisampled_render_to_single_sampled)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_multisampled_render_to_single_sampled has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT);
                VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* structure =
                    (VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multisampledRenderToSingleSampled),
                                       structure->multisampledRenderToSingleSampled);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceExtendedDynamicState2FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_extended_dynamic_state2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT), but its parent extension "
                    "VK_EXT_extended_dynamic_state2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
                VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState2), structure->extendedDynamicState2);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState2LogicOp), structure->extendedDynamicState2LogicOp);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState2PatchControlPoints),
                                       structure->extendedDynamicState2PatchControlPoints);
            }
        } break;

        // Validation code for VkPhysicalDeviceColorWriteEnableFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceColorWriteEnableFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_color_write_enable)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_color_write_enable has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceColorWriteEnableFeaturesEXT);
                VkPhysicalDeviceColorWriteEnableFeaturesEXT* structure = (VkPhysicalDeviceColorWriteEnableFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::colorWriteEnable), structure->colorWriteEnable);
            }
        } break;

        // Validation code for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: {  // Covers
                                                                                           // VUID-VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_primitives_generated_query)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT), but its parent extension "
                    "VK_EXT_primitives_generated_query has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT);
                VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* structure =
                    (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::primitivesGeneratedQuery), structure->primitivesGeneratedQuery);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitivesGeneratedQueryWithRasterizerDiscard),
                                       structure->primitivesGeneratedQueryWithRasterizerDiscard);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitivesGeneratedQueryWithNonZeroStreams),
                                       structure->primitivesGeneratedQueryWithNonZeroStreams);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageViewMinLodFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceImageViewMinLodFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_view_min_lod)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_image_view_min_lod has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageViewMinLodFeaturesEXT);
                VkPhysicalDeviceImageViewMinLodFeaturesEXT* structure = (VkPhysicalDeviceImageViewMinLodFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::minLod), structure->minLod);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiDrawFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {  // Covers
                                                                           // VUID-VkPhysicalDeviceMultiDrawFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_multi_draw)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_multi_draw has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMultiDrawFeaturesEXT);
                VkPhysicalDeviceMultiDrawFeaturesEXT* structure = (VkPhysicalDeviceMultiDrawFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiDraw), structure->multiDraw);
            }
        } break;

        // Validation code for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceImage2DViewOf3DFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_2d_view_of_3d)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_image_2d_view_of_3d has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImage2DViewOf3DFeaturesEXT);
                VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* structure = (VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::image2DViewOf3D), structure->image2DViewOf3D);

                skip |= ValidateBool32(pNext_loc.dot(Field::sampler2DViewOf3D), structure->sampler2DViewOf3D);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderTileImageFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceShaderTileImageFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_tile_image)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_shader_tile_image has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderTileImageFeaturesEXT);
                VkPhysicalDeviceShaderTileImageFeaturesEXT* structure = (VkPhysicalDeviceShaderTileImageFeaturesEXT*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderTileImageColorReadAccess), structure->shaderTileImageColorReadAccess);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderTileImageDepthReadAccess), structure->shaderTileImageDepthReadAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTileImageStencilReadAccess),
                                       structure->shaderTileImageStencilReadAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceOpacityMicromapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceOpacityMicromapFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_opacity_micromap)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_opacity_micromap has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceOpacityMicromapFeaturesEXT);
                VkPhysicalDeviceOpacityMicromapFeaturesEXT* structure = (VkPhysicalDeviceOpacityMicromapFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::micromap), structure->micromap);

                skip |= ValidateBool32(pNext_loc.dot(Field::micromapCaptureReplay), structure->micromapCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::micromapHostCommands), structure->micromapHostCommands);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceDisplacementMicromapFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceDisplacementMicromapFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_displacement_micromap)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV), but its parent extension "
                                 "VK_NV_displacement_micromap has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDisplacementMicromapFeaturesNV);
                VkPhysicalDeviceDisplacementMicromapFeaturesNV* structure = (VkPhysicalDeviceDisplacementMicromapFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::displacementMicromap), structure->displacementMicromap);
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_cluster_culling_shader)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI), but its parent extension "
                    "VK_HUAWEI_cluster_culling_shader has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI);
                VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* structure =
                    (VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::clustercullingShader), structure->clustercullingShader);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::multiviewClusterCullingShader), structure->multiviewClusterCullingShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceBorderColorSwizzleFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_border_color_swizzle)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_border_color_swizzle has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
                VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* structure = (VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::borderColorSwizzle), structure->borderColorSwizzle);

                skip |= ValidateBool32(pNext_loc.dot(Field::borderColorSwizzleFromImage), structure->borderColorSwizzleFromImage);
            }
        } break;

        // Validation code for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: {  // Covers
                                                                                             // VUID-VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pageable_device_local_memory)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT), but its parent extension "
                    "VK_EXT_pageable_device_local_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
                VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* structure =
                    (VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pageableDeviceLocalMemory), structure->pageableDeviceLocalMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceSchedulingControlsFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceSchedulingControlsFeaturesARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_scheduling_controls)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM), but its parent extension "
                                 "VK_ARM_scheduling_controls has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSchedulingControlsFeaturesARM);
                VkPhysicalDeviceSchedulingControlsFeaturesARM* structure = (VkPhysicalDeviceSchedulingControlsFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::schedulingControls), structure->schedulingControls);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_sliced_view_of_3d)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT), but its parent extension "
                    "VK_EXT_image_sliced_view_of_3d has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT);
                VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* structure = (VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageSlicedViewOf3D), structure->imageSlicedViewOf3D);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType

            if (!IsExtEnabled(extensions.vk_valve_descriptor_set_host_mapping)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE), but its parent extension "
                    "VK_VALVE_descriptor_set_host_mapping has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE);
                VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* structure =
                    (VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorSetHostMapping), structure->descriptorSetHostMapping);
            }
        } break;

        // Validation code for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_non_seamless_cube_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_non_seamless_cube_map has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT);
                VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* structure = (VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::nonSeamlessCubeMap), structure->nonSeamlessCubeMap);
            }
        } break;

        // Validation code for VkPhysicalDeviceRenderPassStripedFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceRenderPassStripedFeaturesARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_render_pass_striped)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM), but its parent extension "
                                 "VK_ARM_render_pass_striped has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRenderPassStripedFeaturesARM);
                VkPhysicalDeviceRenderPassStripedFeaturesARM* structure = (VkPhysicalDeviceRenderPassStripedFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::renderPassStriped), structure->renderPassStriped);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_fragment_density_map_offset)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM), but its parent extension "
                    "VK_QCOM_fragment_density_map_offset has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM);
                VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* structure =
                    (VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapOffset), structure->fragmentDensityMapOffset);
            }
        } break;

        // Validation code for VkPhysicalDeviceCopyMemoryIndirectFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCopyMemoryIndirectFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_copy_memory_indirect)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV), but its parent extension "
                                 "VK_NV_copy_memory_indirect has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCopyMemoryIndirectFeaturesNV);
                VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* structure = (VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::indirectCopy), structure->indirectCopy);
            }
        } break;

        // Validation code for VkPhysicalDeviceMemoryDecompressionFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceMemoryDecompressionFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_memory_decompression)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV), but its parent extension "
                                 "VK_NV_memory_decompression has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMemoryDecompressionFeaturesNV);
                VkPhysicalDeviceMemoryDecompressionFeaturesNV* structure = (VkPhysicalDeviceMemoryDecompressionFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::memoryDecompression), structure->memoryDecompression);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV: {  // Covers
                                                                                                 // VUID-VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_generated_commands_compute)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV), but its parent extension "
                    "VK_NV_device_generated_commands_compute has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV);
                VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* structure =
                    (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedCompute), structure->deviceGeneratedCompute);

                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedComputePipelines),
                                       structure->deviceGeneratedComputePipelines);

                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedComputeCaptureReplay),
                                       structure->deviceGeneratedComputeCaptureReplay);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV: {  // Covers
                                                                                                // VUID-VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_linear_swept_spheres)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV), but its parent extension "
                    "VK_NV_ray_tracing_linear_swept_spheres has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV);
                VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* structure =
                    (VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::spheres), structure->spheres);

                skip |= ValidateBool32(pNext_loc.dot(Field::linearSweptSpheres), structure->linearSweptSpheres);
            }
        } break;

        // Validation code for VkPhysicalDeviceLinearColorAttachmentFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceLinearColorAttachmentFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_linear_color_attachment)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV), but its parent extension "
                    "VK_NV_linear_color_attachment has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLinearColorAttachmentFeaturesNV);
                VkPhysicalDeviceLinearColorAttachmentFeaturesNV* structure =
                    (VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::linearColorAttachment), structure->linearColorAttachment);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: {  // Covers
                                                                                                    // VUID-VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_compression_control_swapchain)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_image_compression_control_swapchain has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT);
                VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* structure =
                    (VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageCompressionControlSwapchain),
                                       structure->imageCompressionControlSwapchain);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageProcessingFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceImageProcessingFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_image_processing)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM), but its parent extension "
                                     "VK_QCOM_image_processing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageProcessingFeaturesQCOM);
                VkPhysicalDeviceImageProcessingFeaturesQCOM* structure = (VkPhysicalDeviceImageProcessingFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::textureSampleWeighted), structure->textureSampleWeighted);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureBoxFilter), structure->textureBoxFilter);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureBlockMatch), structure->textureBlockMatch);
            }
        } break;

        // Validation code for VkPhysicalDeviceNestedCommandBufferFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceNestedCommandBufferFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_nested_command_buffer)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_nested_command_buffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceNestedCommandBufferFeaturesEXT);
                VkPhysicalDeviceNestedCommandBufferFeaturesEXT* structure = (VkPhysicalDeviceNestedCommandBufferFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::nestedCommandBuffer), structure->nestedCommandBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::nestedCommandBufferRendering), structure->nestedCommandBufferRendering);

                skip |= ValidateBool32(pNext_loc.dot(Field::nestedCommandBufferSimultaneousUse),
                                       structure->nestedCommandBufferSimultaneousUse);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceExtendedDynamicState3FeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_extended_dynamic_state3)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT), but its parent extension "
                    "VK_EXT_extended_dynamic_state3 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicState3FeaturesEXT);
                VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3TessellationDomainOrigin),
                                       structure->extendedDynamicState3TessellationDomainOrigin);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3DepthClampEnable),
                                       structure->extendedDynamicState3DepthClampEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3PolygonMode),
                                       structure->extendedDynamicState3PolygonMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3RasterizationSamples),
                                       structure->extendedDynamicState3RasterizationSamples);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3SampleMask),
                                       structure->extendedDynamicState3SampleMask);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3AlphaToCoverageEnable),
                                       structure->extendedDynamicState3AlphaToCoverageEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3AlphaToOneEnable),
                                       structure->extendedDynamicState3AlphaToOneEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3LogicOpEnable),
                                       structure->extendedDynamicState3LogicOpEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorBlendEnable),
                                       structure->extendedDynamicState3ColorBlendEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorBlendEquation),
                                       structure->extendedDynamicState3ColorBlendEquation);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorWriteMask),
                                       structure->extendedDynamicState3ColorWriteMask);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3RasterizationStream),
                                       structure->extendedDynamicState3RasterizationStream);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ConservativeRasterizationMode),
                                       structure->extendedDynamicState3ConservativeRasterizationMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ExtraPrimitiveOverestimationSize),
                                       structure->extendedDynamicState3ExtraPrimitiveOverestimationSize);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3DepthClipEnable),
                                       structure->extendedDynamicState3DepthClipEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3SampleLocationsEnable),
                                       structure->extendedDynamicState3SampleLocationsEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorBlendAdvanced),
                                       structure->extendedDynamicState3ColorBlendAdvanced);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ProvokingVertexMode),
                                       structure->extendedDynamicState3ProvokingVertexMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3LineRasterizationMode),
                                       structure->extendedDynamicState3LineRasterizationMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3LineStippleEnable),
                                       structure->extendedDynamicState3LineStippleEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3DepthClipNegativeOneToOne),
                                       structure->extendedDynamicState3DepthClipNegativeOneToOne);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ViewportWScalingEnable),
                                       structure->extendedDynamicState3ViewportWScalingEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ViewportSwizzle),
                                       structure->extendedDynamicState3ViewportSwizzle);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageToColorEnable),
                                       structure->extendedDynamicState3CoverageToColorEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageToColorLocation),
                                       structure->extendedDynamicState3CoverageToColorLocation);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageModulationMode),
                                       structure->extendedDynamicState3CoverageModulationMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageModulationTableEnable),
                                       structure->extendedDynamicState3CoverageModulationTableEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageModulationTable),
                                       structure->extendedDynamicState3CoverageModulationTable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageReductionMode),
                                       structure->extendedDynamicState3CoverageReductionMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3RepresentativeFragmentTestEnable),
                                       structure->extendedDynamicState3RepresentativeFragmentTestEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ShadingRateImageEnable),
                                       structure->extendedDynamicState3ShadingRateImageEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_subpass_merge_feedback)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT), but its parent extension "
                    "VK_EXT_subpass_merge_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT);
                VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* structure =
                    (VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::subpassMergeFeedback), structure->subpassMergeFeedback);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_module_identifier)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT), but its parent extension "
                    "VK_EXT_shader_module_identifier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT);
                VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* structure =
                    (VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderModuleIdentifier), structure->shaderModuleIdentifier);
            }
        } break;

        // Validation code for VkPhysicalDeviceOpticalFlowFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: {  // Covers
                                                                            // VUID-VkPhysicalDeviceOpticalFlowFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_optical_flow)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV), but its parent extension "
                                     "VK_NV_optical_flow has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceOpticalFlowFeaturesNV);
                VkPhysicalDeviceOpticalFlowFeaturesNV* structure = (VkPhysicalDeviceOpticalFlowFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::opticalFlow), structure->opticalFlow);
            }
        } break;

        // Validation code for VkPhysicalDeviceLegacyDitheringFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceLegacyDitheringFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_legacy_dithering)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_legacy_dithering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLegacyDitheringFeaturesEXT);
                VkPhysicalDeviceLegacyDitheringFeaturesEXT* structure = (VkPhysicalDeviceLegacyDitheringFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::legacyDithering), structure->legacyDithering);
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkPhysicalDeviceExternalFormatResolveFeaturesANDROID structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceExternalFormatResolveFeaturesANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_format_resolve)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID), but its parent extension "
                    "VK_ANDROID_external_format_resolve has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExternalFormatResolveFeaturesANDROID);
                VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* structure =
                    (VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::externalFormatResolve), structure->externalFormatResolve);
            }
        } break;
#endif  // VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkPhysicalDeviceAntiLagFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD: {  // Covers
                                                                         // VUID-VkPhysicalDeviceAntiLagFeaturesAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_anti_lag)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD), but its parent extension "
                                     "VK_AMD_anti_lag has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAntiLagFeaturesAMD);
                VkPhysicalDeviceAntiLagFeaturesAMD* structure = (VkPhysicalDeviceAntiLagFeaturesAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::antiLag), structure->antiLag);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderObjectFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT: {  // Covers
                                                                              // VUID-VkPhysicalDeviceShaderObjectFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_object)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_shader_object has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderObjectFeaturesEXT);
                VkPhysicalDeviceShaderObjectFeaturesEXT* structure = (VkPhysicalDeviceShaderObjectFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderObject), structure->shaderObject);
            }
        } break;

        // Validation code for VkPhysicalDeviceTilePropertiesFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceTilePropertiesFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_tile_properties)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM), but its parent extension "
                                     "VK_QCOM_tile_properties has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTilePropertiesFeaturesQCOM);
                VkPhysicalDeviceTilePropertiesFeaturesQCOM* structure = (VkPhysicalDeviceTilePropertiesFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::tileProperties), structure->tileProperties);
            }
        } break;

        // Validation code for VkPhysicalDeviceAmigoProfilingFeaturesSEC structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC: {  // Covers
                                                                                // VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType

            if (!IsExtEnabled(extensions.vk_sec_amigo_profiling)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC), but its parent extension "
                                     "VK_SEC_amigo_profiling has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAmigoProfilingFeaturesSEC);
                VkPhysicalDeviceAmigoProfilingFeaturesSEC* structure = (VkPhysicalDeviceAmigoProfilingFeaturesSEC*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::amigoProfiling), structure->amigoProfiling);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_multiview_per_view_viewports)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM), but its parent extension "
                    "VK_QCOM_multiview_per_view_viewports has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM);
                VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* structure =
                    (VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewPerViewViewports), structure->multiviewPerViewViewports);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_invocation_reorder)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV), but its parent extension "
                    "VK_NV_ray_tracing_invocation_reorder has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV);
                VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* structure =
                    (VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingInvocationReorder), structure->rayTracingInvocationReorder);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeVectorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceCooperativeVectorFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_cooperative_vector)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV), but its parent extension "
                                     "VK_NV_cooperative_vector has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCooperativeVectorFeaturesNV);
                VkPhysicalDeviceCooperativeVectorFeaturesNV* structure = (VkPhysicalDeviceCooperativeVectorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeVector), structure->cooperativeVector);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeVectorTraining), structure->cooperativeVectorTraining);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_extended_sparse_address_space)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV), but its parent extension "
                    "VK_NV_extended_sparse_address_space has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV);
                VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* structure =
                    (VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedSparseAddressSpace), structure->extendedSparseAddressSpace);
            }
        } break;

        // Validation code for VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_legacy_vertex_attributes)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT), but its parent extension "
                    "VK_EXT_legacy_vertex_attributes has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT);
                VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* structure =
                    (VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::legacyVertexAttributes), structure->legacyVertexAttributes);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_shader_core_builtins)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM), but its parent extension "
                                 "VK_ARM_shader_core_builtins has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM);
                VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* structure = (VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderCoreBuiltins), structure->shaderCoreBuiltins);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT: {  // Covers
                                                                                               // VUID-VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_library_group_handles)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT), but its parent extension "
                    "VK_EXT_pipeline_library_group_handles has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT);
                VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* structure =
                    (VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineLibraryGroupHandles), structure->pipelineLibraryGroupHandles);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT: {  // Covers
                                                                                                     // VUID-VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_dynamic_rendering_unused_attachments)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_dynamic_rendering_unused_attachments has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT);
                VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* structure =
                    (VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRenderingUnusedAttachments),
                                       structure->dynamicRenderingUnusedAttachments);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM: {  // Covers
                                                                                                 // VUID-VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_multiview_per_view_render_areas)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM), but its parent extension "
                    "VK_QCOM_multiview_per_view_render_areas has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM);
                VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* structure =
                    (VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewPerViewRenderAreas), structure->multiviewPerViewRenderAreas);
            }
        } break;

        // Validation code for VkPhysicalDevicePerStageDescriptorSetFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV: {  // Covers
                                                                                        // VUID-VkPhysicalDevicePerStageDescriptorSetFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_per_stage_descriptor_set)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV), but its parent extension "
                    "VK_NV_per_stage_descriptor_set has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePerStageDescriptorSetFeaturesNV);
                VkPhysicalDevicePerStageDescriptorSetFeaturesNV* structure =
                    (VkPhysicalDevicePerStageDescriptorSetFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::perStageDescriptorSet), structure->perStageDescriptorSet);

                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicPipelineLayout), structure->dynamicPipelineLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageProcessing2FeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceImageProcessing2FeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_image_processing2)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM), but its parent extension "
                                 "VK_QCOM_image_processing2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageProcessing2FeaturesQCOM);
                VkPhysicalDeviceImageProcessing2FeaturesQCOM* structure = (VkPhysicalDeviceImageProcessing2FeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::textureBlockMatch2), structure->textureBlockMatch2);
            }
        } break;

        // Validation code for VkPhysicalDeviceCubicWeightsFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM: {  // Covers
                                                                               // VUID-VkPhysicalDeviceCubicWeightsFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_filter_cubic_weights)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM), but its parent extension "
                                     "VK_QCOM_filter_cubic_weights has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCubicWeightsFeaturesQCOM);
                VkPhysicalDeviceCubicWeightsFeaturesQCOM* structure = (VkPhysicalDeviceCubicWeightsFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::selectableCubicWeights), structure->selectableCubicWeights);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcrDegammaFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM: {  // Covers
                                                                               // VUID-VkPhysicalDeviceYcbcrDegammaFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_ycbcr_degamma)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM), but its parent extension "
                                     "VK_QCOM_ycbcr_degamma has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceYcbcrDegammaFeaturesQCOM);
                VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* structure = (VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::ycbcrDegamma), structure->ycbcrDegamma);
            }
        } break;

        // Validation code for VkPhysicalDeviceCubicClampFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM: {  // Covers
                                                                             // VUID-VkPhysicalDeviceCubicClampFeaturesQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_filter_cubic_clamp)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM), but its parent extension "
                                     "VK_QCOM_filter_cubic_clamp has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCubicClampFeaturesQCOM);
                VkPhysicalDeviceCubicClampFeaturesQCOM* structure = (VkPhysicalDeviceCubicClampFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cubicRangeClamp), structure->cubicRangeClamp);
            }
        } break;

        // Validation code for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT: {  // Covers
                                                                                                       // VUID-VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_attachment_feedback_loop_dynamic_state)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_attachment_feedback_loop_dynamic_state has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT);
                VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* structure =
                    (VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::attachmentFeedbackLoopDynamicState),
                                       structure->attachmentFeedbackLoopDynamicState);
            }
        } break;
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX-sType-sType

            if (!IsExtEnabled(extensions.vk_qnx_external_memory_screen_buffer)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX), but its parent extension "
                    "VK_QNX_external_memory_screen_buffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX);
                VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX* structure =
                    (VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::screenBufferImport), structure->screenBufferImport);
            }
        } break;
#endif  // VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_descriptor_pool_overallocation)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV), but its parent extension "
                    "VK_NV_descriptor_pool_overallocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV);
                VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* structure =
                    (VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorPoolOverallocation), structure->descriptorPoolOverallocation);
            }
        } break;

        // Validation code for VkPhysicalDeviceRawAccessChainsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceRawAccessChainsFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_raw_access_chains)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV), but its parent extension "
                                     "VK_NV_raw_access_chains has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRawAccessChainsFeaturesNV);
                VkPhysicalDeviceRawAccessChainsFeaturesNV* structure = (VkPhysicalDeviceRawAccessChainsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderRawAccessChains), structure->shaderRawAccessChains);
            }
        } break;

        // Validation code for VkPhysicalDeviceCommandBufferInheritanceFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceCommandBufferInheritanceFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_command_buffer_inheritance)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV), but its parent extension "
                    "VK_NV_command_buffer_inheritance has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCommandBufferInheritanceFeaturesNV);
                VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* structure =
                    (VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::commandBufferInheritance), structure->commandBufferInheritance);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_shader_atomic_float16_vector)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV), but its parent extension "
                    "VK_NV_shader_atomic_float16_vector has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV);
                VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* structure =
                    (VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat16VectorAtomics), structure->shaderFloat16VectorAtomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_replicated_composites)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT), but its parent extension "
                    "VK_EXT_shader_replicated_composites has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT);
                VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* structure =
                    (VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderReplicatedComposites), structure->shaderReplicatedComposites);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingValidationFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceRayTracingValidationFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_validation)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV), but its parent extension "
                                 "VK_NV_ray_tracing_validation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingValidationFeaturesNV);
                VkPhysicalDeviceRayTracingValidationFeaturesNV* structure = (VkPhysicalDeviceRayTracingValidationFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingValidation), structure->rayTracingValidation);
            }
        } break;

        // Validation code for VkPhysicalDeviceClusterAccelerationStructureFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceClusterAccelerationStructureFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_cluster_acceleration_structure)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV), but its parent extension "
                    "VK_NV_cluster_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceClusterAccelerationStructureFeaturesNV);
                VkPhysicalDeviceClusterAccelerationStructureFeaturesNV* structure =
                    (VkPhysicalDeviceClusterAccelerationStructureFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::clusterAccelerationStructure), structure->clusterAccelerationStructure);
            }
        } break;

        // Validation code for VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV: {  // Covers
                                                                                                  // VUID-VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_partitioned_acceleration_structure)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV), but its parent extension "
                    "VK_NV_partitioned_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV);
                VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* structure =
                    (VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::partitionedAccelerationStructure),
                                       structure->partitionedAccelerationStructure);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_generated_commands)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT), but its parent extension "
                    "VK_EXT_device_generated_commands has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT);
                VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* structure =
                    (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedCommands), structure->deviceGeneratedCommands);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::dynamicGeneratedPipelineLayout), structure->dynamicGeneratedPipelineLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageAlignmentControlFeaturesMESA structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceImageAlignmentControlFeaturesMESA-sType-sType

            if (!IsExtEnabled(extensions.vk_mesa_image_alignment_control)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA), but its parent extension "
                    "VK_MESA_image_alignment_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageAlignmentControlFeaturesMESA);
                VkPhysicalDeviceImageAlignmentControlFeaturesMESA* structure =
                    (VkPhysicalDeviceImageAlignmentControlFeaturesMESA*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageAlignmentControl), structure->imageAlignmentControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClampControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceDepthClampControlFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_clamp_control)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT), but its parent extension "
                                 "VK_EXT_depth_clamp_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClampControlFeaturesEXT);
                VkPhysicalDeviceDepthClampControlFeaturesEXT* structure = (VkPhysicalDeviceDepthClampControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClampControl), structure->depthClampControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceHdrVividFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI: {  // Covers
                                                                             // VUID-VkPhysicalDeviceHdrVividFeaturesHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_hdr_vivid)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI), but its parent extension "
                                     "VK_HUAWEI_hdr_vivid has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceHdrVividFeaturesHUAWEI);
                VkPhysicalDeviceHdrVividFeaturesHUAWEI* structure = (VkPhysicalDeviceHdrVividFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::hdrVivid), structure->hdrVivid);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrix2FeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCooperativeMatrix2FeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_cooperative_matrix2)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV), but its parent extension "
                                 "VK_NV_cooperative_matrix2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCooperativeMatrix2FeaturesNV);
                VkPhysicalDeviceCooperativeMatrix2FeaturesNV* structure = (VkPhysicalDeviceCooperativeMatrix2FeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixWorkgroupScope),
                                       structure->cooperativeMatrixWorkgroupScope);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixFlexibleDimensions),
                                       structure->cooperativeMatrixFlexibleDimensions);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixReductions), structure->cooperativeMatrixReductions);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixConversions), structure->cooperativeMatrixConversions);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixPerElementOperations),
                                       structure->cooperativeMatrixPerElementOperations);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixTensorAddressing),
                                       structure->cooperativeMatrixTensorAddressing);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixBlockLoads), structure->cooperativeMatrixBlockLoads);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineOpacityMicromapFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM: {  // Covers
                                                                                          // VUID-VkPhysicalDevicePipelineOpacityMicromapFeaturesARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_pipeline_opacity_micromap)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM), but its parent extension "
                    "VK_ARM_pipeline_opacity_micromap has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineOpacityMicromapFeaturesARM);
                VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* structure =
                    (VkPhysicalDevicePipelineOpacityMicromapFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineOpacityMicromap), structure->pipelineOpacityMicromap);
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_vertex_attribute_robustness)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT), but its parent extension "
                    "VK_EXT_vertex_attribute_robustness has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT);
                VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* structure =
                    (VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeRobustness), structure->vertexAttributeRobustness);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentMeteringFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV: {  // Covers
                                                                                // VUID-VkPhysicalDevicePresentMeteringFeaturesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_present_metering)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV), but its parent extension "
                                     "VK_NV_present_metering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentMeteringFeaturesNV);
                VkPhysicalDevicePresentMeteringFeaturesNV* structure = (VkPhysicalDevicePresentMeteringFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentMetering), structure->presentMetering);
            }
        } break;

        // Validation code for VkPhysicalDeviceAccelerationStructureFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceAccelerationStructureFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_acceleration_structure)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR), but its parent extension "
                    "VK_KHR_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAccelerationStructureFeaturesKHR);
                VkPhysicalDeviceAccelerationStructureFeaturesKHR* structure =
                    (VkPhysicalDeviceAccelerationStructureFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructure), structure->accelerationStructure);

                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructureCaptureReplay),
                                       structure->accelerationStructureCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructureIndirectBuild),
                                       structure->accelerationStructureIndirectBuild);

                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructureHostCommands),
                                       structure->accelerationStructureHostCommands);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingAccelerationStructureUpdateAfterBind),
                                       structure->descriptorBindingAccelerationStructureUpdateAfterBind);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingPipelineFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR), but its parent extension "
                                 "VK_KHR_ray_tracing_pipeline has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
                VkPhysicalDeviceRayTracingPipelineFeaturesKHR* structure = (VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipeline), structure->rayTracingPipeline);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineShaderGroupHandleCaptureReplay),
                                       structure->rayTracingPipelineShaderGroupHandleCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineShaderGroupHandleCaptureReplayMixed),
                                       structure->rayTracingPipelineShaderGroupHandleCaptureReplayMixed);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineTraceRaysIndirect),
                                       structure->rayTracingPipelineTraceRaysIndirect);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTraversalPrimitiveCulling), structure->rayTraversalPrimitiveCulling);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {  // Covers
                                                                          // VUID-VkPhysicalDeviceRayQueryFeaturesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_ray_query)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR), but its parent extension "
                                     "VK_KHR_ray_query has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayQueryFeaturesKHR);
                VkPhysicalDeviceRayQueryFeaturesKHR* structure = (VkPhysicalDeviceRayQueryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayQuery), structure->rayQuery);
            }
        } break;

        // Validation code for VkPhysicalDeviceMeshShaderFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: {  // Covers
                                                                            // VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_mesh_shader)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT), but its parent extension "
                                     "VK_EXT_mesh_shader has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMeshShaderFeaturesEXT);
                VkPhysicalDeviceMeshShaderFeaturesEXT* structure = (VkPhysicalDeviceMeshShaderFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::taskShader), structure->taskShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::meshShader), structure->meshShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewMeshShader), structure->multiviewMeshShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveFragmentShadingRateMeshShader),
                                       structure->primitiveFragmentShadingRateMeshShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::meshShaderQueries), structure->meshShaderQueries);
            }
        } break;

        default:
            skip = false;
    }
    return skip;
}

// All structs that are not a Feature or Property struct
bool Context::ValidatePnextStructContents(const Location& loc, const VkBaseOutStructure* header, const char* pnext_vuid,
                                          bool is_const_param) const {
    bool skip = false;
    switch (header->sType) {
        // Validation code for VkShaderModuleCreateInfo structure members
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {  // Covers VUID-VkShaderModuleCreateInfo-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkShaderModuleCreateInfo);
                VkShaderModuleCreateInfo* structure = (VkShaderModuleCreateInfo*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

                skip |= ValidateArray(pNext_loc.dot(Field::codeSize), pNext_loc.dot(Field::pCode), structure->codeSize / 4,
                                      &structure->pCode, true, true, "VUID-VkShaderModuleCreateInfo-codeSize-01085",
                                      "VUID-VkShaderModuleCreateInfo-pCode-parameter");
            }
        } break;

        // Validation code for VkPipelineLayoutCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {  // Covers VUID-VkPipelineLayoutCreateInfo-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineLayoutCreateInfo);
                VkPipelineLayoutCreateInfo* structure = (VkPipelineLayoutCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineLayoutCreateFlagBits,
                                      AllVkPipelineLayoutCreateFlagBits, structure->flags, kOptionalFlags,
                                      "VUID-VkPipelineLayoutCreateInfo-flags-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::pushConstantRangeCount), pNext_loc.dot(Field::pPushConstantRanges),
                                      structure->pushConstantRangeCount, &structure->pPushConstantRanges, false, true,
                                      kVUIDUndefined, "VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter");

                if (structure->pPushConstantRanges != nullptr) {
                    for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < structure->pushConstantRangeCount;
                         ++pushConstantRangeIndex) {
                        [[maybe_unused]] const Location pPushConstantRanges_loc =
                            pNext_loc.dot(Field::pPushConstantRanges, pushConstantRangeIndex);
                        skip |= ValidateFlags(pPushConstantRanges_loc.dot(Field::stageFlags),
                                              vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                              structure->pPushConstantRanges[pushConstantRangeIndex].stageFlags, kRequiredFlags,
                                              "VUID-VkPushConstantRange-stageFlags-parameter",
                                              "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
                    }
                }
            }
        } break;

        // Validation code for VkMemoryDedicatedRequirements structure members
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {  // Covers VUID-VkMemoryDedicatedRequirements-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dedicated_allocation)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS), "
                                     "but its parent extension "
                                     "VK_KHR_dedicated_allocation has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryDedicatedAllocateInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {  // Covers VUID-VkMemoryDedicatedAllocateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dedicated_allocation)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_dedicated_allocation has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryAllocateFlagsInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {  // Covers VUID-VkMemoryAllocateFlagsInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO), but "
                                     "its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMemoryAllocateFlagsInfo);
                VkMemoryAllocateFlagsInfo* structure = (VkMemoryAllocateFlagsInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryAllocateFlagBits,
                                      AllVkMemoryAllocateFlagBits, structure->flags, kOptionalFlags,
                                      "VUID-VkMemoryAllocateFlagsInfo-flags-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupRenderPassBeginInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {  // Covers VUID-VkDeviceGroupRenderPassBeginInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO), but its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupRenderPassBeginInfo);
                VkDeviceGroupRenderPassBeginInfo* structure = (VkDeviceGroupRenderPassBeginInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::deviceRenderAreaCount), pNext_loc.dot(Field::pDeviceRenderAreas),
                                      structure->deviceRenderAreaCount, &structure->pDeviceRenderAreas, false, true, kVUIDUndefined,
                                      "VUID-VkDeviceGroupRenderPassBeginInfo-pDeviceRenderAreas-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupCommandBufferBeginInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {  // Covers
                                                                          // VUID-VkDeviceGroupCommandBufferBeginInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO), but its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
        } break;

        // Validation code for VkDeviceGroupSubmitInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {  // Covers VUID-VkDeviceGroupSubmitInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO), but "
                                     "its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupSubmitInfo);
                VkDeviceGroupSubmitInfo* structure = (VkDeviceGroupSubmitInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::waitSemaphoreCount), pNext_loc.dot(Field::pWaitSemaphoreDeviceIndices),
                                      structure->waitSemaphoreCount, &structure->pWaitSemaphoreDeviceIndices, false, true,
                                      kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::commandBufferCount), pNext_loc.dot(Field::pCommandBufferDeviceMasks),
                                      structure->commandBufferCount, &structure->pCommandBufferDeviceMasks, false, true,
                                      kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::signalSemaphoreCount), pNext_loc.dot(Field::pSignalSemaphoreDeviceIndices),
                                  structure->signalSemaphoreCount, &structure->pSignalSemaphoreDeviceIndices, false, true,
                                  kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pSignalSemaphoreDeviceIndices-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupBindSparseInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {  // Covers VUID-VkDeviceGroupBindSparseInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
        } break;

        // Validation code for VkBindBufferMemoryDeviceGroupInfo structure members
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {  // Covers VUID-VkBindBufferMemoryDeviceGroupInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO), but its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindBufferMemoryDeviceGroupInfo);
                VkBindBufferMemoryDeviceGroupInfo* structure = (VkBindBufferMemoryDeviceGroupInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::deviceIndexCount), pNext_loc.dot(Field::pDeviceIndices),
                                      structure->deviceIndexCount, &structure->pDeviceIndices, false, true, kVUIDUndefined,
                                      "VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-parameter");
            }
        } break;

        // Validation code for VkBindImageMemoryDeviceGroupInfo structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {  // Covers VUID-VkBindImageMemoryDeviceGroupInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO), but its parent extension "
                                     "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindImageMemoryDeviceGroupInfo);
                VkBindImageMemoryDeviceGroupInfo* structure = (VkBindImageMemoryDeviceGroupInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::deviceIndexCount), pNext_loc.dot(Field::pDeviceIndices),
                                      structure->deviceIndexCount, &structure->pDeviceIndices, false, true, kVUIDUndefined,
                                      "VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::splitInstanceBindRegionCount),
                                      pNext_loc.dot(Field::pSplitInstanceBindRegions), structure->splitInstanceBindRegionCount,
                                      &structure->pSplitInstanceBindRegions, false, true, kVUIDUndefined,
                                      "VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupDeviceCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {  // Covers VUID-VkDeviceGroupDeviceCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_device_group_creation)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_device_group_creation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupDeviceCreateInfo);
                VkDeviceGroupDeviceCreateInfo* structure = (VkDeviceGroupDeviceCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::physicalDeviceCount), pNext_loc.dot(Field::pPhysicalDevices),
                                      structure->physicalDeviceCount, &structure->pPhysicalDevices, false, true, kVUIDUndefined,
                                      "VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceFeatures2 structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {  // Covers VUID-VkPhysicalDeviceFeatures2-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2), but "
                                     "its parent extension "
                                     "VK_KHR_get_physical_device_properties2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFeatures2);
                VkPhysicalDeviceFeatures2* structure = (VkPhysicalDeviceFeatures2*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustBufferAccess), structure->features.robustBufferAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::fullDrawIndexUint32), structure->features.fullDrawIndexUint32);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageCubeArray), structure->features.imageCubeArray);

                skip |= ValidateBool32(pNext_loc.dot(Field::independentBlend), structure->features.independentBlend);

                skip |= ValidateBool32(pNext_loc.dot(Field::geometryShader), structure->features.geometryShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::tessellationShader), structure->features.tessellationShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::sampleRateShading), structure->features.sampleRateShading);

                skip |= ValidateBool32(pNext_loc.dot(Field::dualSrcBlend), structure->features.dualSrcBlend);

                skip |= ValidateBool32(pNext_loc.dot(Field::logicOp), structure->features.logicOp);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiDrawIndirect), structure->features.multiDrawIndirect);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::drawIndirectFirstInstance), structure->features.drawIndirectFirstInstance);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthClamp), structure->features.depthClamp);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasClamp), structure->features.depthBiasClamp);

                skip |= ValidateBool32(pNext_loc.dot(Field::fillModeNonSolid), structure->features.fillModeNonSolid);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBounds), structure->features.depthBounds);

                skip |= ValidateBool32(pNext_loc.dot(Field::wideLines), structure->features.wideLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::largePoints), structure->features.largePoints);

                skip |= ValidateBool32(pNext_loc.dot(Field::alphaToOne), structure->features.alphaToOne);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiViewport), structure->features.multiViewport);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerAnisotropy), structure->features.samplerAnisotropy);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionETC2), structure->features.textureCompressionETC2);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionASTC_LDR),
                                       structure->features.textureCompressionASTC_LDR);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionBC), structure->features.textureCompressionBC);

                skip |= ValidateBool32(pNext_loc.dot(Field::occlusionQueryPrecise), structure->features.occlusionQueryPrecise);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineStatisticsQuery), structure->features.pipelineStatisticsQuery);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexPipelineStoresAndAtomics),
                                       structure->features.vertexPipelineStoresAndAtomics);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::fragmentStoresAndAtomics), structure->features.fragmentStoresAndAtomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTessellationAndGeometryPointSize),
                                       structure->features.shaderTessellationAndGeometryPointSize);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderImageGatherExtended), structure->features.shaderImageGatherExtended);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageExtendedFormats),
                                       structure->features.shaderStorageImageExtendedFormats);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageMultisample),
                                       structure->features.shaderStorageImageMultisample);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageReadWithoutFormat),
                                       structure->features.shaderStorageImageReadWithoutFormat);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageWriteWithoutFormat),
                                       structure->features.shaderStorageImageWriteWithoutFormat);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformBufferArrayDynamicIndexing),
                                       structure->features.shaderUniformBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampledImageArrayDynamicIndexing),
                                       structure->features.shaderSampledImageArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageBufferArrayDynamicIndexing),
                                       structure->features.shaderStorageBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageArrayDynamicIndexing),
                                       structure->features.shaderStorageImageArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderClipDistance), structure->features.shaderClipDistance);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderCullDistance), structure->features.shaderCullDistance);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat64), structure->features.shaderFloat64);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt64), structure->features.shaderInt64);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt16), structure->features.shaderInt16);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderResourceResidency), structure->features.shaderResourceResidency);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderResourceMinLod), structure->features.shaderResourceMinLod);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseBinding), structure->features.sparseBinding);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyBuffer), structure->features.sparseResidencyBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyImage2D), structure->features.sparseResidencyImage2D);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyImage3D), structure->features.sparseResidencyImage3D);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidency2Samples), structure->features.sparseResidency2Samples);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidency4Samples), structure->features.sparseResidency4Samples);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidency8Samples), structure->features.sparseResidency8Samples);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::sparseResidency16Samples), structure->features.sparseResidency16Samples);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyAliased), structure->features.sparseResidencyAliased);

                skip |= ValidateBool32(pNext_loc.dot(Field::variableMultisampleRate), structure->features.variableMultisampleRate);

                skip |= ValidateBool32(pNext_loc.dot(Field::inheritedQueries), structure->features.inheritedQueries);
            }
        } break;

        // Validation code for VkRenderPassInputAttachmentAspectCreateInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {  // Covers
                                                                                   // VUID-VkRenderPassInputAttachmentAspectCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance2)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO), but its parent extension "
                                 "VK_KHR_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassInputAttachmentAspectCreateInfo);
                VkRenderPassInputAttachmentAspectCreateInfo* structure = (VkRenderPassInputAttachmentAspectCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::aspectReferenceCount), pNext_loc.dot(Field::pAspectReferences),
                                      structure->aspectReferenceCount, &structure->pAspectReferences, true, true,
                                      "VUID-VkRenderPassInputAttachmentAspectCreateInfo-aspectReferenceCount-arraylength",
                                      "VUID-VkRenderPassInputAttachmentAspectCreateInfo-pAspectReferences-parameter");

                if (structure->pAspectReferences != nullptr) {
                    for (uint32_t aspectReferenceIndex = 0; aspectReferenceIndex < structure->aspectReferenceCount;
                         ++aspectReferenceIndex) {
                        [[maybe_unused]] const Location pAspectReferences_loc =
                            pNext_loc.dot(Field::pAspectReferences, aspectReferenceIndex);
                        skip |=
                            ValidateFlags(pAspectReferences_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, structure->pAspectReferences[aspectReferenceIndex].aspectMask,
                                          kRequiredFlags, "VUID-VkInputAttachmentAspectReference-aspectMask-parameter",
                                          "VUID-VkInputAttachmentAspectReference-aspectMask-requiredbitmask");
                    }
                }
            }
        } break;

        // Validation code for VkImageViewUsageCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {  // Covers VUID-VkImageViewUsageCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageViewUsageCreateInfo);
                VkImageViewUsageCreateInfo* structure = (VkImageViewUsageCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits,
                                      structure->usage, kRequiredFlags, "VUID-VkImageViewUsageCreateInfo-usage-parameter",
                                      "VUID-VkImageViewUsageCreateInfo-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkPipelineTessellationDomainOriginStateCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {  // Covers
                                                                                         // VUID-VkPipelineTessellationDomainOriginStateCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO), but its parent extension "
                    "VK_KHR_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineTessellationDomainOriginStateCreateInfo);
                VkPipelineTessellationDomainOriginStateCreateInfo* structure =
                    (VkPipelineTessellationDomainOriginStateCreateInfo*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::domainOrigin), vvl::Enum::VkTessellationDomainOrigin,
                                           structure->domainOrigin,
                                           "VUID-VkPipelineTessellationDomainOriginStateCreateInfo-domainOrigin-parameter");
            }
        } break;

        // Validation code for VkRenderPassMultiviewCreateInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {  // Covers VUID-VkRenderPassMultiviewCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_multiview)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO), but its parent extension "
                                     "VK_KHR_multiview has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassMultiviewCreateInfo);
                VkRenderPassMultiviewCreateInfo* structure = (VkRenderPassMultiviewCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::subpassCount), pNext_loc.dot(Field::pViewMasks), structure->subpassCount,
                                      &structure->pViewMasks, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::dependencyCount), pNext_loc.dot(Field::pViewOffsets),
                                      structure->dependencyCount, &structure->pViewOffsets, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassMultiviewCreateInfo-pViewOffsets-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::correlationMaskCount), pNext_loc.dot(Field::pCorrelationMasks),
                                      structure->correlationMaskCount, &structure->pCorrelationMasks, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-parameter");
            }
        } break;

        // Validation code for VkProtectedSubmitInfo structure members
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {  // Covers VUID-VkProtectedSubmitInfo-sType-sType

            if (extensions.api_version < VK_API_VERSION_1_1) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO) which was "
                                     "added in VK_API_VERSION_1_1 but the "
                                     "current effective API version is %s.",
                                     StringAPIVersion(extensions.api_version).c_str());
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkProtectedSubmitInfo);
                VkProtectedSubmitInfo* structure = (VkProtectedSubmitInfo*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::protectedSubmit), structure->protectedSubmit);
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionInfo structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {  // Covers VUID-VkSamplerYcbcrConversionInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerYcbcrConversionInfo);
                VkSamplerYcbcrConversionInfo* structure = (VkSamplerYcbcrConversionInfo*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::conversion), structure->conversion);
            }
        } break;

        // Validation code for VkBindImagePlaneMemoryInfo structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {  // Covers VUID-VkBindImagePlaneMemoryInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindImagePlaneMemoryInfo);
                VkBindImagePlaneMemoryInfo* structure = (VkBindImagePlaneMemoryInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, structure->planeAspect, kRequiredSingleBit,
                                      "VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter",
                                      "VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter");
            }
        } break;

        // Validation code for VkImagePlaneMemoryRequirementsInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {  // Covers
                                                                        // VUID-VkImagePlaneMemoryRequirementsInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO), but its parent extension "
                                     "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImagePlaneMemoryRequirementsInfo);
                VkImagePlaneMemoryRequirementsInfo* structure = (VkImagePlaneMemoryRequirementsInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, structure->planeAspect, kRequiredSingleBit,
                                      "VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter",
                                      "VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter");
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionImageFormatProperties structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {  // Covers
                                                                                    // VUID-VkSamplerYcbcrConversionImageFormatProperties-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES), but its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceExternalImageFormatInfo structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {  // Covers
                                                                              // VUID-VkPhysicalDeviceExternalImageFormatInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory_capabilities)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO), but its parent extension "
                                     "VK_KHR_external_memory_capabilities has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExternalImageFormatInfo);
                VkPhysicalDeviceExternalImageFormatInfo* structure = (VkPhysicalDeviceExternalImageFormatInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      "VUID-VkPhysicalDeviceExternalImageFormatInfo-handleType-parameter");
            }
        } break;

        // Validation code for VkExternalImageFormatProperties structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {  // Covers VUID-VkExternalImageFormatProperties-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory_capabilities)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES), but its parent extension "
                                     "VK_KHR_external_memory_capabilities has not been enabled.");
            }
        } break;

        // Validation code for VkExternalMemoryImageCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {  // Covers VUID-VkExternalMemoryImageCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO), but its parent extension "
                                     "VK_KHR_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryImageCreateInfo);
                VkExternalMemoryImageCreateInfo* structure = (VkExternalMemoryImageCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExternalMemoryImageCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExternalMemoryBufferCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {  // Covers VUID-VkExternalMemoryBufferCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO), but its parent extension "
                                     "VK_KHR_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryBufferCreateInfo);
                VkExternalMemoryBufferCreateInfo* structure = (VkExternalMemoryBufferCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExternalMemoryBufferCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportMemoryAllocateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {  // Covers VUID-VkExportMemoryAllocateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO), but "
                                     "its parent extension "
                                     "VK_KHR_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMemoryAllocateInfo);
                VkExportMemoryAllocateInfo* structure = (VkExportMemoryAllocateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExportMemoryAllocateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportFenceCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {  // Covers VUID-VkExportFenceCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_fence)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO), but "
                                     "its parent extension "
                                     "VK_KHR_external_fence has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportFenceCreateInfo);
                VkExportFenceCreateInfo* structure = (VkExportFenceCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                                      AllVkExternalFenceHandleTypeFlagBits, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExportFenceCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportSemaphoreCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {  // Covers VUID-VkExportSemaphoreCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_semaphore)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_external_semaphore has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportSemaphoreCreateInfo);
                VkExportSemaphoreCreateInfo* structure = (VkExportSemaphoreCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                                      AllVkExternalSemaphoreHandleTypeFlagBits, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExportSemaphoreCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkImageFormatListCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {  // Covers VUID-VkImageFormatListCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_image_format_list)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_image_format_list has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageFormatListCreateInfo);
                VkImageFormatListCreateInfo* structure = (VkImageFormatListCreateInfo*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::viewFormatCount), pNext_loc.dot(Field::pViewFormats),
                                                vvl::Enum::VkFormat, structure->viewFormatCount, structure->pViewFormats, false,
                                                true, kVUIDUndefined, "VUID-VkImageFormatListCreateInfo-pViewFormats-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetLayoutBindingFlagsCreateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {  // Covers
                                                                                   // VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_indexing)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO), but its parent extension "
                                 "VK_EXT_descriptor_indexing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDescriptorSetLayoutBindingFlagsCreateInfo);
                VkDescriptorSetLayoutBindingFlagsCreateInfo* structure = (VkDescriptorSetLayoutBindingFlagsCreateInfo*)header;
                skip |= ValidateFlagsArray(pNext_loc.dot(Field::bindingCount), pNext_loc.dot(Field::pBindingFlags),
                                           vvl::FlagBitmask::VkDescriptorBindingFlagBits, AllVkDescriptorBindingFlagBits,
                                           structure->bindingCount, structure->pBindingFlags, false, kVUIDUndefined,
                                           "VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetVariableDescriptorCountAllocateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {  // Covers
                                                                                          // VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_indexing)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO), but its parent extension "
                    "VK_EXT_descriptor_indexing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDescriptorSetVariableDescriptorCountAllocateInfo);
                VkDescriptorSetVariableDescriptorCountAllocateInfo* structure =
                    (VkDescriptorSetVariableDescriptorCountAllocateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::descriptorSetCount), pNext_loc.dot(Field::pDescriptorCounts),
                                      structure->descriptorSetCount, &structure->pDescriptorCounts, false, true, kVUIDUndefined,
                                      "VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetVariableDescriptorCountLayoutSupport structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {  // Covers
                                                                                           // VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_indexing)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT), but its parent extension "
                    "VK_EXT_descriptor_indexing has not been enabled.");
            }
        } break;

        // Validation code for VkSubpassDescriptionDepthStencilResolve structure members
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {  // Covers
                                                                             // VUID-VkSubpassDescriptionDepthStencilResolve-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_depth_stencil_resolve)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE), but its parent extension "
                                     "VK_KHR_depth_stencil_resolve has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSubpassDescriptionDepthStencilResolve);
                VkSubpassDescriptionDepthStencilResolve* structure = (VkSubpassDescriptionDepthStencilResolve*)header;
                skip |=
                    ValidateStructType(pNext_loc.dot(Field::pDepthStencilResolveAttachment),
                                       structure->pDepthStencilResolveAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                                       "VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-parameter",
                                       "VUID-VkAttachmentReference2-sType-sType");

                if (structure->pDepthStencilResolveAttachment != nullptr) {
                    [[maybe_unused]] const Location pDepthStencilResolveAttachment_loc =
                        pNext_loc.dot(Field::pDepthStencilResolveAttachment);
                    constexpr std::array allowed_structs_VkAttachmentReference2 = {
                        VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                    skip |= ValidateStructPnext(
                        pDepthStencilResolveAttachment_loc, structure->pDepthStencilResolveAttachment->pNext,
                        allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                        "VUID-VkAttachmentReference2-sType-unique", true);

                    skip |= ValidateRangedEnum(pDepthStencilResolveAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               structure->pDepthStencilResolveAttachment->layout,
                                               "VUID-VkAttachmentReference2-layout-parameter");
                }
            }
        } break;

        // Validation code for VkImageStencilUsageCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {  // Covers VUID-VkImageStencilUsageCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_separate_stencil_usage)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_EXT_separate_stencil_usage has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageStencilUsageCreateInfo);
                VkImageStencilUsageCreateInfo* structure = (VkImageStencilUsageCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::stencilUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, structure->stencilUsage, kRequiredFlags,
                                      "VUID-VkImageStencilUsageCreateInfo-stencilUsage-parameter",
                                      "VUID-VkImageStencilUsageCreateInfo-stencilUsage-requiredbitmask");
            }
        } break;

        // Validation code for VkSamplerReductionModeCreateInfo structure members
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {  // Covers VUID-VkSamplerReductionModeCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_sampler_filter_minmax)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO), but its parent extension "
                                     "VK_EXT_sampler_filter_minmax has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerReductionModeCreateInfo);
                VkSamplerReductionModeCreateInfo* structure = (VkSamplerReductionModeCreateInfo*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::reductionMode), vvl::Enum::VkSamplerReductionMode,
                                       structure->reductionMode, "VUID-VkSamplerReductionModeCreateInfo-reductionMode-parameter");
            }
        } break;

        // Validation code for VkFramebufferAttachmentsCreateInfo structure members
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {  // Covers VUID-VkFramebufferAttachmentsCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_imageless_framebuffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO), but its parent extension "
                                     "VK_KHR_imageless_framebuffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkFramebufferAttachmentsCreateInfo);
                VkFramebufferAttachmentsCreateInfo* structure = (VkFramebufferAttachmentsCreateInfo*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::attachmentImageInfoCount), pNext_loc.dot(Field::pAttachmentImageInfos),
                    structure->attachmentImageInfoCount, structure->pAttachmentImageInfos,
                    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO, false, true,
                    "VUID-VkFramebufferAttachmentImageInfo-sType-sType",
                    "VUID-VkFramebufferAttachmentsCreateInfo-pAttachmentImageInfos-parameter", kVUIDUndefined);

                if (structure->pAttachmentImageInfos != nullptr) {
                    for (uint32_t attachmentImageInfoIndex = 0; attachmentImageInfoIndex < structure->attachmentImageInfoCount;
                         ++attachmentImageInfoIndex) {
                        [[maybe_unused]] const Location pAttachmentImageInfos_loc =
                            pNext_loc.dot(Field::pAttachmentImageInfos, attachmentImageInfoIndex);
                        skip |= ValidateStructPnext(pAttachmentImageInfos_loc,
                                                    structure->pAttachmentImageInfos[attachmentImageInfoIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion,
                                                    "VUID-VkFramebufferAttachmentImageInfo-pNext-pNext", kVUIDUndefined, true);

                        skip |= ValidateFlags(pAttachmentImageInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                              AllVkImageCreateFlagBits,
                                              structure->pAttachmentImageInfos[attachmentImageInfoIndex].flags, kOptionalFlags,
                                              "VUID-VkFramebufferAttachmentImageInfo-flags-parameter");

                        skip |=
                            ValidateFlags(pAttachmentImageInfos_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                          AllVkImageUsageFlagBits, structure->pAttachmentImageInfos[attachmentImageInfoIndex].usage,
                                          kRequiredFlags, "VUID-VkFramebufferAttachmentImageInfo-usage-parameter",
                                          "VUID-VkFramebufferAttachmentImageInfo-usage-requiredbitmask");

                        skip |= ValidateRangedEnumArray(pAttachmentImageInfos_loc.dot(Field::viewFormatCount),
                                                        pAttachmentImageInfos_loc.dot(Field::pViewFormats), vvl::Enum::VkFormat,
                                                        structure->pAttachmentImageInfos[attachmentImageInfoIndex].viewFormatCount,
                                                        structure->pAttachmentImageInfos[attachmentImageInfoIndex].pViewFormats,
                                                        false, true, kVUIDUndefined,
                                                        "VUID-VkFramebufferAttachmentImageInfo-pViewFormats-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassAttachmentBeginInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {  // Covers VUID-VkRenderPassAttachmentBeginInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_imageless_framebuffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO), but its parent extension "
                                     "VK_KHR_imageless_framebuffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassAttachmentBeginInfo);
                VkRenderPassAttachmentBeginInfo* structure = (VkRenderPassAttachmentBeginInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::attachmentCount), pNext_loc.dot(Field::pAttachments),
                                      structure->attachmentCount, &structure->pAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassAttachmentBeginInfo-pAttachments-parameter");
            }
        } break;

        // Validation code for VkAttachmentReferenceStencilLayout structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {  // Covers VUID-VkAttachmentReferenceStencilLayout-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_separate_depth_stencil_layouts)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT), but its parent extension "
                                     "VK_KHR_separate_depth_stencil_layouts has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAttachmentReferenceStencilLayout);
                VkAttachmentReferenceStencilLayout* structure = (VkAttachmentReferenceStencilLayout*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::stencilLayout), vvl::Enum::VkImageLayout, structure->stencilLayout,
                                           "VUID-VkAttachmentReferenceStencilLayout-stencilLayout-parameter");
            }
        } break;

        // Validation code for VkAttachmentDescriptionStencilLayout structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {  // Covers
                                                                         // VUID-VkAttachmentDescriptionStencilLayout-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_separate_depth_stencil_layouts)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT), but its parent extension "
                                     "VK_KHR_separate_depth_stencil_layouts has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAttachmentDescriptionStencilLayout);
                VkAttachmentDescriptionStencilLayout* structure = (VkAttachmentDescriptionStencilLayout*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::stencilInitialLayout), vvl::Enum::VkImageLayout,
                                           structure->stencilInitialLayout,
                                           "VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::stencilFinalLayout), vvl::Enum::VkImageLayout,
                                           structure->stencilFinalLayout,
                                           "VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-parameter");
            }
        } break;

        // Validation code for VkSemaphoreTypeCreateInfo structure members
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {  // Covers VUID-VkSemaphoreTypeCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_timeline_semaphore)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO), but "
                                     "its parent extension "
                                     "VK_KHR_timeline_semaphore has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSemaphoreTypeCreateInfo);
                VkSemaphoreTypeCreateInfo* structure = (VkSemaphoreTypeCreateInfo*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::semaphoreType), vvl::Enum::VkSemaphoreType,
                                           structure->semaphoreType, "VUID-VkSemaphoreTypeCreateInfo-semaphoreType-parameter");
            }
        } break;

        // Validation code for VkTimelineSemaphoreSubmitInfo structure members
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {  // Covers VUID-VkTimelineSemaphoreSubmitInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_timeline_semaphore)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_timeline_semaphore has not been enabled.");
            }
        } break;

        // Validation code for VkBufferOpaqueCaptureAddressCreateInfo structure members
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {  // Covers
                                                                             // VUID-VkBufferOpaqueCaptureAddressCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_buffer_device_address)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO), but its parent extension "
                                     "VK_KHR_buffer_device_address has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryOpaqueCaptureAddressAllocateInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {  // Covers
                                                                               // VUID-VkMemoryOpaqueCaptureAddressAllocateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_buffer_device_address)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO), but its parent extension "
                                     "VK_KHR_buffer_device_address has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineCreationFeedbackCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {  // Covers
                                                                          // VUID-VkPipelineCreationFeedbackCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_creation_feedback)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO), but its parent extension "
                                     "VK_EXT_pipeline_creation_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCreationFeedbackCreateInfo);
                VkPipelineCreationFeedbackCreateInfo* structure = (VkPipelineCreationFeedbackCreateInfo*)header;
                skip |=
                    ValidateRequiredPointer(pNext_loc.dot(Field::pPipelineCreationFeedback), structure->pPipelineCreationFeedback,
                                            "VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineCreationFeedback-parameter");

                skip |= ValidateArray(
                    pNext_loc.dot(Field::pipelineStageCreationFeedbackCount), pNext_loc.dot(Field::pPipelineStageCreationFeedbacks),
                    structure->pipelineStageCreationFeedbackCount, &structure->pPipelineStageCreationFeedbacks, false, true,
                    kVUIDUndefined, "VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineStageCreationFeedbacks-parameter");

                if (structure->pPipelineStageCreationFeedbacks != nullptr) {
                    for (uint32_t pipelineStageCreationFeedbackIndex = 0;
                         pipelineStageCreationFeedbackIndex < structure->pipelineStageCreationFeedbackCount;
                         ++pipelineStageCreationFeedbackIndex) {
                        [[maybe_unused]] const Location pPipelineStageCreationFeedbacks_loc =
                            pNext_loc.dot(Field::pPipelineStageCreationFeedbacks, pipelineStageCreationFeedbackIndex);
                    }
                }
            }
        } break;

        // Validation code for VkDevicePrivateDataCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: {  // Covers VUID-VkDevicePrivateDataCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_private_data)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_EXT_private_data has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryBarrier2 structure members
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {  // Covers VUID-VkMemoryBarrier2-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_synchronization2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_BARRIER_2), but its parent extension "
                    "VK_KHR_synchronization2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMemoryBarrier2);
                VkMemoryBarrier2* structure = (VkMemoryBarrier2*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2, structure->srcStageMask, kOptionalFlags,
                                      "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                  structure->srcAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2, structure->dstStageMask, kOptionalFlags,
                                      "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                  structure->dstAccessMask, kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        } break;

        // Validation code for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {  // Covers
                                                                                            // VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_shader_object)) && (!IsExtEnabled(extensions.vk_ext_subgroup_size_control))) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO), but its parent extension "
                    "VK_EXT_shader_object, or VK_EXT_subgroup_size_control has not been enabled.");
            }
        } break;

        // Validation code for VkWriteDescriptorSetInlineUniformBlock structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: {  // Covers
                                                                             // VUID-VkWriteDescriptorSetInlineUniformBlock-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_inline_uniform_block)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK), but its parent extension "
                                     "VK_EXT_inline_uniform_block has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWriteDescriptorSetInlineUniformBlock);
                VkWriteDescriptorSetInlineUniformBlock* structure = (VkWriteDescriptorSetInlineUniformBlock*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::dataSize), pNext_loc.dot(Field::pData), structure->dataSize,
                                  &structure->pData, true, true, "VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-arraylength",
                                  "VUID-VkWriteDescriptorSetInlineUniformBlock-pData-parameter");
            }
        } break;

        // Validation code for VkDescriptorPoolInlineUniformBlockCreateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: {  // Covers
                                                                                    // VUID-VkDescriptorPoolInlineUniformBlockCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_inline_uniform_block)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO), but its parent extension "
                                 "VK_EXT_inline_uniform_block has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineRenderingCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {  // Covers VUID-VkPipelineRenderingCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_KHR_dynamic_rendering has not been enabled.");
            }
        } break;

        // Validation code for VkCommandBufferInheritanceRenderingInfo structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {  // Covers
                                                                             // VUID-VkCommandBufferInheritanceRenderingInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO), but its parent extension "
                                     "VK_KHR_dynamic_rendering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkCommandBufferInheritanceRenderingInfo);
                VkCommandBufferInheritanceRenderingInfo* structure = (VkCommandBufferInheritanceRenderingInfo*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderingFlagBits, AllVkRenderingFlagBits,
                                  structure->flags, kOptionalFlags, "VUID-VkCommandBufferInheritanceRenderingInfo-flags-parameter");

                skip |= ValidateRangedEnumArray(
                    pNext_loc.dot(Field::colorAttachmentCount), pNext_loc.dot(Field::pColorAttachmentFormats), vvl::Enum::VkFormat,
                    structure->colorAttachmentCount, structure->pColorAttachmentFormats, false, true, kVUIDUndefined,
                    "VUID-VkCommandBufferInheritanceRenderingInfo-pColorAttachmentFormats-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::depthAttachmentFormat), vvl::Enum::VkFormat,
                                           structure->depthAttachmentFormat,
                                           "VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::stencilAttachmentFormat), vvl::Enum::VkFormat,
                                           structure->stencilAttachmentFormat,
                                           "VUID-VkCommandBufferInheritanceRenderingInfo-stencilAttachmentFormat-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, structure->rasterizationSamples, kOptionalSingleBit,
                                      "VUID-VkCommandBufferInheritanceRenderingInfo-rasterizationSamples-parameter");
            }
        } break;

        // Validation code for VkFormatProperties3 structure members
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: {  // Covers VUID-VkFormatProperties3-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_format_feature_flags2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3), but its parent extension "
                    "VK_KHR_format_feature_flags2 has not been enabled.");
            }
        } break;

        // Validation code for VkDeviceQueueGlobalPriorityCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO: {  // Covers
                                                                            // VUID-VkDeviceQueueGlobalPriorityCreateInfo-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_global_priority)) && (!IsExtEnabled(extensions.vk_khr_global_priority))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO), but its parent extension "
                                     "VK_EXT_global_priority, or VK_KHR_global_priority has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceQueueGlobalPriorityCreateInfo);
                VkDeviceQueueGlobalPriorityCreateInfo* structure = (VkDeviceQueueGlobalPriorityCreateInfo*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::globalPriority), vvl::Enum::VkQueueGlobalPriority,
                                           structure->globalPriority,
                                           "VUID-VkDeviceQueueGlobalPriorityCreateInfo-globalPriority-parameter");
            }
        } break;

        // Validation code for VkQueueFamilyGlobalPriorityProperties structure members
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES: {  // Covers
                                                                           // VUID-VkQueueFamilyGlobalPriorityProperties-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_global_priority_query)) && (!IsExtEnabled(extensions.vk_khr_global_priority))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES), but its parent extension "
                                     "VK_EXT_global_priority_query, or VK_KHR_global_priority has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineRasterizationLineStateCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO: {  // Covers
                                                                                 // VUID-VkPipelineRasterizationLineStateCreateInfo-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_line_rasterization)) && (!IsExtEnabled(extensions.vk_khr_line_rasterization))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO), but its parent extension "
                                     "VK_EXT_line_rasterization, or VK_KHR_line_rasterization has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationLineStateCreateInfo);
                VkPipelineRasterizationLineStateCreateInfo* structure = (VkPipelineRasterizationLineStateCreateInfo*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::lineRasterizationMode), vvl::Enum::VkLineRasterizationMode,
                                           structure->lineRasterizationMode,
                                           "VUID-VkPipelineRasterizationLineStateCreateInfo-lineRasterizationMode-parameter");

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledLineEnable), structure->stippledLineEnable);
            }
        } break;

        // Validation code for VkPipelineVertexInputDivisorStateCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO: {  // Covers
                                                                                   // VUID-VkPipelineVertexInputDivisorStateCreateInfo-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_vertex_attribute_divisor)) &&
                (!IsExtEnabled(extensions.vk_khr_vertex_attribute_divisor))) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO), but its parent extension "
                                 "VK_EXT_vertex_attribute_divisor, or VK_KHR_vertex_attribute_divisor has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineVertexInputDivisorStateCreateInfo);
                VkPipelineVertexInputDivisorStateCreateInfo* structure = (VkPipelineVertexInputDivisorStateCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::vertexBindingDivisorCount), pNext_loc.dot(Field::pVertexBindingDivisors),
                                      structure->vertexBindingDivisorCount, &structure->pVertexBindingDivisors, true, true,
                                      "VUID-VkPipelineVertexInputDivisorStateCreateInfo-vertexBindingDivisorCount-arraylength",
                                      "VUID-VkPipelineVertexInputDivisorStateCreateInfo-pVertexBindingDivisors-parameter");

                if (structure->pVertexBindingDivisors != nullptr) {
                    for (uint32_t vertexBindingDivisorIndex = 0; vertexBindingDivisorIndex < structure->vertexBindingDivisorCount;
                         ++vertexBindingDivisorIndex) {
                        [[maybe_unused]] const Location pVertexBindingDivisors_loc =
                            pNext_loc.dot(Field::pVertexBindingDivisors, vertexBindingDivisorIndex);
                    }
                }
            }
        } break;

        // Validation code for VkPipelineCreateFlags2CreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO: {  // Covers VUID-VkPipelineCreateFlags2CreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance5)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO), but its parent extension "
                                     "VK_KHR_maintenance5 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCreateFlags2CreateInfo);
                VkPipelineCreateFlags2CreateInfo* structure = (VkPipelineCreateFlags2CreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineCreateFlagBits2,
                                      AllVkPipelineCreateFlagBits2, structure->flags, kRequiredFlags,
                                      "VUID-VkPipelineCreateFlags2CreateInfo-flags-parameter",
                                      "VUID-VkPipelineCreateFlags2CreateInfo-flags-requiredbitmask");
            }
        } break;

        // Validation code for VkBufferUsageFlags2CreateInfo structure members
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: {  // Covers VUID-VkBufferUsageFlags2CreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance5)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO), but its parent extension "
                                     "VK_KHR_maintenance5 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBufferUsageFlags2CreateInfo);
                VkBufferUsageFlags2CreateInfo* structure = (VkBufferUsageFlags2CreateInfo*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::usage), vvl::FlagBitmask::VkBufferUsageFlagBits2, AllVkBufferUsageFlagBits2,
                                  structure->usage, kRequiredFlags, "VUID-VkBufferUsageFlags2CreateInfo-usage-parameter",
                                  "VUID-VkBufferUsageFlags2CreateInfo-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkRenderingAttachmentLocationInfo structure members
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO: {  // Covers VUID-VkRenderingAttachmentLocationInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering_local_read)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO), but its parent extension "
                                     "VK_KHR_dynamic_rendering_local_read has not been enabled.");
            }
        } break;

        // Validation code for VkRenderingInputAttachmentIndexInfo structure members
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO: {  // Covers
                                                                         // VUID-VkRenderingInputAttachmentIndexInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering_local_read)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO), but its parent extension "
                                     "VK_KHR_dynamic_rendering_local_read has not been enabled.");
            }
        } break;

        // Validation code for VkBindMemoryStatus structure members
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS: {  // Covers VUID-VkBindMemoryStatus-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance6)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS), but its parent extension "
                    "VK_KHR_maintenance6 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindMemoryStatus);
                VkBindMemoryStatus* structure = (VkBindMemoryStatus*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pResult), structure->pResult,
                                                "VUID-VkBindMemoryStatus-pResult-parameter");
            }
        } break;

        // Validation code for VkPipelineRobustnessCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO: {  // Covers VUID-VkPipelineRobustnessCreateInfo-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_pipeline_robustness)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO), "
                                     "but its parent extension "
                                     "VK_EXT_pipeline_robustness has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRobustnessCreateInfo);
                VkPipelineRobustnessCreateInfo* structure = (VkPipelineRobustnessCreateInfo*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::storageBuffers), vvl::Enum::VkPipelineRobustnessBufferBehavior,
                                       structure->storageBuffers, "VUID-VkPipelineRobustnessCreateInfo-storageBuffers-parameter");

                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::uniformBuffers), vvl::Enum::VkPipelineRobustnessBufferBehavior,
                                       structure->uniformBuffers, "VUID-VkPipelineRobustnessCreateInfo-uniformBuffers-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::vertexInputs), vvl::Enum::VkPipelineRobustnessBufferBehavior,
                                           structure->vertexInputs, "VUID-VkPipelineRobustnessCreateInfo-vertexInputs-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::images), vvl::Enum::VkPipelineRobustnessImageBehavior,
                                           structure->images, "VUID-VkPipelineRobustnessCreateInfo-images-parameter");
            }
        } break;

        // Validation code for VkSubresourceHostMemcpySize structure members
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE: {  // Covers VUID-VkSubresourceHostMemcpySize-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_host_image_copy)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE), "
                                     "but its parent extension "
                                     "VK_EXT_host_image_copy has not been enabled.");
            }
        } break;

        // Validation code for VkHostImageCopyDevicePerformanceQuery structure members
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY: {  // Covers
                                                                            // VUID-VkHostImageCopyDevicePerformanceQuery-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_host_image_copy)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY), but its parent extension "
                                     "VK_EXT_host_image_copy has not been enabled.");
            }
        } break;

        // Validation code for VkImageSwapchainCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: {  // Covers VUID-VkImageSwapchainCreateInfoKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_khr_device_group)) && (!IsExtEnabled(extensions.vk_khr_swapchain))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR), "
                                     "but its parent extension "
                                     "VK_KHR_device_group, or VK_KHR_swapchain has not been enabled.");
            }
        } break;

        // Validation code for VkBindImageMemorySwapchainInfoKHR structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {  // Covers VUID-VkBindImageMemorySwapchainInfoKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_khr_device_group)) && (!IsExtEnabled(extensions.vk_khr_swapchain))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR), but its parent extension "
                                     "VK_KHR_device_group, or VK_KHR_swapchain has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindImageMemorySwapchainInfoKHR);
                VkBindImageMemorySwapchainInfoKHR* structure = (VkBindImageMemorySwapchainInfoKHR*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::swapchain), structure->swapchain);
            }
        } break;

        // Validation code for VkDeviceGroupPresentInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {  // Covers VUID-VkDeviceGroupPresentInfoKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_khr_device_group)) && (!IsExtEnabled(extensions.vk_khr_swapchain))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR), "
                                     "but its parent extension "
                                     "VK_KHR_device_group, or VK_KHR_swapchain has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupPresentInfoKHR);
                VkDeviceGroupPresentInfoKHR* structure = (VkDeviceGroupPresentInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pDeviceMasks),
                                      structure->swapchainCount, &structure->pDeviceMasks, false, true, kVUIDUndefined,
                                      "VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::mode), vvl::FlagBitmask::VkDeviceGroupPresentModeFlagBitsKHR,
                                      AllVkDeviceGroupPresentModeFlagBitsKHR, structure->mode, kRequiredSingleBit,
                                      "VUID-VkDeviceGroupPresentInfoKHR-mode-parameter",
                                      "VUID-VkDeviceGroupPresentInfoKHR-mode-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupSwapchainCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {  // Covers
                                                                          // VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType

            if ((!IsExtEnabled(extensions.vk_khr_device_group)) && (!IsExtEnabled(extensions.vk_khr_swapchain))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR), but its parent extension "
                                     "VK_KHR_device_group, or VK_KHR_swapchain has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupSwapchainCreateInfoKHR);
                VkDeviceGroupSwapchainCreateInfoKHR* structure = (VkDeviceGroupSwapchainCreateInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::modes), vvl::FlagBitmask::VkDeviceGroupPresentModeFlagBitsKHR,
                                      AllVkDeviceGroupPresentModeFlagBitsKHR, structure->modes, kRequiredFlags,
                                      "VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter",
                                      "VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask");
            }
        } break;

        // Validation code for VkDisplayPresentInfoKHR structure members
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {  // Covers VUID-VkDisplayPresentInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_display_swapchain)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_display_swapchain has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDisplayPresentInfoKHR);
                VkDisplayPresentInfoKHR* structure = (VkDisplayPresentInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::persistent), structure->persistent);
            }
        } break;

        // Validation code for VkQueueFamilyQueryResultStatusPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR: {  // Covers
                                                                                   // VUID-VkQueueFamilyQueryResultStatusPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_queue)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR), but its parent extension "
                                 "VK_KHR_video_queue has not been enabled.");
            }
        } break;

        // Validation code for VkQueueFamilyVideoPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR: {  // Covers VUID-VkQueueFamilyVideoPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR), but its parent extension "
                                     "VK_KHR_video_queue has not been enabled.");
            }
        } break;

        // Validation code for VkVideoProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_queue)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_queue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoProfileInfoKHR);
                VkVideoProfileInfoKHR* structure = (VkVideoProfileInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                                      AllVkVideoCodecOperationFlagBitsKHR, structure->videoCodecOperation, kRequiredSingleBit,
                                      "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                                      "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::chromaSubsampling), vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                                  AllVkVideoChromaSubsamplingFlagBitsKHR, structure->chromaSubsampling, kRequiredFlags,
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

                skip |= ValidateFlags(pNext_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                      AllVkVideoComponentBitDepthFlagBitsKHR, structure->lumaBitDepth, kRequiredFlags,
                                      "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                                      "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

                skip |= ValidateFlags(pNext_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                      AllVkVideoComponentBitDepthFlagBitsKHR, structure->chromaBitDepth, kOptionalFlags,
                                      "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
            }
        } break;

        // Validation code for VkVideoProfileListInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: {  // Covers VUID-VkVideoProfileListInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_video_queue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoProfileListInfoKHR);
                VkVideoProfileListInfoKHR* structure = (VkVideoProfileListInfoKHR*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::profileCount), pNext_loc.dot(Field::pProfiles), structure->profileCount,
                    structure->pProfiles, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, false, true,
                    "VUID-VkVideoProfileInfoKHR-sType-sType", "VUID-VkVideoProfileListInfoKHR-pProfiles-parameter", kVUIDUndefined);

                if (structure->pProfiles != nullptr) {
                    for (uint32_t profileIndex = 0; profileIndex < structure->profileCount; ++profileIndex) {
                        [[maybe_unused]] const Location pProfiles_loc = pNext_loc.dot(Field::pProfiles, profileIndex);
                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                            AllVkVideoCodecOperationFlagBitsKHR, structure->pProfiles[profileIndex].videoCodecOperation,
                            kRequiredSingleBit, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                            "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::chromaSubsampling), vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                            AllVkVideoChromaSubsamplingFlagBitsKHR, structure->pProfiles[profileIndex].chromaSubsampling,
                            kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                            "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                            AllVkVideoComponentBitDepthFlagBitsKHR, structure->pProfiles[profileIndex].lumaBitDepth, kRequiredFlags,
                            "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                            "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                            AllVkVideoComponentBitDepthFlagBitsKHR, structure->pProfiles[profileIndex].chromaBitDepth,
                            kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkVideoDecodeCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR: {  // Covers VUID-VkVideoDecodeCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR), "
                                     "but its parent extension "
                                     "VK_KHR_video_decode_queue has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeUsageInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: {  // Covers VUID-VkVideoDecodeUsageInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_video_decode_queue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeUsageInfoKHR);
                VkVideoDecodeUsageInfoKHR* structure = (VkVideoDecodeUsageInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::videoUsageHints), vvl::FlagBitmask::VkVideoDecodeUsageFlagBitsKHR,
                                      AllVkVideoDecodeUsageFlagBitsKHR, structure->videoUsageHints, kOptionalFlags,
                                      "VUID-VkVideoDecodeUsageInfoKHR-videoUsageHints-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH264CapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR: {  // Covers VUID-VkVideoEncodeH264CapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH264QualityLevelPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeH264QualityLevelPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH264SessionCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR: {  // Covers
                                                                             // VUID-VkVideoEncodeH264SessionCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264SessionCreateInfoKHR);
                VkVideoEncodeH264SessionCreateInfoKHR* structure = (VkVideoEncodeH264SessionCreateInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxLevelIdc), structure->useMaxLevelIdc);
            }
        } break;

        // Validation code for VkVideoEncodeH264SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_encode_h264 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH264SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoEncodeH264SessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264SessionParametersCreateInfoKHR);
                VkVideoEncodeH264SessionParametersCreateInfoKHR* structure =
                    (VkVideoEncodeH264SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoEncodeH264SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-sType-sType");
            }
        } break;

        // Validation code for VkVideoEncodeH264SessionParametersGetInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoEncodeH264SessionParametersGetInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264SessionParametersGetInfoKHR);
                VkVideoEncodeH264SessionParametersGetInfoKHR* structure = (VkVideoEncodeH264SessionParametersGetInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdSPS), structure->writeStdSPS);

                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdPPS), structure->writeStdPPS);
            }
        } break;

        // Validation code for VkVideoEncodeH264SessionParametersFeedbackInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {  // Covers
                                                                                          // VUID-VkVideoEncodeH264SessionParametersFeedbackInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR), but its parent extension "
                    "VK_KHR_video_encode_h264 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH264PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoEncodeH264PictureInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR);
                VkVideoEncodeH264PictureInfoKHR* structure = (VkVideoEncodeH264PictureInfoKHR*)header;
                skip |= ValidateStructTypeArray(pNext_loc.dot(Field::naluSliceEntryCount), pNext_loc.dot(Field::pNaluSliceEntries),
                                                structure->naluSliceEntryCount, structure->pNaluSliceEntries,
                                                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR, true, true,
                                                "VUID-VkVideoEncodeH264NaluSliceInfoKHR-sType-sType",
                                                "VUID-VkVideoEncodeH264PictureInfoKHR-pNaluSliceEntries-parameter",
                                                "VUID-VkVideoEncodeH264PictureInfoKHR-naluSliceEntryCount-arraylength");

                if (structure->pNaluSliceEntries != nullptr) {
                    for (uint32_t naluSliceEntryIndex = 0; naluSliceEntryIndex < structure->naluSliceEntryCount;
                         ++naluSliceEntryIndex) {
                        [[maybe_unused]] const Location pNaluSliceEntries_loc =
                            pNext_loc.dot(Field::pNaluSliceEntries, naluSliceEntryIndex);
                        skip |= ValidateStructPnext(pNaluSliceEntries_loc, structure->pNaluSliceEntries[naluSliceEntryIndex].pNext,
                                                    0, nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkVideoEncodeH264NaluSliceInfoKHR-pNext-pNext", kVUIDUndefined, true);

                        skip |= ValidateRequiredPointer(pNaluSliceEntries_loc.dot(Field::pStdSliceHeader),
                                                        structure->pNaluSliceEntries[naluSliceEntryIndex].pStdSliceHeader,
                                                        "VUID-VkVideoEncodeH264NaluSliceInfoKHR-pStdSliceHeader-parameter");
                    }
                }

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoEncodeH264PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateBool32(pNext_loc.dot(Field::generatePrefixNalu), structure->generatePrefixNalu);
            }
        } break;

        // Validation code for VkVideoEncodeH264DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoEncodeH264DpbSlotInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264DpbSlotInfoKHR);
                VkVideoEncodeH264DpbSlotInfoKHR* structure = (VkVideoEncodeH264DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoEncodeH264DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH264ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoEncodeH264ProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH264RateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR: {  // Covers
                                                                           // VUID-VkVideoEncodeH264RateControlInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264RateControlInfoKHR);
                VkVideoEncodeH264RateControlInfoKHR* structure = (VkVideoEncodeH264RateControlInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoEncodeH264RateControlFlagBitsKHR,
                                      AllVkVideoEncodeH264RateControlFlagBitsKHR, structure->flags, kOptionalFlags,
                                      "VUID-VkVideoEncodeH264RateControlInfoKHR-flags-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH264RateControlLayerInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR: {  // Covers
                                                                                 // VUID-VkVideoEncodeH264RateControlLayerInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264RateControlLayerInfoKHR);
                VkVideoEncodeH264RateControlLayerInfoKHR* structure = (VkVideoEncodeH264RateControlLayerInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMinQp), structure->useMinQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxQp), structure->useMaxQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxFrameSize), structure->useMaxFrameSize);
            }
        } break;

        // Validation code for VkVideoEncodeH264GopRemainingFrameInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeH264GopRemainingFrameInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264GopRemainingFrameInfoKHR);
                VkVideoEncodeH264GopRemainingFrameInfoKHR* structure = (VkVideoEncodeH264GopRemainingFrameInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useGopRemainingFrames), structure->useGopRemainingFrames);
            }
        } break;

        // Validation code for VkVideoEncodeH265CapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR: {  // Covers VUID-VkVideoEncodeH265CapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH265SessionCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR: {  // Covers
                                                                             // VUID-VkVideoEncodeH265SessionCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265SessionCreateInfoKHR);
                VkVideoEncodeH265SessionCreateInfoKHR* structure = (VkVideoEncodeH265SessionCreateInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxLevelIdc), structure->useMaxLevelIdc);
            }
        } break;

        // Validation code for VkVideoEncodeH265QualityLevelPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeH265QualityLevelPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH265SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_encode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH265SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoEncodeH265SessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265SessionParametersCreateInfoKHR);
                VkVideoEncodeH265SessionParametersCreateInfoKHR* structure =
                    (VkVideoEncodeH265SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoEncodeH265SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-sType-sType");
            }
        } break;

        // Validation code for VkVideoEncodeH265SessionParametersGetInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoEncodeH265SessionParametersGetInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265SessionParametersGetInfoKHR);
                VkVideoEncodeH265SessionParametersGetInfoKHR* structure = (VkVideoEncodeH265SessionParametersGetInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdVPS), structure->writeStdVPS);

                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdSPS), structure->writeStdSPS);

                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdPPS), structure->writeStdPPS);
            }
        } break;

        // Validation code for VkVideoEncodeH265SessionParametersFeedbackInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR: {  // Covers
                                                                                          // VUID-VkVideoEncodeH265SessionParametersFeedbackInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR), but its parent extension "
                    "VK_KHR_video_encode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH265PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoEncodeH265PictureInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265PictureInfoKHR);
                VkVideoEncodeH265PictureInfoKHR* structure = (VkVideoEncodeH265PictureInfoKHR*)header;
                skip |= ValidateStructTypeArray(pNext_loc.dot(Field::naluSliceSegmentEntryCount),
                                                pNext_loc.dot(Field::pNaluSliceSegmentEntries),
                                                structure->naluSliceSegmentEntryCount, structure->pNaluSliceSegmentEntries,
                                                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR, true, true,
                                                "VUID-VkVideoEncodeH265NaluSliceSegmentInfoKHR-sType-sType",
                                                "VUID-VkVideoEncodeH265PictureInfoKHR-pNaluSliceSegmentEntries-parameter",
                                                "VUID-VkVideoEncodeH265PictureInfoKHR-naluSliceSegmentEntryCount-arraylength");

                if (structure->pNaluSliceSegmentEntries != nullptr) {
                    for (uint32_t naluSliceSegmentEntryIndex = 0;
                         naluSliceSegmentEntryIndex < structure->naluSliceSegmentEntryCount; ++naluSliceSegmentEntryIndex) {
                        [[maybe_unused]] const Location pNaluSliceSegmentEntries_loc =
                            pNext_loc.dot(Field::pNaluSliceSegmentEntries, naluSliceSegmentEntryIndex);
                        skip |= ValidateStructPnext(
                            pNaluSliceSegmentEntries_loc, structure->pNaluSliceSegmentEntries[naluSliceSegmentEntryIndex].pNext, 0,
                            nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeH265NaluSliceSegmentInfoKHR-pNext-pNext",
                            kVUIDUndefined, true);

                        skip |= ValidateRequiredPointer(
                            pNaluSliceSegmentEntries_loc.dot(Field::pStdSliceSegmentHeader),
                            structure->pNaluSliceSegmentEntries[naluSliceSegmentEntryIndex].pStdSliceSegmentHeader,
                            "VUID-VkVideoEncodeH265NaluSliceSegmentInfoKHR-pStdSliceSegmentHeader-parameter");
                    }
                }

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoEncodeH265PictureInfoKHR-pStdPictureInfo-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH265DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoEncodeH265DpbSlotInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265DpbSlotInfoKHR);
                VkVideoEncodeH265DpbSlotInfoKHR* structure = (VkVideoEncodeH265DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoEncodeH265DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH265ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoEncodeH265ProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH265RateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR: {  // Covers
                                                                           // VUID-VkVideoEncodeH265RateControlInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265RateControlInfoKHR);
                VkVideoEncodeH265RateControlInfoKHR* structure = (VkVideoEncodeH265RateControlInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoEncodeH265RateControlFlagBitsKHR,
                                      AllVkVideoEncodeH265RateControlFlagBitsKHR, structure->flags, kOptionalFlags,
                                      "VUID-VkVideoEncodeH265RateControlInfoKHR-flags-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH265RateControlLayerInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR: {  // Covers
                                                                                 // VUID-VkVideoEncodeH265RateControlLayerInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265RateControlLayerInfoKHR);
                VkVideoEncodeH265RateControlLayerInfoKHR* structure = (VkVideoEncodeH265RateControlLayerInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMinQp), structure->useMinQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxQp), structure->useMaxQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxFrameSize), structure->useMaxFrameSize);
            }
        } break;

        // Validation code for VkVideoEncodeH265GopRemainingFrameInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeH265GopRemainingFrameInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265GopRemainingFrameInfoKHR);
                VkVideoEncodeH265GopRemainingFrameInfoKHR* structure = (VkVideoEncodeH265GopRemainingFrameInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useGopRemainingFrames), structure->useGopRemainingFrames);
            }
        } break;

        // Validation code for VkVideoDecodeH264ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH264ProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264ProfileInfoKHR);
                VkVideoDecodeH264ProfileInfoKHR* structure = (VkVideoDecodeH264ProfileInfoKHR*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::pictureLayout), vvl::FlagBitmask::VkVideoDecodeH264PictureLayoutFlagBitsKHR,
                                  AllVkVideoDecodeH264PictureLayoutFlagBitsKHR, structure->pictureLayout, kOptionalSingleBit,
                                  "VUID-VkVideoDecodeH264ProfileInfoKHR-pictureLayout-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264CapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR: {  // Covers VUID-VkVideoDecodeH264CapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h264 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeH264SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h264)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_decode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264SessionParametersAddInfoKHR);
                VkVideoDecodeH264SessionParametersAddInfoKHR* structure = (VkVideoDecodeH264SessionParametersAddInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::stdSPSCount), pNext_loc.dot(Field::pStdSPSs), structure->stdSPSCount,
                                      &structure->pStdSPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdSPSs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::stdPPSCount), pNext_loc.dot(Field::pStdPPSs), structure->stdPPSCount,
                                      &structure->pStdPPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdPPSs-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoDecodeH264SessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h264)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_decode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264SessionParametersCreateInfoKHR);
                VkVideoDecodeH264SessionParametersCreateInfoKHR* structure =
                    (VkVideoDecodeH264SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoDecodeH264SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr) {
                    [[maybe_unused]] const Location pParametersAddInfo_loc = pNext_loc.dot(Field::pParametersAddInfo);
                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdSPSCount), pParametersAddInfo_loc.dot(Field::pStdSPSs),
                                      structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdSPSs-parameter");

                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdPPSCount), pParametersAddInfo_loc.dot(Field::pStdPPSs),
                                      structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdPPSs-parameter");
                }
            }
        } break;

        // Validation code for VkVideoDecodeH264PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH264PictureInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264PictureInfoKHR);
                VkVideoDecodeH264PictureInfoKHR* structure = (VkVideoDecodeH264PictureInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoDecodeH264PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::sliceCount), pNext_loc.dot(Field::pSliceOffsets), structure->sliceCount,
                                      &structure->pSliceOffsets, true, true,
                                      "VUID-VkVideoDecodeH264PictureInfoKHR-sliceCount-arraylength",
                                      "VUID-VkVideoDecodeH264PictureInfoKHR-pSliceOffsets-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoDecodeH264DpbSlotInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h264)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h264 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264DpbSlotInfoKHR);
                VkVideoDecodeH264DpbSlotInfoKHR* structure = (VkVideoDecodeH264DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoDecodeH264DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryWin32HandleInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: {  // Covers VUID-VkImportMemoryWin32HandleInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR), but its parent extension "
                                     "VK_KHR_external_memory_win32 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryWin32HandleInfoKHR);
                VkImportMemoryWin32HandleInfoKHR* structure = (VkImportMemoryWin32HandleInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      "VUID-VkImportMemoryWin32HandleInfoKHR-handleType-parameter");
            }
        } break;

        // Validation code for VkExportMemoryWin32HandleInfoKHR structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: {  // Covers VUID-VkExportMemoryWin32HandleInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR), but its parent extension "
                                     "VK_KHR_external_memory_win32 has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryFdInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: {  // Covers VUID-VkImportMemoryFdInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_memory_fd)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_external_memory_fd has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryFdInfoKHR);
                VkImportMemoryFdInfoKHR* structure = (VkImportMemoryFdInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      "VUID-VkImportMemoryFdInfoKHR-handleType-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkWin32KeyedMutexAcquireReleaseInfoKHR structure members
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {  // Covers
                                                                              // VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_win32_keyed_mutex)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR), but its parent extension "
                                     "VK_KHR_win32_keyed_mutex has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWin32KeyedMutexAcquireReleaseInfoKHR);
                VkWin32KeyedMutexAcquireReleaseInfoKHR* structure = (VkWin32KeyedMutexAcquireReleaseInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireSyncs),
                                      structure->acquireCount, &structure->pAcquireSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireKeys),
                                      structure->acquireCount, &structure->pAcquireKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireKeys-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireTimeouts),
                                      structure->acquireCount, &structure->pAcquireTimeouts, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireTimeouts-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseSyncs),
                                      structure->releaseCount, &structure->pReleaseSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseKeys),
                                      structure->releaseCount, &structure->pReleaseKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseKeys-parameter");
            }
        } break;

        // Validation code for VkExportSemaphoreWin32HandleInfoKHR structure members
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: {  // Covers
                                                                          // VUID-VkExportSemaphoreWin32HandleInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_semaphore_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR), but its parent extension "
                                     "VK_KHR_external_semaphore_win32 has not been enabled.");
            }
        } break;

        // Validation code for VkD3D12FenceSubmitInfoKHR structure members
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: {  // Covers VUID-VkD3D12FenceSubmitInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_semaphore_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_external_semaphore_win32 has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkPresentRegionsKHR structure members
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {  // Covers VUID-VkPresentRegionsKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_incremental_present)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR), but its parent extension "
                    "VK_KHR_incremental_present has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPresentRegionsKHR);
                VkPresentRegionsKHR* structure = (VkPresentRegionsKHR*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pRegions), structure->swapchainCount,
                                  &structure->pRegions, true, false, "VUID-VkPresentRegionsKHR-swapchainCount-arraylength",
                                  "VUID-VkPresentRegionsKHR-pRegions-parameter");

                if (structure->pRegions != nullptr) {
                    for (uint32_t swapchainIndex = 0; swapchainIndex < structure->swapchainCount; ++swapchainIndex) {
                        [[maybe_unused]] const Location pRegions_loc = pNext_loc.dot(Field::pRegions, swapchainIndex);
                        if (structure->pRegions[swapchainIndex].pRectangles != nullptr) {
                            for (uint32_t rectangleIndex = 0; rectangleIndex < structure->pRegions[swapchainIndex].rectangleCount;
                                 ++rectangleIndex) {
                                [[maybe_unused]] const Location pRectangles_loc =
                                    pRegions_loc.dot(Field::pRectangles, rectangleIndex);
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkSharedPresentSurfaceCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: {  // Covers
                                                                           // VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_shared_presentable_image)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_shared_presentable_image has not been enabled.");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkExportFenceWin32HandleInfoKHR structure members
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: {  // Covers VUID-VkExportFenceWin32HandleInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_external_fence_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR), but its parent extension "
                                     "VK_KHR_external_fence_win32 has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkQueryPoolPerformanceCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {  // Covers
                                                                          // VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_performance_query)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR), but its parent extension "
                                     "VK_KHR_performance_query has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryPoolPerformanceCreateInfoKHR);
                VkQueryPoolPerformanceCreateInfoKHR* structure = (VkQueryPoolPerformanceCreateInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::counterIndexCount), pNext_loc.dot(Field::pCounterIndices),
                                      structure->counterIndexCount, &structure->pCounterIndices, true, true,
                                      "VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength",
                                      "VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter");
            }
        } break;

        // Validation code for VkPerformanceQuerySubmitInfoKHR structure members
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: {  // Covers VUID-VkPerformanceQuerySubmitInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_performance_query)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR), but its parent extension "
                                     "VK_KHR_performance_query has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeH265ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH265ProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeH265CapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR: {  // Covers VUID-VkVideoDecodeH265CapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h265 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeH265SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h265)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_decode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265SessionParametersAddInfoKHR);
                VkVideoDecodeH265SessionParametersAddInfoKHR* structure = (VkVideoDecodeH265SessionParametersAddInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::stdVPSCount), pNext_loc.dot(Field::pStdVPSs), structure->stdVPSCount,
                                      &structure->pStdVPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdVPSs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::stdSPSCount), pNext_loc.dot(Field::pStdSPSs), structure->stdSPSCount,
                                      &structure->pStdSPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdSPSs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::stdPPSCount), pNext_loc.dot(Field::pStdPPSs), structure->stdPPSCount,
                                      &structure->pStdPPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdPPSs-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH265SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoDecodeH265SessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h265)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_decode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265SessionParametersCreateInfoKHR);
                VkVideoDecodeH265SessionParametersCreateInfoKHR* structure =
                    (VkVideoDecodeH265SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoDecodeH265SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr) {
                    [[maybe_unused]] const Location pParametersAddInfo_loc = pNext_loc.dot(Field::pParametersAddInfo);
                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdVPSCount), pParametersAddInfo_loc.dot(Field::pStdVPSs),
                                      structure->pParametersAddInfo->stdVPSCount, &structure->pParametersAddInfo->pStdVPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdVPSs-parameter");

                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdSPSCount), pParametersAddInfo_loc.dot(Field::pStdSPSs),
                                      structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdSPSs-parameter");

                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdPPSCount), pParametersAddInfo_loc.dot(Field::pStdPPSs),
                                      structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdPPSs-parameter");
                }
            }
        } break;

        // Validation code for VkVideoDecodeH265PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH265PictureInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265PictureInfoKHR);
                VkVideoDecodeH265PictureInfoKHR* structure = (VkVideoDecodeH265PictureInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoDecodeH265PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::sliceSegmentCount), pNext_loc.dot(Field::pSliceSegmentOffsets),
                                      structure->sliceSegmentCount, &structure->pSliceSegmentOffsets, true, true,
                                      "VUID-VkVideoDecodeH265PictureInfoKHR-sliceSegmentCount-arraylength",
                                      "VUID-VkVideoDecodeH265PictureInfoKHR-pSliceSegmentOffsets-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH265DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoDecodeH265DpbSlotInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_h265)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_h265 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265DpbSlotInfoKHR);
                VkVideoDecodeH265DpbSlotInfoKHR* structure = (VkVideoDecodeH265DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoDecodeH265DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkFragmentShadingRateAttachmentInfoKHR structure members
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {  // Covers
                                                                             // VUID-VkFragmentShadingRateAttachmentInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_fragment_shading_rate)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR), but its parent extension "
                                     "VK_KHR_fragment_shading_rate has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkFragmentShadingRateAttachmentInfoKHR);
                VkFragmentShadingRateAttachmentInfoKHR* structure = (VkFragmentShadingRateAttachmentInfoKHR*)header;
                skip |=
                    ValidateStructType(pNext_loc.dot(Field::pFragmentShadingRateAttachment),
                                       structure->pFragmentShadingRateAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                                       "VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-parameter",
                                       "VUID-VkAttachmentReference2-sType-sType");

                if (structure->pFragmentShadingRateAttachment != nullptr) {
                    [[maybe_unused]] const Location pFragmentShadingRateAttachment_loc =
                        pNext_loc.dot(Field::pFragmentShadingRateAttachment);
                    constexpr std::array allowed_structs_VkAttachmentReference2 = {
                        VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                    skip |= ValidateStructPnext(
                        pFragmentShadingRateAttachment_loc, structure->pFragmentShadingRateAttachment->pNext,
                        allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                        "VUID-VkAttachmentReference2-sType-unique", true);

                    skip |= ValidateRangedEnum(pFragmentShadingRateAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               structure->pFragmentShadingRateAttachment->layout,
                                               "VUID-VkAttachmentReference2-layout-parameter");
                }
            }
        } break;

        // Validation code for VkPipelineFragmentShadingRateStateCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkPipelineFragmentShadingRateStateCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_fragment_shading_rate)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_fragment_shading_rate has not been enabled.");
            }
        } break;

        // Validation code for VkRenderingFragmentShadingRateAttachmentInfoKHR structure members
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {  // Covers
                                                                                       // VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_fragment_shading_rate)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR), but its parent extension "
                    "VK_KHR_fragment_shading_rate has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR);
                VkRenderingFragmentShadingRateAttachmentInfoKHR* structure =
                    (VkRenderingFragmentShadingRateAttachmentInfoKHR*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, structure->imageLayout,
                                           "VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageLayout-parameter");
            }
        } break;

        // Validation code for VkSurfaceProtectedCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: {  // Covers VUID-VkSurfaceProtectedCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_surface_protected_capabilities)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_surface_protected_capabilities has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineLibraryCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {  // Covers VUID-VkPipelineLibraryCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_pipeline_library)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR), but its parent extension "
                                     "VK_KHR_pipeline_library has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineLibraryCreateInfoKHR);
                VkPipelineLibraryCreateInfoKHR* structure = (VkPipelineLibraryCreateInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::libraryCount), pNext_loc.dot(Field::pLibraries), structure->libraryCount,
                                      &structure->pLibraries, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }
        } break;

        // Validation code for VkPresentIdKHR structure members
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR: {  // Covers VUID-VkPresentIdKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_present_id)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PRESENT_ID_KHR), but its parent extension "
                    "VK_KHR_present_id has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPresentIdKHR);
                VkPresentIdKHR* structure = (VkPresentIdKHR*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pPresentIds),
                                  structure->swapchainCount, &structure->pPresentIds, true, false,
                                  "VUID-VkPresentIdKHR-swapchainCount-arraylength", "VUID-VkPresentIdKHR-pPresentIds-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR: {  // Covers VUID-VkVideoEncodeCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR), "
                                     "but its parent extension "
                                     "VK_KHR_video_encode_queue has not been enabled.");
            }
        } break;

        // Validation code for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR: {  // Covers
                                                                                    // VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_queue)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR), but its parent extension "
                                 "VK_KHR_video_encode_queue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryPoolVideoEncodeFeedbackCreateInfoKHR);
                VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* structure = (VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::encodeFeedbackFlags), vvl::FlagBitmask::VkVideoEncodeFeedbackFlagBitsKHR,
                                      AllVkVideoEncodeFeedbackFlagBitsKHR, structure->encodeFeedbackFlags, kRequiredFlags,
                                      "VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-encodeFeedbackFlags-parameter",
                                      "VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-encodeFeedbackFlags-requiredbitmask");
            }
        } break;

        // Validation code for VkVideoEncodeUsageInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: {  // Covers VUID-VkVideoEncodeUsageInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_video_encode_queue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeUsageInfoKHR);
                VkVideoEncodeUsageInfoKHR* structure = (VkVideoEncodeUsageInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::videoUsageHints), vvl::FlagBitmask::VkVideoEncodeUsageFlagBitsKHR,
                                      AllVkVideoEncodeUsageFlagBitsKHR, structure->videoUsageHints, kOptionalFlags,
                                      "VUID-VkVideoEncodeUsageInfoKHR-videoUsageHints-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::videoContentHints), vvl::FlagBitmask::VkVideoEncodeContentFlagBitsKHR,
                                      AllVkVideoEncodeContentFlagBitsKHR, structure->videoContentHints, kOptionalFlags,
                                      "VUID-VkVideoEncodeUsageInfoKHR-videoContentHints-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::tuningMode), vvl::Enum::VkVideoEncodeTuningModeKHR,
                                           structure->tuningMode, "VUID-VkVideoEncodeUsageInfoKHR-tuningMode-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeRateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: {  // Covers VUID-VkVideoEncodeRateControlInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_queue has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeRateControlInfoKHR);
                VkVideoEncodeRateControlInfoKHR* structure = (VkVideoEncodeRateControlInfoKHR*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkVideoEncodeRateControlInfoKHR-flags-zerobitmask");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::rateControlMode), vvl::FlagBitmask::VkVideoEncodeRateControlModeFlagBitsKHR,
                                  AllVkVideoEncodeRateControlModeFlagBitsKHR, structure->rateControlMode, kOptionalSingleBit,
                                  "VUID-VkVideoEncodeRateControlInfoKHR-rateControlMode-parameter");

                skip |=
                    ValidateStructTypeArray(pNext_loc.dot(Field::layerCount), pNext_loc.dot(Field::pLayers), structure->layerCount,
                                            structure->pLayers, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR, false,
                                            true, "VUID-VkVideoEncodeRateControlLayerInfoKHR-sType-sType",
                                            "VUID-VkVideoEncodeRateControlInfoKHR-pLayers-parameter", kVUIDUndefined);

                if (structure->pLayers != nullptr) {
                    for (uint32_t layerIndex = 0; layerIndex < structure->layerCount; ++layerIndex) {
                        [[maybe_unused]] const Location pLayers_loc = pNext_loc.dot(Field::pLayers, layerIndex);
                        constexpr std::array allowed_structs_VkVideoEncodeRateControlLayerInfoKHR = {
                            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR,
                            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR,
                            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR};

                        skip |= ValidateStructPnext(pLayers_loc, structure->pLayers[layerIndex].pNext,
                                                    allowed_structs_VkVideoEncodeRateControlLayerInfoKHR.size(),
                                                    allowed_structs_VkVideoEncodeRateControlLayerInfoKHR.data(),
                                                    GeneratedVulkanHeaderVersion,
                                                    "VUID-VkVideoEncodeRateControlLayerInfoKHR-pNext-pNext",
                                                    "VUID-VkVideoEncodeRateControlLayerInfoKHR-sType-unique", true);
                    }
                }
            }
        } break;

        // Validation code for VkVideoEncodeQualityLevelInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR: {  // Covers VUID-VkVideoEncodeQualityLevelInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_queue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_queue has not been enabled.");
            }
        } break;

        // Validation code for VkDevicePipelineBinaryInternalCacheControlKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR: {  // Covers
                                                                                     // VUID-VkDevicePipelineBinaryInternalCacheControlKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_pipeline_binary)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR), but its parent extension "
                                 "VK_KHR_pipeline_binary has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDevicePipelineBinaryInternalCacheControlKHR);
                VkDevicePipelineBinaryInternalCacheControlKHR* structure = (VkDevicePipelineBinaryInternalCacheControlKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::disableInternalCache), structure->disableInternalCache);
            }
        } break;

        // Validation code for VkPipelineBinaryInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR: {  // Covers VUID-VkPipelineBinaryInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_pipeline_binary)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_pipeline_binary has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineBinaryInfoKHR);
                VkPipelineBinaryInfoKHR* structure = (VkPipelineBinaryInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::binaryCount), pNext_loc.dot(Field::pPipelineBinaries),
                                      structure->binaryCount, &structure->pPipelineBinaries, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineBinaryInfoKHR-pPipelineBinaries-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeAV1ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoDecodeAV1ProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1ProfileInfoKHR);
                VkVideoDecodeAV1ProfileInfoKHR* structure = (VkVideoDecodeAV1ProfileInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::filmGrainSupport), structure->filmGrainSupport);
            }
        } break;

        // Validation code for VkVideoDecodeAV1CapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR: {  // Covers VUID-VkVideoDecodeAV1CapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_decode_av1 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeAV1SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                       // VUID-VkVideoDecodeAV1SessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_av1)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_decode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1SessionParametersCreateInfoKHR);
                VkVideoDecodeAV1SessionParametersCreateInfoKHR* structure = (VkVideoDecodeAV1SessionParametersCreateInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdSequenceHeader), structure->pStdSequenceHeader,
                                                "VUID-VkVideoDecodeAV1SessionParametersCreateInfoKHR-pStdSequenceHeader-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeAV1PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoDecodeAV1PictureInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR);
                VkVideoDecodeAV1PictureInfoKHR* structure = (VkVideoDecodeAV1PictureInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoDecodeAV1PictureInfoKHR-pStdPictureInfo-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::tileCount), pNext_loc.dot(Field::pTileOffsets), structure->tileCount,
                                  &structure->pTileOffsets, true, true, "VUID-VkVideoDecodeAV1PictureInfoKHR-tileCount-arraylength",
                                  "VUID-VkVideoDecodeAV1PictureInfoKHR-pTileOffsets-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::tileCount), pNext_loc.dot(Field::pTileSizes), structure->tileCount,
                                  &structure->pTileSizes, true, true, "VUID-VkVideoDecodeAV1PictureInfoKHR-tileCount-arraylength",
                                  "VUID-VkVideoDecodeAV1PictureInfoKHR-pTileSizes-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeAV1DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoDecodeAV1DpbSlotInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_decode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_decode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1DpbSlotInfoKHR);
                VkVideoDecodeAV1DpbSlotInfoKHR* structure = (VkVideoDecodeAV1DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoDecodeAV1DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeAV1CapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR: {  // Covers VUID-VkVideoEncodeAV1CapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeAV1QualityLevelPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR: {  // Covers
                                                                                 // VUID-VkVideoEncodeAV1QualityLevelPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeAV1SessionCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR: {  // Covers
                                                                            // VUID-VkVideoEncodeAV1SessionCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1SessionCreateInfoKHR);
                VkVideoEncodeAV1SessionCreateInfoKHR* structure = (VkVideoEncodeAV1SessionCreateInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxLevel), structure->useMaxLevel);
            }
        } break;

        // Validation code for VkVideoEncodeAV1SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                       // VUID-VkVideoEncodeAV1SessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR), but its parent extension "
                    "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1SessionParametersCreateInfoKHR);
                VkVideoEncodeAV1SessionParametersCreateInfoKHR* structure = (VkVideoEncodeAV1SessionParametersCreateInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdSequenceHeader), structure->pStdSequenceHeader,
                                                "VUID-VkVideoEncodeAV1SessionParametersCreateInfoKHR-pStdSequenceHeader-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeAV1PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoEncodeAV1PictureInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1PictureInfoKHR);
                VkVideoEncodeAV1PictureInfoKHR* structure = (VkVideoEncodeAV1PictureInfoKHR*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::predictionMode), vvl::Enum::VkVideoEncodeAV1PredictionModeKHR,
                                       structure->predictionMode, "VUID-VkVideoEncodeAV1PictureInfoKHR-predictionMode-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::rateControlGroup), vvl::Enum::VkVideoEncodeAV1RateControlGroupKHR,
                                           structure->rateControlGroup,
                                           "VUID-VkVideoEncodeAV1PictureInfoKHR-rateControlGroup-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoEncodeAV1PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateBool32(pNext_loc.dot(Field::primaryReferenceCdfOnly), structure->primaryReferenceCdfOnly);

                skip |= ValidateBool32(pNext_loc.dot(Field::generateObuExtensionHeader), structure->generateObuExtensionHeader);
            }
        } break;

        // Validation code for VkVideoEncodeAV1DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoEncodeAV1DpbSlotInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1DpbSlotInfoKHR);
                VkVideoEncodeAV1DpbSlotInfoKHR* structure = (VkVideoEncodeAV1DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoEncodeAV1DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeAV1ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoEncodeAV1ProfileInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeAV1GopRemainingFrameInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR: {  // Covers
                                                                                 // VUID-VkVideoEncodeAV1GopRemainingFrameInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1GopRemainingFrameInfoKHR);
                VkVideoEncodeAV1GopRemainingFrameInfoKHR* structure = (VkVideoEncodeAV1GopRemainingFrameInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useGopRemainingFrames), structure->useGopRemainingFrames);
            }
        } break;

        // Validation code for VkVideoEncodeAV1RateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR: {  // Covers
                                                                          // VUID-VkVideoEncodeAV1RateControlInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1RateControlInfoKHR);
                VkVideoEncodeAV1RateControlInfoKHR* structure = (VkVideoEncodeAV1RateControlInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoEncodeAV1RateControlFlagBitsKHR,
                                      AllVkVideoEncodeAV1RateControlFlagBitsKHR, structure->flags, kOptionalFlags,
                                      "VUID-VkVideoEncodeAV1RateControlInfoKHR-flags-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeAV1RateControlLayerInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR: {  // Covers
                                                                                // VUID-VkVideoEncodeAV1RateControlLayerInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_av1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_av1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeAV1RateControlLayerInfoKHR);
                VkVideoEncodeAV1RateControlLayerInfoKHR* structure = (VkVideoEncodeAV1RateControlLayerInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMinQIndex), structure->useMinQIndex);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxQIndex), structure->useMaxQIndex);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxFrameSize), structure->useMaxFrameSize);
            }
        } break;

        // Validation code for VkVideoInlineQueryInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR: {  // Covers VUID-VkVideoInlineQueryInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_video_maintenance1 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeQuantizationMapCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeQuantizationMapCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoFormatQuantizationMapPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR: {  // Covers
                                                                                // VUID-VkVideoFormatQuantizationMapPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR), but its parent extension "
                                     "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeQuantizationMapInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR: {  // Covers
                                                                          // VUID-VkVideoEncodeQuantizationMapInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR), but its parent extension "
                                     "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                                    // VUID-VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR), but "
                                     "its parent extension "
                                     "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH264QuantizationMapCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR: {  // Covers
                                                                                       // VUID-VkVideoEncodeH264QuantizationMapCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR), but its parent extension "
                    "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeH265QuantizationMapCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR: {  // Covers
                                                                                       // VUID-VkVideoEncodeH265QuantizationMapCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR), but its parent extension "
                    "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoFormatH265QuantizationMapPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR: {  // Covers
                                                                                     // VUID-VkVideoFormatH265QuantizationMapPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR), but its parent extension "
                                 "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoEncodeAV1QuantizationMapCapabilitiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR: {  // Covers
                                                                                      // VUID-VkVideoEncodeAV1QuantizationMapCapabilitiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR), but its parent extension "
                                 "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkVideoFormatAV1QuantizationMapPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR: {  // Covers
                                                                                    // VUID-VkVideoFormatAV1QuantizationMapPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_encode_quantization_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR), but its parent extension "
                                 "VK_KHR_video_encode_quantization_map has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceLayeredApiVulkanPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceLayeredApiVulkanPropertiesKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance7)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR), but its parent extension "
                                 "VK_KHR_maintenance7 has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryBarrierAccessFlags3KHR structure members
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR: {  // Covers VUID-VkMemoryBarrierAccessFlags3KHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_maintenance8)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR), but its parent extension "
                                     "VK_KHR_maintenance8 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMemoryBarrierAccessFlags3KHR);
                VkMemoryBarrierAccessFlags3KHR* structure = (VkMemoryBarrierAccessFlags3KHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::srcAccessMask3), vvl::FlagBitmask::VkAccessFlagBits3KHR,
                                      AllVkAccessFlagBits3KHR, structure->srcAccessMask3, kOptionalFlags,
                                      "VUID-VkMemoryBarrierAccessFlags3KHR-srcAccessMask3-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::dstAccessMask3), vvl::FlagBitmask::VkAccessFlagBits3KHR,
                                      AllVkAccessFlagBits3KHR, structure->dstAccessMask3, kOptionalFlags,
                                      "VUID-VkMemoryBarrierAccessFlags3KHR-dstAccessMask3-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264InlineSessionParametersInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoDecodeH264InlineSessionParametersInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_maintenance2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR), but its parent extension "
                    "VK_KHR_video_maintenance2 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeH265InlineSessionParametersInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoDecodeH265InlineSessionParametersInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_maintenance2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR), but its parent extension "
                    "VK_KHR_video_maintenance2 has not been enabled.");
            }
        } break;

        // Validation code for VkVideoDecodeAV1InlineSessionParametersInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR: {  // Covers
                                                                                       // VUID-VkVideoDecodeAV1InlineSessionParametersInfoKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_video_maintenance2)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR), but its parent extension "
                    "VK_KHR_video_maintenance2 has not been enabled.");
            }
        } break;

        // Validation code for VkDebugReportCallbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: {  // Covers
                                                                         // VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_debug_report)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_debug_report has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDebugReportCallbackCreateInfoEXT);
                VkDebugReportCallbackCreateInfoEXT* structure = (VkDebugReportCallbackCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkDebugReportFlagBitsEXT,
                                      AllVkDebugReportFlagBitsEXT, structure->flags, kOptionalFlags,
                                      "VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pfnCallback),
                                                reinterpret_cast<const void*>(structure->pfnCallback),
                                                "VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter");
            }
        } break;

        // Validation code for VkPipelineRasterizationStateRasterizationOrderAMD structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {  // Covers
                                                                                        // VUID-VkPipelineRasterizationStateRasterizationOrderAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_rasterization_order)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD), but its parent extension "
                    "VK_AMD_rasterization_order has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationStateRasterizationOrderAMD);
                VkPipelineRasterizationStateRasterizationOrderAMD* structure =
                    (VkPipelineRasterizationStateRasterizationOrderAMD*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::rasterizationOrder), vvl::Enum::VkRasterizationOrderAMD,
                                           structure->rasterizationOrder,
                                           "VUID-VkPipelineRasterizationStateRasterizationOrderAMD-rasterizationOrder-parameter");
            }
        } break;

        // Validation code for VkDedicatedAllocationImageCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {  // Covers
                                                                             // VUID-VkDedicatedAllocationImageCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_dedicated_allocation)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_dedicated_allocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDedicatedAllocationImageCreateInfoNV);
                VkDedicatedAllocationImageCreateInfoNV* structure = (VkDedicatedAllocationImageCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dedicatedAllocation), structure->dedicatedAllocation);
            }
        } break;

        // Validation code for VkDedicatedAllocationBufferCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {  // Covers
                                                                              // VUID-VkDedicatedAllocationBufferCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_dedicated_allocation)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_dedicated_allocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDedicatedAllocationBufferCreateInfoNV);
                VkDedicatedAllocationBufferCreateInfoNV* structure = (VkDedicatedAllocationBufferCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dedicatedAllocation), structure->dedicatedAllocation);
            }
        } break;

        // Validation code for VkDedicatedAllocationMemoryAllocateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: {  // Covers
                                                                                // VUID-VkDedicatedAllocationMemoryAllocateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_dedicated_allocation)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV), but its parent extension "
                                     "VK_NV_dedicated_allocation has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineRasterizationStateStreamCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {  // Covers
                                                                                       // VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_transform_feedback)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_transform_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationStateStreamCreateInfoEXT);
                VkPipelineRasterizationStateStreamCreateInfoEXT* structure =
                    (VkPipelineRasterizationStateStreamCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-flags-zerobitmask");
            }
        } break;

        // Validation code for VkCuModuleTexturingModeCreateInfoNVX structure members
        case VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX: {  // Covers
                                                                            // VUID-VkCuModuleTexturingModeCreateInfoNVX-sType-sType

            if (!IsExtEnabled(extensions.vk_nvx_binary_import)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX), but its parent extension "
                                     "VK_NVX_binary_import has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkCuModuleTexturingModeCreateInfoNVX);
                VkCuModuleTexturingModeCreateInfoNVX* structure = (VkCuModuleTexturingModeCreateInfoNVX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::use64bitTexturing), structure->use64bitTexturing);
            }
        } break;

        // Validation code for VkTextureLODGatherFormatPropertiesAMD structure members
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: {  // Covers
                                                                            // VUID-VkTextureLODGatherFormatPropertiesAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_texture_gather_bias_lod)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD), but its parent extension "
                                     "VK_AMD_texture_gather_bias_lod has not been enabled.");
            }
        } break;

        // Validation code for VkExternalMemoryImageCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {  // Covers VUID-VkExternalMemoryImageCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_external_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryImageCreateInfoNV);
                VkExternalMemoryImageCreateInfoNV* structure = (VkExternalMemoryImageCreateInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                      AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExternalMemoryImageCreateInfoNV-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportMemoryAllocateInfoNV structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {  // Covers VUID-VkExportMemoryAllocateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_external_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV), "
                                     "but its parent extension "
                                     "VK_NV_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMemoryAllocateInfoNV);
                VkExportMemoryAllocateInfoNV* structure = (VkExportMemoryAllocateInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                      AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleTypes, kOptionalFlags,
                                      "VUID-VkExportMemoryAllocateInfoNV-handleTypes-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryWin32HandleInfoNV structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: {  // Covers VUID-VkImportMemoryWin32HandleInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_external_memory_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV), but its parent extension "
                                     "VK_NV_external_memory_win32 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryWin32HandleInfoNV);
                VkImportMemoryWin32HandleInfoNV* structure = (VkImportMemoryWin32HandleInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                      AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleType, kOptionalFlags,
                                      "VUID-VkImportMemoryWin32HandleInfoNV-handleType-parameter");
            }
        } break;

        // Validation code for VkExportMemoryWin32HandleInfoNV structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: {  // Covers VUID-VkExportMemoryWin32HandleInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_external_memory_win32)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV), but its parent extension "
                                     "VK_NV_external_memory_win32 has not been enabled.");
            }
        } break;

        // Validation code for VkWin32KeyedMutexAcquireReleaseInfoNV structure members
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: {  // Covers
                                                                             // VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_win32_keyed_mutex)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV), but its parent extension "
                                     "VK_NV_win32_keyed_mutex has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWin32KeyedMutexAcquireReleaseInfoNV);
                VkWin32KeyedMutexAcquireReleaseInfoNV* structure = (VkWin32KeyedMutexAcquireReleaseInfoNV*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireSyncs),
                                      structure->acquireCount, &structure->pAcquireSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireKeys),
                                      structure->acquireCount, &structure->pAcquireKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireKeys-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireTimeoutMilliseconds),
                                      structure->acquireCount, &structure->pAcquireTimeoutMilliseconds, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireTimeoutMilliseconds-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseSyncs),
                                      structure->releaseCount, &structure->pReleaseSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseKeys),
                                      structure->releaseCount, &structure->pReleaseKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseKeys-parameter");
            }
        } break;
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkValidationFlagsEXT structure members
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {  // Covers VUID-VkValidationFlagsEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_validation_flags)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT), but its parent extension "
                    "VK_EXT_validation_flags has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkValidationFlagsEXT);
                VkValidationFlagsEXT* structure = (VkValidationFlagsEXT*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::disabledValidationCheckCount),
                                                pNext_loc.dot(Field::pDisabledValidationChecks), vvl::Enum::VkValidationCheckEXT,
                                                structure->disabledValidationCheckCount, structure->pDisabledValidationChecks, true,
                                                true, "VUID-VkValidationFlagsEXT-disabledValidationCheckCount-arraylength",
                                                "VUID-VkValidationFlagsEXT-pDisabledValidationChecks-parameter");
            }
        } break;

        // Validation code for VkImageViewASTCDecodeModeEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {  // Covers VUID-VkImageViewASTCDecodeModeEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_astc_decode_mode)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_astc_decode_mode has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageViewASTCDecodeModeEXT);
                VkImageViewASTCDecodeModeEXT* structure = (VkImageViewASTCDecodeModeEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::decodeMode), vvl::Enum::VkFormat, structure->decodeMode,
                                           "VUID-VkImageViewASTCDecodeModeEXT-decodeMode-parameter");
            }
        } break;

        // Validation code for VkCommandBufferInheritanceConditionalRenderingInfoEXT structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {  // Covers
                                                                                             // VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_conditional_rendering)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT), but its parent extension "
                    "VK_EXT_conditional_rendering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkCommandBufferInheritanceConditionalRenderingInfoEXT);
                VkCommandBufferInheritanceConditionalRenderingInfoEXT* structure =
                    (VkCommandBufferInheritanceConditionalRenderingInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::conditionalRenderingEnable), structure->conditionalRenderingEnable);
            }
        } break;

        // Validation code for VkPipelineViewportWScalingStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {  // Covers
                                                                                    // VUID-VkPipelineViewportWScalingStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_clip_space_w_scaling)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV), but its parent extension "
                                 "VK_NV_clip_space_w_scaling has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportWScalingStateCreateInfoNV);
                VkPipelineViewportWScalingStateCreateInfoNV* structure = (VkPipelineViewportWScalingStateCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::viewportWScalingEnable), structure->viewportWScalingEnable);

                skip |= ValidateArray(pNext_loc.dot(Field::viewportCount), loc, structure->viewportCount,
                                      &structure->pViewportWScalings, true, false,
                                      "VUID-VkPipelineViewportWScalingStateCreateInfoNV-viewportCount-arraylength", kVUIDUndefined);
            }
        } break;

        // Validation code for VkSwapchainCounterCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {  // Covers VUID-VkSwapchainCounterCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_display_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_display_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainCounterCreateInfoEXT);
                VkSwapchainCounterCreateInfoEXT* structure = (VkSwapchainCounterCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::surfaceCounters), vvl::FlagBitmask::VkSurfaceCounterFlagBitsEXT,
                                      AllVkSurfaceCounterFlagBitsEXT, structure->surfaceCounters, kOptionalFlags,
                                      "VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter");
            }
        } break;

        // Validation code for VkPresentTimesInfoGOOGLE structure members
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: {  // Covers VUID-VkPresentTimesInfoGOOGLE-sType-sType

            if (!IsExtEnabled(extensions.vk_google_display_timing)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE), but "
                                     "its parent extension "
                                     "VK_GOOGLE_display_timing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPresentTimesInfoGOOGLE);
                VkPresentTimesInfoGOOGLE* structure = (VkPresentTimesInfoGOOGLE*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pTimes), structure->swapchainCount,
                                      &structure->pTimes, true, false, "VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength",
                                      "VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter");

                if (structure->pTimes != nullptr) {
                    for (uint32_t swapchainIndex = 0; swapchainIndex < structure->swapchainCount; ++swapchainIndex) {
                        [[maybe_unused]] const Location pTimes_loc = pNext_loc.dot(Field::pTimes, swapchainIndex);
                    }
                }
            }
        } break;

        // Validation code for VkMultiviewPerViewAttributesInfoNVX structure members
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: {  // Covers
                                                                          // VUID-VkMultiviewPerViewAttributesInfoNVX-sType-sType

            if (!IsExtEnabled(extensions.vk_nvx_multiview_per_view_attributes)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX), but its parent extension "
                                     "VK_NVX_multiview_per_view_attributes has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMultiviewPerViewAttributesInfoNVX);
                VkMultiviewPerViewAttributesInfoNVX* structure = (VkMultiviewPerViewAttributesInfoNVX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::perViewAttributes), structure->perViewAttributes);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::perViewAttributesPositionXOnly), structure->perViewAttributesPositionXOnly);
            }
        } break;

        // Validation code for VkPipelineViewportSwizzleStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {  // Covers
                                                                                  // VUID-VkPipelineViewportSwizzleStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_viewport_swizzle)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_viewport_swizzle has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportSwizzleStateCreateInfoNV);
                VkPipelineViewportSwizzleStateCreateInfoNV* structure = (VkPipelineViewportSwizzleStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateArray(pNext_loc.dot(Field::viewportCount), pNext_loc.dot(Field::pViewportSwizzles),
                                      structure->viewportCount, &structure->pViewportSwizzles, true, true,
                                      "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-arraylength",
                                      "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-pViewportSwizzles-parameter");

                if (structure->pViewportSwizzles != nullptr) {
                    for (uint32_t viewportIndex = 0; viewportIndex < structure->viewportCount; ++viewportIndex) {
                        [[maybe_unused]] const Location pViewportSwizzles_loc =
                            pNext_loc.dot(Field::pViewportSwizzles, viewportIndex);
                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::x), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].x,
                                                   "VUID-VkViewportSwizzleNV-x-parameter");

                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::y), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].y,
                                                   "VUID-VkViewportSwizzleNV-y-parameter");

                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::z), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].z,
                                                   "VUID-VkViewportSwizzleNV-z-parameter");

                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::w), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].w,
                                                   "VUID-VkViewportSwizzleNV-w-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkPipelineDiscardRectangleStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                    // VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_discard_rectangles)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT), but its parent extension "
                                 "VK_EXT_discard_rectangles has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineDiscardRectangleStateCreateInfoEXT);
                VkPipelineDiscardRectangleStateCreateInfoEXT* structure = (VkPipelineDiscardRectangleStateCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::discardRectangleMode), vvl::Enum::VkDiscardRectangleModeEXT,
                                           structure->discardRectangleMode,
                                           "VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleMode-parameter");
            }
        } break;

        // Validation code for VkPipelineRasterizationConservativeStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                             // VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_conservative_rasterization)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_conservative_rasterization has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPipelineRasterizationConservativeStateCreateInfoEXT);
                VkPipelineRasterizationConservativeStateCreateInfoEXT* structure =
                    (VkPipelineRasterizationConservativeStateCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::conservativeRasterizationMode), vvl::Enum::VkConservativeRasterizationModeEXT,
                    structure->conservativeRasterizationMode,
                    "VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-conservativeRasterizationMode-parameter");
            }
        } break;

        // Validation code for VkPipelineRasterizationDepthClipStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                           // VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_clip_enable)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_depth_clip_enable has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationDepthClipStateCreateInfoEXT);
                VkPipelineRasterizationDepthClipStateCreateInfoEXT* structure =
                    (VkPipelineRasterizationDepthClipStateCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateBool32(pNext_loc.dot(Field::depthClipEnable), structure->depthClipEnable);
            }
        } break;

        // Validation code for VkDebugUtilsObjectNameInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {  // Covers VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_debug_utils)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT), but its parent extension "
                                     "VK_EXT_debug_utils has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDebugUtilsObjectNameInfoEXT);
                VkDebugUtilsObjectNameInfoEXT* structure = (VkDebugUtilsObjectNameInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::objectType), vvl::Enum::VkObjectType, structure->objectType,
                                           "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter");
            }
        } break;

        // Validation code for VkDebugUtilsMessengerCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: {  // Covers
                                                                         // VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_debug_utils)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_debug_utils has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDebugUtilsMessengerCreateInfoEXT);
                VkDebugUtilsMessengerCreateInfoEXT* structure = (VkDebugUtilsMessengerCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::messageSeverity), vvl::FlagBitmask::VkDebugUtilsMessageSeverityFlagBitsEXT,
                                  AllVkDebugUtilsMessageSeverityFlagBitsEXT, structure->messageSeverity, kRequiredFlags,
                                  "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter",
                                  "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask");

                skip |= ValidateFlags(pNext_loc.dot(Field::messageType), vvl::FlagBitmask::VkDebugUtilsMessageTypeFlagBitsEXT,
                                      AllVkDebugUtilsMessageTypeFlagBitsEXT, structure->messageType, kRequiredFlags,
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter",
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pfnUserCallback),
                                                reinterpret_cast<const void*>(structure->pfnUserCallback),
                                                "VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkAndroidHardwareBufferUsageANDROID structure members
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: {  // Covers
                                                                         // VUID-VkAndroidHardwareBufferUsageANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID), but its parent extension "
                                     "VK_ANDROID_external_memory_android_hardware_buffer has not been enabled.");
            }
        } break;

        // Validation code for VkAndroidHardwareBufferFormatPropertiesANDROID structure members
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: {  // Covers
                                                                                     // VUID-VkAndroidHardwareBufferFormatPropertiesANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID), but its parent extension "
                                 "VK_ANDROID_external_memory_android_hardware_buffer has not been enabled.");
            }
        } break;

        // Validation code for VkImportAndroidHardwareBufferInfoANDROID structure members
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: {  // Covers
                                                                               // VUID-VkImportAndroidHardwareBufferInfoANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID), but its parent extension "
                                     "VK_ANDROID_external_memory_android_hardware_buffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportAndroidHardwareBufferInfoANDROID);
                VkImportAndroidHardwareBufferInfoANDROID* structure = (VkImportAndroidHardwareBufferInfoANDROID*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::buffer), structure->buffer,
                                                "VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-parameter");
            }
        } break;

        // Validation code for VkExternalFormatANDROID structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: {  // Covers VUID-VkExternalFormatANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID), but its parent extension "
                    "VK_ANDROID_external_memory_android_hardware_buffer has not been enabled.");
            }
        } break;

        // Validation code for VkAndroidHardwareBufferFormatProperties2ANDROID structure members
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID: {  // Covers
                                                                                       // VUID-VkAndroidHardwareBufferFormatProperties2ANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID), but its parent extension "
                    "VK_ANDROID_external_memory_android_hardware_buffer has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPipelineShaderStageNodeCreateInfoAMDX structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX: {  // Covers
                                                                               // VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType

            if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX), but its parent extension "
                                     "VK_AMDX_shader_enqueue has not been enabled.");
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkAttachmentSampleCountInfoAMD structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: {  // Covers VUID-VkAttachmentSampleCountInfoAMD-sType-sType

            if ((!IsExtEnabled(extensions.vk_amd_mixed_attachment_samples)) &&
                (!IsExtEnabled(extensions.vk_nv_framebuffer_mixed_samples))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD), but its parent extension "
                                     "VK_AMD_mixed_attachment_samples, or VK_NV_framebuffer_mixed_samples has not been enabled.");
            }
        } break;

        // Validation code for VkSampleLocationsInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {  // Covers VUID-VkSampleLocationsInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_sample_locations)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_sample_locations has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSampleLocationsInfoEXT);
                VkSampleLocationsInfoEXT* structure = (VkSampleLocationsInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::sampleLocationsCount), pNext_loc.dot(Field::pSampleLocations),
                                      structure->sampleLocationsCount, &structure->pSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                if (structure->pSampleLocations != nullptr) {
                    for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < structure->sampleLocationsCount;
                         ++sampleLocationsIndex) {
                        [[maybe_unused]] const Location pSampleLocations_loc =
                            pNext_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassSampleLocationsBeginInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {  // Covers
                                                                               // VUID-VkRenderPassSampleLocationsBeginInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_sample_locations)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT), but its parent extension "
                                     "VK_EXT_sample_locations has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassSampleLocationsBeginInfoEXT);
                VkRenderPassSampleLocationsBeginInfoEXT* structure = (VkRenderPassSampleLocationsBeginInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::attachmentInitialSampleLocationsCount),
                                      pNext_loc.dot(Field::pAttachmentInitialSampleLocations),
                                      structure->attachmentInitialSampleLocationsCount,
                                      &structure->pAttachmentInitialSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassSampleLocationsBeginInfoEXT-pAttachmentInitialSampleLocations-parameter");

                if (structure->pAttachmentInitialSampleLocations != nullptr) {
                    for (uint32_t attachmentInitialSampleLocationsIndex = 0;
                         attachmentInitialSampleLocationsIndex < structure->attachmentInitialSampleLocationsCount;
                         ++attachmentInitialSampleLocationsIndex) {
                        [[maybe_unused]] const Location pAttachmentInitialSampleLocations_loc =
                            pNext_loc.dot(Field::pAttachmentInitialSampleLocations, attachmentInitialSampleLocationsIndex);
                        skip |=
                            ValidateStructType(pAttachmentInitialSampleLocations_loc.dot(Field::sampleLocationsInfo),
                                               &(structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                                     .sampleLocationsInfo),
                                               VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined,
                                               "VUID-VkSampleLocationsInfoEXT-sType-sType");

                        skip |=
                            ValidateArray(pAttachmentInitialSampleLocations_loc.dot(Field::sampleLocationsCount),
                                          pAttachmentInitialSampleLocations_loc.dot(Field::pSampleLocations),
                                          structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                              .sampleLocationsInfo.sampleLocationsCount,
                                          &structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                               .sampleLocationsInfo.pSampleLocations,
                                          false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                        if (structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                .sampleLocationsInfo.pSampleLocations != nullptr) {
                            for (uint32_t sampleLocationsIndex = 0;
                                 sampleLocationsIndex <
                                 structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                     .sampleLocationsInfo.sampleLocationsCount;
                                 ++sampleLocationsIndex) {
                                [[maybe_unused]] const Location pSampleLocations_loc =
                                    pAttachmentInitialSampleLocations_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                            }
                        }
                    }
                }

                skip |= ValidateArray(pNext_loc.dot(Field::postSubpassSampleLocationsCount),
                                      pNext_loc.dot(Field::pPostSubpassSampleLocations), structure->postSubpassSampleLocationsCount,
                                      &structure->pPostSubpassSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassSampleLocationsBeginInfoEXT-pPostSubpassSampleLocations-parameter");

                if (structure->pPostSubpassSampleLocations != nullptr) {
                    for (uint32_t postSubpassSampleLocationsIndex = 0;
                         postSubpassSampleLocationsIndex < structure->postSubpassSampleLocationsCount;
                         ++postSubpassSampleLocationsIndex) {
                        [[maybe_unused]] const Location pPostSubpassSampleLocations_loc =
                            pNext_loc.dot(Field::pPostSubpassSampleLocations, postSubpassSampleLocationsIndex);
                        skip |= ValidateStructType(
                            pPostSubpassSampleLocations_loc.dot(Field::sampleLocationsInfo),
                            &(structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo),
                            VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined,
                            "VUID-VkSampleLocationsInfoEXT-sType-sType");

                        skip |=
                            ValidateArray(pPostSubpassSampleLocations_loc.dot(Field::sampleLocationsCount),
                                          pPostSubpassSampleLocations_loc.dot(Field::pSampleLocations),
                                          structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                              .sampleLocationsInfo.sampleLocationsCount,
                                          &structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                               .sampleLocationsInfo.pSampleLocations,
                                          false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                        if (structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                .sampleLocationsInfo.pSampleLocations != nullptr) {
                            for (uint32_t sampleLocationsIndex = 0;
                                 sampleLocationsIndex < structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                                            .sampleLocationsInfo.sampleLocationsCount;
                                 ++sampleLocationsIndex) {
                                [[maybe_unused]] const Location pSampleLocations_loc =
                                    pPostSubpassSampleLocations_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkPipelineSampleLocationsStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                   // VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_sample_locations)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT), but its parent extension "
                                 "VK_EXT_sample_locations has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineSampleLocationsStateCreateInfoEXT);
                VkPipelineSampleLocationsStateCreateInfoEXT* structure = (VkPipelineSampleLocationsStateCreateInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::sampleLocationsEnable), structure->sampleLocationsEnable);

                skip |= ValidateStructType(pNext_loc.dot(Field::sampleLocationsInfo), &(structure->sampleLocationsInfo),
                                           VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined,
                                           "VUID-VkSampleLocationsInfoEXT-sType-sType");

                skip |= ValidateArray(pNext_loc.dot(Field::sampleLocationsCount), pNext_loc.dot(Field::pSampleLocations),
                                      structure->sampleLocationsInfo.sampleLocationsCount,
                                      &structure->sampleLocationsInfo.pSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                if (structure->sampleLocationsInfo.pSampleLocations != nullptr) {
                    for (uint32_t sampleLocationsIndex = 0;
                         sampleLocationsIndex < structure->sampleLocationsInfo.sampleLocationsCount; ++sampleLocationsIndex) {
                        [[maybe_unused]] const Location pSampleLocations_loc =
                            pNext_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                    }
                }
            }
        } break;

        // Validation code for VkPipelineColorBlendAdvancedStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                       // VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_blend_operation_advanced)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_blend_operation_advanced has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineColorBlendAdvancedStateCreateInfoEXT);
                VkPipelineColorBlendAdvancedStateCreateInfoEXT* structure = (VkPipelineColorBlendAdvancedStateCreateInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::srcPremultiplied), structure->srcPremultiplied);

                skip |= ValidateBool32(pNext_loc.dot(Field::dstPremultiplied), structure->dstPremultiplied);

                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::blendOverlap), vvl::Enum::VkBlendOverlapEXT, structure->blendOverlap,
                                       "VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-parameter");
            }
        } break;

        // Validation code for VkPipelineCoverageToColorStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {  // Covers
                                                                                   // VUID-VkPipelineCoverageToColorStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_fragment_coverage_to_color)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV), but its parent extension "
                                 "VK_NV_fragment_coverage_to_color has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCoverageToColorStateCreateInfoNV);
                VkPipelineCoverageToColorStateCreateInfoNV* structure = (VkPipelineCoverageToColorStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineCoverageToColorStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateBool32(pNext_loc.dot(Field::coverageToColorEnable), structure->coverageToColorEnable);
            }
        } break;

        // Validation code for VkPipelineCoverageModulationStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {  // Covers
                                                                                     // VUID-VkPipelineCoverageModulationStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_framebuffer_mixed_samples)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV), but its parent extension "
                                 "VK_NV_framebuffer_mixed_samples has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCoverageModulationStateCreateInfoNV);
                VkPipelineCoverageModulationStateCreateInfoNV* structure = (VkPipelineCoverageModulationStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineCoverageModulationStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::coverageModulationMode), vvl::Enum::VkCoverageModulationModeNV,
                                           structure->coverageModulationMode,
                                           "VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationMode-parameter");

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::coverageModulationTableEnable), structure->coverageModulationTableEnable);
            }
        } break;

        // Validation code for VkDrmFormatModifierPropertiesListEXT structure members
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: {  // Covers
                                                                           // VUID-VkDrmFormatModifierPropertiesListEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_drm_format_modifier)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT), but its parent extension "
                                     "VK_EXT_image_drm_format_modifier has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceImageDrmFormatModifierInfoEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_drm_format_modifier)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT), but its parent extension "
                                 "VK_EXT_image_drm_format_modifier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
                VkPhysicalDeviceImageDrmFormatModifierInfoEXT* structure = (VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode, structure->sharingMode,
                                           "VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-parameter");
            }
        } break;

        // Validation code for VkImageDrmFormatModifierListCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: {  // Covers
                                                                                  // VUID-VkImageDrmFormatModifierListCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_drm_format_modifier)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_image_drm_format_modifier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageDrmFormatModifierListCreateInfoEXT);
                VkImageDrmFormatModifierListCreateInfoEXT* structure = (VkImageDrmFormatModifierListCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::drmFormatModifierCount), pNext_loc.dot(Field::pDrmFormatModifiers),
                                      structure->drmFormatModifierCount, &structure->pDrmFormatModifiers, true, true,
                                      "VUID-VkImageDrmFormatModifierListCreateInfoEXT-drmFormatModifierCount-arraylength",
                                      "VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-parameter");
            }
        } break;

        // Validation code for VkImageDrmFormatModifierExplicitCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: {  // Covers
                                                                                      // VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_drm_format_modifier)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT), but its parent extension "
                                 "VK_EXT_image_drm_format_modifier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageDrmFormatModifierExplicitCreateInfoEXT);
                VkImageDrmFormatModifierExplicitCreateInfoEXT* structure = (VkImageDrmFormatModifierExplicitCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::drmFormatModifierPlaneCount), pNext_loc.dot(Field::pPlaneLayouts),
                                      structure->drmFormatModifierPlaneCount, &structure->pPlaneLayouts, true, true,
                                      "VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifierPlaneCount-arraylength",
                                      "VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-pPlaneLayouts-parameter");

                if (structure->pPlaneLayouts != nullptr) {
                    for (uint32_t drmFormatModifierPlaneIndex = 0;
                         drmFormatModifierPlaneIndex < structure->drmFormatModifierPlaneCount; ++drmFormatModifierPlaneIndex) {
                        [[maybe_unused]] const Location pPlaneLayouts_loc =
                            pNext_loc.dot(Field::pPlaneLayouts, drmFormatModifierPlaneIndex);
                    }
                }
            }
        } break;

        // Validation code for VkDrmFormatModifierPropertiesList2EXT structure members
        case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT: {  // Covers
                                                                             // VUID-VkDrmFormatModifierPropertiesList2EXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_drm_format_modifier)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT), but its parent extension "
                                     "VK_EXT_image_drm_format_modifier has not been enabled.");
            }
        } break;

        // Validation code for VkShaderModuleValidationCacheCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {  // Covers
                                                                                  // VUID-VkShaderModuleValidationCacheCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_validation_cache)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_validation_cache has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkShaderModuleValidationCacheCreateInfoEXT);
                VkShaderModuleValidationCacheCreateInfoEXT* structure = (VkShaderModuleValidationCacheCreateInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::validationCache), structure->validationCache);
            }
        } break;

        // Validation code for VkPipelineViewportShadingRateImageStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {  // Covers
                                                                                             // VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_shading_rate_image)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV), but its parent extension "
                    "VK_NV_shading_rate_image has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportShadingRateImageStateCreateInfoNV);
                VkPipelineViewportShadingRateImageStateCreateInfoNV* structure =
                    (VkPipelineViewportShadingRateImageStateCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shadingRateImageEnable), structure->shadingRateImageEnable);
            }
        } break;

        // Validation code for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {  // Covers
                                                                                              // VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_shading_rate_image)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV), but its parent extension "
                    "VK_NV_shading_rate_image has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);
                VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* structure =
                    (VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::sampleOrderType), vvl::Enum::VkCoarseSampleOrderTypeNV,
                                           structure->sampleOrderType,
                                           "VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::customSampleOrderCount), pNext_loc.dot(Field::pCustomSampleOrders),
                                  structure->customSampleOrderCount, &structure->pCustomSampleOrders, false, true, kVUIDUndefined,
                                  "VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-parameter");

                if (structure->pCustomSampleOrders != nullptr) {
                    for (uint32_t customSampleOrderIndex = 0; customSampleOrderIndex < structure->customSampleOrderCount;
                         ++customSampleOrderIndex) {
                        [[maybe_unused]] const Location pCustomSampleOrders_loc =
                            pNext_loc.dot(Field::pCustomSampleOrders, customSampleOrderIndex);
                        skip |= ValidateRangedEnum(pCustomSampleOrders_loc.dot(Field::shadingRate),
                                                   vvl::Enum::VkShadingRatePaletteEntryNV,
                                                   structure->pCustomSampleOrders[customSampleOrderIndex].shadingRate,
                                                   "VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter");

                        skip |= ValidateArray(pCustomSampleOrders_loc.dot(Field::sampleLocationCount),
                                              pCustomSampleOrders_loc.dot(Field::pSampleLocations),
                                              structure->pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount,
                                              &structure->pCustomSampleOrders[customSampleOrderIndex].pSampleLocations, true, true,
                                              "VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength",
                                              "VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter");

                        if (structure->pCustomSampleOrders[customSampleOrderIndex].pSampleLocations != nullptr) {
                            for (uint32_t sampleLocationIndex = 0;
                                 sampleLocationIndex < structure->pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount;
                                 ++sampleLocationIndex) {
                                [[maybe_unused]] const Location pSampleLocations_loc =
                                    pCustomSampleOrders_loc.dot(Field::pSampleLocations, sampleLocationIndex);
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkWriteDescriptorSetAccelerationStructureNV structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {  // Covers
                                                                                  // VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV), but its parent extension "
                                     "VK_NV_ray_tracing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWriteDescriptorSetAccelerationStructureNV);
                VkWriteDescriptorSetAccelerationStructureNV* structure = (VkWriteDescriptorSetAccelerationStructureNV*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::accelerationStructureCount), pNext_loc.dot(Field::pAccelerationStructures),
                                  structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false,
                                  "VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength",
                                  "VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter");
            }
        } break;

        // Validation code for VkPipelineRepresentativeFragmentTestStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {  // Covers
                                                                                              // VUID-VkPipelineRepresentativeFragmentTestStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_representative_fragment_test)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV), but its parent extension "
                    "VK_NV_representative_fragment_test has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPipelineRepresentativeFragmentTestStateCreateInfoNV);
                VkPipelineRepresentativeFragmentTestStateCreateInfoNV* structure =
                    (VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::representativeFragmentTestEnable),
                                       structure->representativeFragmentTestEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageViewImageFormatInfoEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_filter_cubic)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT), but its parent extension "
                                 "VK_EXT_filter_cubic has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageViewImageFormatInfoEXT);
                VkPhysicalDeviceImageViewImageFormatInfoEXT* structure = (VkPhysicalDeviceImageViewImageFormatInfoEXT*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::imageViewType), vvl::Enum::VkImageViewType, structure->imageViewType,
                                       "VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-imageViewType-parameter");
            }
        } break;

        // Validation code for VkFilterCubicImageViewImageFormatPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: {  // Covers
                                                                                       // VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_filter_cubic)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT), but its parent extension "
                    "VK_EXT_filter_cubic has not been enabled.");
            }
        } break;

        // Validation code for VkImportMemoryHostPointerInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: {  // Covers VUID-VkImportMemoryHostPointerInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_external_memory_host)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT), but its parent extension "
                                     "VK_EXT_external_memory_host has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryHostPointerInfoEXT);
                VkImportMemoryHostPointerInfoEXT* structure = (VkImportMemoryHostPointerInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kRequiredSingleBit,
                                      "VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter",
                                      "VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pHostPointer), structure->pHostPointer,
                                                "VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-parameter");
            }
        } break;

        // Validation code for VkPipelineCompilerControlCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {  // Covers
                                                                             // VUID-VkPipelineCompilerControlCreateInfoAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_pipeline_compiler_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD), but its parent extension "
                                     "VK_AMD_pipeline_compiler_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCompilerControlCreateInfoAMD);
                VkPipelineCompilerControlCreateInfoAMD* structure = (VkPipelineCompilerControlCreateInfoAMD*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::compilerControlFlags), structure->compilerControlFlags,
                                              "VUID-VkPipelineCompilerControlCreateInfoAMD-compilerControlFlags-zerobitmask");
            }
        } break;

        // Validation code for VkDeviceMemoryOverallocationCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {  // Covers
                                                                                // VUID-VkDeviceMemoryOverallocationCreateInfoAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_memory_overallocation_behavior)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD), but its parent extension "
                                     "VK_AMD_memory_overallocation_behavior has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceMemoryOverallocationCreateInfoAMD);
                VkDeviceMemoryOverallocationCreateInfoAMD* structure = (VkDeviceMemoryOverallocationCreateInfoAMD*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::overallocationBehavior),
                                           vvl::Enum::VkMemoryOverallocationBehaviorAMD, structure->overallocationBehavior,
                                           "VUID-VkDeviceMemoryOverallocationCreateInfoAMD-overallocationBehavior-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_GGP

        // Validation code for VkPresentFrameTokenGGP structure members
        case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: {  // Covers VUID-VkPresentFrameTokenGGP-sType-sType

            if (!IsExtEnabled(extensions.vk_ggp_frame_token)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP), but its parent extension "
                    "VK_GGP_frame_token has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_GGP

        // Validation code for VkPipelineViewportExclusiveScissorStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV: {  // Covers
                                                                                            // VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_scissor_exclusive)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV), but its parent extension "
                    "VK_NV_scissor_exclusive has not been enabled.");
            }
        } break;

        // Validation code for VkQueueFamilyCheckpointPropertiesNV structure members
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: {  // Covers
                                                                         // VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_diagnostic_checkpoints)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV), but its parent extension "
                                     "VK_NV_device_diagnostic_checkpoints has not been enabled.");
            }
        } break;

        // Validation code for VkQueueFamilyCheckpointProperties2NV structure members
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: {  // Covers
                                                                           // VUID-VkQueueFamilyCheckpointProperties2NV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_diagnostic_checkpoints)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV), but its parent extension "
                                     "VK_NV_device_diagnostic_checkpoints has not been enabled.");
            }
        } break;

        // Validation code for VkQueryPoolPerformanceQueryCreateInfoINTEL structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {  // Covers
                                                                                  // VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-sType-sType

            if (!IsExtEnabled(extensions.vk_intel_performance_query)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL), but its parent extension "
                                     "VK_INTEL_performance_query has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryPoolPerformanceQueryCreateInfoINTEL);
                VkQueryPoolPerformanceQueryCreateInfoINTEL* structure = (VkQueryPoolPerformanceQueryCreateInfoINTEL*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::performanceCountersSampling),
                                           vvl::Enum::VkQueryPoolSamplingModeINTEL, structure->performanceCountersSampling,
                                           "VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-performanceCountersSampling-parameter");
            }
        } break;

        // Validation code for VkDisplayNativeHdrSurfaceCapabilitiesAMD structure members
        case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: {  // Covers
                                                                               // VUID-VkDisplayNativeHdrSurfaceCapabilitiesAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_display_native_hdr)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD), but its parent extension "
                                     "VK_AMD_display_native_hdr has not been enabled.");
            }
        } break;

        // Validation code for VkSwapchainDisplayNativeHdrCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: {  // Covers
                                                                                // VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-sType-sType

            if (!IsExtEnabled(extensions.vk_amd_display_native_hdr)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD), but its parent extension "
                                     "VK_AMD_display_native_hdr has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainDisplayNativeHdrCreateInfoAMD);
                VkSwapchainDisplayNativeHdrCreateInfoAMD* structure = (VkSwapchainDisplayNativeHdrCreateInfoAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::localDimmingEnable), structure->localDimmingEnable);
            }
        } break;

        // Validation code for VkRenderPassFragmentDensityMapCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {  // Covers
                                                                                    // VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_fragment_density_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT), but its parent extension "
                                 "VK_EXT_fragment_density_map has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassFragmentDensityMapCreateInfoEXT);
                VkRenderPassFragmentDensityMapCreateInfoEXT* structure = (VkRenderPassFragmentDensityMapCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                           structure->fragmentDensityMapAttachment.layout,
                                           "VUID-VkAttachmentReference-layout-parameter");
            }
        } break;

        // Validation code for VkRenderingFragmentDensityMapAttachmentInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: {  // Covers
                                                                                      // VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_fragment_density_map)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT), but its parent extension "
                                 "VK_EXT_fragment_density_map has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderingFragmentDensityMapAttachmentInfoEXT);
                VkRenderingFragmentDensityMapAttachmentInfoEXT* structure = (VkRenderingFragmentDensityMapAttachmentInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::imageView), structure->imageView);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, structure->imageLayout,
                                           "VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageLayout-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceMemoryBudgetPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: {  // Covers
                                                                                // VUID-VkPhysicalDeviceMemoryBudgetPropertiesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_memory_budget)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT), but its parent extension "
                                     "VK_EXT_memory_budget has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryPriorityAllocateInfoEXT structure members
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {  // Covers VUID-VkMemoryPriorityAllocateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_memory_priority)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_memory_priority has not been enabled.");
            }
        } break;

        // Validation code for VkBufferDeviceAddressCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: {  // Covers
                                                                         // VUID-VkBufferDeviceAddressCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_buffer_device_address)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_buffer_device_address has not been enabled.");
            }
        } break;

        // Validation code for VkValidationFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {  // Covers VUID-VkValidationFeaturesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_validation_features)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT), but its parent extension "
                    "VK_EXT_validation_features has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkValidationFeaturesEXT);
                VkValidationFeaturesEXT* structure = (VkValidationFeaturesEXT*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::enabledValidationFeatureCount),
                                                pNext_loc.dot(Field::pEnabledValidationFeatures),
                                                vvl::Enum::VkValidationFeatureEnableEXT, structure->enabledValidationFeatureCount,
                                                structure->pEnabledValidationFeatures, false, true, kVUIDUndefined,
                                                "VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-parameter");

                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::disabledValidationFeatureCount),
                                                pNext_loc.dot(Field::pDisabledValidationFeatures),
                                                vvl::Enum::VkValidationFeatureDisableEXT, structure->disabledValidationFeatureCount,
                                                structure->pDisabledValidationFeatures, false, true, kVUIDUndefined,
                                                "VUID-VkValidationFeaturesEXT-pDisabledValidationFeatures-parameter");
            }
        } break;

        // Validation code for VkPipelineCoverageReductionStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {  // Covers
                                                                                    // VUID-VkPipelineCoverageReductionStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_coverage_reduction_mode)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV), but its parent extension "
                                 "VK_NV_coverage_reduction_mode has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCoverageReductionStateCreateInfoNV);
                VkPipelineCoverageReductionStateCreateInfoNV* structure = (VkPipelineCoverageReductionStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineCoverageReductionStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::coverageReductionMode), vvl::Enum::VkCoverageReductionModeNV,
                                           structure->coverageReductionMode,
                                           "VUID-VkPipelineCoverageReductionStateCreateInfoNV-coverageReductionMode-parameter");
            }
        } break;

        // Validation code for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                                 // VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_provoking_vertex)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_provoking_vertex has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPipelineRasterizationProvokingVertexStateCreateInfoEXT);
                VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* structure =
                    (VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::provokingVertexMode), vvl::Enum::VkProvokingVertexModeEXT, structure->provokingVertexMode,
                    "VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-provokingVertexMode-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkSurfaceFullScreenExclusiveInfoEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: {  // Covers
                                                                          // VUID-VkSurfaceFullScreenExclusiveInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_full_screen_exclusive)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT), but its parent extension "
                                     "VK_EXT_full_screen_exclusive has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSurfaceFullScreenExclusiveInfoEXT);
                VkSurfaceFullScreenExclusiveInfoEXT* structure = (VkSurfaceFullScreenExclusiveInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::fullScreenExclusive), vvl::Enum::VkFullScreenExclusiveEXT,
                                           structure->fullScreenExclusive,
                                           "VUID-VkSurfaceFullScreenExclusiveInfoEXT-fullScreenExclusive-parameter");
            }
        } break;

        // Validation code for VkSurfaceCapabilitiesFullScreenExclusiveEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: {  // Covers
                                                                                  // VUID-VkSurfaceCapabilitiesFullScreenExclusiveEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_full_screen_exclusive)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT), but its parent extension "
                                     "VK_EXT_full_screen_exclusive has not been enabled.");
            }
        } break;

        // Validation code for VkSurfaceFullScreenExclusiveWin32InfoEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: {  // Covers
                                                                                // VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_full_screen_exclusive)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT), but its parent extension "
                                     "VK_EXT_full_screen_exclusive has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkMemoryMapPlacedInfoEXT structure members
        case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT: {  // Covers VUID-VkMemoryMapPlacedInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_map_memory_placed)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_map_memory_placed has not been enabled.");
            }
        } break;

        // Validation code for VkSurfacePresentModeEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: {  // Covers VUID-VkSurfacePresentModeEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_surface_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT), but "
                                     "its parent extension "
                                     "VK_EXT_surface_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSurfacePresentModeEXT);
                VkSurfacePresentModeEXT* structure = (VkSurfacePresentModeEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::presentMode), vvl::Enum::VkPresentModeKHR, structure->presentMode,
                                           "VUID-VkSurfacePresentModeEXT-presentMode-parameter");
            }
        } break;

        // Validation code for VkSurfacePresentScalingCapabilitiesEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT: {  // Covers
                                                                            // VUID-VkSurfacePresentScalingCapabilitiesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_surface_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT), but its parent extension "
                                     "VK_EXT_surface_maintenance1 has not been enabled.");
            }
        } break;

        // Validation code for VkSurfacePresentModeCompatibilityEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT: {  // Covers
                                                                          // VUID-VkSurfacePresentModeCompatibilityEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_surface_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT), but its parent extension "
                                     "VK_EXT_surface_maintenance1 has not been enabled.");
            }
        } break;

        // Validation code for VkSwapchainPresentFenceInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {  // Covers VUID-VkSwapchainPresentFenceInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_swapchain_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT), but its parent extension "
                                     "VK_EXT_swapchain_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentFenceInfoEXT);
                VkSwapchainPresentFenceInfoEXT* structure = (VkSwapchainPresentFenceInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pFences),
                                      structure->swapchainCount, &structure->pFences, true, false,
                                      "VUID-VkSwapchainPresentFenceInfoEXT-swapchainCount-arraylength",
                                      "VUID-VkSwapchainPresentFenceInfoEXT-pFences-parameter");
            }
        } break;

        // Validation code for VkSwapchainPresentModesCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: {  // Covers
                                                                           // VUID-VkSwapchainPresentModesCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_swapchain_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_swapchain_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentModesCreateInfoEXT);
                VkSwapchainPresentModesCreateInfoEXT* structure = (VkSwapchainPresentModesCreateInfoEXT*)header;
                skip |=
                    ValidateRangedEnumArray(pNext_loc.dot(Field::presentModeCount), pNext_loc.dot(Field::pPresentModes),
                                            vvl::Enum::VkPresentModeKHR, structure->presentModeCount, structure->pPresentModes,
                                            true, true, "VUID-VkSwapchainPresentModesCreateInfoEXT-presentModeCount-arraylength",
                                            "VUID-VkSwapchainPresentModesCreateInfoEXT-pPresentModes-parameter");
            }
        } break;

        // Validation code for VkSwapchainPresentModeInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: {  // Covers VUID-VkSwapchainPresentModeInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_swapchain_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_swapchain_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentModeInfoEXT);
                VkSwapchainPresentModeInfoEXT* structure = (VkSwapchainPresentModeInfoEXT*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pPresentModes),
                                                vvl::Enum::VkPresentModeKHR, structure->swapchainCount, structure->pPresentModes,
                                                true, true, "VUID-VkSwapchainPresentModeInfoEXT-swapchainCount-arraylength",
                                                "VUID-VkSwapchainPresentModeInfoEXT-pPresentModes-parameter");
            }
        } break;

        // Validation code for VkSwapchainPresentScalingCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: {  // Covers
                                                                             // VUID-VkSwapchainPresentScalingCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_swapchain_maintenance1)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_swapchain_maintenance1 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentScalingCreateInfoEXT);
                VkSwapchainPresentScalingCreateInfoEXT* structure = (VkSwapchainPresentScalingCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::scalingBehavior), vvl::FlagBitmask::VkPresentScalingFlagBitsEXT,
                                      AllVkPresentScalingFlagBitsEXT, structure->scalingBehavior, kOptionalFlags,
                                      "VUID-VkSwapchainPresentScalingCreateInfoEXT-scalingBehavior-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::presentGravityX), vvl::FlagBitmask::VkPresentGravityFlagBitsEXT,
                                      AllVkPresentGravityFlagBitsEXT, structure->presentGravityX, kOptionalFlags,
                                      "VUID-VkSwapchainPresentScalingCreateInfoEXT-presentGravityX-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::presentGravityY), vvl::FlagBitmask::VkPresentGravityFlagBitsEXT,
                                      AllVkPresentGravityFlagBitsEXT, structure->presentGravityY, kOptionalFlags,
                                      "VUID-VkSwapchainPresentScalingCreateInfoEXT-presentGravityY-parameter");
            }
        } break;

        // Validation code for VkGraphicsPipelineShaderGroupsCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {  // Covers
                                                                                  // VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_generated_commands)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_device_generated_commands has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGraphicsPipelineShaderGroupsCreateInfoNV);
                VkGraphicsPipelineShaderGroupsCreateInfoNV* structure = (VkGraphicsPipelineShaderGroupsCreateInfoNV*)header;
                skip |=
                    ValidateStructTypeArray(pNext_loc.dot(Field::groupCount), pNext_loc.dot(Field::pGroups), structure->groupCount,
                                            structure->pGroups, VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV, false, true,
                                            "VUID-VkGraphicsShaderGroupCreateInfoNV-sType-sType",
                                            "VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-parameter", kVUIDUndefined);

                if (structure->pGroups != nullptr) {
                    for (uint32_t groupIndex = 0; groupIndex < structure->groupCount; ++groupIndex) {
                        [[maybe_unused]] const Location pGroups_loc = pNext_loc.dot(Field::pGroups, groupIndex);
                        skip |= ValidateStructPnext(pGroups_loc, structure->pGroups[groupIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion,
                                                    "VUID-VkGraphicsShaderGroupCreateInfoNV-pNext-pNext", kVUIDUndefined, true);

                        skip |= ValidateStructTypeArray(pGroups_loc.dot(Field::stageCount), pGroups_loc.dot(Field::pStages),
                                                        structure->pGroups[groupIndex].stageCount,
                                                        structure->pGroups[groupIndex].pStages,
                                                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true,
                                                        "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                                        "VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-parameter",
                                                        "VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-arraylength");

                        if (structure->pGroups[groupIndex].pStages != nullptr) {
                            for (uint32_t stageIndex = 0; stageIndex < structure->pGroups[groupIndex].stageCount; ++stageIndex) {
                                [[maybe_unused]] const Location pStages_loc = pGroups_loc.dot(Field::pStages, stageIndex);
                                constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                                    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                                    VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                                    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                                    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                                    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                                    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                                    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                                skip |= ValidateStructPnext(pStages_loc, structure->pGroups[groupIndex].pStages[stageIndex].pNext,
                                                            allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                            allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                            GeneratedVulkanHeaderVersion,
                                                            "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                            "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

                                skip |= ValidateFlags(pStages_loc.dot(Field::flags),
                                                      vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                                      AllVkPipelineShaderStageCreateFlagBits,
                                                      structure->pGroups[groupIndex].pStages[stageIndex].flags, kOptionalFlags,
                                                      "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                                skip |= ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                                      AllVkShaderStageFlagBits,
                                                      structure->pGroups[groupIndex].pStages[stageIndex].stage, kRequiredSingleBit,
                                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                                skip |= ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                                structure->pGroups[groupIndex].pStages[stageIndex].pName,
                                                                "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                                if (structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                                    [[maybe_unused]] const Location pSpecializationInfo_loc =
                                        pStages_loc.dot(Field::pSpecializationInfo);
                                    skip |= ValidateArray(
                                        pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                        pSpecializationInfo_loc.dot(Field::pMapEntries),
                                        structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                                        &structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false,
                                        true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                                    if (structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries !=
                                        nullptr) {
                                        for (uint32_t mapEntryIndex = 0;
                                             mapEntryIndex <
                                             structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                             ++mapEntryIndex) {
                                            [[maybe_unused]] const Location pMapEntries_loc =
                                                pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                        }
                                    }

                                    skip |= ValidateArray(
                                        pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                        structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                                        &structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true,
                                        kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                                }
                            }
                        }
                    }
                }

                skip |= ValidateArray(pNext_loc.dot(Field::pipelineCount), pNext_loc.dot(Field::pPipelines),
                                      structure->pipelineCount, &structure->pPipelines, false, true, kVUIDUndefined,
                                      "VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-parameter");
            }
        } break;

        // Validation code for VkCommandBufferInheritanceViewportScissorInfoNV structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {  // Covers
                                                                                       // VUID-VkCommandBufferInheritanceViewportScissorInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_inherited_viewport_scissor)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV), but its parent extension "
                    "VK_NV_inherited_viewport_scissor has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkCommandBufferInheritanceViewportScissorInfoNV);
                VkCommandBufferInheritanceViewportScissorInfoNV* structure =
                    (VkCommandBufferInheritanceViewportScissorInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::viewportScissor2D), structure->viewportScissor2D);
            }
        } break;

        // Validation code for VkRenderPassTransformBeginInfoQCOM structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: {  // Covers
                                                                         // VUID-VkRenderPassTransformBeginInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_render_pass_transform)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM), but its parent extension "
                                     "VK_QCOM_render_pass_transform has not been enabled.");
            }
        } break;

        // Validation code for VkCommandBufferInheritanceRenderPassTransformInfoQCOM structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM: {  // Covers
                                                                                              // VUID-VkCommandBufferInheritanceRenderPassTransformInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_render_pass_transform)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM), but its parent extension "
                    "VK_QCOM_render_pass_transform has not been enabled.");
            }
        } break;

        // Validation code for VkDepthBiasRepresentationInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT: {  // Covers VUID-VkDepthBiasRepresentationInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_bias_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT), but its parent extension "
                                     "VK_EXT_depth_bias_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDepthBiasRepresentationInfoEXT);
                VkDepthBiasRepresentationInfoEXT* structure = (VkDepthBiasRepresentationInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::depthBiasRepresentation), vvl::Enum::VkDepthBiasRepresentationEXT,
                                           structure->depthBiasRepresentation,
                                           "VUID-VkDepthBiasRepresentationInfoEXT-depthBiasRepresentation-parameter");

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasExact), structure->depthBiasExact);
            }
        } break;

        // Validation code for VkDeviceDeviceMemoryReportCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: {  // Covers
                                                                               // VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_memory_report)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_device_memory_report has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceDeviceMemoryReportCreateInfoEXT);
                VkDeviceDeviceMemoryReportCreateInfoEXT* structure = (VkDeviceDeviceMemoryReportCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pfnUserCallback),
                                                reinterpret_cast<const void*>(structure->pfnUserCallback),
                                                "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pfnUserCallback-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pUserData), structure->pUserData,
                                                "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pUserData-parameter");
            }
        } break;

        // Validation code for VkSamplerCustomBorderColorCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {  // Covers
                                                                               // VUID-VkSamplerCustomBorderColorCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_custom_border_color)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_custom_border_color has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerCustomBorderColorCreateInfoEXT);
                VkSamplerCustomBorderColorCreateInfoEXT* structure = (VkSamplerCustomBorderColorCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::format), vvl::Enum::VkFormat, structure->format,
                                           "VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-parameter");
            }
        } break;

        // Validation code for VkSurfaceCapabilitiesPresentBarrierNV structure members
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV: {  // Covers
                                                                           // VUID-VkSurfaceCapabilitiesPresentBarrierNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_present_barrier)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV), but its parent extension "
                                     "VK_NV_present_barrier has not been enabled.");
            }
        } break;

        // Validation code for VkSwapchainPresentBarrierCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: {  // Covers
                                                                            // VUID-VkSwapchainPresentBarrierCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_present_barrier)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_present_barrier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentBarrierCreateInfoNV);
                VkSwapchainPresentBarrierCreateInfoNV* structure = (VkSwapchainPresentBarrierCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentBarrierEnable), structure->presentBarrierEnable);
            }
        } break;

        // Validation code for VkDeviceDiagnosticsConfigCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {  // Covers
                                                                            // VUID-VkDeviceDiagnosticsConfigCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_diagnostics_config)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_device_diagnostics_config has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceDiagnosticsConfigCreateInfoNV);
                VkDeviceDiagnosticsConfigCreateInfoNV* structure = (VkDeviceDiagnosticsConfigCreateInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceDiagnosticsConfigFlagBitsNV,
                                      AllVkDeviceDiagnosticsConfigFlagBitsNV, structure->flags, kOptionalFlags,
                                      "VUID-VkDeviceDiagnosticsConfigCreateInfoNV-flags-parameter");
            }
        } break;

        // Validation code for VkQueryLowLatencySupportNV structure members
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: {  // Covers VUID-VkQueryLowLatencySupportNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_low_latency)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV), "
                                     "but its parent extension "
                                     "VK_NV_low_latency has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryLowLatencySupportNV);
                VkQueryLowLatencySupportNV* structure = (VkQueryLowLatencySupportNV*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pQueriedLowLatencyData), structure->pQueriedLowLatencyData,
                                                "VUID-VkQueryLowLatencySupportNV-pQueriedLowLatencyData-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalObjectCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: {  // Covers VUID-VkExportMetalObjectCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalObjectCreateInfoEXT);
                VkExportMetalObjectCreateInfoEXT* structure = (VkExportMetalObjectCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::exportObjectType), vvl::FlagBitmask::VkExportMetalObjectTypeFlagBitsEXT,
                                      AllVkExportMetalObjectTypeFlagBitsEXT, structure->exportObjectType, kOptionalSingleBit,
                                      "VUID-VkExportMetalObjectCreateInfoEXT-exportObjectType-parameter");
            }
        } break;

        // Validation code for VkExportMetalDeviceInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT: {  // Covers VUID-VkExportMetalDeviceInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
        } break;

        // Validation code for VkExportMetalCommandQueueInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: {  // Covers VUID-VkExportMetalCommandQueueInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT), but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalCommandQueueInfoEXT);
                VkExportMetalCommandQueueInfoEXT* structure = (VkExportMetalCommandQueueInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::queue), structure->queue);
            }
        } break;

        // Validation code for VkExportMetalBufferInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: {  // Covers VUID-VkExportMetalBufferInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalBufferInfoEXT);
                VkExportMetalBufferInfoEXT* structure = (VkExportMetalBufferInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::memory), structure->memory);
            }
        } break;

        // Validation code for VkImportMetalBufferInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT: {  // Covers VUID-VkImportMetalBufferInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
        } break;

        // Validation code for VkExportMetalTextureInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: {  // Covers VUID-VkExportMetalTextureInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalTextureInfoEXT);
                VkExportMetalTextureInfoEXT* structure = (VkExportMetalTextureInfoEXT*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::plane), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                                  structure->plane, kRequiredSingleBit, "VUID-VkExportMetalTextureInfoEXT-plane-parameter",
                                  "VUID-VkExportMetalTextureInfoEXT-plane-parameter");
            }
        } break;

        // Validation code for VkImportMetalTextureInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: {  // Covers VUID-VkImportMetalTextureInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMetalTextureInfoEXT);
                VkImportMetalTextureInfoEXT* structure = (VkImportMetalTextureInfoEXT*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::plane), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                                  structure->plane, kRequiredSingleBit, "VUID-VkImportMetalTextureInfoEXT-plane-parameter",
                                  "VUID-VkImportMetalTextureInfoEXT-plane-parameter");
            }
        } break;

        // Validation code for VkExportMetalIOSurfaceInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: {  // Covers VUID-VkExportMetalIOSurfaceInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT), but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalIOSurfaceInfoEXT);
                VkExportMetalIOSurfaceInfoEXT* structure = (VkExportMetalIOSurfaceInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::image), structure->image);
            }
        } break;

        // Validation code for VkImportMetalIOSurfaceInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT: {  // Covers VUID-VkImportMetalIOSurfaceInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT), but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
        } break;

        // Validation code for VkExportMetalSharedEventInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT: {  // Covers VUID-VkExportMetalSharedEventInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT), but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
        } break;

        // Validation code for VkImportMetalSharedEventInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT: {  // Covers VUID-VkImportMetalSharedEventInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_metal_objects)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT), but its parent extension "
                                     "VK_EXT_metal_objects has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT: {  // Covers
                                                                                               // VUID-VkDescriptorBufferBindingPushDescriptorBufferHandleEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT), but its parent extension "
                    "VK_EXT_descriptor_buffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkDescriptorBufferBindingPushDescriptorBufferHandleEXT);
                VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* structure =
                    (VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::buffer), structure->buffer);
            }
        } break;

        // Validation code for VkOpaqueCaptureDescriptorDataCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: {  // Covers
                                                                                  // VUID-VkOpaqueCaptureDescriptorDataCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_descriptor_buffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkOpaqueCaptureDescriptorDataCreateInfoEXT);
                VkOpaqueCaptureDescriptorDataCreateInfoEXT* structure = (VkOpaqueCaptureDescriptorDataCreateInfoEXT*)header;
                skip |= ValidateRequiredPointer(
                    pNext_loc.dot(Field::opaqueCaptureDescriptorData), structure->opaqueCaptureDescriptorData,
                    "VUID-VkOpaqueCaptureDescriptorDataCreateInfoEXT-opaqueCaptureDescriptorData-parameter");
            }
        } break;

        // Validation code for VkGraphicsPipelineLibraryCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: {  // Covers
                                                                             // VUID-VkGraphicsPipelineLibraryCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_graphics_pipeline_library)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_graphics_pipeline_library has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGraphicsPipelineLibraryCreateInfoEXT);
                VkGraphicsPipelineLibraryCreateInfoEXT* structure = (VkGraphicsPipelineLibraryCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkGraphicsPipelineLibraryFlagBitsEXT,
                                      AllVkGraphicsPipelineLibraryFlagBitsEXT, structure->flags, kRequiredFlags,
                                      "VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-parameter",
                                      "VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-requiredbitmask");
            }
        } break;

        // Validation code for VkPipelineFragmentShadingRateEnumStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV: {  // Covers
                                                                                            // VUID-VkPipelineFragmentShadingRateEnumStateCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_fragment_shading_rate_enums)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV), but its parent extension "
                    "VK_NV_fragment_shading_rate_enums has not been enabled.");
            }
        } break;

        // Validation code for VkAccelerationStructureGeometryMotionTrianglesDataNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV: {  // Covers
                                                                                            // VUID-VkAccelerationStructureGeometryMotionTrianglesDataNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_motion_blur)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV), but its parent extension "
                    "VK_NV_ray_tracing_motion_blur has not been enabled.");
            }
        } break;

        // Validation code for VkAccelerationStructureMotionInfoNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {  // Covers
                                                                         // VUID-VkAccelerationStructureMotionInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_motion_blur)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV), but its parent extension "
                                     "VK_NV_ray_tracing_motion_blur has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAccelerationStructureMotionInfoNV);
                VkAccelerationStructureMotionInfoNV* structure = (VkAccelerationStructureMotionInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkAccelerationStructureMotionInfoNV-flags-zerobitmask");
            }
        } break;

        // Validation code for VkCopyCommandTransformInfoQCOM structure members
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: {  // Covers VUID-VkCopyCommandTransformInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_rotated_copy_commands)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM), but its parent extension "
                                     "VK_QCOM_rotated_copy_commands has not been enabled.");
            }
        } break;

        // Validation code for VkImageCompressionControlEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: {  // Covers VUID-VkImageCompressionControlEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_compression_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT), "
                                     "but its parent extension "
                                     "VK_EXT_image_compression_control has not been enabled.");
            }
        } break;

        // Validation code for VkImageCompressionPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: {  // Covers VUID-VkImageCompressionPropertiesEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_compression_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT), but its parent extension "
                                     "VK_EXT_image_compression_control has not been enabled.");
            }
        } break;

        // Validation code for VkMutableDescriptorTypeCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: {  // Covers
                                                                           // VUID-VkMutableDescriptorTypeCreateInfoEXT-sType-sType

            if ((!IsExtEnabled(extensions.vk_ext_mutable_descriptor_type)) &&
                (!IsExtEnabled(extensions.vk_valve_mutable_descriptor_type))) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_mutable_descriptor_type, or VK_VALVE_mutable_descriptor_type has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMutableDescriptorTypeCreateInfoEXT);
                VkMutableDescriptorTypeCreateInfoEXT* structure = (VkMutableDescriptorTypeCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::mutableDescriptorTypeListCount),
                                      pNext_loc.dot(Field::pMutableDescriptorTypeLists), structure->mutableDescriptorTypeListCount,
                                      &structure->pMutableDescriptorTypeLists, false, true, kVUIDUndefined,
                                      "VUID-VkMutableDescriptorTypeCreateInfoEXT-pMutableDescriptorTypeLists-parameter");

                if (structure->pMutableDescriptorTypeLists != nullptr) {
                    for (uint32_t mutableDescriptorTypeListIndex = 0;
                         mutableDescriptorTypeListIndex < structure->mutableDescriptorTypeListCount;
                         ++mutableDescriptorTypeListIndex) {
                        [[maybe_unused]] const Location pMutableDescriptorTypeLists_loc =
                            pNext_loc.dot(Field::pMutableDescriptorTypeLists, mutableDescriptorTypeListIndex);
                        skip |= ValidateRangedEnumArray(
                            pMutableDescriptorTypeLists_loc.dot(Field::descriptorTypeCount),
                            pMutableDescriptorTypeLists_loc.dot(Field::pDescriptorTypes), vvl::Enum::VkDescriptorType,
                            structure->pMutableDescriptorTypeLists[mutableDescriptorTypeListIndex].descriptorTypeCount,
                            structure->pMutableDescriptorTypeLists[mutableDescriptorTypeListIndex].pDescriptorTypes, false, true,
                            kVUIDUndefined, "VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkDeviceAddressBindingCallbackDataEXT structure members
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: {  // Covers
                                                                            // VUID-VkDeviceAddressBindingCallbackDataEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_address_binding_report)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT), but its parent extension "
                                     "VK_EXT_device_address_binding_report has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceAddressBindingCallbackDataEXT);
                VkDeviceAddressBindingCallbackDataEXT* structure = (VkDeviceAddressBindingCallbackDataEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceAddressBindingFlagBitsEXT,
                                      AllVkDeviceAddressBindingFlagBitsEXT, structure->flags, kOptionalFlags,
                                      "VUID-VkDeviceAddressBindingCallbackDataEXT-flags-parameter");

                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::bindingType), vvl::Enum::VkDeviceAddressBindingTypeEXT,
                                       structure->bindingType, "VUID-VkDeviceAddressBindingCallbackDataEXT-bindingType-parameter");
            }
        } break;

        // Validation code for VkPipelineViewportDepthClipControlCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: {  // Covers
                                                                                        // VUID-VkPipelineViewportDepthClipControlCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_clip_control)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_depth_clip_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportDepthClipControlCreateInfoEXT);
                VkPipelineViewportDepthClipControlCreateInfoEXT* structure =
                    (VkPipelineViewportDepthClipControlCreateInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::negativeOneToOne), structure->negativeOneToOne);
            }
        } break;
#ifdef VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkImportMemoryZirconHandleInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: {  // Covers
                                                                            // VUID-VkImportMemoryZirconHandleInfoFUCHSIA-sType-sType

            if (!IsExtEnabled(extensions.vk_fuchsia_external_memory)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA), but its parent extension "
                                     "VK_FUCHSIA_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryZirconHandleInfoFUCHSIA);
                VkImportMemoryZirconHandleInfoFUCHSIA* structure = (VkImportMemoryZirconHandleInfoFUCHSIA*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      "VUID-VkImportMemoryZirconHandleInfoFUCHSIA-handleType-parameter");
            }
        } break;

        // Validation code for VkImportMemoryBufferCollectionFUCHSIA structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: {  // Covers
                                                                           // VUID-VkImportMemoryBufferCollectionFUCHSIA-sType-sType

            if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA), but its parent extension "
                                     "VK_FUCHSIA_buffer_collection has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryBufferCollectionFUCHSIA);
                VkImportMemoryBufferCollectionFUCHSIA* structure = (VkImportMemoryBufferCollectionFUCHSIA*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::collection), structure->collection);
            }
        } break;

        // Validation code for VkBufferCollectionImageCreateInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: {  // Covers
                                                                               // VUID-VkBufferCollectionImageCreateInfoFUCHSIA-sType-sType

            if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA), but its parent extension "
                                     "VK_FUCHSIA_buffer_collection has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBufferCollectionImageCreateInfoFUCHSIA);
                VkBufferCollectionImageCreateInfoFUCHSIA* structure = (VkBufferCollectionImageCreateInfoFUCHSIA*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::collection), structure->collection);
            }
        } break;

        // Validation code for VkBufferCollectionBufferCreateInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: {  // Covers
                                                                                // VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-sType-sType

            if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA), but its parent extension "
                                     "VK_FUCHSIA_buffer_collection has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBufferCollectionBufferCreateInfoFUCHSIA);
                VkBufferCollectionBufferCreateInfoFUCHSIA* structure = (VkBufferCollectionBufferCreateInfoFUCHSIA*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::collection), structure->collection);
            }
        } break;
#endif  // VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkSubpassShadingPipelineCreateInfoHUAWEI structure members
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {  // Covers
                                                                               // VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_subpass_shading)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI), but its parent extension "
                                     "VK_HUAWEI_subpass_shading has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSubpassShadingPipelineCreateInfoHUAWEI);
                VkSubpassShadingPipelineCreateInfoHUAWEI* structure = (VkSubpassShadingPipelineCreateInfoHUAWEI*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::renderPass), structure->renderPass);
            }
        } break;

        // Validation code for VkFrameBoundaryEXT structure members
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: {  // Covers VUID-VkFrameBoundaryEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_frame_boundary)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT), but its parent extension "
                    "VK_EXT_frame_boundary has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkFrameBoundaryEXT);
                VkFrameBoundaryEXT* structure = (VkFrameBoundaryEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkFrameBoundaryFlagBitsEXT,
                                      AllVkFrameBoundaryFlagBitsEXT, structure->flags, kOptionalFlags,
                                      "VUID-VkFrameBoundaryEXT-flags-parameter");
            }
        } break;

        // Validation code for VkSubpassResolvePerformanceQueryEXT structure members
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: {  // Covers
                                                                         // VUID-VkSubpassResolvePerformanceQueryEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_multisampled_render_to_single_sampled)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT), but its parent extension "
                                     "VK_EXT_multisampled_render_to_single_sampled has not been enabled.");
            }
        } break;

        // Validation code for VkMultisampledRenderToSingleSampledInfoEXT structure members
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: {  // Covers
                                                                                  // VUID-VkMultisampledRenderToSingleSampledInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_multisampled_render_to_single_sampled)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT), but its parent extension "
                                     "VK_EXT_multisampled_render_to_single_sampled has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMultisampledRenderToSingleSampledInfoEXT);
                VkMultisampledRenderToSingleSampledInfoEXT* structure = (VkMultisampledRenderToSingleSampledInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multisampledRenderToSingleSampledEnable),
                                       structure->multisampledRenderToSingleSampledEnable);

                skip |= ValidateFlags(pNext_loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, structure->rasterizationSamples, kRequiredSingleBit,
                                      "VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter",
                                      "VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter");
            }
        } break;

        // Validation code for VkPipelineColorWriteCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {  // Covers VUID-VkPipelineColorWriteCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_color_write_enable)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_color_write_enable has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineColorWriteCreateInfoEXT);
                VkPipelineColorWriteCreateInfoEXT* structure = (VkPipelineColorWriteCreateInfoEXT*)header;
                skip |= ValidateBool32Array(pNext_loc.dot(Field::attachmentCount), pNext_loc.dot(Field::pColorWriteEnables),
                                            structure->attachmentCount, structure->pColorWriteEnables, false, true, kVUIDUndefined,
                                            "VUID-VkPipelineColorWriteCreateInfoEXT-pColorWriteEnables-parameter");
            }
        } break;

        // Validation code for VkImageViewMinLodCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: {  // Covers VUID-VkImageViewMinLodCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_view_min_lod)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_image_view_min_lod has not been enabled.");
            }
        } break;

        // Validation code for VkAccelerationStructureTrianglesOpacityMicromapEXT structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: {  // Covers
                                                                                         // VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_opacity_micromap)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT), but its parent extension "
                    "VK_EXT_opacity_micromap has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAccelerationStructureTrianglesOpacityMicromapEXT);
                VkAccelerationStructureTrianglesOpacityMicromapEXT* structure =
                    (VkAccelerationStructureTrianglesOpacityMicromapEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexType), vvl::Enum::VkIndexType, structure->indexType,
                                           "VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-parameter");

                if (structure->pUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location pUsageCounts_loc = pNext_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    }
                }

                if (structure->ppUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location ppUsageCounts_loc = pNext_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    }
                }
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkAccelerationStructureTrianglesDisplacementMicromapNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV: {  // Covers
                                                                                             // VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_displacement_micromap)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV), but its parent extension "
                    "VK_NV_displacement_micromap has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkAccelerationStructureTrianglesDisplacementMicromapNV);
                VkAccelerationStructureTrianglesDisplacementMicromapNV* structure =
                    (VkAccelerationStructureTrianglesDisplacementMicromapNV*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::displacementBiasAndScaleFormat), vvl::Enum::VkFormat,
                    structure->displacementBiasAndScaleFormat,
                    "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementBiasAndScaleFormat-parameter");

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::displacementVectorFormat), vvl::Enum::VkFormat, structure->displacementVectorFormat,
                    "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementVectorFormat-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexType), vvl::Enum::VkIndexType, structure->indexType,
                                           "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-indexType-parameter");

                if (structure->pUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location pUsageCounts_loc = pNext_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    }
                }

                if (structure->ppUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location ppUsageCounts_loc = pNext_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    }
                }
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_cluster_culling_shader)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI), but its parent extension "
                    "VK_HUAWEI_cluster_culling_shader has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI);
                VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* structure =
                    (VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::clusterShadingRate), structure->clusterShadingRate);
            }
        } break;

        // Validation code for VkSamplerBorderColorComponentMappingCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: {  // Covers
                                                                                          // VUID-VkSamplerBorderColorComponentMappingCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_border_color_swizzle)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_border_color_swizzle has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerBorderColorComponentMappingCreateInfoEXT);
                VkSamplerBorderColorComponentMappingCreateInfoEXT* structure =
                    (VkSamplerBorderColorComponentMappingCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::r), vvl::Enum::VkComponentSwizzle, structure->components.r,
                                           "VUID-VkComponentMapping-r-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::g), vvl::Enum::VkComponentSwizzle, structure->components.g,
                                           "VUID-VkComponentMapping-g-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::b), vvl::Enum::VkComponentSwizzle, structure->components.b,
                                           "VUID-VkComponentMapping-b-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::a), vvl::Enum::VkComponentSwizzle, structure->components.a,
                                           "VUID-VkComponentMapping-a-parameter");

                skip |= ValidateBool32(pNext_loc.dot(Field::srgb), structure->srgb);
            }
        } break;

        // Validation code for VkDeviceQueueShaderCoreControlCreateInfoARM structure members
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM: {  // Covers
                                                                                    // VUID-VkDeviceQueueShaderCoreControlCreateInfoARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_scheduling_controls)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM), but its parent extension "
                                 "VK_ARM_scheduling_controls has not been enabled.");
            }
        } break;

        // Validation code for VkImageViewSlicedCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT: {  // Covers VUID-VkImageViewSlicedCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_image_sliced_view_of_3d)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_image_sliced_view_of_3d has not been enabled.");
            }
        } break;

        // Validation code for VkRenderPassStripeBeginInfoARM structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM: {  // Covers VUID-VkRenderPassStripeBeginInfoARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_render_pass_striped)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM), but its parent extension "
                                     "VK_ARM_render_pass_striped has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassStripeBeginInfoARM);
                VkRenderPassStripeBeginInfoARM* structure = (VkRenderPassStripeBeginInfoARM*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::stripeInfoCount), pNext_loc.dot(Field::pStripeInfos), structure->stripeInfoCount,
                    structure->pStripeInfos, VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM, true, true,
                    "VUID-VkRenderPassStripeInfoARM-sType-sType", "VUID-VkRenderPassStripeBeginInfoARM-pStripeInfos-parameter",
                    "VUID-VkRenderPassStripeBeginInfoARM-stripeInfoCount-arraylength");

                if (structure->pStripeInfos != nullptr) {
                    for (uint32_t stripeInfoIndex = 0; stripeInfoIndex < structure->stripeInfoCount; ++stripeInfoIndex) {
                        [[maybe_unused]] const Location pStripeInfos_loc = pNext_loc.dot(Field::pStripeInfos, stripeInfoIndex);
                        skip |= ValidateStructPnext(pStripeInfos_loc, structure->pStripeInfos[stripeInfoIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkRenderPassStripeInfoARM-pNext-pNext",
                                                    kVUIDUndefined, true);
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassStripeSubmitInfoARM structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM: {  // Covers VUID-VkRenderPassStripeSubmitInfoARM-sType-sType

            if (!IsExtEnabled(extensions.vk_arm_render_pass_striped)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM), but its parent extension "
                                     "VK_ARM_render_pass_striped has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassStripeSubmitInfoARM);
                VkRenderPassStripeSubmitInfoARM* structure = (VkRenderPassStripeSubmitInfoARM*)header;
                skip |= ValidateStructTypeArray(pNext_loc.dot(Field::stripeSemaphoreInfoCount),
                                                pNext_loc.dot(Field::pStripeSemaphoreInfos), structure->stripeSemaphoreInfoCount,
                                                structure->pStripeSemaphoreInfos, VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, true,
                                                true, "VUID-VkSemaphoreSubmitInfo-sType-sType",
                                                "VUID-VkRenderPassStripeSubmitInfoARM-pStripeSemaphoreInfos-parameter",
                                                "VUID-VkRenderPassStripeSubmitInfoARM-stripeSemaphoreInfoCount-arraylength");

                if (structure->pStripeSemaphoreInfos != nullptr) {
                    for (uint32_t stripeSemaphoreInfoIndex = 0; stripeSemaphoreInfoIndex < structure->stripeSemaphoreInfoCount;
                         ++stripeSemaphoreInfoIndex) {
                        [[maybe_unused]] const Location pStripeSemaphoreInfos_loc =
                            pNext_loc.dot(Field::pStripeSemaphoreInfos, stripeSemaphoreInfoIndex);
                        skip |= ValidateStructPnext(
                            pStripeSemaphoreInfos_loc, structure->pStripeSemaphoreInfos[stripeSemaphoreInfoIndex].pNext, 0, nullptr,
                            GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, true);

                        skip |= ValidateRequiredHandle(pStripeSemaphoreInfos_loc.dot(Field::semaphore),
                                                       structure->pStripeSemaphoreInfos[stripeSemaphoreInfoIndex].semaphore);

                        skip |= ValidateFlags(pStripeSemaphoreInfos_loc.dot(Field::stageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              structure->pStripeSemaphoreInfos[stripeSemaphoreInfoIndex].stageMask, kOptionalFlags,
                                              "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkSubpassFragmentDensityMapOffsetEndInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: {  // Covers
                                                                                     // VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_fragment_density_map_offset)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM), but its parent extension "
                                 "VK_QCOM_fragment_density_map_offset has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSubpassFragmentDensityMapOffsetEndInfoQCOM);
                VkSubpassFragmentDensityMapOffsetEndInfoQCOM* structure = (VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::fragmentDensityOffsetCount),
                                      pNext_loc.dot(Field::pFragmentDensityOffsets), structure->fragmentDensityOffsetCount,
                                      &structure->pFragmentDensityOffsets, false, true, kVUIDUndefined,
                                      "VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pFragmentDensityOffsets-parameter");

                if (structure->pFragmentDensityOffsets != nullptr) {
                    for (uint32_t fragmentDensityOffsetIndex = 0;
                         fragmentDensityOffsetIndex < structure->fragmentDensityOffsetCount; ++fragmentDensityOffsetIndex) {
                        [[maybe_unused]] const Location pFragmentDensityOffsets_loc =
                            pNext_loc.dot(Field::pFragmentDensityOffsets, fragmentDensityOffsetIndex);
                    }
                }
            }
        } break;

        // Validation code for VkComputePipelineIndirectBufferInfoNV structure members
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV: {  // Covers
                                                                            // VUID-VkComputePipelineIndirectBufferInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_device_generated_commands_compute)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV), but its parent extension "
                                     "VK_NV_device_generated_commands_compute has not been enabled.");
            }
        } break;

        // Validation code for VkAccelerationStructureGeometryLinearSweptSpheresDataNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV: {  // Covers
                                                                                                // VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_linear_swept_spheres)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV), but its parent extension "
                    "VK_NV_ray_tracing_linear_swept_spheres has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkAccelerationStructureGeometryLinearSweptSpheresDataNV);
                VkAccelerationStructureGeometryLinearSweptSpheresDataNV* structure =
                    (VkAccelerationStructureGeometryLinearSweptSpheresDataNV*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat, structure->vertexFormat,
                                           "VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-vertexFormat-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::radiusFormat), vvl::Enum::VkFormat, structure->radiusFormat,
                                           "VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-radiusFormat-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexType), vvl::Enum::VkIndexType, structure->indexType,
                                           "VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-indexType-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexingMode), vvl::Enum::VkRayTracingLssIndexingModeNV,
                                           structure->indexingMode,
                                           "VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-indexingMode-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::endCapsMode), vvl::Enum::VkRayTracingLssPrimitiveEndCapsModeNV,
                                           structure->endCapsMode,
                                           "VUID-VkAccelerationStructureGeometryLinearSweptSpheresDataNV-endCapsMode-parameter");
            }
        } break;

        // Validation code for VkAccelerationStructureGeometrySpheresDataNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV: {  // Covers
                                                                                   // VUID-VkAccelerationStructureGeometrySpheresDataNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_ray_tracing_linear_swept_spheres)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV), but its parent extension "
                                 "VK_NV_ray_tracing_linear_swept_spheres has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAccelerationStructureGeometrySpheresDataNV);
                VkAccelerationStructureGeometrySpheresDataNV* structure = (VkAccelerationStructureGeometrySpheresDataNV*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat, structure->vertexFormat,
                                           "VUID-VkAccelerationStructureGeometrySpheresDataNV-vertexFormat-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::radiusFormat), vvl::Enum::VkFormat, structure->radiusFormat,
                                           "VUID-VkAccelerationStructureGeometrySpheresDataNV-radiusFormat-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexType), vvl::Enum::VkIndexType, structure->indexType,
                                           "VUID-VkAccelerationStructureGeometrySpheresDataNV-indexType-parameter");
            }
        } break;

        // Validation code for VkImageViewSampleWeightCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM: {  // Covers
                                                                             // VUID-VkImageViewSampleWeightCreateInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_image_processing)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM), but its parent extension "
                                     "VK_QCOM_image_processing has not been enabled.");
            }
        } break;

        // Validation code for VkExternalMemoryAcquireUnmodifiedEXT structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT: {  // Covers
                                                                          // VUID-VkExternalMemoryAcquireUnmodifiedEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_external_memory_acquire_unmodified)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT), but its parent extension "
                                     "VK_EXT_external_memory_acquire_unmodified has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryAcquireUnmodifiedEXT);
                VkExternalMemoryAcquireUnmodifiedEXT* structure = (VkExternalMemoryAcquireUnmodifiedEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::acquireUnmodifiedMemory), structure->acquireUnmodifiedMemory);
            }
        } break;

        // Validation code for VkRenderPassCreationControlEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: {  // Covers VUID-VkRenderPassCreationControlEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_subpass_merge_feedback)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT), but its parent extension "
                                     "VK_EXT_subpass_merge_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassCreationControlEXT);
                VkRenderPassCreationControlEXT* structure = (VkRenderPassCreationControlEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::disallowMerging), structure->disallowMerging);
            }
        } break;

        // Validation code for VkRenderPassCreationFeedbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: {  // Covers
                                                                                 // VUID-VkRenderPassCreationFeedbackCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_subpass_merge_feedback)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_subpass_merge_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassCreationFeedbackCreateInfoEXT);
                VkRenderPassCreationFeedbackCreateInfoEXT* structure = (VkRenderPassCreationFeedbackCreateInfoEXT*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pRenderPassFeedback), structure->pRenderPassFeedback,
                                                "VUID-VkRenderPassCreationFeedbackCreateInfoEXT-pRenderPassFeedback-parameter");
            }
        } break;

        // Validation code for VkRenderPassSubpassFeedbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: {  // Covers
                                                                                // VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_subpass_merge_feedback)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT), but its parent extension "
                                     "VK_EXT_subpass_merge_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassSubpassFeedbackCreateInfoEXT);
                VkRenderPassSubpassFeedbackCreateInfoEXT* structure = (VkRenderPassSubpassFeedbackCreateInfoEXT*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pSubpassFeedback), structure->pSubpassFeedback,
                                                "VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-pSubpassFeedback-parameter");
            }
        } break;

        // Validation code for VkDirectDriverLoadingListLUNARG structure members
        case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG: {  // Covers VUID-VkDirectDriverLoadingListLUNARG-sType-sType

            if (!IsExtEnabled(extensions.vk_lunarg_direct_driver_loading)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG), but its parent extension "
                                     "VK_LUNARG_direct_driver_loading has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDirectDriverLoadingListLUNARG);
                VkDirectDriverLoadingListLUNARG* structure = (VkDirectDriverLoadingListLUNARG*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::mode), vvl::Enum::VkDirectDriverLoadingModeLUNARG, structure->mode,
                                           "VUID-VkDirectDriverLoadingListLUNARG-mode-parameter");

                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::driverCount), pNext_loc.dot(Field::pDrivers), structure->driverCount, structure->pDrivers,
                    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG, true, true,
                    "VUID-VkDirectDriverLoadingInfoLUNARG-sType-sType", "VUID-VkDirectDriverLoadingListLUNARG-pDrivers-parameter",
                    "VUID-VkDirectDriverLoadingListLUNARG-driverCount-arraylength");

                if (structure->pDrivers != nullptr) {
                    for (uint32_t driverIndex = 0; driverIndex < structure->driverCount; ++driverIndex) {
                        [[maybe_unused]] const Location pDrivers_loc = pNext_loc.dot(Field::pDrivers, driverIndex);
                        skip |= ValidateReservedFlags(pDrivers_loc.dot(Field::flags), structure->pDrivers[driverIndex].flags,
                                                      "VUID-VkDirectDriverLoadingInfoLUNARG-flags-zerobitmask");
                    }
                }
            }
        } break;

        // Validation code for VkPipelineShaderStageModuleIdentifierCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT: {  // Covers
                                                                                           // VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_shader_module_identifier)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_shader_module_identifier has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineShaderStageModuleIdentifierCreateInfoEXT);
                VkPipelineShaderStageModuleIdentifierCreateInfoEXT* structure =
                    (VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::identifierSize), pNext_loc.dot(Field::pIdentifier),
                                      structure->identifierSize, &structure->pIdentifier, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pIdentifier-parameter");
            }
        } break;

        // Validation code for VkOpticalFlowImageFormatInfoNV structure members
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: {  // Covers VUID-VkOpticalFlowImageFormatInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_optical_flow)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV), but its parent extension "
                                     "VK_NV_optical_flow has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkOpticalFlowImageFormatInfoNV);
                VkOpticalFlowImageFormatInfoNV* structure = (VkOpticalFlowImageFormatInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::usage), vvl::FlagBitmask::VkOpticalFlowUsageFlagBitsNV,
                                      AllVkOpticalFlowUsageFlagBitsNV, structure->usage, kRequiredFlags,
                                      "VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter",
                                      "VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkOpticalFlowSessionCreatePrivateDataInfoNV structure members
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: {  // Covers
                                                                                    // VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_optical_flow)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV), but its parent extension "
                                 "VK_NV_optical_flow has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkOpticalFlowSessionCreatePrivateDataInfoNV);
                VkOpticalFlowSessionCreatePrivateDataInfoNV* structure = (VkOpticalFlowSessionCreatePrivateDataInfoNV*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pPrivateData), structure->pPrivateData,
                                                "VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-pPrivateData-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkAndroidHardwareBufferFormatResolvePropertiesANDROID structure members
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID: {  // Covers
                                                                                             // VUID-VkAndroidHardwareBufferFormatResolvePropertiesANDROID-sType-sType

            if (!IsExtEnabled(extensions.vk_android_external_format_resolve)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID), but its parent extension "
                    "VK_ANDROID_external_format_resolve has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkAmigoProfilingSubmitInfoSEC structure members
        case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC: {  // Covers VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType

            if (!IsExtEnabled(extensions.vk_sec_amigo_profiling)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC), "
                                     "but its parent extension "
                                     "VK_SEC_amigo_profiling has not been enabled.");
            }
        } break;

        // Validation code for VkLatencySubmissionPresentIdNV structure members
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: {  // Covers VUID-VkLatencySubmissionPresentIdNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_low_latency2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV), but its parent extension "
                                     "VK_NV_low_latency2 has not been enabled.");
            }
        } break;

        // Validation code for VkSwapchainLatencyCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV: {  // Covers VUID-VkSwapchainLatencyCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_low_latency2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_low_latency2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainLatencyCreateInfoNV);
                VkSwapchainLatencyCreateInfoNV* structure = (VkSwapchainLatencyCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::latencyModeEnable), structure->latencyModeEnable);
            }
        } break;

        // Validation code for VkLatencySurfaceCapabilitiesNV structure members
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV: {  // Covers VUID-VkLatencySurfaceCapabilitiesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_low_latency2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV), "
                                     "but its parent extension "
                                     "VK_NV_low_latency2 has not been enabled.");
            }
        } break;

        // Validation code for VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM structure members
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM: {  // Covers
                                                                                               // VUID-VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_multiview_per_view_render_areas)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM), but its parent extension "
                    "VK_QCOM_multiview_per_view_render_areas has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM);
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* structure =
                    (VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::perViewRenderAreaCount), pNext_loc.dot(Field::pPerViewRenderAreas),
                                  structure->perViewRenderAreaCount, &structure->pPerViewRenderAreas, false, true, kVUIDUndefined,
                                  "VUID-VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM-pPerViewRenderAreas-parameter");
            }
        } break;

        // Validation code for VkSamplerBlockMatchWindowCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM: {  // Covers
                                                                               // VUID-VkSamplerBlockMatchWindowCreateInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_image_processing2)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM), but its parent extension "
                                     "VK_QCOM_image_processing2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerBlockMatchWindowCreateInfoQCOM);
                VkSamplerBlockMatchWindowCreateInfoQCOM* structure = (VkSamplerBlockMatchWindowCreateInfoQCOM*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::windowCompareMode), vvl::Enum::VkBlockMatchWindowCompareModeQCOM,
                                           structure->windowCompareMode,
                                           "VUID-VkSamplerBlockMatchWindowCreateInfoQCOM-windowCompareMode-parameter");
            }
        } break;

        // Validation code for VkSamplerCubicWeightsCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM: {  // Covers
                                                                          // VUID-VkSamplerCubicWeightsCreateInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_filter_cubic_weights)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM), but its parent extension "
                                     "VK_QCOM_filter_cubic_weights has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerCubicWeightsCreateInfoQCOM);
                VkSamplerCubicWeightsCreateInfoQCOM* structure = (VkSamplerCubicWeightsCreateInfoQCOM*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::cubicWeights), vvl::Enum::VkCubicFilterWeightsQCOM,
                                       structure->cubicWeights, "VUID-VkSamplerCubicWeightsCreateInfoQCOM-cubicWeights-parameter");
            }
        } break;

        // Validation code for VkBlitImageCubicWeightsInfoQCOM structure members
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM: {  // Covers VUID-VkBlitImageCubicWeightsInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_filter_cubic_weights)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM), but its parent extension "
                                     "VK_QCOM_filter_cubic_weights has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBlitImageCubicWeightsInfoQCOM);
                VkBlitImageCubicWeightsInfoQCOM* structure = (VkBlitImageCubicWeightsInfoQCOM*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::cubicWeights), vvl::Enum::VkCubicFilterWeightsQCOM,
                                           structure->cubicWeights, "VUID-VkBlitImageCubicWeightsInfoQCOM-cubicWeights-parameter");
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM: {  // Covers
                                                                                           // VUID-VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM-sType-sType

            if (!IsExtEnabled(extensions.vk_qcom_ycbcr_degamma)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM), but its parent extension "
                    "VK_QCOM_ycbcr_degamma has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM);
                VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* structure =
                    (VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::enableYDegamma), structure->enableYDegamma);

                skip |= ValidateBool32(pNext_loc.dot(Field::enableCbCrDegamma), structure->enableCbCrDegamma);
            }
        } break;
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkScreenBufferFormatPropertiesQNX structure members
        case VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX: {  // Covers VUID-VkScreenBufferFormatPropertiesQNX-sType-sType

            if (!IsExtEnabled(extensions.vk_qnx_external_memory_screen_buffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX), but its parent extension "
                                     "VK_QNX_external_memory_screen_buffer has not been enabled.");
            }
        } break;

        // Validation code for VkImportScreenBufferInfoQNX structure members
        case VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX: {  // Covers VUID-VkImportScreenBufferInfoQNX-sType-sType

            if (!IsExtEnabled(extensions.vk_qnx_external_memory_screen_buffer)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX), "
                                     "but its parent extension "
                                     "VK_QNX_external_memory_screen_buffer has not been enabled.");
            }
        } break;

        // Validation code for VkExternalFormatQNX structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX: {  // Covers VUID-VkExternalFormatQNX-sType-sType

            if (!IsExtEnabled(extensions.vk_qnx_external_memory_screen_buffer)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX), but its parent extension "
                    "VK_QNX_external_memory_screen_buffer has not been enabled.");
            }
        } break;
#endif  // VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkDisplaySurfaceStereoCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV: {  // Covers
                                                                         // VUID-VkDisplaySurfaceStereoCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_display_stereo)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV), but its parent extension "
                                     "VK_NV_display_stereo has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDisplaySurfaceStereoCreateInfoNV);
                VkDisplaySurfaceStereoCreateInfoNV* structure = (VkDisplaySurfaceStereoCreateInfoNV*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::stereoType), vvl::Enum::VkDisplaySurfaceStereoTypeNV,
                                           structure->stereoType, "VUID-VkDisplaySurfaceStereoCreateInfoNV-stereoType-parameter");
            }
        } break;

        // Validation code for VkDisplayModeStereoPropertiesNV structure members
        case VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV: {  // Covers VUID-VkDisplayModeStereoPropertiesNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_display_stereo)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV), but its parent extension "
                                     "VK_NV_display_stereo has not been enabled.");
            }
        } break;

        // Validation code for VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV: {  // Covers
                                                                                                      // VUID-VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_cluster_acceleration_structure)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV), but "
                                     "its parent extension "
                                     "VK_NV_cluster_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV);
                VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV* structure =
                    (VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::allowClusterAccelerationStructure),
                                       structure->allowClusterAccelerationStructure);
            }
        } break;

        // Validation code for VkPartitionedAccelerationStructureFlagsNV structure members
        case VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV: {  // Covers
                                                                               // VUID-VkPartitionedAccelerationStructureFlagsNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_partitioned_acceleration_structure)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV), but its parent extension "
                                     "VK_NV_partitioned_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPartitionedAccelerationStructureFlagsNV);
                VkPartitionedAccelerationStructureFlagsNV* structure = (VkPartitionedAccelerationStructureFlagsNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::enablePartitionTranslation), structure->enablePartitionTranslation);
            }
        } break;

        // Validation code for VkWriteDescriptorSetPartitionedAccelerationStructureNV structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV: {  // Covers
                                                                                              // VUID-VkWriteDescriptorSetPartitionedAccelerationStructureNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_partitioned_acceleration_structure)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV), but its parent extension "
                    "VK_NV_partitioned_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkWriteDescriptorSetPartitionedAccelerationStructureNV);
                VkWriteDescriptorSetPartitionedAccelerationStructureNV* structure =
                    (VkWriteDescriptorSetPartitionedAccelerationStructureNV*)header;
                skip |= ValidateArray(
                    pNext_loc.dot(Field::accelerationStructureCount), pNext_loc.dot(Field::pAccelerationStructures),
                    structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false,
                    "VUID-VkWriteDescriptorSetPartitionedAccelerationStructureNV-accelerationStructureCount-arraylength",
                    "VUID-VkWriteDescriptorSetPartitionedAccelerationStructureNV-pAccelerationStructures-parameter");
            }
        } break;

        // Validation code for VkGeneratedCommandsPipelineInfoEXT structure members
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT: {  // Covers
                                                                        // VUID-VkGeneratedCommandsPipelineInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_generated_commands)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT), but its parent extension "
                                     "VK_EXT_device_generated_commands has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGeneratedCommandsPipelineInfoEXT);
                VkGeneratedCommandsPipelineInfoEXT* structure = (VkGeneratedCommandsPipelineInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::pipeline), structure->pipeline);
            }
        } break;

        // Validation code for VkGeneratedCommandsShaderInfoEXT structure members
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT: {  // Covers VUID-VkGeneratedCommandsShaderInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_device_generated_commands)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT), but its parent extension "
                                     "VK_EXT_device_generated_commands has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGeneratedCommandsShaderInfoEXT);
                VkGeneratedCommandsShaderInfoEXT* structure = (VkGeneratedCommandsShaderInfoEXT*)header;
                skip |= ValidateHandleArray(pNext_loc.dot(Field::shaderCount), pNext_loc.dot(Field::pShaders),
                                            structure->shaderCount, structure->pShaders, true, true,
                                            "VUID-VkGeneratedCommandsShaderInfoEXT-shaderCount-arraylength");
            }
        } break;

        // Validation code for VkImageAlignmentControlCreateInfoMESA structure members
        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: {  // Covers
                                                                            // VUID-VkImageAlignmentControlCreateInfoMESA-sType-sType

            if (!IsExtEnabled(extensions.vk_mesa_image_alignment_control)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA), but its parent extension "
                                     "VK_MESA_image_alignment_control has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineViewportDepthClampControlCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT: {  // Covers
                                                                                         // VUID-VkPipelineViewportDepthClampControlCreateInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_depth_clamp_control)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT), but its parent extension "
                    "VK_EXT_depth_clamp_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportDepthClampControlCreateInfoEXT);
                VkPipelineViewportDepthClampControlCreateInfoEXT* structure =
                    (VkPipelineViewportDepthClampControlCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::depthClampMode), vvl::Enum::VkDepthClampModeEXT,
                                           structure->depthClampMode,
                                           "VUID-VkPipelineViewportDepthClampControlCreateInfoEXT-depthClampMode-parameter");
            }
        } break;

        // Validation code for VkHdrVividDynamicMetadataHUAWEI structure members
        case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI: {  // Covers VUID-VkHdrVividDynamicMetadataHUAWEI-sType-sType

            if (!IsExtEnabled(extensions.vk_huawei_hdr_vivid)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI), but its parent extension "
                                     "VK_HUAWEI_hdr_vivid has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkHdrVividDynamicMetadataHUAWEI);
                VkHdrVividDynamicMetadataHUAWEI* structure = (VkHdrVividDynamicMetadataHUAWEI*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::dynamicMetadataSize), pNext_loc.dot(Field::pDynamicMetadata),
                                      structure->dynamicMetadataSize, &structure->pDynamicMetadata, true, true,
                                      "VUID-VkHdrVividDynamicMetadataHUAWEI-dynamicMetadataSize-arraylength",
                                      "VUID-VkHdrVividDynamicMetadataHUAWEI-pDynamicMetadata-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkImportMemoryMetalHandleInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT: {  // Covers VUID-VkImportMemoryMetalHandleInfoEXT-sType-sType

            if (!IsExtEnabled(extensions.vk_ext_external_memory_metal)) {
                skip |= log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT), but its parent extension "
                                     "VK_EXT_external_memory_metal has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryMetalHandleInfoEXT);
                VkImportMemoryMetalHandleInfoEXT* structure = (VkImportMemoryMetalHandleInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      "VUID-VkImportMemoryMetalHandleInfoEXT-handleType-parameter");
            }
        } break;
#endif  // VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkSetPresentConfigNV structure members
        case VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV: {  // Covers VUID-VkSetPresentConfigNV-sType-sType

            if (!IsExtEnabled(extensions.vk_nv_present_metering)) {
                skip |= log.LogError(
                    pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV), but its parent extension "
                    "VK_NV_present_metering has not been enabled.");
            }
        } break;

        // Validation code for VkWriteDescriptorSetAccelerationStructureKHR structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {  // Covers
                                                                                   // VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType

            if (!IsExtEnabled(extensions.vk_khr_acceleration_structure)) {
                skip |=
                    log.LogError(pnext_vuid, error_obj.handle, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR), but its parent extension "
                                 "VK_KHR_acceleration_structure has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWriteDescriptorSetAccelerationStructureKHR);
                VkWriteDescriptorSetAccelerationStructureKHR* structure = (VkWriteDescriptorSetAccelerationStructureKHR*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::accelerationStructureCount), pNext_loc.dot(Field::pAccelerationStructures),
                                  structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false,
                                  "VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength",
                                  "VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter");
            }
        } break;

        default:
            skip = false;
    }
    return skip;
}

bool Instance::PreCallValidateDestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Instance::PreCallValidateEnumeratePhysicalDevices(VkInstance instance, uint32_t* pPhysicalDeviceCount,
                                                       VkPhysicalDevice* pPhysicalDevices, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidatePointerArray(loc.dot(Field::pPhysicalDeviceCount), loc.dot(Field::pPhysicalDevices),
                                         pPhysicalDeviceCount, &pPhysicalDevices, true, false, false,
                                         "VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter", kVUIDUndefined,
                                         "VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFeatures), pFeatures,
                                            "VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                VkFormatProperties* pFormatProperties,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                                       "VUID-vkGetPhysicalDeviceFormatProperties-format-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFormatProperties), pFormatProperties,
                                            "VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                     VkImageType type, VkImageTiling tiling,
                                                                     VkImageUsageFlags usage, VkImageCreateFlags flags,
                                                                     VkImageFormatProperties* pImageFormatProperties,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                                       "VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::type), vvl::Enum::VkImageType, type,
                                       "VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::tiling), vvl::Enum::VkImageTiling, tiling,
                                       "VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits, usage,
                                  kRequiredFlags, "VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter",
                                  "VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask");
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits, flags,
                                  kOptionalFlags, "VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pImageFormatProperties), pImageFormatProperties,
                                            "VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags,
                                                                             pImageFormatProperties, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pProperties), pProperties,
                                            "VUID-vkGetPhysicalDeviceProperties-pProperties-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice,
                                                                     uint32_t* pQueueFamilyPropertyCount,
                                                                     VkQueueFamilyProperties* pQueueFamilyProperties,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidatePointerArray(loc.dot(Field::pQueueFamilyPropertyCount), loc.dot(Field::pQueueFamilyProperties),
                                         pQueueFamilyPropertyCount, &pQueueFamilyProperties, true, false, false,
                                         "VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter",
                                         kVUIDUndefined,
                                         "VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter");
    if (pQueueFamilyProperties != nullptr) {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount;
             ++pQueueFamilyPropertyIndex) {
            [[maybe_unused]] const Location pQueueFamilyProperties_loc =
                loc.dot(Field::pQueueFamilyProperties, pQueueFamilyPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice,
                                                                VkPhysicalDeviceMemoryProperties* pMemoryProperties,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMemoryProperties), pMemoryProperties,
                                            "VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter");
    return skip;
}

bool Instance::PreCallValidateCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo,
                                           const VkAllocationCallbacks* pAllocator, VkDevice* pDevice,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, true,
                                       "VUID-vkCreateDevice-pCreateInfo-parameter", "VUID-VkDeviceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDeviceCreateInfo = {
            VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
            VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
            VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
            VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDeviceCreateInfo.size(),
                                            allowed_structs_VkDeviceCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceCreateInfo-pNext-pNext", "VUID-VkDeviceCreateInfo-sType-unique", true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkDeviceCreateInfo-flags-zerobitmask");

        skip |= context.ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::queueCreateInfoCount), pCreateInfo_loc.dot(Field::pQueueCreateInfos),
            pCreateInfo->queueCreateInfoCount, pCreateInfo->pQueueCreateInfos, VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, true,
            true, "VUID-VkDeviceQueueCreateInfo-sType-sType", "VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter",
            "VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength");

        if (pCreateInfo->pQueueCreateInfos != nullptr) {
            for (uint32_t queueCreateInfoIndex = 0; queueCreateInfoIndex < pCreateInfo->queueCreateInfoCount;
                 ++queueCreateInfoIndex) {
                [[maybe_unused]] const Location pQueueCreateInfos_loc =
                    pCreateInfo_loc.dot(Field::pQueueCreateInfos, queueCreateInfoIndex);
                constexpr std::array allowed_structs_VkDeviceQueueCreateInfo = {
                    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
                    VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM};

                skip |= context.ValidateStructPnext(
                    pQueueCreateInfos_loc, pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pNext,
                    allowed_structs_VkDeviceQueueCreateInfo.size(), allowed_structs_VkDeviceQueueCreateInfo.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkDeviceQueueCreateInfo-pNext-pNext",
                    "VUID-VkDeviceQueueCreateInfo-sType-unique", true);

                skip |= context.ValidateFlags(pQueueCreateInfos_loc.dot(Field::flags),
                                              vvl::FlagBitmask::VkDeviceQueueCreateFlagBits, AllVkDeviceQueueCreateFlagBits,
                                              pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].flags, kOptionalFlags,
                                              "VUID-VkDeviceQueueCreateInfo-flags-parameter");

                skip |= context.ValidateArray(pQueueCreateInfos_loc.dot(Field::queueCount),
                                              pQueueCreateInfos_loc.dot(Field::pQueuePriorities),
                                              pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].queueCount,
                                              &pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pQueuePriorities, true, true,
                                              "VUID-VkDeviceQueueCreateInfo-queueCount-arraylength",
                                              "VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter");
            }
        }

        skip |= context.ValidateStringArray(pCreateInfo_loc.dot(Field::enabledLayerCount),
                                            pCreateInfo_loc.dot(Field::ppEnabledLayerNames), pCreateInfo->enabledLayerCount,
                                            pCreateInfo->ppEnabledLayerNames, false, true, kVUIDUndefined,
                                            "VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter");

        skip |= context.ValidateStringArray(pCreateInfo_loc.dot(Field::enabledExtensionCount),
                                            pCreateInfo_loc.dot(Field::ppEnabledExtensionNames), pCreateInfo->enabledExtensionCount,
                                            pCreateInfo->ppEnabledExtensionNames, false, true, kVUIDUndefined,
                                            "VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDevice), pDevice, "VUID-vkCreateDevice-pDevice-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice, context);
    return skip;
}

bool Device::PreCallValidateDestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pQueue), pQueue, "VUID-vkGetDeviceQueue-pQueue-parameter");
    return skip;
}

bool Device::PreCallValidateQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::submitCount), loc.dot(Field::pSubmits), submitCount, pSubmits,
                                            VK_STRUCTURE_TYPE_SUBMIT_INFO, false, true, "VUID-VkSubmitInfo-sType-sType",
                                            "VUID-vkQueueSubmit-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr) {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex) {
            [[maybe_unused]] const Location pSubmits_loc = loc.dot(Field::pSubmits, submitIndex);
            constexpr std::array allowed_structs_VkSubmitInfo = {VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC,
                                                                 VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
                                                                 VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                                                                 VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
                                                                 VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
                                                                 VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
                                                                 VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV};

            skip |= context.ValidateStructPnext(pSubmits_loc, pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo.size(),
                                                allowed_structs_VkSubmitInfo.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkSubmitInfo-pNext-pNext", "VUID-VkSubmitInfo-sType-unique", true);

            skip |= context.ValidateArray(pSubmits_loc.dot(Field::waitSemaphoreCount), pSubmits_loc.dot(Field::pWaitSemaphores),
                                          pSubmits[submitIndex].waitSemaphoreCount, &pSubmits[submitIndex].pWaitSemaphores, false,
                                          true, kVUIDUndefined, "VUID-VkSubmitInfo-pWaitSemaphores-parameter");

            skip |= context.ValidateFlagsArray(
                pSubmits_loc.dot(Field::waitSemaphoreCount), pSubmits_loc.dot(Field::pWaitDstStageMask),
                vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits, pSubmits[submitIndex].waitSemaphoreCount,
                pSubmits[submitIndex].pWaitDstStageMask, false, kVUIDUndefined, "VUID-VkSubmitInfo-pWaitDstStageMask-parameter");

            skip |= context.ValidateArray(pSubmits_loc.dot(Field::commandBufferCount), pSubmits_loc.dot(Field::pCommandBuffers),
                                          pSubmits[submitIndex].commandBufferCount, &pSubmits[submitIndex].pCommandBuffers, false,
                                          true, kVUIDUndefined, "VUID-VkSubmitInfo-pCommandBuffers-parameter");

            skip |= context.ValidateArray(pSubmits_loc.dot(Field::signalSemaphoreCount), pSubmits_loc.dot(Field::pSignalSemaphores),
                                          pSubmits[submitIndex].signalSemaphoreCount, &pSubmits[submitIndex].pSignalSemaphores,
                                          false, true, kVUIDUndefined, "VUID-VkSubmitInfo-pSignalSemaphores-parameter");
        }
    }
    return skip;
}

bool Device::PreCallValidateQueueWaitIdle(VkQueue queue, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateDeviceWaitIdle(VkDevice device, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateAllocateMemory(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo,
                                           const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pAllocateInfo), pAllocateInfo, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, true,
                                       "VUID-vkAllocateMemory-pAllocateInfo-parameter", "VUID-VkMemoryAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr) {
        [[maybe_unused]] const Location pAllocateInfo_loc = loc.dot(Field::pAllocateInfo);
        constexpr std::array allowed_structs_VkMemoryAllocateInfo = {VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
                                                                     VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
                                                                     VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
                                                                     VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
                                                                     VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
                                                                     VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT};

        skip |=
            context.ValidateStructPnext(pAllocateInfo_loc, pAllocateInfo->pNext, allowed_structs_VkMemoryAllocateInfo.size(),
                                        allowed_structs_VkMemoryAllocateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkMemoryAllocateInfo-pNext-pNext", "VUID-VkMemoryAllocateInfo-sType-unique", true);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMemory), pMemory, "VUID-vkAllocateMemory-pMemory-parameter");
    if (!skip) skip |= manual_PreCallValidateAllocateMemory(device, pAllocateInfo, pAllocator, pMemory, context);
    return skip;
}

bool Device::PreCallValidateFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator,
                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
                                      VkMemoryMapFlags flags, void** ppData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryMapFlagBits, AllVkMemoryMapFlagBits, flags,
                                  kOptionalFlags, "VUID-vkMapMemory-flags-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::ppData), ppData, "VUID-vkMapMemory-ppData-parameter");
    return skip;
}

bool Device::PreCallValidateUnmapMemory(VkDevice device, VkDeviceMemory memory, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    return skip;
}

bool Device::PreCallValidateFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                    const VkMappedMemoryRange* pMemoryRanges, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::memoryRangeCount), loc.dot(Field::pMemoryRanges), memoryRangeCount, pMemoryRanges,
        VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, "VUID-VkMappedMemoryRange-sType-sType",
        "VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter", "VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength");
    if (pMemoryRanges != nullptr) {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex) {
            [[maybe_unused]] const Location pMemoryRanges_loc = loc.dot(Field::pMemoryRanges, memoryRangeIndex);
            skip |= context.ValidateStructPnext(pMemoryRanges_loc, pMemoryRanges[memoryRangeIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkMappedMemoryRange-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRequiredHandle(pMemoryRanges_loc.dot(Field::memory), pMemoryRanges[memoryRangeIndex].memory);
        }
    }
    return skip;
}

bool Device::PreCallValidateInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                         const VkMappedMemoryRange* pMemoryRanges,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::memoryRangeCount), loc.dot(Field::pMemoryRanges), memoryRangeCount,
                                            pMemoryRanges, VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true,
                                            "VUID-VkMappedMemoryRange-sType-sType",
                                            "VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter",
                                            "VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength");
    if (pMemoryRanges != nullptr) {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex) {
            [[maybe_unused]] const Location pMemoryRanges_loc = loc.dot(Field::pMemoryRanges, memoryRangeIndex);
            skip |= context.ValidateStructPnext(pMemoryRanges_loc, pMemoryRanges[memoryRangeIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkMappedMemoryRange-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRequiredHandle(pMemoryRanges_loc.dot(Field::memory), pMemoryRanges[memoryRangeIndex].memory);
        }
    }
    return skip;
}

bool Device::PreCallValidateGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCommittedMemoryInBytes), pCommittedMemoryInBytes,
                                            "VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter");
    return skip;
}

bool Device::PreCallValidateBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    return skip;
}

bool Device::PreCallValidateBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    return skip;
}

bool Device::PreCallValidateGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMemoryRequirements), pMemoryRequirements,
                                            "VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter");
    return skip;
}

bool Device::PreCallValidateGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMemoryRequirements), pMemoryRequirements,
                                            "VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter");
    return skip;
}

bool Device::PreCallValidateGetImageSparseMemoryRequirements(VkDevice device, VkImage image,
                                                             uint32_t* pSparseMemoryRequirementCount,
                                                             VkSparseImageMemoryRequirements* pSparseMemoryRequirements,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |=
        context.ValidatePointerArray(loc.dot(Field::pSparseMemoryRequirementCount), loc.dot(Field::pSparseMemoryRequirements),
                                     pSparseMemoryRequirementCount, &pSparseMemoryRequirements, true, false, false,
                                     "VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter",
                                     kVUIDUndefined, "VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter");
    if (pSparseMemoryRequirements != nullptr) {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount;
             ++pSparseMemoryRequirementIndex) {
            [[maybe_unused]] const Location pSparseMemoryRequirements_loc =
                loc.dot(Field::pSparseMemoryRequirements, pSparseMemoryRequirementIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                           VkImageType type, VkSampleCountFlagBits samples,
                                                                           VkImageUsageFlags usage, VkImageTiling tiling,
                                                                           uint32_t* pPropertyCount,
                                                                           VkSparseImageFormatProperties* pProperties,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                                       "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::type), vvl::Enum::VkImageType, type,
                                       "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter");
    skip |=
        context.ValidateFlags(loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits, samples,
                              kRequiredSingleBit, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter",
                              "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits, usage,
                                  kRequiredFlags, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter",
                                  "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask");
    skip |= context.ValidateRangedEnum(loc.dot(Field::tiling), vvl::Enum::VkImageTiling, tiling,
                                       "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter");
    skip |= context.ValidatePointerArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties, true, false, false,
        "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfo), bindInfoCount, pBindInfo,
                                            VK_STRUCTURE_TYPE_BIND_SPARSE_INFO, false, true, "VUID-VkBindSparseInfo-sType-sType",
                                            "VUID-vkQueueBindSparse-pBindInfo-parameter", kVUIDUndefined);
    if (pBindInfo != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfo_loc = loc.dot(Field::pBindInfo, bindInfoIndex);
            constexpr std::array allowed_structs_VkBindSparseInfo = {VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
                                                                     VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                                                                     VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO};

            skip |=
                context.ValidateStructPnext(pBindInfo_loc, pBindInfo[bindInfoIndex].pNext, allowed_structs_VkBindSparseInfo.size(),
                                            allowed_structs_VkBindSparseInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkBindSparseInfo-pNext-pNext", "VUID-VkBindSparseInfo-sType-unique", true);

            skip |= context.ValidateArray(pBindInfo_loc.dot(Field::waitSemaphoreCount), pBindInfo_loc.dot(Field::pWaitSemaphores),
                                          pBindInfo[bindInfoIndex].waitSemaphoreCount, &pBindInfo[bindInfoIndex].pWaitSemaphores,
                                          false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pWaitSemaphores-parameter");

            skip |= context.ValidateArray(pBindInfo_loc.dot(Field::bufferBindCount), pBindInfo_loc.dot(Field::pBufferBinds),
                                          pBindInfo[bindInfoIndex].bufferBindCount, &pBindInfo[bindInfoIndex].pBufferBinds, false,
                                          true, kVUIDUndefined, "VUID-VkBindSparseInfo-pBufferBinds-parameter");

            if (pBindInfo[bindInfoIndex].pBufferBinds != nullptr) {
                for (uint32_t bufferBindIndex = 0; bufferBindIndex < pBindInfo[bindInfoIndex].bufferBindCount; ++bufferBindIndex) {
                    [[maybe_unused]] const Location pBufferBinds_loc = pBindInfo_loc.dot(Field::pBufferBinds, bufferBindIndex);
                    skip |= context.ValidateRequiredHandle(pBufferBinds_loc.dot(Field::buffer),
                                                           pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].buffer);

                    skip |= context.ValidateArray(pBufferBinds_loc.dot(Field::bindCount), pBufferBinds_loc.dot(Field::pBinds),
                                                  pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount,
                                                  &pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds, true, true,
                                                  "VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength",
                                                  "VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds != nullptr) {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount;
                             ++bindIndex) {
                            [[maybe_unused]] const Location pBinds_loc = pBufferBinds_loc.dot(Field::pBinds, bindIndex);
                            skip |= context.ValidateFlags(
                                pBinds_loc.dot(Field::flags), vvl::FlagBitmask::VkSparseMemoryBindFlagBits,
                                AllVkSparseMemoryBindFlagBits,
                                pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds[bindIndex].flags, kOptionalFlags,
                                "VUID-VkSparseMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |=
                context.ValidateArray(pBindInfo_loc.dot(Field::imageOpaqueBindCount), pBindInfo_loc.dot(Field::pImageOpaqueBinds),
                                      pBindInfo[bindInfoIndex].imageOpaqueBindCount, &pBindInfo[bindInfoIndex].pImageOpaqueBinds,
                                      false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter");

            if (pBindInfo[bindInfoIndex].pImageOpaqueBinds != nullptr) {
                for (uint32_t imageOpaqueBindIndex = 0; imageOpaqueBindIndex < pBindInfo[bindInfoIndex].imageOpaqueBindCount;
                     ++imageOpaqueBindIndex) {
                    [[maybe_unused]] const Location pImageOpaqueBinds_loc =
                        pBindInfo_loc.dot(Field::pImageOpaqueBinds, imageOpaqueBindIndex);
                    skip |= context.ValidateRequiredHandle(pImageOpaqueBinds_loc.dot(Field::image),
                                                           pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].image);

                    skip |=
                        context.ValidateArray(pImageOpaqueBinds_loc.dot(Field::bindCount), pImageOpaqueBinds_loc.dot(Field::pBinds),
                                              pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount,
                                              &pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds, true, true,
                                              "VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength",
                                              "VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds != nullptr) {
                        for (uint32_t bindIndex = 0;
                             bindIndex < pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount; ++bindIndex) {
                            [[maybe_unused]] const Location pBinds_loc = pImageOpaqueBinds_loc.dot(Field::pBinds, bindIndex);
                            skip |= context.ValidateFlags(
                                pBinds_loc.dot(Field::flags), vvl::FlagBitmask::VkSparseMemoryBindFlagBits,
                                AllVkSparseMemoryBindFlagBits,
                                pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds[bindIndex].flags,
                                kOptionalFlags, "VUID-VkSparseMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= context.ValidateArray(pBindInfo_loc.dot(Field::imageBindCount), pBindInfo_loc.dot(Field::pImageBinds),
                                          pBindInfo[bindInfoIndex].imageBindCount, &pBindInfo[bindInfoIndex].pImageBinds, false,
                                          true, kVUIDUndefined, "VUID-VkBindSparseInfo-pImageBinds-parameter");

            if (pBindInfo[bindInfoIndex].pImageBinds != nullptr) {
                for (uint32_t imageBindIndex = 0; imageBindIndex < pBindInfo[bindInfoIndex].imageBindCount; ++imageBindIndex) {
                    [[maybe_unused]] const Location pImageBinds_loc = pBindInfo_loc.dot(Field::pImageBinds, imageBindIndex);
                    skip |= context.ValidateRequiredHandle(pImageBinds_loc.dot(Field::image),
                                                           pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].image);

                    skip |= context.ValidateArray(pImageBinds_loc.dot(Field::bindCount), pImageBinds_loc.dot(Field::pBinds),
                                                  pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount,
                                                  &pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds, true, true,
                                                  "VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength",
                                                  "VUID-VkSparseImageMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds != nullptr) {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount;
                             ++bindIndex) {
                            [[maybe_unused]] const Location pBinds_loc = pImageBinds_loc.dot(Field::pBinds, bindIndex);
                            skip |= context.ValidateFlags(
                                pBinds_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                AllVkImageAspectFlagBits,
                                pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].subresource.aspectMask,
                                kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter",
                                "VUID-VkImageSubresource-aspectMask-requiredbitmask");

                            // No xml-driven validation

                            // No xml-driven validation

                            skip |=
                                context.ValidateFlags(pBinds_loc.dot(Field::flags), vvl::FlagBitmask::VkSparseMemoryBindFlagBits,
                                                      AllVkSparseMemoryBindFlagBits,
                                                      pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].flags,
                                                      kOptionalFlags, "VUID-VkSparseImageMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |=
                context.ValidateArray(pBindInfo_loc.dot(Field::signalSemaphoreCount), pBindInfo_loc.dot(Field::pSignalSemaphores),
                                      pBindInfo[bindInfoIndex].signalSemaphoreCount, &pBindInfo[bindInfoIndex].pSignalSemaphores,
                                      false, true, kVUIDUndefined, "VUID-VkBindSparseInfo-pSignalSemaphores-parameter");
        }
    }
    if (!skip) skip |= manual_PreCallValidateQueueBindSparse(queue, bindInfoCount, pBindInfo, fence, context);
    return skip;
}

bool Device::PreCallValidateCreateFence(VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator, VkFence* pFence,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, true,
                                       "VUID-vkCreateFence-pCreateInfo-parameter", "VUID-VkFenceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkFenceCreateInfo = {VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
                                                                  VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkFenceCreateInfo.size(),
                                            allowed_structs_VkFenceCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkFenceCreateInfo-pNext-pNext", "VUID-VkFenceCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFenceCreateFlagBits,
                                      AllVkFenceCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkFenceCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFence), pFence, "VUID-vkCreateFence-pFence-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateResetFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateHandleArray(loc.dot(Field::fenceCount), loc.dot(Field::pFences), fenceCount, pFences, true, true,
                                        "VUID-vkResetFences-fenceCount-arraylength");
    return skip;
}

bool Device::PreCallValidateGetFenceStatus(VkDevice device, VkFence fence, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::fence), fence);
    return skip;
}

bool Device::PreCallValidateWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll,
                                          uint64_t timeout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateHandleArray(loc.dot(Field::fenceCount), loc.dot(Field::pFences), fenceCount, pFences, true, true,
                                        "VUID-vkWaitForFences-fenceCount-arraylength");
    skip |= context.ValidateBool32(loc.dot(Field::waitAll), waitAll);
    return skip;
}

bool Device::PreCallValidateCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, true,
                                       "VUID-vkCreateSemaphore-pCreateInfo-parameter", "VUID-VkSemaphoreCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSemaphoreCreateInfo = {
            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
            VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV,           VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO};

        skip |=
            context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSemaphoreCreateInfo.size(),
                                        allowed_structs_VkSemaphoreCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkSemaphoreCreateInfo-pNext-pNext", "VUID-VkSemaphoreCreateInfo-sType-unique", true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkSemaphoreCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSemaphore), pSemaphore, "VUID-vkCreateSemaphore-pSemaphore-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore, context);
    return skip;
}

bool Device::PreCallValidateDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateEvent(VkDevice device, const VkEventCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator, VkEvent* pEvent,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_EVENT_CREATE_INFO, true,
                                       "VUID-vkCreateEvent-pCreateInfo-parameter", "VUID-VkEventCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkEventCreateInfo = {VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                                                                  VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkEventCreateInfo.size(),
                                            allowed_structs_VkEventCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkEventCreateInfo-pNext-pNext", "VUID-VkEventCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkEventCreateFlagBits,
                                      AllVkEventCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkEventCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pEvent), pEvent, "VUID-vkCreateEvent-pEvent-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateEvent(device, pCreateInfo, pAllocator, pEvent, context);
    return skip;
}

bool Device::PreCallValidateDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetEventStatus(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    return skip;
}

bool Device::PreCallValidateSetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    return skip;
}

bool Device::PreCallValidateResetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    return skip;
}

bool Device::PreCallValidateCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, true,
                                       "VUID-vkCreateQueryPool-pCreateInfo-parameter", "VUID-VkQueryPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkQueryPoolCreateInfo = {
            VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR};

        skip |=
            context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkQueryPoolCreateInfo.size(),
                                        allowed_structs_VkQueryPoolCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkQueryPoolCreateInfo-pNext-pNext", "VUID-VkQueryPoolCreateInfo-sType-unique", true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkQueryPoolCreateInfo-flags-zerobitmask");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::queryType), vvl::Enum::VkQueryType, pCreateInfo->queryType,
                                           "VUID-VkQueryPoolCreateInfo-queryType-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pQueryPool), pQueryPool, "VUID-vkCreateQueryPool-pQueryPool-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool, context);
    return skip;
}

bool Device::PreCallValidateDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
                                                size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkGetQueryPoolResults-dataSize-arraylength", "VUID-vkGetQueryPoolResults-pData-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryResultFlagBits, AllVkQueryResultFlagBits, flags,
                                  kOptionalFlags, "VUID-vkGetQueryPoolResults-flags-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags,
                                                          context);
    return skip;
}

bool Device::PreCallValidateCreateBuffer(VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                                         const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true,
                                       "VUID-vkCreateBuffer-pCreateInfo-parameter", "VUID-VkBufferCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkBufferCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                                                                   VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
                                                                   VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(),
                                            allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                                      AllVkBufferCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkBufferCreateInfo-flags-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                           pCreateInfo->sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pBuffer), pBuffer, "VUID-vkCreateBuffer-pBuffer-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateBuffer(device, pCreateInfo, pAllocator, pBuffer, context);
    return skip;
}

bool Device::PreCallValidateDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateBufferView(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator, VkBufferView* pView,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, true,
                                       "VUID-vkCreateBufferView-pCreateInfo-parameter", "VUID-VkBufferViewCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkBufferViewCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                                                                       VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkBufferViewCreateInfo.size(),
                                            allowed_structs_VkBufferViewCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferViewCreateInfo-pNext-pNext", "VUID-VkBufferViewCreateInfo-sType-unique",
                                            true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkBufferViewCreateInfo-flags-zerobitmask");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::buffer), pCreateInfo->buffer);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                           "VUID-VkBufferViewCreateInfo-format-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pView), pView, "VUID-vkCreateBufferView-pView-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateBufferView(device, pCreateInfo, pAllocator, pView, context);
    return skip;
}

bool Device::PreCallValidateDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateImage(VkDevice device, const VkImageCreateInfo* pCreateInfo,
                                        const VkAllocationCallbacks* pAllocator, VkImage* pImage,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
                                       "VUID-vkCreateImage-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkImageCreateInfo = {
            VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
            VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
            VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                            allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                      AllVkImageCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkImageCreateInfo-flags-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType, pCreateInfo->imageType,
                                           "VUID-VkImageCreateInfo-imageType-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                           "VUID-VkImageCreateInfo-format-parameter");

        // No xml-driven validation

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, pCreateInfo->samples, kRequiredSingleBit,
                                      "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pCreateInfo->tiling,
                                           "VUID-VkImageCreateInfo-tiling-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, pCreateInfo->usage, kRequiredFlags,
                                      "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                           pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                           pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pImage), pImage, "VUID-vkCreateImage-pImage-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateImage(device, pCreateInfo, pAllocator, pImage, context);
    return skip;
}

bool Device::PreCallValidateDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource* pSubresource,
                                                      VkSubresourceLayout* pLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSubresource), pSubresource,
                                            "VUID-vkGetImageSubresourceLayout-pSubresource-parameter");
    if (pSubresource != nullptr) {
        [[maybe_unused]] const Location pSubresource_loc = loc.dot(Field::pSubresource);
        skip |= context.ValidateFlags(pSubresource_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pSubresource->aspectMask, kRequiredFlags,
                                      "VUID-VkImageSubresource-aspectMask-parameter",
                                      "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pLayout), pLayout, "VUID-vkGetImageSubresourceLayout-pLayout-parameter");
    return skip;
}

bool Device::PreCallValidateCreateImageView(VkDevice device, const VkImageViewCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator, VkImageView* pView,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, true,
                                       "VUID-vkCreateImageView-pCreateInfo-parameter", "VUID-VkImageViewCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkImageViewCreateInfo = {
            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO};

        skip |=
            context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkImageViewCreateInfo.size(),
                                        allowed_structs_VkImageViewCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkImageViewCreateInfo-pNext-pNext", "VUID-VkImageViewCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageViewCreateFlagBits,
                                      AllVkImageViewCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkImageViewCreateInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::image), pCreateInfo->image);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::viewType), vvl::Enum::VkImageViewType, pCreateInfo->viewType,
                                           "VUID-VkImageViewCreateInfo-viewType-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                           "VUID-VkImageViewCreateInfo-format-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::r), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.r,
                                           "VUID-VkComponentMapping-r-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::g), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.g,
                                           "VUID-VkComponentMapping-g-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::b), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.b,
                                           "VUID-VkComponentMapping-b-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::a), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.a,
                                           "VUID-VkComponentMapping-a-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pCreateInfo->subresourceRange.aspectMask, kRequiredFlags,
                                      "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                      "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pView), pView, "VUID-vkCreateImageView-pView-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateImageView(device, pCreateInfo, pAllocator, pView, context);
    return skip;
}

bool Device::PreCallValidateDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo,
                                               const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true,
                                   "VUID-vkCreateShaderModule-pCreateInfo-parameter", "VUID-VkShaderModuleCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

        skip |= context.ValidateArray(
            pCreateInfo_loc.dot(Field::codeSize), pCreateInfo_loc.dot(Field::pCode), pCreateInfo->codeSize / 4, &pCreateInfo->pCode,
            true, true, "VUID-VkShaderModuleCreateInfo-codeSize-01085", "VUID-VkShaderModuleCreateInfo-pCode-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pShaderModule), pShaderModule,
                                            "VUID-vkCreateShaderModule-pShaderModule-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule, context);
    return skip;
}

bool Device::PreCallValidateDestroyShaderModule(VkDevice device, VkShaderModule shaderModule,
                                                const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo,
                                                const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, true,
                                       "VUID-vkCreatePipelineCache-pCreateInfo-parameter",
                                       "VUID-VkPipelineCacheCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineCacheCreateInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineCacheCreateFlagBits,
                                      AllVkPipelineCacheCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkPipelineCacheCreateInfo-flags-parameter");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::initialDataSize), pCreateInfo_loc.dot(Field::pInitialData),
                                      pCreateInfo->initialDataSize, &pCreateInfo->pInitialData, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineCacheCreateInfo-pInitialData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pPipelineCache), pPipelineCache,
                                            "VUID-vkCreatePipelineCache-pPipelineCache-parameter");
    if (!skip) skip |= manual_PreCallValidateCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache, context);
    return skip;
}

bool Device::PreCallValidateDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache,
                                                 const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipelineCache), pipelineCache);
    skip |= context.ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                         "VUID-vkGetPipelineCacheData-pDataSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetPipelineCacheData-pData-parameter");
    return skip;
}

bool Device::PreCallValidateMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount,
                                                const VkPipelineCache* pSrcCaches, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstCache), dstCache);
    skip |= context.ValidateHandleArray(loc.dot(Field::srcCacheCount), loc.dot(Field::pSrcCaches), srcCacheCount, pSrcCaches, true,
                                        true, "VUID-vkMergePipelineCaches-srcCacheCount-arraylength");
    if (!skip) skip |= manual_PreCallValidateMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches, context);
    return skip;
}

bool Device::PreCallValidateCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                    const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                                    const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
        VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, true, true, "VUID-VkGraphicsPipelineCreateInfo-sType-sType",
        "VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter", "VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkGraphicsPipelineCreateInfo = {
                VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
                VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext, allowed_structs_VkGraphicsPipelineCreateInfo.size(),
                allowed_structs_VkGraphicsPipelineCreateInfo.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkGraphicsPipelineCreateInfo-pNext-pNext", "VUID-VkGraphicsPipelineCreateInfo-sType-unique", true);

            skip |= context.ValidateStructType(
                pCreateInfos_loc.dot(Field::pDynamicState), pCreateInfos[createInfoIndex].pDynamicState,
                VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false,
                "VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter", "VUID-VkPipelineDynamicStateCreateInfo-sType-sType");

            if (pCreateInfos[createInfoIndex].pDynamicState != nullptr) {
                [[maybe_unused]] const Location pDynamicState_loc = pCreateInfos_loc.dot(Field::pDynamicState);
                skip |= context.ValidateStructPnext(pDynamicState_loc, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateReservedFlags(pDynamicState_loc.dot(Field::flags),
                                                      pCreateInfos[createInfoIndex].pDynamicState->flags,
                                                      "VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask");

                skip |= context.ValidateRangedEnumArray(
                    pDynamicState_loc.dot(Field::dynamicStateCount), pDynamicState_loc.dot(Field::pDynamicStates),
                    vvl::Enum::VkDynamicState, pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount,
                    pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, false, true, kVUIDUndefined,
                    "VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true,
                                  true, "VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength",
                                  "VUID-vkCreateGraphicsPipelines-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                              pPipelines, context);
    return skip;
}

bool Device::PreCallValidateCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                   const VkComputePipelineCreateInfo* pCreateInfos,
                                                   const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
        VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, true, true, "VUID-VkComputePipelineCreateInfo-sType-sType",
        "VUID-vkCreateComputePipelines-pCreateInfos-parameter", "VUID-vkCreateComputePipelines-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkComputePipelineCreateInfo = {
                VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,   VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,  VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,     VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext, allowed_structs_VkComputePipelineCreateInfo.size(),
                allowed_structs_VkComputePipelineCreateInfo.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkComputePipelineCreateInfo-pNext-pNext", "VUID-VkComputePipelineCreateInfo-sType-unique", true);

            skip |= context.ValidateStructType(pCreateInfos_loc.dot(Field::stage), &(pCreateInfos[createInfoIndex].stage),
                                               VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, kVUIDUndefined,
                                               "VUID-VkPipelineShaderStageCreateInfo-sType-sType");

            constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[createInfoIndex].stage.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                          AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].stage.flags,
                                          kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

            skip |= context.ValidateFlags(pCreateInfos_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                          AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage.stage, kRequiredSingleBit,
                                          "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                          "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

            skip |= context.ValidateRequiredPointer(pCreateInfos_loc.dot(Field::pName), pCreateInfos[createInfoIndex].stage.pName,
                                                    "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

            if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo != nullptr) {
                [[maybe_unused]] const Location pSpecializationInfo_loc = pCreateInfos_loc.dot(Field::pSpecializationInfo);
                skip |= context.ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                              pSpecializationInfo_loc.dot(Field::pMapEntries),
                                              pCreateInfos[createInfoIndex].stage.pSpecializationInfo->mapEntryCount,
                                              &pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pMapEntries, false, true,
                                              kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pMapEntries != nullptr) {
                    for (uint32_t mapEntryIndex = 0;
                         mapEntryIndex < pCreateInfos[createInfoIndex].stage.pSpecializationInfo->mapEntryCount; ++mapEntryIndex) {
                        [[maybe_unused]] const Location pMapEntries_loc =
                            pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                        // No xml-driven validation
                    }
                }

                skip |=
                    context.ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                          pCreateInfos[createInfoIndex].stage.pSpecializationInfo->dataSize,
                                          &pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pData, false, true,
                                          kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
            }

            skip |= context.ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true,
                                  true, "VUID-vkCreateComputePipelines-createInfoCount-arraylength",
                                  "VUID-vkCreateComputePipelines-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                             pPipelines, context);
    return skip;
}

bool Device::PreCallValidateDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo,
                                                 const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                                       true, "VUID-vkCreatePipelineLayout-pCreateInfo-parameter",
                                       "VUID-VkPipelineLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineLayoutCreateFlagBits,
                                      AllVkPipelineLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkPipelineLayoutCreateInfo-flags-parameter");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::pushConstantRangeCount),
                                      pCreateInfo_loc.dot(Field::pPushConstantRanges), pCreateInfo->pushConstantRangeCount,
                                      &pCreateInfo->pPushConstantRanges, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter");

        if (pCreateInfo->pPushConstantRanges != nullptr) {
            for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < pCreateInfo->pushConstantRangeCount;
                 ++pushConstantRangeIndex) {
                [[maybe_unused]] const Location pPushConstantRanges_loc =
                    pCreateInfo_loc.dot(Field::pPushConstantRanges, pushConstantRangeIndex);
                skip |= context.ValidateFlags(
                    pPushConstantRanges_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                    AllVkShaderStageFlagBits, pCreateInfo->pPushConstantRanges[pushConstantRangeIndex].stageFlags, kRequiredFlags,
                    "VUID-VkPushConstantRange-stageFlags-parameter", "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pPipelineLayout), pPipelineLayout,
                                            "VUID-vkCreatePipelineLayout-pPipelineLayout-parameter");
    if (!skip) skip |= manual_PreCallValidateCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout, context);
    return skip;
}

bool Device::PreCallValidateDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout,
                                                  const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateSampler(VkDevice device, const VkSamplerCreateInfo* pCreateInfo,
                                          const VkAllocationCallbacks* pAllocator, VkSampler* pSampler,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, true,
                                       "VUID-vkCreateSampler-pCreateInfo-parameter", "VUID-VkSamplerCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSamplerCreateInfo = {
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM,
            VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM,
            VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSamplerCreateInfo.size(),
                                            allowed_structs_VkSamplerCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkSamplerCreateInfo-pNext-pNext", "VUID-VkSamplerCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSamplerCreateFlagBits,
                                      AllVkSamplerCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkSamplerCreateInfo-flags-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::magFilter), vvl::Enum::VkFilter, pCreateInfo->magFilter,
                                           "VUID-VkSamplerCreateInfo-magFilter-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::minFilter), vvl::Enum::VkFilter, pCreateInfo->minFilter,
                                           "VUID-VkSamplerCreateInfo-minFilter-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::mipmapMode), vvl::Enum::VkSamplerMipmapMode,
                                           pCreateInfo->mipmapMode, "VUID-VkSamplerCreateInfo-mipmapMode-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::addressModeU), vvl::Enum::VkSamplerAddressMode,
                                           pCreateInfo->addressModeU, "VUID-VkSamplerCreateInfo-addressModeU-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::addressModeV), vvl::Enum::VkSamplerAddressMode,
                                           pCreateInfo->addressModeV, "VUID-VkSamplerCreateInfo-addressModeV-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::addressModeW), vvl::Enum::VkSamplerAddressMode,
                                           pCreateInfo->addressModeW, "VUID-VkSamplerCreateInfo-addressModeW-parameter");

        skip |= context.ValidateBool32(pCreateInfo_loc.dot(Field::anisotropyEnable), pCreateInfo->anisotropyEnable);

        skip |= context.ValidateBool32(pCreateInfo_loc.dot(Field::compareEnable), pCreateInfo->compareEnable);

        skip |= context.ValidateBool32(pCreateInfo_loc.dot(Field::unnormalizedCoordinates), pCreateInfo->unnormalizedCoordinates);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSampler), pSampler, "VUID-vkCreateSampler-pSampler-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSampler(device, pCreateInfo, pAllocator, pSampler, context);
    return skip;
}

bool Device::PreCallValidateDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true,
        "VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter", "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(),
            allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext", "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDescriptorSetLayoutCreateFlagBits,
                                      AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::bindingCount), pCreateInfo_loc.dot(Field::pBindings),
                                      pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined,
                                      "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr) {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex) {
                [[maybe_unused]] const Location pBindings_loc = pCreateInfo_loc.dot(Field::pBindings, bindingIndex);
                skip |= context.ValidateRangedEnum(pBindings_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                                   pCreateInfo->pBindings[bindingIndex].descriptorType,
                                                   "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSetLayout), pSetLayout,
                                            "VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout, context);
    return skip;
}

bool Device::PreCallValidateDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
                                                       const VkAllocationCallbacks* pAllocator,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo,
                                                 const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
                                       true, "VUID-vkCreateDescriptorPool-pCreateInfo-parameter",
                                       "VUID-VkDescriptorPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDescriptorPoolCreateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDescriptorPoolCreateInfo.size(),
                                            allowed_structs_VkDescriptorPoolCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkDescriptorPoolCreateInfo-pNext-pNext",
                                            "VUID-VkDescriptorPoolCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDescriptorPoolCreateFlagBits,
                                      AllVkDescriptorPoolCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkDescriptorPoolCreateInfo-flags-parameter");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::poolSizeCount), pCreateInfo_loc.dot(Field::pPoolSizes),
                                      pCreateInfo->poolSizeCount, &pCreateInfo->pPoolSizes, false, true, kVUIDUndefined,
                                      "VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter");

        if (pCreateInfo->pPoolSizes != nullptr) {
            for (uint32_t poolSizeIndex = 0; poolSizeIndex < pCreateInfo->poolSizeCount; ++poolSizeIndex) {
                [[maybe_unused]] const Location pPoolSizes_loc = pCreateInfo_loc.dot(Field::pPoolSizes, poolSizeIndex);
                skip |= context.ValidateRangedEnum(pPoolSizes_loc.dot(Field::type), vvl::Enum::VkDescriptorType,
                                                   pCreateInfo->pPoolSizes[poolSizeIndex].type,
                                                   "VUID-VkDescriptorPoolSize-type-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDescriptorPool), pDescriptorPool,
                                            "VUID-vkCreateDescriptorPool-pDescriptorPool-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool, context);
    return skip;
}

bool Device::PreCallValidateDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                                  const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::descriptorPool), descriptorPool);
    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), flags, "VUID-vkResetDescriptorPool-flags-zerobitmask");
    return skip;
}

bool Device::PreCallValidateAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                                   VkDescriptorSet* pDescriptorSets, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pAllocateInfo), pAllocateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
                                       true, "VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter",
                                       "VUID-VkDescriptorSetAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr) {
        [[maybe_unused]] const Location pAllocateInfo_loc = loc.dot(Field::pAllocateInfo);
        constexpr std::array allowed_structs_VkDescriptorSetAllocateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO};

        skip |= context.ValidateStructPnext(
            pAllocateInfo_loc, pAllocateInfo->pNext, allowed_structs_VkDescriptorSetAllocateInfo.size(),
            allowed_structs_VkDescriptorSetAllocateInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkDescriptorSetAllocateInfo-pNext-pNext", "VUID-VkDescriptorSetAllocateInfo-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pAllocateInfo_loc.dot(Field::descriptorPool), pAllocateInfo->descriptorPool);

        skip |=
            context.ValidateHandleArray(pAllocateInfo_loc.dot(Field::descriptorSetCount), pAllocateInfo_loc.dot(Field::pSetLayouts),
                                        pAllocateInfo->descriptorSetCount, pAllocateInfo->pSetLayouts, true, true,
                                        "VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength");
    }
    if (pAllocateInfo != nullptr) {
        skip |= context.ValidateArray(loc.dot(Field::pAllocateInfo).dot(Field::descriptorSetCount), loc.dot(Field::pDescriptorSets),
                                      pAllocateInfo->descriptorSetCount, &pDescriptorSets, true, true,
                                      "VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength",
                                      "VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter");
    }
    return skip;
}

bool Device::PreCallValidateFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                                               const VkDescriptorSet* pDescriptorSets, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::descriptorPool), descriptorPool);
    skip |= context.ValidateArray(loc.dot(Field::descriptorSetCount), loc, descriptorSetCount, &pDescriptorSets, true, false,
                                  "VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength", kVUIDUndefined);
    if (!skip)
        skip |= manual_PreCallValidateFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets, context);
    return skip;
}

bool Device::PreCallValidateUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount,
                                                 const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount,
                                                 const VkCopyDescriptorSet* pDescriptorCopies, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::descriptorWriteCount), loc.dot(Field::pDescriptorWrites),
                                            descriptorWriteCount, pDescriptorWrites, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, false,
                                            true, "VUID-VkWriteDescriptorSet-sType-sType",
                                            "VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter", kVUIDUndefined);
    if (pDescriptorWrites != nullptr) {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex) {
            [[maybe_unused]] const Location pDescriptorWrites_loc = loc.dot(Field::pDescriptorWrites, descriptorWriteIndex);
            constexpr std::array allowed_structs_VkWriteDescriptorSet = {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV};

            skip |= context.ValidateStructPnext(
                pDescriptorWrites_loc, pDescriptorWrites[descriptorWriteIndex].pNext, allowed_structs_VkWriteDescriptorSet.size(),
                allowed_structs_VkWriteDescriptorSet.data(), GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext",
                "VUID-VkWriteDescriptorSet-sType-unique", true);

            skip |= context.ValidateRangedEnum(pDescriptorWrites_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                               pDescriptorWrites[descriptorWriteIndex].descriptorType,
                                               "VUID-VkWriteDescriptorSet-descriptorType-parameter");

            skip |= context.ValidateArray(pDescriptorWrites_loc.dot(Field::descriptorCount), loc,
                                          pDescriptorWrites[descriptorWriteIndex].descriptorCount,
                                          &pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false,
                                          "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
        }
    }
    skip |= context.ValidateStructTypeArray(loc.dot(Field::descriptorCopyCount), loc.dot(Field::pDescriptorCopies),
                                            descriptorCopyCount, pDescriptorCopies, VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, false,
                                            true, "VUID-VkCopyDescriptorSet-sType-sType",
                                            "VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter", kVUIDUndefined);
    if (pDescriptorCopies != nullptr) {
        for (uint32_t descriptorCopyIndex = 0; descriptorCopyIndex < descriptorCopyCount; ++descriptorCopyIndex) {
            [[maybe_unused]] const Location pDescriptorCopies_loc = loc.dot(Field::pDescriptorCopies, descriptorCopyIndex);
            skip |= context.ValidateStructPnext(pDescriptorCopies_loc, pDescriptorCopies[descriptorCopyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCopyDescriptorSet-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRequiredHandle(pDescriptorCopies_loc.dot(Field::srcSet),
                                                   pDescriptorCopies[descriptorCopyIndex].srcSet);

            skip |= context.ValidateRequiredHandle(pDescriptorCopies_loc.dot(Field::dstSet),
                                                   pDescriptorCopies[descriptorCopyIndex].dstSet);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount,
                                                           pDescriptorCopies, context);
    return skip;
}

bool Device::PreCallValidateCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, true,
                                   "VUID-vkCreateFramebuffer-pCreateInfo-parameter", "VUID-VkFramebufferCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkFramebufferCreateInfo = {VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkFramebufferCreateInfo.size(),
                                            allowed_structs_VkFramebufferCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkFramebufferCreateInfo-pNext-pNext", "VUID-VkFramebufferCreateInfo-sType-unique",
                                            true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFramebufferCreateFlagBits,
                                      AllVkFramebufferCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkFramebufferCreateInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::renderPass), pCreateInfo->renderPass);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFramebuffer), pFramebuffer,
                                            "VUID-vkCreateFramebuffer-pFramebuffer-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer, context);
    return skip;
}

bool Device::PreCallValidateDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo,
                                             const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, true,
                                       "VUID-vkCreateRenderPass-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkRenderPassCreateInfo = {
            VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO, VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo.size(),
                                            allowed_structs_VkRenderPassCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkRenderPassCreateInfo-pNext-pNext", "VUID-VkRenderPassCreateInfo-sType-unique",
                                            true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderPassCreateFlagBits,
                                      AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkRenderPassCreateInfo-flags-parameter");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::attachmentCount), pCreateInfo_loc.dot(Field::pAttachments),
                                      pCreateInfo->attachmentCount, &pCreateInfo->pAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassCreateInfo-pAttachments-parameter");

        if (pCreateInfo->pAttachments != nullptr) {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex) {
                [[maybe_unused]] const Location pAttachments_loc = pCreateInfo_loc.dot(Field::pAttachments, attachmentIndex);
                skip |= context.ValidateFlags(pAttachments_loc.dot(Field::flags), vvl::FlagBitmask::VkAttachmentDescriptionFlagBits,
                                              AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags,
                                              kOptionalFlags, "VUID-VkAttachmentDescription-flags-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::format), vvl::Enum::VkFormat,
                                                   pCreateInfo->pAttachments[attachmentIndex].format,
                                                   "VUID-VkAttachmentDescription-format-parameter");

                skip |= context.ValidateFlags(pAttachments_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                              AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples,
                                              kRequiredSingleBit, "VUID-VkAttachmentDescription-samples-parameter",
                                              "VUID-VkAttachmentDescription-samples-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].loadOp,
                                                   "VUID-VkAttachmentDescription-loadOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].storeOp,
                                                   "VUID-VkAttachmentDescription-storeOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::stencilLoadOp), vvl::Enum::VkAttachmentLoadOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp,
                                                   "VUID-VkAttachmentDescription-stencilLoadOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::stencilStoreOp), vvl::Enum::VkAttachmentStoreOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp,
                                                   "VUID-VkAttachmentDescription-stencilStoreOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                                   pCreateInfo->pAttachments[attachmentIndex].initialLayout,
                                                   "VUID-VkAttachmentDescription-initialLayout-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::finalLayout), vvl::Enum::VkImageLayout,
                                                   pCreateInfo->pAttachments[attachmentIndex].finalLayout,
                                                   "VUID-VkAttachmentDescription-finalLayout-parameter");
            }
        }

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::subpassCount), pCreateInfo_loc.dot(Field::pSubpasses),
                                      pCreateInfo->subpassCount, &pCreateInfo->pSubpasses, true, true,
                                      "VUID-VkRenderPassCreateInfo-subpassCount-arraylength",
                                      "VUID-VkRenderPassCreateInfo-pSubpasses-parameter");

        if (pCreateInfo->pSubpasses != nullptr) {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex) {
                [[maybe_unused]] const Location pSubpasses_loc = pCreateInfo_loc.dot(Field::pSubpasses, subpassIndex);
                skip |= context.ValidateFlags(pSubpasses_loc.dot(Field::flags), vvl::FlagBitmask::VkSubpassDescriptionFlagBits,
                                              AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags,
                                              kOptionalFlags, "VUID-VkSubpassDescription-flags-parameter");

                skip |= context.ValidateRangedEnum(pSubpasses_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                                   pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint,
                                                   "VUID-VkSubpassDescription-pipelineBindPoint-parameter");

                skip |= context.ValidateArray(pSubpasses_loc.dot(Field::inputAttachmentCount),
                                              pSubpasses_loc.dot(Field::pInputAttachments),
                                              pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount,
                                              &pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, false, true, kVUIDUndefined,
                                              "VUID-VkSubpassDescription-pInputAttachments-parameter");

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr) {
                    for (uint32_t inputAttachmentIndex = 0;
                         inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount;
                         ++inputAttachmentIndex) {
                        [[maybe_unused]] const Location pInputAttachments_loc =
                            pSubpasses_loc.dot(Field::pInputAttachments, inputAttachmentIndex);
                        skip |= context.ValidateRangedEnum(
                            pInputAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout,
                            "VUID-VkAttachmentReference-layout-parameter");
                    }
                }

                skip |= context.ValidateArray(pSubpasses_loc.dot(Field::colorAttachmentCount),
                                              pSubpasses_loc.dot(Field::pColorAttachments),
                                              pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount,
                                              &pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, false, true, kVUIDUndefined,
                                              "VUID-VkSubpassDescription-pColorAttachments-parameter");

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pColorAttachments_loc =
                            pSubpasses_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                        skip |= context.ValidateRangedEnum(
                            pColorAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout,
                            "VUID-VkAttachmentReference-layout-parameter");
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pResolveAttachments_loc =
                            pSubpasses_loc.dot(Field::pResolveAttachments, colorAttachmentIndex);
                        skip |= context.ValidateRangedEnum(
                            pResolveAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout,
                            "VUID-VkAttachmentReference-layout-parameter");
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr) {
                    [[maybe_unused]] const Location pDepthStencilAttachment_loc =
                        pSubpasses_loc.dot(Field::pDepthStencilAttachment);
                    skip |= context.ValidateRangedEnum(pDepthStencilAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                                       pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout,
                                                       "VUID-VkAttachmentReference-layout-parameter");
                }

                skip |= context.ValidateArray(pSubpasses_loc.dot(Field::preserveAttachmentCount),
                                              pSubpasses_loc.dot(Field::pPreserveAttachments),
                                              pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount,
                                              &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true,
                                              kVUIDUndefined, "VUID-VkSubpassDescription-pPreserveAttachments-parameter");
            }
        }

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::dependencyCount), pCreateInfo_loc.dot(Field::pDependencies),
                                      pCreateInfo->dependencyCount, &pCreateInfo->pDependencies, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassCreateInfo-pDependencies-parameter");

        if (pCreateInfo->pDependencies != nullptr) {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex) {
                [[maybe_unused]] const Location pDependencies_loc = pCreateInfo_loc.dot(Field::pDependencies, dependencyIndex);
                skip |= context.ValidateFlags(pDependencies_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                              AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask,
                                              kOptionalFlags, "VUID-VkSubpassDependency-srcStageMask-parameter");

                skip |= context.ValidateFlags(pDependencies_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                              AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask,
                                              kOptionalFlags, "VUID-VkSubpassDependency-dstStageMask-parameter");

                skip |= context.ValidateFlags(pDependencies_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                              AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask,
                                              kOptionalFlags, "VUID-VkSubpassDependency-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pDependencies_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                              AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask,
                                              kOptionalFlags, "VUID-VkSubpassDependency-dstAccessMask-parameter");

                skip |= context.ValidateFlags(pDependencies_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                              AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags,
                                              kOptionalFlags, "VUID-VkSubpassDependency-dependencyFlags-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pRenderPass), pRenderPass, "VUID-vkCreateRenderPass-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass, context);
    return skip;
}

bool Device::PreCallValidateDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::renderPass), renderPass);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pGranularity), pGranularity,
                                            "VUID-vkGetRenderAreaGranularity-pGranularity-parameter");
    return skip;
}

bool Device::PreCallValidateCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, true,
                                   "VUID-vkCreateCommandPool-pCreateInfo-parameter", "VUID-VkCommandPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCommandPoolCreateInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkCommandPoolCreateFlagBits,
                                      AllVkCommandPoolCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkCommandPoolCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCommandPool), pCommandPool,
                                            "VUID-vkCreateCommandPool-pCommandPool-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkCommandPoolResetFlagBits,
                                  AllVkCommandPoolResetFlagBits, flags, kOptionalFlags, "VUID-vkResetCommandPool-flags-parameter");
    return skip;
}

bool Device::PreCallValidateAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo,
                                                   VkCommandBuffer* pCommandBuffers, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pAllocateInfo), pAllocateInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
                                       true, "VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter",
                                       "VUID-VkCommandBufferAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr) {
        [[maybe_unused]] const Location pAllocateInfo_loc = loc.dot(Field::pAllocateInfo);
        skip |= context.ValidateStructPnext(pAllocateInfo_loc, pAllocateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCommandBufferAllocateInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pAllocateInfo_loc.dot(Field::commandPool), pAllocateInfo->commandPool);

        skip |= context.ValidateRangedEnum(pAllocateInfo_loc.dot(Field::level), vvl::Enum::VkCommandBufferLevel,
                                           pAllocateInfo->level, "VUID-VkCommandBufferAllocateInfo-level-parameter");
    }
    if (pAllocateInfo != nullptr) {
        skip |= context.ValidateArray(loc.dot(Field::pAllocateInfo).dot(Field::commandBufferCount), loc.dot(Field::pCommandBuffers),
                                      pAllocateInfo->commandBufferCount, &pCommandBuffers, true, true,
                                      "VUID-vkAllocateCommandBuffers-pAllocateInfo::commandBufferCount-arraylength",
                                      "VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter");
    }
    return skip;
}

bool Device::PreCallValidateFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount,
                                               const VkCommandBuffer* pCommandBuffers, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);
    skip |= context.ValidateArray(loc.dot(Field::commandBufferCount), loc, commandBufferCount, &pCommandBuffers, true, false,
                                  "VUID-vkFreeCommandBuffers-commandBufferCount-arraylength", kVUIDUndefined);
    if (!skip) skip |= manual_PreCallValidateFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers, context);
    return skip;
}

bool Device::PreCallValidateBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pBeginInfo), pBeginInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, true,
                                   "VUID-vkBeginCommandBuffer-pBeginInfo-parameter", "VUID-VkCommandBufferBeginInfo-sType-sType");
    if (pBeginInfo != nullptr) {
        [[maybe_unused]] const Location pBeginInfo_loc = loc.dot(Field::pBeginInfo);
        constexpr std::array allowed_structs_VkCommandBufferBeginInfo = {VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO};

        skip |= context.ValidateStructPnext(pBeginInfo_loc, pBeginInfo->pNext, allowed_structs_VkCommandBufferBeginInfo.size(),
                                            allowed_structs_VkCommandBufferBeginInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkCommandBufferBeginInfo-pNext-pNext",
                                            "VUID-VkCommandBufferBeginInfo-sType-unique", true);

        skip |= context.ValidateFlags(pBeginInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkCommandBufferUsageFlagBits,
                                      AllVkCommandBufferUsageFlagBits, pBeginInfo->flags, kOptionalFlags,
                                      "VUID-VkCommandBufferBeginInfo-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateBeginCommandBuffer(commandBuffer, pBeginInfo, context);
    return skip;
}

bool Device::PreCallValidateEndCommandBuffer(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkCommandBufferResetFlagBits,
                              AllVkCommandBufferResetFlagBits, flags, kOptionalFlags, "VUID-vkResetCommandBuffer-flags-parameter");
    return skip;
}

bool Device::PreCallValidateCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                            VkPipeline pipeline, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdBindPipeline-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool Device::PreCallValidateCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
                                           const VkViewport* pViewports, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewports), viewportCount, &pViewports, true, true,
                                  "VUID-vkCmdSetViewport-viewportCount-arraylength", "VUID-vkCmdSetViewport-pViewports-parameter");
    if (pViewports != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewports_loc = loc.dot(Field::pViewports, viewportIndex);
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports, context);
    return skip;
}

bool Device::PreCallValidateCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount,
                                          const VkRect2D* pScissors, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateArray(loc.dot(Field::scissorCount), loc.dot(Field::pScissors), scissorCount, &pScissors, true, true,
                                  "VUID-vkCmdSetScissor-scissorCount-arraylength", "VUID-vkCmdSetScissor-pScissors-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors, context);
    return skip;
}

bool Device::PreCallValidateCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdSetLineWidth(commandBuffer, lineWidth, context);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp,
                                            float depthBiasSlopeFactor, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4],
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                     uint32_t compareMask, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits,
                                  faceMask, kRequiredFlags, "VUID-vkCmdSetStencilCompareMask-faceMask-parameter",
                                  "VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask");
    return skip;
}

bool Device::PreCallValidateCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits,
                                  faceMask, kRequiredFlags, "VUID-vkCmdSetStencilWriteMask-faceMask-parameter",
                                  "VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask");
    return skip;
}

bool Device::PreCallValidateCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits,
                                  faceMask, kRequiredFlags, "VUID-vkCmdSetStencilReference-faceMask-parameter",
                                  "VUID-vkCmdSetStencilReference-faceMask-requiredbitmask");
    return skip;
}

bool Device::PreCallValidateCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                  VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount,
                                                  const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount,
                                                  const uint32_t* pDynamicOffsets, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= context.ValidateArray(loc.dot(Field::descriptorSetCount), loc.dot(Field::pDescriptorSets), descriptorSetCount,
                                  &pDescriptorSets, true, false, "VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength",
                                  "VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter");
    skip |= context.ValidateArray(loc.dot(Field::dynamicOffsetCount), loc.dot(Field::pDynamicOffsets), dynamicOffsetCount,
                                  &pDynamicOffsets, false, true, kVUIDUndefined,
                                  "VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter");
    return skip;
}

bool Device::PreCallValidateCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                               VkIndexType indexType, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::indexType), vvl::Enum::VkIndexType, indexType,
                                       "VUID-vkCmdBindIndexBuffer-indexType-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType, context);
    return skip;
}

bool Device::PreCallValidateCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
                                                 const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateArray(loc.dot(Field::bindingCount), loc.dot(Field::pBuffers), bindingCount, &pBuffers, true, false,
                                  "VUID-vkCmdBindVertexBuffers-bindingCount-arraylength",
                                  "VUID-vkCmdBindVertexBuffers-pBuffers-parameter");
    skip |= context.ValidateArray(loc.dot(Field::bindingCount), loc.dot(Field::pOffsets), bindingCount, &pOffsets, true, true,
                                  "VUID-vkCmdBindVertexBuffers-bindingCount-arraylength",
                                  "VUID-vkCmdBindVertexBuffers-pOffsets-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, context);
    return skip;
}

bool Device::PreCallValidateCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
                                    uint32_t firstVertex, uint32_t firstInstance, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount,
                                           uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount,
                                            uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                   uint32_t drawCount, uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool Device::PreCallValidateCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                                        uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool Device::PreCallValidateCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer,
                                          uint32_t regionCount, const VkBufferCopy* pRegions, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::srcBuffer), srcBuffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= context.ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                                  "VUID-vkCmdCopyBuffer-regionCount-arraylength", "VUID-vkCmdCopyBuffer-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                         VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                                         const VkImageCopy* pRegions, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                                       "VUID-vkCmdCopyImage-srcImageLayout-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                                       "VUID-vkCmdCopyImage-dstImageLayout-parameter");
    skip |= context.ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                                  "VUID-vkCmdCopyImage-regionCount-arraylength", "VUID-vkCmdCopyImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                         VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                                         const VkImageBlit* pRegions, VkFilter filter, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                                       "VUID-vkCmdBlitImage-srcImageLayout-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                                       "VUID-vkCmdBlitImage-dstImageLayout-parameter");
    skip |= context.ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                                  "VUID-vkCmdBlitImage-regionCount-arraylength", "VUID-vkCmdBlitImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
        }
    }
    skip |= context.ValidateRangedEnum(loc.dot(Field::filter), vvl::Enum::VkFilter, filter, "VUID-vkCmdBlitImage-filter-parameter");
    return skip;
}

bool Device::PreCallValidateCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
                                                 VkImageLayout dstImageLayout, uint32_t regionCount,
                                                 const VkBufferImageCopy* pRegions, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::srcBuffer), srcBuffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                                       "VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter");
    skip |= context.ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                                  "VUID-vkCmdCopyBufferToImage-regionCount-arraylength",
                                  "VUID-vkCmdCopyBufferToImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                                 VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                                       "VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= context.ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                                  "VUID-vkCmdCopyImageToBuffer-regionCount-arraylength",
                                  "VUID-vkCmdCopyImageToBuffer-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                            VkDeviceSize dataSize, const void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkCmdUpdateBuffer-dataSize-arraylength", "VUID-vkCmdUpdateBuffer-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData, context);
    return skip;
}

bool Device::PreCallValidateCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                          VkDeviceSize size, uint32_t data, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    if (!skip) skip |= manual_PreCallValidateCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data, context);
    return skip;
}

bool Device::PreCallValidateCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
                                               const VkClearColorValue* pColor, uint32_t rangeCount,
                                               const VkImageSubresourceRange* pRanges, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                                       "VUID-vkCmdClearColorImage-imageLayout-parameter");
    skip |=
        context.ValidateArray(loc.dot(Field::rangeCount), loc.dot(Field::pRanges), rangeCount, &pRanges, true, true,
                              "VUID-vkCmdClearColorImage-rangeCount-arraylength", "VUID-vkCmdClearColorImage-pRanges-parameter");
    if (pRanges != nullptr) {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex) {
            [[maybe_unused]] const Location pRanges_loc = loc.dot(Field::pRanges, rangeIndex);
            skip |= context.ValidateFlags(pRanges_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                          "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges, context);
    return skip;
}

bool Device::PreCallValidateCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
                                                      const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount,
                                                      const VkImageSubresourceRange* pRanges, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                                       "VUID-vkCmdClearDepthStencilImage-imageLayout-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDepthStencil), pDepthStencil,
                                            "VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter");
    skip |= context.ValidateArray(loc.dot(Field::rangeCount), loc.dot(Field::pRanges), rangeCount, &pRanges, true, true,
                                  "VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength",
                                  "VUID-vkCmdClearDepthStencilImage-pRanges-parameter");
    if (pRanges != nullptr) {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex) {
            [[maybe_unused]] const Location pRanges_loc = loc.dot(Field::pRanges, rangeIndex);
            skip |= context.ValidateFlags(pRanges_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                          "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                                const VkClearAttachment* pAttachments, uint32_t rectCount,
                                                const VkClearRect* pRects, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateArray(loc.dot(Field::attachmentCount), loc.dot(Field::pAttachments), attachmentCount, &pAttachments,
                                  true, true, "VUID-vkCmdClearAttachments-attachmentCount-arraylength",
                                  "VUID-vkCmdClearAttachments-pAttachments-parameter");
    if (pAttachments != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pAttachments_loc = loc.dot(Field::pAttachments, attachmentIndex);
            skip |= context.ValidateFlags(pAttachments_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pAttachments[attachmentIndex].aspectMask, kRequiredFlags,
                                          "VUID-VkClearAttachment-aspectMask-parameter",
                                          "VUID-VkClearAttachment-aspectMask-requiredbitmask");
        }
    }
    skip |=
        context.ValidateArray(loc.dot(Field::rectCount), loc.dot(Field::pRects), rectCount, &pRects, true, true,
                              "VUID-vkCmdClearAttachments-rectCount-arraylength", "VUID-vkCmdClearAttachments-pRects-parameter");
    if (pRects != nullptr) {
        for (uint32_t rectIndex = 0; rectIndex < rectCount; ++rectIndex) {
            [[maybe_unused]] const Location pRects_loc = loc.dot(Field::pRects, rectIndex);
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects, context);
    return skip;
}

bool Device::PreCallValidateCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                            VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                                            const VkImageResolve* pRegions, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                                       "VUID-vkCmdResolveImage-srcImageLayout-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                                       "VUID-vkCmdResolveImage-dstImageLayout-parameter");
    skip |= context.ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                                  "VUID-vkCmdResolveImage-regionCount-arraylength", "VUID-vkCmdResolveImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= context.ValidateFlags(loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                                  stageMask, kOptionalFlags, "VUID-vkCmdSetEvent-stageMask-parameter");
    return skip;
}

bool Device::PreCallValidateCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= context.ValidateFlags(loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                                  stageMask, kOptionalFlags, "VUID-vkCmdResetEvent-stageMask-parameter");
    return skip;
}

bool Device::PreCallValidateCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                                          VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
                                          uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                                          uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                                          uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateHandleArray(loc.dot(Field::eventCount), loc.dot(Field::pEvents), eventCount, pEvents, true, true,
                                        "VUID-vkCmdWaitEvents-eventCount-arraylength");
    skip |=
        context.ValidateFlags(loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                              srcStageMask, kOptionalFlags, "VUID-vkCmdWaitEvents-srcStageMask-parameter");
    skip |=
        context.ValidateFlags(loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                              dstStageMask, kOptionalFlags, "VUID-vkCmdWaitEvents-dstStageMask-parameter");
    skip |= context.ValidateStructTypeArray(loc.dot(Field::memoryBarrierCount), loc.dot(Field::pMemoryBarriers), memoryBarrierCount,
                                            pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true,
                                            "VUID-VkMemoryBarrier-sType-sType", "VUID-vkCmdWaitEvents-pMemoryBarriers-parameter",
                                            kVUIDUndefined);
    if (pMemoryBarriers != nullptr) {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex) {
            [[maybe_unused]] const Location pMemoryBarriers_loc = loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
            skip |=
                context.ValidateStructPnext(pMemoryBarriers_loc, pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryBarrier-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                          AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags,
                                          "VUID-VkMemoryBarrier-srcAccessMask-parameter");

            skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                          AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags,
                                          "VUID-VkMemoryBarrier-dstAccessMask-parameter");
        }
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::bufferMemoryBarrierCount), loc.dot(Field::pBufferMemoryBarriers), bufferMemoryBarrierCount,
        pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false, true, "VUID-VkBufferMemoryBarrier-sType-sType",
        "VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter", kVUIDUndefined);
    if (pBufferMemoryBarriers != nullptr) {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount;
             ++bufferMemoryBarrierIndex) {
            [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkBufferMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

            skip |= context.ValidateStructPnext(pBufferMemoryBarriers_loc, pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                                                allowed_structs_VkBufferMemoryBarrier.size(),
                                                allowed_structs_VkBufferMemoryBarrier.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkBufferMemoryBarrier-pNext-pNext", "VUID-VkBufferMemoryBarrier-sType-unique",
                                                true);

            skip |= context.ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                                   pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }
    skip |= context.ValidateStructTypeArray(loc.dot(Field::imageMemoryBarrierCount), loc.dot(Field::pImageMemoryBarriers),
                                            imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
                                            false, true, "VUID-VkImageMemoryBarrier-sType-sType",
                                            "VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter", kVUIDUndefined);
    if (pImageMemoryBarriers != nullptr) {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex) {
            [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkImageMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                                                                         VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

            skip |= context.ValidateStructPnext(pImageMemoryBarriers_loc, pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                                                allowed_structs_VkImageMemoryBarrier.size(),
                                                allowed_structs_VkImageMemoryBarrier.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkImageMemoryBarrier-pNext-pNext", "VUID-VkImageMemoryBarrier-sType-unique",
                                                true);

            skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                               pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                               "VUID-VkImageMemoryBarrier-oldLayout-parameter");

            skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                               pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                               "VUID-VkImageMemoryBarrier-newLayout-parameter");

            skip |= context.ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                                   pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= context.ValidateFlags(
                pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags,
                "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
                                               VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
                                               uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
                                               uint32_t bufferMemoryBarrierCount,
                                               const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount,
                                               const VkImageMemoryBarrier* pImageMemoryBarriers,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateFlags(loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                              srcStageMask, kOptionalFlags, "VUID-vkCmdPipelineBarrier-srcStageMask-parameter");
    skip |=
        context.ValidateFlags(loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                              dstStageMask, kOptionalFlags, "VUID-vkCmdPipelineBarrier-dstStageMask-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits, AllVkDependencyFlagBits,
                                  dependencyFlags, kOptionalFlags, "VUID-vkCmdPipelineBarrier-dependencyFlags-parameter");
    skip |= context.ValidateStructTypeArray(loc.dot(Field::memoryBarrierCount), loc.dot(Field::pMemoryBarriers), memoryBarrierCount,
                                            pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true,
                                            "VUID-VkMemoryBarrier-sType-sType",
                                            "VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter", kVUIDUndefined);
    if (pMemoryBarriers != nullptr) {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex) {
            [[maybe_unused]] const Location pMemoryBarriers_loc = loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
            skip |=
                context.ValidateStructPnext(pMemoryBarriers_loc, pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryBarrier-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                          AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags,
                                          "VUID-VkMemoryBarrier-srcAccessMask-parameter");

            skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                          AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags,
                                          "VUID-VkMemoryBarrier-dstAccessMask-parameter");
        }
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::bufferMemoryBarrierCount), loc.dot(Field::pBufferMemoryBarriers), bufferMemoryBarrierCount,
        pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false, true, "VUID-VkBufferMemoryBarrier-sType-sType",
        "VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter", kVUIDUndefined);
    if (pBufferMemoryBarriers != nullptr) {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount;
             ++bufferMemoryBarrierIndex) {
            [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkBufferMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

            skip |= context.ValidateStructPnext(pBufferMemoryBarriers_loc, pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                                                allowed_structs_VkBufferMemoryBarrier.size(),
                                                allowed_structs_VkBufferMemoryBarrier.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkBufferMemoryBarrier-pNext-pNext", "VUID-VkBufferMemoryBarrier-sType-unique",
                                                true);

            skip |= context.ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                                   pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }
    skip |= context.ValidateStructTypeArray(loc.dot(Field::imageMemoryBarrierCount), loc.dot(Field::pImageMemoryBarriers),
                                            imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
                                            false, true, "VUID-VkImageMemoryBarrier-sType-sType",
                                            "VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter", kVUIDUndefined);
    if (pImageMemoryBarriers != nullptr) {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex) {
            [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkImageMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                                                                         VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

            skip |= context.ValidateStructPnext(pImageMemoryBarriers_loc, pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                                                allowed_structs_VkImageMemoryBarrier.size(),
                                                allowed_structs_VkImageMemoryBarrier.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkImageMemoryBarrier-pNext-pNext", "VUID-VkImageMemoryBarrier-sType-unique",
                                                true);

            skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                               pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                               "VUID-VkImageMemoryBarrier-oldLayout-parameter");

            skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                               pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                               "VUID-VkImageMemoryBarrier-newLayout-parameter");

            skip |= context.ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                                   pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= context.ValidateFlags(
                pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags,
                "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                          VkQueryControlFlags flags, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryControlFlagBits, AllVkQueryControlFlagBits, flags,
                                  kOptionalFlags, "VUID-vkCmdBeginQuery-flags-parameter");
    return skip;
}

bool Device::PreCallValidateCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool Device::PreCallValidateCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery,
                                              uint32_t queryCount, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool Device::PreCallValidateCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
                                              VkQueryPool queryPool, uint32_t query, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(
        loc.dot(Field::pipelineStage), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits, pipelineStage,
        kRequiredSingleBit, "VUID-vkCmdWriteTimestamp-pipelineStage-parameter", "VUID-vkCmdWriteTimestamp-pipelineStage-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool Device::PreCallValidateCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery,
                                                    uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                                    VkDeviceSize stride, VkQueryResultFlags flags,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryResultFlagBits, AllVkQueryResultFlagBits, flags,
                                  kOptionalFlags, "VUID-vkCmdCopyQueryPoolResults-flags-parameter");
    return skip;
}

bool Device::PreCallValidateCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags,
                                             uint32_t offset, uint32_t size, const void* pValues,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= context.ValidateFlags(loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                  stageFlags, kRequiredFlags, "VUID-vkCmdPushConstants-stageFlags-parameter",
                                  "VUID-vkCmdPushConstants-stageFlags-requiredbitmask");
    skip |= context.ValidateArray(loc.dot(Field::size), loc.dot(Field::pValues), size, &pValues, true, true,
                                  "VUID-vkCmdPushConstants-size-arraylength", "VUID-vkCmdPushConstants-pValues-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues, context);
    return skip;
}

bool Device::PreCallValidateCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin,
                                               VkSubpassContents contents, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pRenderPassBegin), pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
                                       true, "VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter",
                                       "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr) {
        [[maybe_unused]] const Location pRenderPassBegin_loc = loc.dot(Field::pRenderPassBegin);
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM};

        skip |=
            context.ValidateStructPnext(pRenderPassBegin_loc, pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(),
                                        allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::renderPass), pRenderPassBegin->renderPass);

        skip |= context.ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::framebuffer), pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |= context.ValidateRangedEnum(loc.dot(Field::contents), vvl::Enum::VkSubpassContents, contents,
                                       "VUID-vkCmdBeginRenderPass-contents-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents, context);
    return skip;
}

bool Device::PreCallValidateCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::contents), vvl::Enum::VkSubpassContents, contents,
                                       "VUID-vkCmdNextSubpass-contents-parameter");
    return skip;
}

bool Device::PreCallValidateCmdEndRenderPass(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                               const VkCommandBuffer* pCommandBuffers, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateHandleArray(loc.dot(Field::commandBufferCount), loc.dot(Field::pCommandBuffers), commandBufferCount,
                                        pCommandBuffers, true, true, "VUID-vkCmdExecuteCommands-commandBufferCount-arraylength");
    return skip;
}

bool Device::PreCallValidateBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfos), bindInfoCount, pBindInfos,
        VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO, true, true, "VUID-VkBindBufferMemoryInfo-sType-sType",
        "VUID-vkBindBufferMemory2-pBindInfos-parameter", "VUID-vkBindBufferMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfos_loc = loc.dot(Field::pBindInfos, bindInfoIndex);
            constexpr std::array allowed_structs_VkBindBufferMemoryInfo = {VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
                                                                           VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS};

            skip |= context.ValidateStructPnext(
                pBindInfos_loc, pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindBufferMemoryInfo.size(),
                allowed_structs_VkBindBufferMemoryInfo.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkBindBufferMemoryInfo-pNext-pNext", "VUID-VkBindBufferMemoryInfo-sType-unique", true);

            skip |= context.ValidateRequiredHandle(pBindInfos_loc.dot(Field::buffer), pBindInfos[bindInfoIndex].buffer);

            skip |= context.ValidateRequiredHandle(pBindInfos_loc.dot(Field::memory), pBindInfos[bindInfoIndex].memory);
        }
    }
    return skip;
}

bool Device::PreCallValidateBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfos), bindInfoCount, pBindInfos,
        VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO, true, true, "VUID-VkBindImageMemoryInfo-sType-sType",
        "VUID-vkBindImageMemory2-pBindInfos-parameter", "VUID-vkBindImageMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfos_loc = loc.dot(Field::pBindInfos, bindInfoIndex);
            constexpr std::array allowed_structs_VkBindImageMemoryInfo = {
                VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
                VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS};

            skip |= context.ValidateStructPnext(
                pBindInfos_loc, pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindImageMemoryInfo.size(),
                allowed_structs_VkBindImageMemoryInfo.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkBindImageMemoryInfo-pNext-pNext", "VUID-VkBindImageMemoryInfo-sType-unique", true);

            skip |= context.ValidateRequiredHandle(pBindInfos_loc.dot(Field::image), pBindInfos[bindInfoIndex].image);
        }
    }
    return skip;
}

bool Device::PreCallValidateGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex,
                                                             uint32_t remoteDeviceIndex,
                                                             VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pPeerMemoryFeatures), pPeerMemoryFeatures,
                                            "VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                                            uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Instance::PreCallValidateEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
                                                            VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkEnumeratePhysicalDeviceGroups &&
        CheckPromotedApiAgainstVulkanVersion(instance, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPhysicalDeviceGroupCount), loc.dot(Field::pPhysicalDeviceGroupProperties), pPhysicalDeviceGroupCount,
        pPhysicalDeviceGroupProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, true, false, false,
        "VUID-VkPhysicalDeviceGroupProperties-sType-sType", kVUIDUndefined,
        "VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupCount-parameter", kVUIDUndefined);
    if (pPhysicalDeviceGroupProperties != nullptr) {
        for (uint32_t pPhysicalDeviceGroupIndex = 0; pPhysicalDeviceGroupIndex < *pPhysicalDeviceGroupCount;
             ++pPhysicalDeviceGroupIndex) {
            [[maybe_unused]] const Location pPhysicalDeviceGroupProperties_loc =
                loc.dot(Field::pPhysicalDeviceGroupProperties, pPhysicalDeviceGroupIndex);
            skip |= context.ValidateStructPnext(
                pPhysicalDeviceGroupProperties_loc, pPhysicalDeviceGroupProperties[pPhysicalDeviceGroupIndex].pNext, 0, nullptr,
                GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceGroupProperties-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
                                                        VkMemoryRequirements2* pMemoryRequirements,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, true,
                                       "VUID-vkGetImageMemoryRequirements2-pInfo-parameter",
                                       "VUID-VkImageMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        constexpr std::array allowed_structs_VkImageMemoryRequirementsInfo2 = {
            VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO};

        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, allowed_structs_VkImageMemoryRequirementsInfo2.size(),
                                            allowed_structs_VkImageMemoryRequirementsInfo2.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageMemoryRequirementsInfo2-pNext-pNext",
                                            "VUID-VkImageMemoryRequirementsInfo2-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
                                                         VkMemoryRequirements2* pMemoryRequirements,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2, true,
                                       "VUID-vkGetBufferMemoryRequirements2-pInfo-parameter",
                                       "VUID-VkBufferMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
                                                              uint32_t* pSparseMemoryRequirementCount,
                                                              VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
                                       true, "VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter",
                                       "VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pSparseMemoryRequirementCount), loc.dot(Field::pSparseMemoryRequirements), pSparseMemoryRequirementCount,
        pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false,
        "VUID-VkSparseImageMemoryRequirements2-sType-sType", kVUIDUndefined,
        "VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirementCount-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr) {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount;
             ++pSparseMemoryRequirementIndex) {
            [[maybe_unused]] const Location pSparseMemoryRequirements_loc =
                loc.dot(Field::pSparseMemoryRequirements, pSparseMemoryRequirementIndex);
            skip |= context.ValidateStructPnext(
                pSparseMemoryRequirements_loc, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext, 0, nullptr,
                GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceFeatures2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pFeatures), pFeatures, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, true,
                                       "VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter",
                                       "VUID-VkPhysicalDeviceFeatures2-sType-sType");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice,
                                                           VkPhysicalDeviceProperties2* pProperties,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
                                       true, "VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter",
                                       "VUID-VkPhysicalDeviceProperties2-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        constexpr std::array allowed_structs_VkPhysicalDeviceProperties2 = {
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES};

        skip |= context.ValidateStructPnext(pProperties_loc, pProperties->pNext, allowed_structs_VkPhysicalDeviceProperties2.size(),
                                            allowed_structs_VkPhysicalDeviceProperties2.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkPhysicalDeviceProperties2-pNext-pNext",
                                            "VUID-VkPhysicalDeviceProperties2-sType-unique", false);
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceProperties2(physicalDevice, pProperties, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                 VkFormatProperties2* pFormatProperties,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceFormatProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                                       "VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pFormatProperties), pFormatProperties, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
                                       true, "VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter",
                                       "VUID-VkFormatProperties2-sType-sType");
    if (pFormatProperties != nullptr) {
        [[maybe_unused]] const Location pFormatProperties_loc = loc.dot(Field::pFormatProperties);
        constexpr std::array allowed_structs_VkFormatProperties2 = {
            VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT};

        skip |=
            context.ValidateStructPnext(pFormatProperties_loc, pFormatProperties->pNext, allowed_structs_VkFormatProperties2.size(),
                                        allowed_structs_VkFormatProperties2.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkFormatProperties2-pNext-pNext", "VUID-VkFormatProperties2-sType-unique", false);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice,
                                                                      const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
                                                                      VkImageFormatProperties2* pImageFormatProperties,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceImageFormatProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pImageFormatInfo), pImageFormatInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2, true,
                                       "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter",
                                       "VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType");
    if (pImageFormatInfo != nullptr) {
        [[maybe_unused]] const Location pImageFormatInfo_loc = loc.dot(Field::pImageFormatInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceImageFormatInfo2 = {
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= context.ValidateStructPnext(
            pImageFormatInfo_loc, pImageFormatInfo->pNext, allowed_structs_VkPhysicalDeviceImageFormatInfo2.size(),
            allowed_structs_VkPhysicalDeviceImageFormatInfo2.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext", "VUID-VkPhysicalDeviceImageFormatInfo2-sType-unique", true);

        skip |= context.ValidateRangedEnum(pImageFormatInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pImageFormatInfo->format,
                                           "VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter");

        skip |= context.ValidateRangedEnum(pImageFormatInfo_loc.dot(Field::type), vvl::Enum::VkImageType, pImageFormatInfo->type,
                                           "VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter");

        skip |= context.ValidateRangedEnum(pImageFormatInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling,
                                           pImageFormatInfo->tiling, "VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter");

        skip |= context.ValidateFlags(pImageFormatInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, pImageFormatInfo->usage, kRequiredFlags,
                                      "VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter",
                                      "VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask");

        skip |= context.ValidateFlags(pImageFormatInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                      AllVkImageCreateFlagBits, pImageFormatInfo->flags, kOptionalFlags,
                                      "VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pImageFormatProperties), pImageFormatProperties,
                                       VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, true,
                                       "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter",
                                       "VUID-VkImageFormatProperties2-sType-sType");
    if (pImageFormatProperties != nullptr) {
        [[maybe_unused]] const Location pImageFormatProperties_loc = loc.dot(Field::pImageFormatProperties);
        constexpr std::array allowed_structs_VkImageFormatProperties2 = {
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD};

        skip |= context.ValidateStructPnext(
            pImageFormatProperties_loc, pImageFormatProperties->pNext, allowed_structs_VkImageFormatProperties2.size(),
            allowed_structs_VkImageFormatProperties2.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkImageFormatProperties2-pNext-pNext", "VUID-VkImageFormatProperties2-sType-unique", false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo,
                                                                              pImageFormatProperties, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice,
                                                                      uint32_t* pQueueFamilyPropertyCount,
                                                                      VkQueueFamilyProperties2* pQueueFamilyProperties,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceQueueFamilyProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pQueueFamilyPropertyCount), loc.dot(Field::pQueueFamilyProperties), pQueueFamilyPropertyCount,
        pQueueFamilyProperties, VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, true, false, false,
        "VUID-VkQueueFamilyProperties2-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyPropertyCount-parameter", kVUIDUndefined);
    if (pQueueFamilyProperties != nullptr) {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount;
             ++pQueueFamilyPropertyIndex) {
            [[maybe_unused]] const Location pQueueFamilyProperties_loc =
                loc.dot(Field::pQueueFamilyProperties, pQueueFamilyPropertyIndex);
            constexpr std::array allowed_structs_VkQueueFamilyProperties2 = {
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR};

            skip |= context.ValidateStructPnext(pQueueFamilyProperties_loc, pQueueFamilyProperties[pQueueFamilyPropertyIndex].pNext,
                                                allowed_structs_VkQueueFamilyProperties2.size(),
                                                allowed_structs_VkQueueFamilyProperties2.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkQueueFamilyProperties2-pNext-pNext",
                                                "VUID-VkQueueFamilyProperties2-sType-unique", false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice,
                                                                 VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceMemoryProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryProperties), pMemoryProperties,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, true,
                                       "VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter",
                                       "VUID-VkPhysicalDeviceMemoryProperties2-sType-sType");
    if (pMemoryProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryProperties_loc = loc.dot(Field::pMemoryProperties);
        constexpr std::array allowed_structs_VkPhysicalDeviceMemoryProperties2 = {
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT};

        skip |= context.ValidateStructPnext(
            pMemoryProperties_loc, pMemoryProperties->pNext, allowed_structs_VkPhysicalDeviceMemoryProperties2.size(),
            allowed_structs_VkPhysicalDeviceMemoryProperties2.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext", "VUID-VkPhysicalDeviceMemoryProperties2-sType-unique", false);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceSparseImageFormatProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pFormatInfo), pFormatInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2, true,
                                       "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter",
                                       "VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType");
    if (pFormatInfo != nullptr) {
        [[maybe_unused]] const Location pFormatInfo_loc = loc.dot(Field::pFormatInfo);
        skip |= context.ValidateStructPnext(pFormatInfo_loc, pFormatInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pFormatInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pFormatInfo->format,
                                           "VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter");

        skip |= context.ValidateRangedEnum(pFormatInfo_loc.dot(Field::type), vvl::Enum::VkImageType, pFormatInfo->type,
                                           "VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter");

        skip |= context.ValidateFlags(pFormatInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, pFormatInfo->samples, kRequiredSingleBit,
                                      "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter",
                                      "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter");

        skip |= context.ValidateFlags(pFormatInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, pFormatInfo->usage, kRequiredFlags,
                                      "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter",
                                      "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask");

        skip |= context.ValidateRangedEnum(pFormatInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pFormatInfo->tiling,
                                           "VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter");
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, true, false, false, "VUID-VkSparseImageFormatProperties2-sType-sType",
        kVUIDUndefined, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkSparseImageFormatProperties2-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);
    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), flags, "VUID-vkTrimCommandPool-flags-zerobitmask");
    return skip;
}

bool Device::PreCallValidateGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pQueueInfo), pQueueInfo, VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2, true,
                                       "VUID-vkGetDeviceQueue2-pQueueInfo-parameter", "VUID-VkDeviceQueueInfo2-sType-sType");
    if (pQueueInfo != nullptr) {
        [[maybe_unused]] const Location pQueueInfo_loc = loc.dot(Field::pQueueInfo);
        skip |= context.ValidateStructPnext(pQueueInfo_loc, pQueueInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceQueueInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pQueueInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceQueueCreateFlagBits,
                                      AllVkDeviceQueueCreateFlagBits, pQueueInfo->flags, kOptionalFlags,
                                      "VUID-VkDeviceQueueInfo2-flags-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pQueue), pQueue, "VUID-vkGetDeviceQueue2-pQueue-parameter");
    return skip;
}

bool Device::PreCallValidateCreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                                         const VkAllocationCallbacks* pAllocator,
                                                         VkSamplerYcbcrConversion* pYcbcrConversion,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO, true,
        "VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter", "VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSamplerYcbcrConversionCreateInfo = {
            VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSamplerYcbcrConversionCreateInfo.size(),
            allowed_structs_VkSamplerYcbcrConversionCreateInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext", "VUID-VkSamplerYcbcrConversionCreateInfo-sType-unique", true);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                           "VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::ycbcrModel), vvl::Enum::VkSamplerYcbcrModelConversion,
                                           pCreateInfo->ycbcrModel, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::ycbcrRange), vvl::Enum::VkSamplerYcbcrRange,
                                           pCreateInfo->ycbcrRange, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::r), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.r,
                                           "VUID-VkComponentMapping-r-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::g), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.g,
                                           "VUID-VkComponentMapping-g-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::b), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.b,
                                           "VUID-VkComponentMapping-b-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::a), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.a,
                                           "VUID-VkComponentMapping-a-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::xChromaOffset), vvl::Enum::VkChromaLocation,
                                           pCreateInfo->xChromaOffset,
                                           "VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::yChromaOffset), vvl::Enum::VkChromaLocation,
                                           pCreateInfo->yChromaOffset,
                                           "VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::chromaFilter), vvl::Enum::VkFilter, pCreateInfo->chromaFilter,
                                           "VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter");

        skip |= context.ValidateBool32(pCreateInfo_loc.dot(Field::forceExplicitReconstruction),
                                       pCreateInfo->forceExplicitReconstruction);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pYcbcrConversion), pYcbcrConversion,
                                            "VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion, context);
    return skip;
}

bool Device::PreCallValidateDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO, true,
        "VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter", "VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::descriptorUpdateEntryCount),
                                      pCreateInfo_loc.dot(Field::pDescriptorUpdateEntries), pCreateInfo->descriptorUpdateEntryCount,
                                      &pCreateInfo->pDescriptorUpdateEntries, true, true,
                                      "VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength",
                                      "VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter");

        if (pCreateInfo->pDescriptorUpdateEntries != nullptr) {
            for (uint32_t descriptorUpdateEntryIndex = 0; descriptorUpdateEntryIndex < pCreateInfo->descriptorUpdateEntryCount;
                 ++descriptorUpdateEntryIndex) {
                [[maybe_unused]] const Location pDescriptorUpdateEntries_loc =
                    pCreateInfo_loc.dot(Field::pDescriptorUpdateEntries, descriptorUpdateEntryIndex);
                skip |=
                    context.ValidateRangedEnum(pDescriptorUpdateEntries_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                               pCreateInfo->pDescriptorUpdateEntries[descriptorUpdateEntryIndex].descriptorType,
                                               "VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter");
            }
        }

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::templateType), vvl::Enum::VkDescriptorUpdateTemplateType,
                                           pCreateInfo->templateType,
                                           "VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDescriptorUpdateTemplate), pDescriptorUpdateTemplate,
                                            "VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet,
                                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::descriptorSet), descriptorSet);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::descriptorUpdateTemplate), descriptorUpdateTemplate);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceExternalBufferProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pExternalBufferInfo), pExternalBufferInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO, true,
                                       "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter",
                                       "VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType");
    if (pExternalBufferInfo != nullptr) {
        [[maybe_unused]] const Location pExternalBufferInfo_loc = loc.dot(Field::pExternalBufferInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalBufferInfo = {
            VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO};

        skip |= context.ValidateStructPnext(
            pExternalBufferInfo_loc, pExternalBufferInfo->pNext, allowed_structs_VkPhysicalDeviceExternalBufferInfo.size(),
            allowed_structs_VkPhysicalDeviceExternalBufferInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext", "VUID-VkPhysicalDeviceExternalBufferInfo-sType-unique", true);

        skip |= context.ValidateFlags(pExternalBufferInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                                      AllVkBufferCreateFlagBits, pExternalBufferInfo->flags, kOptionalFlags,
                                      "VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter");

        skip |= context.ValidateFlags(pExternalBufferInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits, AllVkExternalMemoryHandleTypeFlagBits,
                                      pExternalBufferInfo->handleType, kRequiredSingleBit,
                                      "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter",
                                      "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pExternalBufferProperties), pExternalBufferProperties,
                                       VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, true,
                                       "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter",
                                       "VUID-VkExternalBufferProperties-sType-sType");
    if (pExternalBufferProperties != nullptr) {
        [[maybe_unused]] const Location pExternalBufferProperties_loc = loc.dot(Field::pExternalBufferProperties);
        skip |= context.ValidateStructPnext(pExternalBufferProperties_loc, pExternalBufferProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkExternalBufferProperties-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo,
                                                                                pExternalBufferProperties, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice,
                                                                       const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
                                                                       VkExternalFenceProperties* pExternalFenceProperties,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceExternalFenceProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pExternalFenceInfo), pExternalFenceInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, true,
                                       "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter",
                                       "VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType");
    if (pExternalFenceInfo != nullptr) {
        [[maybe_unused]] const Location pExternalFenceInfo_loc = loc.dot(Field::pExternalFenceInfo);
        skip |=
            context.ValidateStructPnext(pExternalFenceInfo_loc, pExternalFenceInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pExternalFenceInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits, AllVkExternalFenceHandleTypeFlagBits,
                                      pExternalFenceInfo->handleType, kRequiredSingleBit,
                                      "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter",
                                      "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pExternalFenceProperties), pExternalFenceProperties,
                                       VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, true,
                                       "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter",
                                       "VUID-VkExternalFenceProperties-sType-sType");
    if (pExternalFenceProperties != nullptr) {
        [[maybe_unused]] const Location pExternalFenceProperties_loc = loc.dot(Field::pExternalFenceProperties);
        skip |= context.ValidateStructPnext(pExternalFenceProperties_loc, pExternalFenceProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkExternalFenceProperties-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceExternalSemaphoreProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= context.ValidateStructType(loc.dot(Field::pExternalSemaphoreInfo), pExternalSemaphoreInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, true,
                                       "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter",
                                       "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType");
    if (pExternalSemaphoreInfo != nullptr) {
        [[maybe_unused]] const Location pExternalSemaphoreInfo_loc = loc.dot(Field::pExternalSemaphoreInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo = {VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO};

        skip |= context.ValidateStructPnext(pExternalSemaphoreInfo_loc, pExternalSemaphoreInfo->pNext,
                                            allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.size(),
                                            allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext",
                                            "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-unique", true);

        skip |= context.ValidateFlags(pExternalSemaphoreInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                                      AllVkExternalSemaphoreHandleTypeFlagBits, pExternalSemaphoreInfo->handleType,
                                      kRequiredSingleBit, "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter",
                                      "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pExternalSemaphoreProperties), pExternalSemaphoreProperties,
                                       VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, true,
                                       "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter",
                                       "VUID-VkExternalSemaphoreProperties-sType-sType");
    if (pExternalSemaphoreProperties != nullptr) {
        [[maybe_unused]] const Location pExternalSemaphoreProperties_loc = loc.dot(Field::pExternalSemaphoreProperties);
        skip |= context.ValidateStructPnext(pExternalSemaphoreProperties_loc, pExternalSemaphoreProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkExternalSemaphoreProperties-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                          VkDescriptorSetLayoutSupport* pSupport,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true,
        "VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter", "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(),
            allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext", "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDescriptorSetLayoutCreateFlagBits,
                                      AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::bindingCount), pCreateInfo_loc.dot(Field::pBindings),
                                      pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined,
                                      "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr) {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex) {
                [[maybe_unused]] const Location pBindings_loc = pCreateInfo_loc.dot(Field::pBindings, bindingIndex);
                skip |= context.ValidateRangedEnum(pBindings_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                                   pCreateInfo->pBindings[bindingIndex].descriptorType,
                                                   "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter");
            }
        }
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSupport), pSupport, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, true,
                                       "VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter",
                                       "VUID-VkDescriptorSetLayoutSupport-sType-sType");
    if (pSupport != nullptr) {
        [[maybe_unused]] const Location pSupport_loc = loc.dot(Field::pSupport);
        constexpr std::array allowed_structs_VkDescriptorSetLayoutSupport = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT};

        skip |= context.ValidateStructPnext(pSupport_loc, pSupport->pNext, allowed_structs_VkDescriptorSetLayoutSupport.size(),
                                            allowed_structs_VkDescriptorSetLayoutSupport.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkDescriptorSetLayoutSupport-pNext-pNext",
                                            "VUID-VkDescriptorSetLayoutSupport-sType-unique", false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, context);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                 VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                 uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                        VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                        uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool Device::PreCallValidateCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, true,
                                   "VUID-vkCreateRenderPass2-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo2-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkRenderPassCreateInfo2 = {
            VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo2.size(),
                                            allowed_structs_VkRenderPassCreateInfo2.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkRenderPassCreateInfo2-pNext-pNext", "VUID-VkRenderPassCreateInfo2-sType-unique",
                                            true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderPassCreateFlagBits,
                                      AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkRenderPassCreateInfo2-flags-parameter");

        skip |= context.ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::attachmentCount), pCreateInfo_loc.dot(Field::pAttachments), pCreateInfo->attachmentCount,
            pCreateInfo->pAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, false, true,
            "VUID-VkAttachmentDescription2-sType-sType", "VUID-VkRenderPassCreateInfo2-pAttachments-parameter", kVUIDUndefined);

        if (pCreateInfo->pAttachments != nullptr) {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex) {
                [[maybe_unused]] const Location pAttachments_loc = pCreateInfo_loc.dot(Field::pAttachments, attachmentIndex);
                constexpr std::array allowed_structs_VkAttachmentDescription2 = {
                    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID};

                skip |= context.ValidateStructPnext(pAttachments_loc, pCreateInfo->pAttachments[attachmentIndex].pNext,
                                                    allowed_structs_VkAttachmentDescription2.size(),
                                                    allowed_structs_VkAttachmentDescription2.data(), GeneratedVulkanHeaderVersion,
                                                    "VUID-VkAttachmentDescription2-pNext-pNext",
                                                    "VUID-VkAttachmentDescription2-sType-unique", true);

                skip |= context.ValidateFlags(pAttachments_loc.dot(Field::flags), vvl::FlagBitmask::VkAttachmentDescriptionFlagBits,
                                              AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags,
                                              kOptionalFlags, "VUID-VkAttachmentDescription2-flags-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::format), vvl::Enum::VkFormat,
                                                   pCreateInfo->pAttachments[attachmentIndex].format,
                                                   "VUID-VkAttachmentDescription2-format-parameter");

                skip |= context.ValidateFlags(pAttachments_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                              AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples,
                                              kRequiredSingleBit, "VUID-VkAttachmentDescription2-samples-parameter",
                                              "VUID-VkAttachmentDescription2-samples-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].loadOp,
                                                   "VUID-VkAttachmentDescription2-loadOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].storeOp,
                                                   "VUID-VkAttachmentDescription2-storeOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::stencilLoadOp), vvl::Enum::VkAttachmentLoadOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp,
                                                   "VUID-VkAttachmentDescription2-stencilLoadOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::stencilStoreOp), vvl::Enum::VkAttachmentStoreOp,
                                                   pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp,
                                                   "VUID-VkAttachmentDescription2-stencilStoreOp-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                                   pCreateInfo->pAttachments[attachmentIndex].initialLayout,
                                                   "VUID-VkAttachmentDescription2-initialLayout-parameter");

                skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::finalLayout), vvl::Enum::VkImageLayout,
                                                   pCreateInfo->pAttachments[attachmentIndex].finalLayout,
                                                   "VUID-VkAttachmentDescription2-finalLayout-parameter");
            }
        }

        skip |= context.ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::subpassCount), pCreateInfo_loc.dot(Field::pSubpasses), pCreateInfo->subpassCount,
            pCreateInfo->pSubpasses, VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, true, true, "VUID-VkSubpassDescription2-sType-sType",
            "VUID-VkRenderPassCreateInfo2-pSubpasses-parameter", "VUID-VkRenderPassCreateInfo2-subpassCount-arraylength");

        if (pCreateInfo->pSubpasses != nullptr) {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex) {
                [[maybe_unused]] const Location pSubpasses_loc = pCreateInfo_loc.dot(Field::pSubpasses, subpassIndex);
                constexpr std::array allowed_structs_VkSubpassDescription2 = {
                    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
                    VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
                    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
                    VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE};

                skip |= context.ValidateStructPnext(
                    pSubpasses_loc, pCreateInfo->pSubpasses[subpassIndex].pNext, allowed_structs_VkSubpassDescription2.size(),
                    allowed_structs_VkSubpassDescription2.data(), GeneratedVulkanHeaderVersion,
                    "VUID-VkSubpassDescription2-pNext-pNext", "VUID-VkSubpassDescription2-sType-unique", true);

                skip |= context.ValidateFlags(pSubpasses_loc.dot(Field::flags), vvl::FlagBitmask::VkSubpassDescriptionFlagBits,
                                              AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags,
                                              kOptionalFlags, "VUID-VkSubpassDescription2-flags-parameter");

                skip |= context.ValidateRangedEnum(pSubpasses_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                                   pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint,
                                                   "VUID-VkSubpassDescription2-pipelineBindPoint-parameter");

                skip |= context.ValidateStructTypeArray(
                    pSubpasses_loc.dot(Field::inputAttachmentCount), pSubpasses_loc.dot(Field::pInputAttachments),
                    pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount,
                    pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true,
                    "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pInputAttachments-parameter",
                    kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr) {
                    for (uint32_t inputAttachmentIndex = 0;
                         inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount;
                         ++inputAttachmentIndex) {
                        [[maybe_unused]] const Location pInputAttachments_loc =
                            pSubpasses_loc.dot(Field::pInputAttachments, inputAttachmentIndex);
                        constexpr std::array allowed_structs_VkAttachmentReference2 = {
                            VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                        skip |= context.ValidateStructPnext(
                            pInputAttachments_loc,
                            pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].pNext,
                            allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                            GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                            "VUID-VkAttachmentReference2-sType-unique", true);

                        skip |= context.ValidateRangedEnum(
                            pInputAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout,
                            "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= context.ValidateStructTypeArray(
                    pSubpasses_loc.dot(Field::colorAttachmentCount), pSubpasses_loc.dot(Field::pColorAttachments),
                    pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount,
                    pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true,
                    "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pColorAttachments-parameter",
                    kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pColorAttachments_loc =
                            pSubpasses_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                        constexpr std::array allowed_structs_VkAttachmentReference2 = {
                            VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                        skip |= context.ValidateStructPnext(
                            pColorAttachments_loc,
                            pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].pNext,
                            allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                            GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                            "VUID-VkAttachmentReference2-sType-unique", true);

                        skip |= context.ValidateRangedEnum(
                            pColorAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout,
                            "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= context.ValidateStructTypeArray(
                    pSubpasses_loc.dot(Field::colorAttachmentCount), pSubpasses_loc.dot(Field::pResolveAttachments),
                    pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount,
                    pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                    false, "VUID-VkAttachmentReference2-sType-sType", kVUIDUndefined, kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pResolveAttachments_loc =
                            pSubpasses_loc.dot(Field::pResolveAttachments, colorAttachmentIndex);
                        constexpr std::array allowed_structs_VkAttachmentReference2 = {
                            VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                        skip |= context.ValidateStructPnext(
                            pResolveAttachments_loc,
                            pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].pNext,
                            allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                            GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                            "VUID-VkAttachmentReference2-sType-unique", true);

                        skip |= context.ValidateRangedEnum(
                            pResolveAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout,
                            "VUID-VkAttachmentReference2-layout-parameter");
                    }
                }

                skip |= context.ValidateStructType(
                    pSubpasses_loc.dot(Field::pDepthStencilAttachment),
                    pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                    "VUID-VkSubpassDescription2-pDepthStencilAttachment-parameter", "VUID-VkAttachmentReference2-sType-sType");

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr) {
                    [[maybe_unused]] const Location pDepthStencilAttachment_loc =
                        pSubpasses_loc.dot(Field::pDepthStencilAttachment);
                    constexpr std::array allowed_structs_VkAttachmentReference2 = {
                        VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                    skip |= context.ValidateStructPnext(
                        pDepthStencilAttachment_loc, pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->pNext,
                        allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                        "VUID-VkAttachmentReference2-sType-unique", true);

                    skip |= context.ValidateRangedEnum(pDepthStencilAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                                       pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout,
                                                       "VUID-VkAttachmentReference2-layout-parameter");
                }

                skip |= context.ValidateArray(pSubpasses_loc.dot(Field::preserveAttachmentCount),
                                              pSubpasses_loc.dot(Field::pPreserveAttachments),
                                              pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount,
                                              &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true,
                                              kVUIDUndefined, "VUID-VkSubpassDescription2-pPreserveAttachments-parameter");
            }
        }

        skip |= context.ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::dependencyCount), pCreateInfo_loc.dot(Field::pDependencies), pCreateInfo->dependencyCount,
            pCreateInfo->pDependencies, VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, false, true,
            "VUID-VkSubpassDependency2-sType-sType", "VUID-VkRenderPassCreateInfo2-pDependencies-parameter", kVUIDUndefined);

        if (pCreateInfo->pDependencies != nullptr) {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex) {
                [[maybe_unused]] const Location pDependencies_loc = pCreateInfo_loc.dot(Field::pDependencies, dependencyIndex);
                constexpr std::array allowed_structs_VkSubpassDependency2 = {VK_STRUCTURE_TYPE_MEMORY_BARRIER_2};

                skip |= context.ValidateStructPnext(pDependencies_loc, pCreateInfo->pDependencies[dependencyIndex].pNext,
                                                    allowed_structs_VkSubpassDependency2.size(),
                                                    allowed_structs_VkSubpassDependency2.data(), GeneratedVulkanHeaderVersion,
                                                    "VUID-VkSubpassDependency2-pNext-pNext",
                                                    "VUID-VkSubpassDependency2-sType-unique", true);

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |=
                        context.ValidateFlags(pDependencies_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                              AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask,
                                              kOptionalFlags, "VUID-VkSubpassDependency2-srcStageMask-parameter");
                }

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |=
                        context.ValidateFlags(pDependencies_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                              AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask,
                                              kOptionalFlags, "VUID-VkSubpassDependency2-dstStageMask-parameter");
                }

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |= context.ValidateFlags(pDependencies_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                                  AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask,
                                                  kOptionalFlags, "VUID-VkSubpassDependency2-srcAccessMask-parameter");
                }

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |= context.ValidateFlags(pDependencies_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                                  AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask,
                                                  kOptionalFlags, "VUID-VkSubpassDependency2-dstAccessMask-parameter");
                }

                skip |= context.ValidateFlags(pDependencies_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                              AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags,
                                              kOptionalFlags, "VUID-VkSubpassDependency2-dependencyFlags-parameter");
            }
        }

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::correlatedViewMaskCount),
                                      pCreateInfo_loc.dot(Field::pCorrelatedViewMasks), pCreateInfo->correlatedViewMaskCount,
                                      &pCreateInfo->pCorrelatedViewMasks, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassCreateInfo2-pCorrelatedViewMasks-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pRenderPass), pRenderPass, "VUID-vkCreateRenderPass2-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, context);
    return skip;
}

bool Device::PreCallValidateCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin,
                                                const VkSubpassBeginInfo* pSubpassBeginInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pRenderPassBegin), pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
                                       true, "VUID-vkCmdBeginRenderPass2-pRenderPassBegin-parameter",
                                       "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr) {
        [[maybe_unused]] const Location pRenderPassBegin_loc = loc.dot(Field::pRenderPassBegin);
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM};

        skip |=
            context.ValidateStructPnext(pRenderPassBegin_loc, pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(),
                                        allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::renderPass), pRenderPassBegin->renderPass);

        skip |= context.ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::framebuffer), pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |=
        context.ValidateStructType(loc.dot(Field::pSubpassBeginInfo), pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true,
                                   "VUID-vkCmdBeginRenderPass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassBeginInfo_loc = loc.dot(Field::pSubpassBeginInfo);
        skip |=
            context.ValidateStructPnext(pSubpassBeginInfo_loc, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pSubpassBeginInfo_loc.dot(Field::contents), vvl::Enum::VkSubpassContents,
                                           pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo,
                                            const VkSubpassEndInfo* pSubpassEndInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pSubpassBeginInfo), pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true,
                                   "VUID-vkCmdNextSubpass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassBeginInfo_loc = loc.dot(Field::pSubpassBeginInfo);
        skip |=
            context.ValidateStructPnext(pSubpassBeginInfo_loc, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pSubpassBeginInfo_loc.dot(Field::contents), vvl::Enum::VkSubpassContents,
                                           pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSubpassEndInfo), pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true,
                                       "VUID-vkCmdNextSubpass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassEndInfo_loc = loc.dot(Field::pSubpassEndInfo);
        constexpr std::array allowed_structs_VkSubpassEndInfo = {
            VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM};

        skip |= context.ValidateStructPnext(pSubpassEndInfo_loc, pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(),
                                            allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", true);
    }
    return skip;
}

bool Device::PreCallValidateCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pSubpassEndInfo), pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true,
                                       "VUID-vkCmdEndRenderPass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassEndInfo_loc = loc.dot(Field::pSubpassEndInfo);
        constexpr std::array allowed_structs_VkSubpassEndInfo = {
            VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM};

        skip |= context.ValidateStructPnext(pSubpassEndInfo_loc, pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(),
                                            allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", true);
    }
    return skip;
}

bool Device::PreCallValidateResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool Device::PreCallValidateGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t* pValue,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::semaphore), semaphore);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pValue), pValue, "VUID-vkGetSemaphoreCounterValue-pValue-parameter");
    return skip;
}

bool Device::PreCallValidateWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pWaitInfo), pWaitInfo, VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, true,
                                       "VUID-vkWaitSemaphores-pWaitInfo-parameter", "VUID-VkSemaphoreWaitInfo-sType-sType");
    if (pWaitInfo != nullptr) {
        [[maybe_unused]] const Location pWaitInfo_loc = loc.dot(Field::pWaitInfo);
        skip |= context.ValidateStructPnext(pWaitInfo_loc, pWaitInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkSemaphoreWaitInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pWaitInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSemaphoreWaitFlagBits,
                                      AllVkSemaphoreWaitFlagBits, pWaitInfo->flags, kOptionalFlags,
                                      "VUID-VkSemaphoreWaitInfo-flags-parameter");

        skip |= context.ValidateHandleArray(pWaitInfo_loc.dot(Field::semaphoreCount), pWaitInfo_loc.dot(Field::pSemaphores),
                                            pWaitInfo->semaphoreCount, pWaitInfo->pSemaphores, true, true,
                                            "VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength");

        skip |= context.ValidateArray(pWaitInfo_loc.dot(Field::semaphoreCount), pWaitInfo_loc.dot(Field::pValues),
                                      pWaitInfo->semaphoreCount, &pWaitInfo->pValues, true, true,
                                      "VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength",
                                      "VUID-VkSemaphoreWaitInfo-pValues-parameter");
    }
    return skip;
}

bool Device::PreCallValidateSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pSignalInfo), pSignalInfo, VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, true,
                                       "VUID-vkSignalSemaphore-pSignalInfo-parameter", "VUID-VkSemaphoreSignalInfo-sType-sType");
    if (pSignalInfo != nullptr) {
        [[maybe_unused]] const Location pSignalInfo_loc = loc.dot(Field::pSignalInfo);
        skip |= context.ValidateStructPnext(pSignalInfo_loc, pSignalInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkSemaphoreSignalInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pSignalInfo_loc.dot(Field::semaphore), pSignalInfo->semaphore);
    }
    return skip;
}

bool Device::PreCallValidateGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true,
                                   "VUID-vkGetBufferDeviceAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    return skip;
}

bool Device::PreCallValidateGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true,
                                       "VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter",
                                       "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    return skip;
}

bool Device::PreCallValidateGetDeviceMemoryOpaqueCaptureAddress(VkDevice device,
                                                                const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
                                       true, "VUID-vkGetDeviceMemoryOpaqueCaptureAddress-pInfo-parameter",
                                       "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::memory), pInfo->memory);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                                              VkPhysicalDeviceToolProperties* pToolProperties,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceToolProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_3))
        return true;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pToolCount), loc.dot(Field::pToolProperties), pToolCount,
                                            pToolProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, true, false, false,
                                            "VUID-VkPhysicalDeviceToolProperties-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetPhysicalDeviceToolProperties-pToolCount-parameter", kVUIDUndefined);
    if (pToolProperties != nullptr) {
        for (uint32_t pToolIndex = 0; pToolIndex < *pToolCount; ++pToolIndex) {
            [[maybe_unused]] const Location pToolProperties_loc = loc.dot(Field::pToolProperties, pToolIndex);
            skip |= context.ValidateStructPnext(pToolProperties_loc, pToolProperties[pToolIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceToolProperties-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateCreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                                  const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
                                       true, "VUID-vkCreatePrivateDataSlot-pCreateInfo-parameter",
                                       "VUID-VkPrivateDataSlotCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPrivateDataSlotCreateInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkPrivateDataSlotCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pPrivateDataSlot), pPrivateDataSlot,
                                            "VUID-vkCreatePrivateDataSlot-pPrivateDataSlot-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                                   const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateSetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                           VkPrivateDataSlot privateDataSlot, uint64_t data, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkObjectType, objectType,
                                       "VUID-vkSetPrivateData-objectType-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::privateDataSlot), privateDataSlot);
    return skip;
}

bool Device::PreCallValidateGetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                           VkPrivateDataSlot privateDataSlot, uint64_t* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkObjectType, objectType,
                                       "VUID-vkGetPrivateData-objectType-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::privateDataSlot), privateDataSlot);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pData), pData, "VUID-vkGetPrivateData-pData-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= context.ValidateStructType(loc.dot(Field::pDependencyInfo), pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true,
                                       "VUID-vkCmdSetEvent2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr) {
        [[maybe_unused]] const Location pDependencyInfo_loc = loc.dot(Field::pDependencyInfo);
        skip |= context.ValidateStructPnext(pDependencyInfo_loc, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pDependencyInfo_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                      AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags,
                                      "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= context.ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::memoryBarrierCount), pDependencyInfo_loc.dot(Field::pMemoryBarriers),
            pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true,
            "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr) {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex) {
                [[maybe_unused]] const Location pMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
                skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags,
                                              "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |=
                    context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask,
                                          kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags,
                                              "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |=
                    context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask,
                                          kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= context.ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::bufferMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers),
            pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers,
            VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr) {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount;
                 ++bufferMemoryBarrierIndex) {
                [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR};

                skip |= context.ValidateStructPnext(
                    pBufferMemoryBarriers_loc, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                    allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext",
                    "VUID-VkBufferMemoryBarrier2-sType-unique", true);

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= context.ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                                       pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= context.ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::imageMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pImageMemoryBarriers),
            pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers,
            VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr) {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount;
                 ++imageMemoryBarrierIndex) {
                [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

                skip |= context.ValidateStructPnext(
                    pImageMemoryBarriers_loc, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                    allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext",
                    "VUID-VkImageMemoryBarrier2-sType-unique", true);

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                                   pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                                   "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                                   pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                                   "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                skip |= context.ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                                       pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= context.ValidateFlags(
                    pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                    AllVkImageAspectFlagBits,
                    pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags,
                    "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |=
        context.ValidateFlags(loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                              stageMask, kOptionalFlags, "VUID-vkCmdResetEvent2-stageMask-parameter");
    return skip;
}

bool Device::PreCallValidateCmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                                           const VkDependencyInfo* pDependencyInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateHandleArray(loc.dot(Field::eventCount), loc.dot(Field::pEvents), eventCount, pEvents, true, true,
                                        "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    skip |= context.ValidateStructTypeArray(loc.dot(Field::eventCount), loc.dot(Field::pDependencyInfos), eventCount,
                                            pDependencyInfos, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, true,
                                            "VUID-VkDependencyInfo-sType-sType", "VUID-vkCmdWaitEvents2-pDependencyInfos-parameter",
                                            "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    if (pDependencyInfos != nullptr) {
        for (uint32_t eventIndex = 0; eventIndex < eventCount; ++eventIndex) {
            [[maybe_unused]] const Location pDependencyInfos_loc = loc.dot(Field::pDependencyInfos, eventIndex);
            skip |= context.ValidateStructPnext(pDependencyInfos_loc, pDependencyInfos[eventIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined,
                                                true);

            skip |= context.ValidateFlags(pDependencyInfos_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                          AllVkDependencyFlagBits, pDependencyInfos[eventIndex].dependencyFlags, kOptionalFlags,
                                          "VUID-VkDependencyInfo-dependencyFlags-parameter");

            skip |= context.ValidateStructTypeArray(
                pDependencyInfos_loc.dot(Field::memoryBarrierCount), pDependencyInfos_loc.dot(Field::pMemoryBarriers),
                pDependencyInfos[eventIndex].memoryBarrierCount, pDependencyInfos[eventIndex].pMemoryBarriers,
                VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType",
                "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pMemoryBarriers != nullptr) {
                for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfos[eventIndex].memoryBarrierCount;
                     ++memoryBarrierIndex) {
                    [[maybe_unused]] const Location pMemoryBarriers_loc =
                        pDependencyInfos_loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
                    skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcStageMask),
                                                  vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                                  pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcStageMask,
                                                  kOptionalFlags, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                    skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask),
                                                  vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                                  pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcAccessMask,
                                                  kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                    skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstStageMask),
                                                  vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                                  pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstStageMask,
                                                  kOptionalFlags, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                    skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask),
                                                  vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                                  pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstAccessMask,
                                                  kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
                }
            }

            skip |= context.ValidateStructTypeArray(
                pDependencyInfos_loc.dot(Field::bufferMemoryBarrierCount), pDependencyInfos_loc.dot(Field::pBufferMemoryBarriers),
                pDependencyInfos[eventIndex].bufferMemoryBarrierCount, pDependencyInfos[eventIndex].pBufferMemoryBarriers,
                VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType",
                "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pBufferMemoryBarriers != nullptr) {
                for (uint32_t bufferMemoryBarrierIndex = 0;
                     bufferMemoryBarrierIndex < pDependencyInfos[eventIndex].bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex) {
                    [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                        pDependencyInfos_loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
                    constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = {
                        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                        VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR};

                    skip |= context.ValidateStructPnext(
                        pBufferMemoryBarriers_loc,
                        pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                        allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext",
                        "VUID-VkBufferMemoryBarrier2-sType-unique", true);

                    skip |= context.ValidateFlags(
                        pBufferMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                        AllVkPipelineStageFlagBits2,
                        pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags,
                        "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                    skip |= context.ValidateFlags(
                        pBufferMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                        AllVkAccessFlagBits2,
                        pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask, kOptionalFlags,
                        "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                    skip |= context.ValidateFlags(
                        pBufferMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                        AllVkPipelineStageFlagBits2,
                        pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags,
                        "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                    skip |= context.ValidateFlags(
                        pBufferMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                        AllVkAccessFlagBits2,
                        pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask, kOptionalFlags,
                        "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                    skip |= context.ValidateRequiredHandle(
                        pBufferMemoryBarriers_loc.dot(Field::buffer),
                        pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
                }
            }

            skip |= context.ValidateStructTypeArray(
                pDependencyInfos_loc.dot(Field::imageMemoryBarrierCount), pDependencyInfos_loc.dot(Field::pImageMemoryBarriers),
                pDependencyInfos[eventIndex].imageMemoryBarrierCount, pDependencyInfos[eventIndex].pImageMemoryBarriers,
                VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType",
                "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pImageMemoryBarriers != nullptr) {
                for (uint32_t imageMemoryBarrierIndex = 0;
                     imageMemoryBarrierIndex < pDependencyInfos[eventIndex].imageMemoryBarrierCount; ++imageMemoryBarrierIndex) {
                    [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                        pDependencyInfos_loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
                    constexpr std::array allowed_structs_VkImageMemoryBarrier2 = {
                        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                        VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

                    skip |= context.ValidateStructPnext(
                        pImageMemoryBarriers_loc, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                        allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext",
                        "VUID-VkImageMemoryBarrier2-sType-unique", true);

                    skip |= context.ValidateFlags(
                        pImageMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                        AllVkPipelineStageFlagBits2,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags,
                        "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                    skip |= context.ValidateFlags(
                        pImageMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                        AllVkAccessFlagBits2,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags,
                        "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                    skip |= context.ValidateFlags(
                        pImageMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                        AllVkPipelineStageFlagBits2,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags,
                        "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                    skip |= context.ValidateFlags(
                        pImageMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                        AllVkAccessFlagBits2,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags,
                        "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                    skip |= context.ValidateRangedEnum(
                        pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                        "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                    skip |= context.ValidateRangedEnum(
                        pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                        "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                    skip |= context.ValidateRequiredHandle(
                        pImageMemoryBarriers_loc.dot(Field::image),
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                    skip |= context.ValidateFlags(
                        pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                        AllVkImageAspectFlagBits,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask,
                        kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter",
                        "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
                }
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pDependencyInfo), pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true,
                                       "VUID-vkCmdPipelineBarrier2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr) {
        [[maybe_unused]] const Location pDependencyInfo_loc = loc.dot(Field::pDependencyInfo);
        skip |= context.ValidateStructPnext(pDependencyInfo_loc, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pDependencyInfo_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                      AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags,
                                      "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= context.ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::memoryBarrierCount), pDependencyInfo_loc.dot(Field::pMemoryBarriers),
            pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true,
            "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr) {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex) {
                [[maybe_unused]] const Location pMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
                skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask, kOptionalFlags,
                                              "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |=
                    context.ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask,
                                          kOptionalFlags, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask, kOptionalFlags,
                                              "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |=
                    context.ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask,
                                          kOptionalFlags, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= context.ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::bufferMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers),
            pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers,
            VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr) {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount;
                 ++bufferMemoryBarrierIndex) {
                [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR};

                skip |= context.ValidateStructPnext(
                    pBufferMemoryBarriers_loc, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                    allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext",
                    "VUID-VkBufferMemoryBarrier2-sType-unique", true);

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= context.ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask,
                                              kOptionalFlags, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= context.ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                                       pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= context.ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::imageMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pImageMemoryBarriers),
            pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers,
            VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr) {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount;
                 ++imageMemoryBarrierIndex) {
                [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR,
                    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

                skip |= context.ValidateStructPnext(
                    pImageMemoryBarriers_loc, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                    allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext",
                    "VUID-VkImageMemoryBarrier2-sType-unique", true);

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstStageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= context.ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstAccessMask),
                                              vvl::FlagBitmask::VkAccessFlagBits2, AllVkAccessFlagBits2,
                                              pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask,
                                              kOptionalFlags, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                                   pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                                   "VUID-VkImageMemoryBarrier2-oldLayout-parameter");

                skip |= context.ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                                   pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                                   "VUID-VkImageMemoryBarrier2-newLayout-parameter");

                skip |= context.ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                                       pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= context.ValidateFlags(
                    pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                    AllVkImageAspectFlagBits,
                    pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags,
                    "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool,
                                               uint32_t query, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::stage), vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                  stage, kOptionalFlags, "VUID-vkCmdWriteTimestamp2-stage-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool Device::PreCallValidateQueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::submitCount), loc.dot(Field::pSubmits), submitCount, pSubmits,
                                            VK_STRUCTURE_TYPE_SUBMIT_INFO_2, false, true, "VUID-VkSubmitInfo2-sType-sType",
                                            "VUID-vkQueueSubmit2-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr) {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex) {
            [[maybe_unused]] const Location pSubmits_loc = loc.dot(Field::pSubmits, submitIndex);
            constexpr std::array allowed_structs_VkSubmitInfo2 = {
                VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT, VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
                VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
                VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV};

            skip |= context.ValidateStructPnext(pSubmits_loc, pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo2.size(),
                                                allowed_structs_VkSubmitInfo2.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkSubmitInfo2-pNext-pNext", "VUID-VkSubmitInfo2-sType-unique", true);

            skip |= context.ValidateFlags(pSubmits_loc.dot(Field::flags), vvl::FlagBitmask::VkSubmitFlagBits, AllVkSubmitFlagBits,
                                          pSubmits[submitIndex].flags, kOptionalFlags, "VUID-VkSubmitInfo2-flags-parameter");

            skip |= context.ValidateStructTypeArray(
                pSubmits_loc.dot(Field::waitSemaphoreInfoCount), pSubmits_loc.dot(Field::pWaitSemaphoreInfos),
                pSubmits[submitIndex].waitSemaphoreInfoCount, pSubmits[submitIndex].pWaitSemaphoreInfos,
                VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType",
                "VUID-VkSubmitInfo2-pWaitSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pWaitSemaphoreInfos != nullptr) {
                for (uint32_t waitSemaphoreInfoIndex = 0; waitSemaphoreInfoIndex < pSubmits[submitIndex].waitSemaphoreInfoCount;
                     ++waitSemaphoreInfoIndex) {
                    [[maybe_unused]] const Location pWaitSemaphoreInfos_loc =
                        pSubmits_loc.dot(Field::pWaitSemaphoreInfos, waitSemaphoreInfoIndex);
                    skip |= context.ValidateStructPnext(
                        pWaitSemaphoreInfos_loc, pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].pNext, 0,
                        nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, true);

                    skip |=
                        context.ValidateRequiredHandle(pWaitSemaphoreInfos_loc.dot(Field::semaphore),
                                                       pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].semaphore);

                    skip |= context.ValidateFlags(pWaitSemaphoreInfos_loc.dot(Field::stageMask),
                                                  vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                                  pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].stageMask,
                                                  kOptionalFlags, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }

            skip |= context.ValidateStructTypeArray(
                pSubmits_loc.dot(Field::commandBufferInfoCount), pSubmits_loc.dot(Field::pCommandBufferInfos),
                pSubmits[submitIndex].commandBufferInfoCount, pSubmits[submitIndex].pCommandBufferInfos,
                VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO, false, true, "VUID-VkCommandBufferSubmitInfo-sType-sType",
                "VUID-VkSubmitInfo2-pCommandBufferInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pCommandBufferInfos != nullptr) {
                for (uint32_t commandBufferInfoIndex = 0; commandBufferInfoIndex < pSubmits[submitIndex].commandBufferInfoCount;
                     ++commandBufferInfoIndex) {
                    [[maybe_unused]] const Location pCommandBufferInfos_loc =
                        pSubmits_loc.dot(Field::pCommandBufferInfos, commandBufferInfoIndex);
                    constexpr std::array allowed_structs_VkCommandBufferSubmitInfo = {
                        VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM};

                    skip |= context.ValidateStructPnext(
                        pCommandBufferInfos_loc, pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].pNext,
                        allowed_structs_VkCommandBufferSubmitInfo.size(), allowed_structs_VkCommandBufferSubmitInfo.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkCommandBufferSubmitInfo-pNext-pNext",
                        "VUID-VkCommandBufferSubmitInfo-sType-unique", true);

                    skip |= context.ValidateRequiredHandle(
                        pCommandBufferInfos_loc.dot(Field::commandBuffer),
                        pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].commandBuffer);
                }
            }

            skip |= context.ValidateStructTypeArray(
                pSubmits_loc.dot(Field::signalSemaphoreInfoCount), pSubmits_loc.dot(Field::pSignalSemaphoreInfos),
                pSubmits[submitIndex].signalSemaphoreInfoCount, pSubmits[submitIndex].pSignalSemaphoreInfos,
                VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType",
                "VUID-VkSubmitInfo2-pSignalSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pSignalSemaphoreInfos != nullptr) {
                for (uint32_t signalSemaphoreInfoIndex = 0;
                     signalSemaphoreInfoIndex < pSubmits[submitIndex].signalSemaphoreInfoCount; ++signalSemaphoreInfoIndex) {
                    [[maybe_unused]] const Location pSignalSemaphoreInfos_loc =
                        pSubmits_loc.dot(Field::pSignalSemaphoreInfos, signalSemaphoreInfoIndex);
                    skip |= context.ValidateStructPnext(
                        pSignalSemaphoreInfos_loc, pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].pNext, 0,
                        nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext", kVUIDUndefined, true);

                    skip |= context.ValidateRequiredHandle(
                        pSignalSemaphoreInfos_loc.dot(Field::semaphore),
                        pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].semaphore);

                    skip |= context.ValidateFlags(pSignalSemaphoreInfos_loc.dot(Field::stageMask),
                                                  vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                                  pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].stageMask,
                                                  kOptionalFlags, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCopyBufferInfo), pCopyBufferInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2, true,
                                       "VUID-vkCmdCopyBuffer2-pCopyBufferInfo-parameter", "VUID-VkCopyBufferInfo2-sType-sType");
    if (pCopyBufferInfo != nullptr) {
        [[maybe_unused]] const Location pCopyBufferInfo_loc = loc.dot(Field::pCopyBufferInfo);
        skip |= context.ValidateStructPnext(pCopyBufferInfo_loc, pCopyBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyBufferInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pCopyBufferInfo_loc.dot(Field::srcBuffer), pCopyBufferInfo->srcBuffer);

        skip |= context.ValidateRequiredHandle(pCopyBufferInfo_loc.dot(Field::dstBuffer), pCopyBufferInfo->dstBuffer);

        skip |= context.ValidateStructTypeArray(
            pCopyBufferInfo_loc.dot(Field::regionCount), pCopyBufferInfo_loc.dot(Field::pRegions), pCopyBufferInfo->regionCount,
            pCopyBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_COPY_2, true, true, "VUID-VkBufferCopy2-sType-sType",
            "VUID-VkCopyBufferInfo2-pRegions-parameter", "VUID-VkCopyBufferInfo2-regionCount-arraylength");

        if (pCopyBufferInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyBufferInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= context.ValidateStructPnext(pRegions_loc, pCopyBufferInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkBufferCopy2-pNext-pNext", kVUIDUndefined,
                                                    true);
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer2(commandBuffer, pCopyBufferInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pCopyImageInfo), pCopyImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2, true,
                                       "VUID-vkCmdCopyImage2-pCopyImageInfo-parameter", "VUID-VkCopyImageInfo2-sType-sType");
    if (pCopyImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageInfo_loc = loc.dot(Field::pCopyImageInfo);
        skip |= context.ValidateStructPnext(pCopyImageInfo_loc, pCopyImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyImageInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pCopyImageInfo_loc.dot(Field::srcImage), pCopyImageInfo->srcImage);

        skip |= context.ValidateRangedEnum(pCopyImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyImageInfo->srcImageLayout, "VUID-VkCopyImageInfo2-srcImageLayout-parameter");

        skip |= context.ValidateRequiredHandle(pCopyImageInfo_loc.dot(Field::dstImage), pCopyImageInfo->dstImage);

        skip |= context.ValidateRangedEnum(pCopyImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyImageInfo->dstImageLayout, "VUID-VkCopyImageInfo2-dstImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(
            pCopyImageInfo_loc.dot(Field::regionCount), pCopyImageInfo_loc.dot(Field::pRegions), pCopyImageInfo->regionCount,
            pCopyImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true, true, "VUID-VkImageCopy2-sType-sType",
            "VUID-VkCopyImageInfo2-pRegions-parameter", "VUID-VkCopyImageInfo2-regionCount-arraylength");

        if (pCopyImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= context.ValidateStructPnext(pRegions_loc, pCopyImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined,
                                                    true);

                skip |=
                    context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |=
                    context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
                                                  const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCopyBufferToImageInfo), pCopyBufferToImageInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2, true,
        "VUID-vkCmdCopyBufferToImage2-pCopyBufferToImageInfo-parameter", "VUID-VkCopyBufferToImageInfo2-sType-sType");
    if (pCopyBufferToImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyBufferToImageInfo_loc = loc.dot(Field::pCopyBufferToImageInfo);
        skip |= context.ValidateStructPnext(pCopyBufferToImageInfo_loc, pCopyBufferToImageInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkCopyBufferToImageInfo2-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pCopyBufferToImageInfo_loc.dot(Field::srcBuffer), pCopyBufferToImageInfo->srcBuffer);

        skip |= context.ValidateRequiredHandle(pCopyBufferToImageInfo_loc.dot(Field::dstImage), pCopyBufferToImageInfo->dstImage);

        skip |= context.ValidateRangedEnum(pCopyBufferToImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyBufferToImageInfo->dstImageLayout,
                                           "VUID-VkCopyBufferToImageInfo2-dstImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(
            pCopyBufferToImageInfo_loc.dot(Field::regionCount), pCopyBufferToImageInfo_loc.dot(Field::pRegions),
            pCopyBufferToImageInfo->regionCount, pCopyBufferToImageInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true,
            true, "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyBufferToImageInfo2-pRegions-parameter",
            "VUID-VkCopyBufferToImageInfo2-regionCount-arraylength");

        if (pCopyBufferToImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferToImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyBufferToImageInfo_loc.dot(Field::pRegions, regionIndex);
                constexpr std::array allowed_structs_VkBufferImageCopy2 = {VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM};

                skip |= context.ValidateStructPnext(
                    pRegions_loc, pCopyBufferToImageInfo->pRegions[regionIndex].pNext, allowed_structs_VkBufferImageCopy2.size(),
                    allowed_structs_VkBufferImageCopy2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext",
                    "VUID-VkBufferImageCopy2-sType-unique", true);

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pCopyBufferToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask,
                                              kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
                                                  const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCopyImageToBufferInfo), pCopyImageToBufferInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2, true,
        "VUID-vkCmdCopyImageToBuffer2-pCopyImageToBufferInfo-parameter", "VUID-VkCopyImageToBufferInfo2-sType-sType");
    if (pCopyImageToBufferInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageToBufferInfo_loc = loc.dot(Field::pCopyImageToBufferInfo);
        skip |= context.ValidateStructPnext(pCopyImageToBufferInfo_loc, pCopyImageToBufferInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToBufferInfo2-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pCopyImageToBufferInfo_loc.dot(Field::srcImage), pCopyImageToBufferInfo->srcImage);

        skip |= context.ValidateRangedEnum(pCopyImageToBufferInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyImageToBufferInfo->srcImageLayout,
                                           "VUID-VkCopyImageToBufferInfo2-srcImageLayout-parameter");

        skip |= context.ValidateRequiredHandle(pCopyImageToBufferInfo_loc.dot(Field::dstBuffer), pCopyImageToBufferInfo->dstBuffer);

        skip |= context.ValidateStructTypeArray(
            pCopyImageToBufferInfo_loc.dot(Field::regionCount), pCopyImageToBufferInfo_loc.dot(Field::pRegions),
            pCopyImageToBufferInfo->regionCount, pCopyImageToBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true,
            true, "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyImageToBufferInfo2-pRegions-parameter",
            "VUID-VkCopyImageToBufferInfo2-regionCount-arraylength");

        if (pCopyImageToBufferInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToBufferInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageToBufferInfo_loc.dot(Field::pRegions, regionIndex);
                constexpr std::array allowed_structs_VkBufferImageCopy2 = {VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM};

                skip |= context.ValidateStructPnext(
                    pRegions_loc, pCopyImageToBufferInfo->pRegions[regionIndex].pNext, allowed_structs_VkBufferImageCopy2.size(),
                    allowed_structs_VkBufferImageCopy2.data(), GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext",
                    "VUID-VkBufferImageCopy2-sType-unique", true);

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pCopyImageToBufferInfo->pRegions[regionIndex].imageSubresource.aspectMask,
                                              kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pBlitImageInfo), pBlitImageInfo, VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2, true,
                                       "VUID-vkCmdBlitImage2-pBlitImageInfo-parameter", "VUID-VkBlitImageInfo2-sType-sType");
    if (pBlitImageInfo != nullptr) {
        [[maybe_unused]] const Location pBlitImageInfo_loc = loc.dot(Field::pBlitImageInfo);
        constexpr std::array allowed_structs_VkBlitImageInfo2 = {VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM};

        skip |= context.ValidateStructPnext(pBlitImageInfo_loc, pBlitImageInfo->pNext, allowed_structs_VkBlitImageInfo2.size(),
                                            allowed_structs_VkBlitImageInfo2.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkBlitImageInfo2-pNext-pNext", "VUID-VkBlitImageInfo2-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pBlitImageInfo_loc.dot(Field::srcImage), pBlitImageInfo->srcImage);

        skip |= context.ValidateRangedEnum(pBlitImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                           pBlitImageInfo->srcImageLayout, "VUID-VkBlitImageInfo2-srcImageLayout-parameter");

        skip |= context.ValidateRequiredHandle(pBlitImageInfo_loc.dot(Field::dstImage), pBlitImageInfo->dstImage);

        skip |= context.ValidateRangedEnum(pBlitImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                           pBlitImageInfo->dstImageLayout, "VUID-VkBlitImageInfo2-dstImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(
            pBlitImageInfo_loc.dot(Field::regionCount), pBlitImageInfo_loc.dot(Field::pRegions), pBlitImageInfo->regionCount,
            pBlitImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_BLIT_2, true, true, "VUID-VkImageBlit2-sType-sType",
            "VUID-VkBlitImageInfo2-pRegions-parameter", "VUID-VkBlitImageInfo2-regionCount-arraylength");

        if (pBlitImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pBlitImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pBlitImageInfo_loc.dot(Field::pRegions, regionIndex);
                constexpr std::array allowed_structs_VkImageBlit2 = {VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM};

                skip |= context.ValidateStructPnext(pRegions_loc, pBlitImageInfo->pRegions[regionIndex].pNext,
                                                    allowed_structs_VkImageBlit2.size(), allowed_structs_VkImageBlit2.data(),
                                                    GeneratedVulkanHeaderVersion, "VUID-VkImageBlit2-pNext-pNext",
                                                    "VUID-VkImageBlit2-sType-unique", true);

                skip |=
                    context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                skip |=
                    context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
            }
        }

        skip |= context.ValidateRangedEnum(pBlitImageInfo_loc.dot(Field::filter), vvl::Enum::VkFilter, pBlitImageInfo->filter,
                                           "VUID-VkBlitImageInfo2-filter-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pResolveImageInfo), pResolveImageInfo, VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2,
                                       true, "VUID-vkCmdResolveImage2-pResolveImageInfo-parameter",
                                       "VUID-VkResolveImageInfo2-sType-sType");
    if (pResolveImageInfo != nullptr) {
        [[maybe_unused]] const Location pResolveImageInfo_loc = loc.dot(Field::pResolveImageInfo);
        skip |=
            context.ValidateStructPnext(pResolveImageInfo_loc, pResolveImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkResolveImageInfo2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pResolveImageInfo_loc.dot(Field::srcImage), pResolveImageInfo->srcImage);

        skip |= context.ValidateRangedEnum(pResolveImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                           pResolveImageInfo->srcImageLayout, "VUID-VkResolveImageInfo2-srcImageLayout-parameter");

        skip |= context.ValidateRequiredHandle(pResolveImageInfo_loc.dot(Field::dstImage), pResolveImageInfo->dstImage);

        skip |= context.ValidateRangedEnum(pResolveImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                           pResolveImageInfo->dstImageLayout, "VUID-VkResolveImageInfo2-dstImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(pResolveImageInfo_loc.dot(Field::regionCount),
                                                pResolveImageInfo_loc.dot(Field::pRegions), pResolveImageInfo->regionCount,
                                                pResolveImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2, true, true,
                                                "VUID-VkImageResolve2-sType-sType", "VUID-VkResolveImageInfo2-pRegions-parameter",
                                                "VUID-VkResolveImageInfo2-regionCount-arraylength");

        if (pResolveImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pResolveImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pResolveImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= context.ValidateStructPnext(pRegions_loc, pResolveImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkImageResolve2-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pResolveImageInfo->pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                              "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pResolveImageInfo->pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                              "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pRenderingInfo), pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true,
                                       "VUID-vkCmdBeginRendering-pRenderingInfo-parameter", "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr) {
        [[maybe_unused]] const Location pRenderingInfo_loc = loc.dot(Field::pRenderingInfo);
        constexpr std::array allowed_structs_VkRenderingInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR};

        skip |= context.ValidateStructPnext(pRenderingInfo_loc, pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(),
                                            allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", true);

        skip |= context.ValidateFlags(pRenderingInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderingFlagBits,
                                      AllVkRenderingFlagBits, pRenderingInfo->flags, kOptionalFlags,
                                      "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= context.ValidateStructTypeArray(
            pRenderingInfo_loc.dot(Field::colorAttachmentCount), pRenderingInfo_loc.dot(Field::pColorAttachments),
            pRenderingInfo->colorAttachmentCount, pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
            false, true, "VUID-VkRenderingAttachmentInfo-sType-sType", "VUID-VkRenderingInfo-pColorAttachments-parameter",
            kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr) {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount;
                 ++colorAttachmentIndex) {
                [[maybe_unused]] const Location pColorAttachments_loc =
                    pRenderingInfo_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                skip |= context.ValidateStructPnext(
                    pColorAttachments_loc, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0, nullptr,
                    GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout,
                                                   "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

                skip |= context.ValidateFlags(pColorAttachments_loc.dot(Field::resolveMode),
                                              vvl::FlagBitmask::VkResolveModeFlagBits, AllVkResolveModeFlagBits,
                                              pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode,
                                              kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout,
                                                   "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp,
                                                   "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp,
                                                   "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

                // No xml-driven validation
            }
        }

        skip |= context.ValidateStructType(pRenderingInfo_loc.dot(Field::pDepthAttachment), pRenderingInfo->pDepthAttachment,
                                           VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                                           "VUID-VkRenderingInfo-pDepthAttachment-parameter",
                                           "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr) {
            [[maybe_unused]] const Location pDepthAttachment_loc = pRenderingInfo_loc.dot(Field::pDepthAttachment);
            skip |= context.ValidateStructPnext(pDepthAttachment_loc, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pDepthAttachment->imageLayout,
                                               "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= context.ValidateFlags(pDepthAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                          AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode,
                                          kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pDepthAttachment->resolveImageLayout,
                                               "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                               pRenderingInfo->pDepthAttachment->loadOp,
                                               "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                               pRenderingInfo->pDepthAttachment->storeOp,
                                               "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }

        skip |= context.ValidateStructType(pRenderingInfo_loc.dot(Field::pStencilAttachment), pRenderingInfo->pStencilAttachment,
                                           VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                                           "VUID-VkRenderingInfo-pStencilAttachment-parameter",
                                           "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr) {
            [[maybe_unused]] const Location pStencilAttachment_loc = pRenderingInfo_loc.dot(Field::pStencilAttachment);
            skip |= context.ValidateStructPnext(pStencilAttachment_loc, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pStencilAttachment->imageLayout,
                                               "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= context.ValidateFlags(pStencilAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                          AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode,
                                          kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pStencilAttachment->resolveImageLayout,
                                               "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                               pRenderingInfo->pStencilAttachment->loadOp,
                                               "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                               pRenderingInfo->pStencilAttachment->storeOp,
                                               "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRendering(commandBuffer, pRenderingInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdEndRendering(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::cullMode), vvl::FlagBitmask::VkCullModeFlagBits, AllVkCullModeFlagBits, cullMode,
                                  kOptionalFlags, "VUID-vkCmdSetCullMode-cullMode-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::frontFace), vvl::Enum::VkFrontFace, frontFace,
                                       "VUID-vkCmdSetFrontFace-frontFace-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::primitiveTopology), vvl::Enum::VkPrimitiveTopology, primitiveTopology,
                                       "VUID-vkCmdSetPrimitiveTopology-primitiveTopology-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                                    const VkViewport* pViewports, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewports), viewportCount, &pViewports, true, true,
                                  "VUID-vkCmdSetViewportWithCount-viewportCount-arraylength",
                                  "VUID-vkCmdSetViewportWithCount-pViewports-parameter");
    if (pViewports != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewports_loc = loc.dot(Field::pViewports, viewportIndex);
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports, context);
    return skip;
}

bool Device::PreCallValidateCmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateArray(loc.dot(Field::scissorCount), loc.dot(Field::pScissors), scissorCount, &pScissors, true, true,
                                  "VUID-vkCmdSetScissorWithCount-scissorCount-arraylength",
                                  "VUID-vkCmdSetScissorWithCount-pScissors-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors, context);
    return skip;
}

bool Device::PreCallValidateCmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
                                                  const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
                                                  const VkDeviceSize* pSizes, const VkDeviceSize* pStrides,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    if (!skip)
        skip |= manual_PreCallValidateCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes,
                                                            pStrides, context);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::depthTestEnable), depthTestEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::depthWriteEnable), depthWriteEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::depthCompareOp), vvl::Enum::VkCompareOp, depthCompareOp,
                                       "VUID-vkCmdSetDepthCompareOp-depthCompareOp-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::depthBoundsTestEnable), depthBoundsTestEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::stencilTestEnable), stencilTestEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp,
                                            VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits,
                                  faceMask, kRequiredFlags, "VUID-vkCmdSetStencilOp-faceMask-parameter",
                                  "VUID-vkCmdSetStencilOp-faceMask-requiredbitmask");
    skip |= context.ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, failOp,
                                       "VUID-vkCmdSetStencilOp-failOp-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, passOp,
                                       "VUID-vkCmdSetStencilOp-passOp-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::depthFailOp), vvl::Enum::VkStencilOp, depthFailOp,
                                       "VUID-vkCmdSetStencilOp-depthFailOp-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::compareOp), vvl::Enum::VkCompareOp, compareOp,
                                       "VUID-vkCmdSetStencilOp-compareOp-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::rasterizerDiscardEnable), rasterizerDiscardEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::depthBiasEnable), depthBiasEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateBool32(loc.dot(Field::primitiveRestartEnable), primitiveRestartEnable);
    return skip;
}

bool Device::PreCallValidateGetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
                                                              VkMemoryRequirements2* pMemoryRequirements,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS, true,
                                       "VUID-vkGetDeviceBufferMemoryRequirements-pInfo-parameter",
                                       "VUID-VkDeviceBufferMemoryRequirements-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceBufferMemoryRequirements-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(
            pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true,
            "VUID-VkDeviceBufferMemoryRequirements-pCreateInfo-parameter", "VUID-VkBufferCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkBufferCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |=
                context.ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(),
                                            allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                                          AllVkBufferCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags,
                                          "VUID-VkBufferCreateInfo-flags-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                               pInfo->pCreateInfo->sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter");
        }
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetDeviceBufferMemoryRequirements-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateGetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
                                                             VkMemoryRequirements2* pMemoryRequirements,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true,
                                       "VUID-vkGetDeviceImageMemoryRequirements-pInfo-parameter",
                                       "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(
            pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
            "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkImageCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |=
                context.ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                            allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                          AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags,
                                          "VUID-VkImageCreateInfo-flags-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType,
                                               pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pInfo->pCreateInfo->format,
                                               "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                          AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit,
                                          "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling,
                                               pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                          AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags,
                                          "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                               pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                               pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= context.ValidateFlags(pInfo_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pInfo->planeAspect, kOptionalSingleBit,
                                      "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetDeviceImageMemoryRequirements-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements, context);
    return skip;
}

bool Device::PreCallValidateGetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
                                                                   uint32_t* pSparseMemoryRequirementCount,
                                                                   VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true,
                                       "VUID-vkGetDeviceImageSparseMemoryRequirements-pInfo-parameter",
                                       "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(
            pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
            "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkImageCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |=
                context.ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                            allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                          AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags,
                                          "VUID-VkImageCreateInfo-flags-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType,
                                               pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pInfo->pCreateInfo->format,
                                               "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                          AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit,
                                          "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling,
                                               pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                          AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags,
                                          "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                               pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                               pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= context.ValidateFlags(pInfo_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pInfo->planeAspect, kOptionalSingleBit,
                                      "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pSparseMemoryRequirementCount), loc.dot(Field::pSparseMemoryRequirements), pSparseMemoryRequirementCount,
        pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false,
        "VUID-VkSparseImageMemoryRequirements2-sType-sType", kVUIDUndefined,
        "VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr) {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount;
             ++pSparseMemoryRequirementIndex) {
            [[maybe_unused]] const Location pSparseMemoryRequirements_loc =
                loc.dot(Field::pSparseMemoryRequirements, pSparseMemoryRequirementIndex);
            skip |= context.ValidateStructPnext(
                pSparseMemoryRequirements_loc, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext, 0, nullptr,
                GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext", kVUIDUndefined, false);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                                             pSparseMemoryRequirements, context);
    return skip;
}

bool Device::PreCallValidateCmdSetLineStipple(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                              uint16_t lineStipplePattern, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern, context);
    return skip;
}

bool Device::PreCallValidateMapMemory2(VkDevice device, const VkMemoryMapInfo* pMemoryMapInfo, void** ppData,
                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryMapInfo), pMemoryMapInfo, VK_STRUCTURE_TYPE_MEMORY_MAP_INFO, true,
                                       "VUID-vkMapMemory2-pMemoryMapInfo-parameter", "VUID-VkMemoryMapInfo-sType-sType");
    if (pMemoryMapInfo != nullptr) {
        [[maybe_unused]] const Location pMemoryMapInfo_loc = loc.dot(Field::pMemoryMapInfo);
        constexpr std::array allowed_structs_VkMemoryMapInfo = {VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT};

        skip |= context.ValidateStructPnext(pMemoryMapInfo_loc, pMemoryMapInfo->pNext, allowed_structs_VkMemoryMapInfo.size(),
                                            allowed_structs_VkMemoryMapInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkMemoryMapInfo-pNext-pNext", "VUID-VkMemoryMapInfo-sType-unique", true);

        skip |= context.ValidateFlags(pMemoryMapInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryMapFlagBits,
                                      AllVkMemoryMapFlagBits, pMemoryMapInfo->flags, kOptionalFlags,
                                      "VUID-VkMemoryMapInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pMemoryMapInfo_loc.dot(Field::memory), pMemoryMapInfo->memory);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::ppData), ppData, "VUID-vkMapMemory2-ppData-parameter");
    return skip;
}

bool Device::PreCallValidateUnmapMemory2(VkDevice device, const VkMemoryUnmapInfo* pMemoryUnmapInfo,
                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pMemoryUnmapInfo), pMemoryUnmapInfo, VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO, true,
                                   "VUID-vkUnmapMemory2-pMemoryUnmapInfo-parameter", "VUID-VkMemoryUnmapInfo-sType-sType");
    if (pMemoryUnmapInfo != nullptr) {
        [[maybe_unused]] const Location pMemoryUnmapInfo_loc = loc.dot(Field::pMemoryUnmapInfo);
        skip |= context.ValidateStructPnext(pMemoryUnmapInfo_loc, pMemoryUnmapInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMemoryUnmapInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pMemoryUnmapInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryUnmapFlagBits,
                                      AllVkMemoryUnmapFlagBits, pMemoryUnmapInfo->flags, kOptionalFlags,
                                      "VUID-VkMemoryUnmapInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pMemoryUnmapInfo_loc.dot(Field::memory), pMemoryUnmapInfo->memory);
    }
    return skip;
}

bool Device::PreCallValidateCmdBindIndexBuffer2(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                VkDeviceSize size, VkIndexType indexType, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::indexType), vvl::Enum::VkIndexType, indexType,
                                       "VUID-vkCmdBindIndexBuffer2-indexType-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdBindIndexBuffer2(commandBuffer, buffer, offset, size, indexType, context);
    return skip;
}

bool Device::PreCallValidateGetRenderingAreaGranularity(VkDevice device, const VkRenderingAreaInfo* pRenderingAreaInfo,
                                                        VkExtent2D* pGranularity, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pRenderingAreaInfo), pRenderingAreaInfo, VK_STRUCTURE_TYPE_RENDERING_AREA_INFO, true,
        "VUID-vkGetRenderingAreaGranularity-pRenderingAreaInfo-parameter", "VUID-VkRenderingAreaInfo-sType-sType");
    if (pRenderingAreaInfo != nullptr) {
        [[maybe_unused]] const Location pRenderingAreaInfo_loc = loc.dot(Field::pRenderingAreaInfo);
        skip |=
            context.ValidateStructPnext(pRenderingAreaInfo_loc, pRenderingAreaInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkRenderingAreaInfo-pNext-pNext", kVUIDUndefined, true);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pGranularity), pGranularity,
                                            "VUID-vkGetRenderingAreaGranularity-pGranularity-parameter");
    return skip;
}

bool Device::PreCallValidateGetDeviceImageSubresourceLayout(VkDevice device, const VkDeviceImageSubresourceInfo* pInfo,
                                                            VkSubresourceLayout2* pLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO, true,
                                       "VUID-vkGetDeviceImageSubresourceLayout-pInfo-parameter",
                                       "VUID-VkDeviceImageSubresourceInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceImageSubresourceInfo-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(
            pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
            "VUID-VkDeviceImageSubresourceInfo-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkImageCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |=
                context.ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                            allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                          AllVkImageCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags,
                                          "VUID-VkImageCreateInfo-flags-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType,
                                               pInfo->pCreateInfo->imageType, "VUID-VkImageCreateInfo-imageType-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pInfo->pCreateInfo->format,
                                               "VUID-VkImageCreateInfo-format-parameter");

            // No xml-driven validation

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                          AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit,
                                          "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling,
                                               pInfo->pCreateInfo->tiling, "VUID-VkImageCreateInfo-tiling-parameter");

            skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                          AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags,
                                          "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                               pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                               pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter");
        }

        skip |= context.ValidateStructType(
            pInfo_loc.dot(Field::pSubresource), pInfo->pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2, true,
            "VUID-VkDeviceImageSubresourceInfo-pSubresource-parameter", "VUID-VkImageSubresource2-sType-sType");

        if (pInfo->pSubresource != nullptr) {
            [[maybe_unused]] const Location pSubresource_loc = pInfo_loc.dot(Field::pSubresource);
            skip |=
                context.ValidateStructPnext(pSubresource_loc, pInfo->pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageSubresource2-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateFlags(pSubresource_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pInfo->pSubresource->imageSubresource.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresource-aspectMask-parameter",
                                          "VUID-VkImageSubresource-aspectMask-requiredbitmask");
        }
    }
    skip |= context.ValidateStructType(loc.dot(Field::pLayout), pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2, true,
                                       "VUID-vkGetDeviceImageSubresourceLayout-pLayout-parameter",
                                       "VUID-VkSubresourceLayout2-sType-sType");
    if (pLayout != nullptr) {
        [[maybe_unused]] const Location pLayout_loc = loc.dot(Field::pLayout);
        constexpr std::array allowed_structs_VkSubresourceLayout2 = {VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                                                                     VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE};

        skip |= context.ValidateStructPnext(
            pLayout_loc, pLayout->pNext, allowed_structs_VkSubresourceLayout2.size(), allowed_structs_VkSubresourceLayout2.data(),
            GeneratedVulkanHeaderVersion, "VUID-VkSubresourceLayout2-pNext-pNext", "VUID-VkSubresourceLayout2-sType-unique", false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageSubresourceLayout(device, pInfo, pLayout, context);
    return skip;
}

bool Device::PreCallValidateGetImageSubresourceLayout2(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource,
                                                       VkSubresourceLayout2* pLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateStructType(loc.dot(Field::pSubresource), pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2, true,
                                       "VUID-vkGetImageSubresourceLayout2-pSubresource-parameter",
                                       "VUID-VkImageSubresource2-sType-sType");
    if (pSubresource != nullptr) {
        [[maybe_unused]] const Location pSubresource_loc = loc.dot(Field::pSubresource);
        skip |= context.ValidateStructPnext(pSubresource_loc, pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageSubresource2-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pSubresource_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pSubresource->imageSubresource.aspectMask, kRequiredFlags,
                                      "VUID-VkImageSubresource-aspectMask-parameter",
                                      "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |=
        context.ValidateStructType(loc.dot(Field::pLayout), pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2, true,
                                   "VUID-vkGetImageSubresourceLayout2-pLayout-parameter", "VUID-VkSubresourceLayout2-sType-sType");
    if (pLayout != nullptr) {
        [[maybe_unused]] const Location pLayout_loc = loc.dot(Field::pLayout);
        constexpr std::array allowed_structs_VkSubresourceLayout2 = {VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                                                                     VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE};

        skip |= context.ValidateStructPnext(
            pLayout_loc, pLayout->pNext, allowed_structs_VkSubresourceLayout2.size(), allowed_structs_VkSubresourceLayout2.data(),
            GeneratedVulkanHeaderVersion, "VUID-VkSubresourceLayout2-pNext-pNext", "VUID-VkSubresourceLayout2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                 VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount,
                                                 const VkWriteDescriptorSet* pDescriptorWrites,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdPushDescriptorSet-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::descriptorWriteCount), loc.dot(Field::pDescriptorWrites), descriptorWriteCount, pDescriptorWrites,
        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, true, true, "VUID-VkWriteDescriptorSet-sType-sType",
        "VUID-vkCmdPushDescriptorSet-pDescriptorWrites-parameter", "VUID-vkCmdPushDescriptorSet-descriptorWriteCount-arraylength");
    if (pDescriptorWrites != nullptr) {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex) {
            [[maybe_unused]] const Location pDescriptorWrites_loc = loc.dot(Field::pDescriptorWrites, descriptorWriteIndex);
            constexpr std::array allowed_structs_VkWriteDescriptorSet = {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV};

            skip |= context.ValidateStructPnext(
                pDescriptorWrites_loc, pDescriptorWrites[descriptorWriteIndex].pNext, allowed_structs_VkWriteDescriptorSet.size(),
                allowed_structs_VkWriteDescriptorSet.data(), GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext",
                "VUID-VkWriteDescriptorSet-sType-unique", true);

            skip |= context.ValidateRangedEnum(pDescriptorWrites_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                               pDescriptorWrites[descriptorWriteIndex].descriptorType,
                                               "VUID-VkWriteDescriptorSet-descriptorType-parameter");

            skip |= context.ValidateArray(pDescriptorWrites_loc.dot(Field::descriptorCount), loc,
                                          pDescriptorWrites[descriptorWriteIndex].descriptorCount,
                                          &pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false,
                                          "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount,
                                                           pDescriptorWrites, context);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSetWithTemplate(VkCommandBuffer commandBuffer,
                                                             VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                             VkPipelineLayout layout, uint32_t set, const void* pData,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::descriptorUpdateTemplate), descriptorUpdateTemplate);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    return skip;
}

bool Device::PreCallValidateCmdSetRenderingAttachmentLocations(VkCommandBuffer commandBuffer,
                                                               const VkRenderingAttachmentLocationInfo* pLocationInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pLocationInfo), pLocationInfo, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO, true,
        "VUID-vkCmdSetRenderingAttachmentLocations-pLocationInfo-parameter", "VUID-VkRenderingAttachmentLocationInfo-sType-sType");
    return skip;
}

bool Device::PreCallValidateCmdSetRenderingInputAttachmentIndices(
    VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pInputAttachmentIndexInfo), pInputAttachmentIndexInfo,
                                       VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO, true,
                                       "VUID-vkCmdSetRenderingInputAttachmentIndices-pInputAttachmentIndexInfo-parameter",
                                       "VUID-VkRenderingInputAttachmentIndexInfo-sType-sType");
    return skip;
}

bool Device::PreCallValidateCmdBindDescriptorSets2(VkCommandBuffer commandBuffer,
                                                   const VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pBindDescriptorSetsInfo), pBindDescriptorSetsInfo, VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO, true,
        "VUID-vkCmdBindDescriptorSets2-pBindDescriptorSetsInfo-parameter", "VUID-VkBindDescriptorSetsInfo-sType-sType");
    if (pBindDescriptorSetsInfo != nullptr) {
        [[maybe_unused]] const Location pBindDescriptorSetsInfo_loc = loc.dot(Field::pBindDescriptorSetsInfo);
        constexpr std::array allowed_structs_VkBindDescriptorSetsInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(
            pBindDescriptorSetsInfo_loc, pBindDescriptorSetsInfo->pNext, allowed_structs_VkBindDescriptorSetsInfo.size(),
            allowed_structs_VkBindDescriptorSetsInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkBindDescriptorSetsInfo-pNext-pNext", "VUID-VkBindDescriptorSetsInfo-sType-unique", true);

        skip |= context.ValidateFlags(pBindDescriptorSetsInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pBindDescriptorSetsInfo->stageFlags, kRequiredFlags,
                                      "VUID-VkBindDescriptorSetsInfo-stageFlags-parameter",
                                      "VUID-VkBindDescriptorSetsInfo-stageFlags-requiredbitmask");

        skip |= context.ValidateHandleArray(pBindDescriptorSetsInfo_loc.dot(Field::descriptorSetCount),
                                            pBindDescriptorSetsInfo_loc.dot(Field::pDescriptorSets),
                                            pBindDescriptorSetsInfo->descriptorSetCount, pBindDescriptorSetsInfo->pDescriptorSets,
                                            true, true, "VUID-VkBindDescriptorSetsInfo-descriptorSetCount-arraylength");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBindDescriptorSets2(commandBuffer, pBindDescriptorSetsInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdPushConstants2(VkCommandBuffer commandBuffer, const VkPushConstantsInfo* pPushConstantsInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pPushConstantsInfo), pPushConstantsInfo, VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO, true,
        "VUID-vkCmdPushConstants2-pPushConstantsInfo-parameter", "VUID-VkPushConstantsInfo-sType-sType");
    if (pPushConstantsInfo != nullptr) {
        [[maybe_unused]] const Location pPushConstantsInfo_loc = loc.dot(Field::pPushConstantsInfo);
        constexpr std::array allowed_structs_VkPushConstantsInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(pPushConstantsInfo_loc, pPushConstantsInfo->pNext,
                                            allowed_structs_VkPushConstantsInfo.size(), allowed_structs_VkPushConstantsInfo.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkPushConstantsInfo-pNext-pNext",
                                            "VUID-VkPushConstantsInfo-sType-unique", true);

        skip |= context.ValidateFlags(pPushConstantsInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pPushConstantsInfo->stageFlags, kRequiredFlags,
                                      "VUID-VkPushConstantsInfo-stageFlags-parameter",
                                      "VUID-VkPushConstantsInfo-stageFlags-requiredbitmask");

        skip |= context.ValidateArray(pPushConstantsInfo_loc.dot(Field::size), pPushConstantsInfo_loc.dot(Field::pValues),
                                      pPushConstantsInfo->size, &pPushConstantsInfo->pValues, true, true,
                                      "VUID-VkPushConstantsInfo-size-arraylength", "VUID-VkPushConstantsInfo-pValues-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdPushConstants2(commandBuffer, pPushConstantsInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSet2(VkCommandBuffer commandBuffer,
                                                  const VkPushDescriptorSetInfo* pPushDescriptorSetInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pPushDescriptorSetInfo), pPushDescriptorSetInfo, VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO, true,
        "VUID-vkCmdPushDescriptorSet2-pPushDescriptorSetInfo-parameter", "VUID-VkPushDescriptorSetInfo-sType-sType");
    if (pPushDescriptorSetInfo != nullptr) {
        [[maybe_unused]] const Location pPushDescriptorSetInfo_loc = loc.dot(Field::pPushDescriptorSetInfo);
        constexpr std::array allowed_structs_VkPushDescriptorSetInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(
            pPushDescriptorSetInfo_loc, pPushDescriptorSetInfo->pNext, allowed_structs_VkPushDescriptorSetInfo.size(),
            allowed_structs_VkPushDescriptorSetInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPushDescriptorSetInfo-pNext-pNext", "VUID-VkPushDescriptorSetInfo-sType-unique", true);

        skip |= context.ValidateFlags(pPushDescriptorSetInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pPushDescriptorSetInfo->stageFlags, kRequiredFlags,
                                      "VUID-VkPushDescriptorSetInfo-stageFlags-parameter",
                                      "VUID-VkPushDescriptorSetInfo-stageFlags-requiredbitmask");

        skip |= context.ValidateStructTypeArray(
            pPushDescriptorSetInfo_loc.dot(Field::descriptorWriteCount), pPushDescriptorSetInfo_loc.dot(Field::pDescriptorWrites),
            pPushDescriptorSetInfo->descriptorWriteCount, pPushDescriptorSetInfo->pDescriptorWrites,
            VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, true, true, "VUID-VkWriteDescriptorSet-sType-sType",
            "VUID-VkPushDescriptorSetInfo-pDescriptorWrites-parameter",
            "VUID-VkPushDescriptorSetInfo-descriptorWriteCount-arraylength");

        if (pPushDescriptorSetInfo->pDescriptorWrites != nullptr) {
            for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < pPushDescriptorSetInfo->descriptorWriteCount;
                 ++descriptorWriteIndex) {
                [[maybe_unused]] const Location pDescriptorWrites_loc =
                    pPushDescriptorSetInfo_loc.dot(Field::pDescriptorWrites, descriptorWriteIndex);
                constexpr std::array allowed_structs_VkWriteDescriptorSet = {
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV};

                skip |= context.ValidateStructPnext(
                    pDescriptorWrites_loc, pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].pNext,
                    allowed_structs_VkWriteDescriptorSet.size(), allowed_structs_VkWriteDescriptorSet.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext", "VUID-VkWriteDescriptorSet-sType-unique",
                    true);

                skip |= context.ValidateRangedEnum(pDescriptorWrites_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                                   pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].descriptorType,
                                                   "VUID-VkWriteDescriptorSet-descriptorType-parameter");

                skip |= context.ValidateArray(pDescriptorWrites_loc.dot(Field::descriptorCount), loc,
                                              pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].descriptorCount,
                                              &pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].pImageInfo, true,
                                              false, "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdPushDescriptorSet2(commandBuffer, pPushDescriptorSetInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSetWithTemplate2(
    VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pPushDescriptorSetWithTemplateInfo), pPushDescriptorSetWithTemplateInfo,
                                       VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO, true,
                                       "VUID-vkCmdPushDescriptorSetWithTemplate2-pPushDescriptorSetWithTemplateInfo-parameter",
                                       "VUID-VkPushDescriptorSetWithTemplateInfo-sType-sType");
    if (pPushDescriptorSetWithTemplateInfo != nullptr) {
        [[maybe_unused]] const Location pPushDescriptorSetWithTemplateInfo_loc = loc.dot(Field::pPushDescriptorSetWithTemplateInfo);
        constexpr std::array allowed_structs_VkPushDescriptorSetWithTemplateInfo = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(pPushDescriptorSetWithTemplateInfo_loc, pPushDescriptorSetWithTemplateInfo->pNext,
                                            allowed_structs_VkPushDescriptorSetWithTemplateInfo.size(),
                                            allowed_structs_VkPushDescriptorSetWithTemplateInfo.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkPushDescriptorSetWithTemplateInfo-pNext-pNext",
                                            "VUID-VkPushDescriptorSetWithTemplateInfo-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pPushDescriptorSetWithTemplateInfo_loc.dot(Field::descriptorUpdateTemplate),
                                               pPushDescriptorSetWithTemplateInfo->descriptorUpdateTemplate);

        skip |= context.ValidateRequiredPointer(pPushDescriptorSetWithTemplateInfo_loc.dot(Field::pData),
                                                pPushDescriptorSetWithTemplateInfo->pData,
                                                "VUID-VkPushDescriptorSetWithTemplateInfo-pData-parameter");
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdPushDescriptorSetWithTemplate2(commandBuffer, pPushDescriptorSetWithTemplateInfo, context);
    return skip;
}

bool Device::PreCallValidateCopyMemoryToImage(VkDevice device, const VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCopyMemoryToImageInfo), pCopyMemoryToImageInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO, true,
        "VUID-vkCopyMemoryToImage-pCopyMemoryToImageInfo-parameter", "VUID-VkCopyMemoryToImageInfo-sType-sType");
    if (pCopyMemoryToImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyMemoryToImageInfo_loc = loc.dot(Field::pCopyMemoryToImageInfo);
        skip |= context.ValidateStructPnext(pCopyMemoryToImageInfo_loc, pCopyMemoryToImageInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkCopyMemoryToImageInfo-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateFlags(pCopyMemoryToImageInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkHostImageCopyFlagBits,
                                      AllVkHostImageCopyFlagBits, pCopyMemoryToImageInfo->flags, kOptionalFlags,
                                      "VUID-VkCopyMemoryToImageInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCopyMemoryToImageInfo_loc.dot(Field::dstImage), pCopyMemoryToImageInfo->dstImage);

        skip |= context.ValidateRangedEnum(pCopyMemoryToImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyMemoryToImageInfo->dstImageLayout,
                                           "VUID-VkCopyMemoryToImageInfo-dstImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(
            pCopyMemoryToImageInfo_loc.dot(Field::regionCount), pCopyMemoryToImageInfo_loc.dot(Field::pRegions),
            pCopyMemoryToImageInfo->regionCount, pCopyMemoryToImageInfo->pRegions, VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY, true,
            true, "VUID-VkMemoryToImageCopy-sType-sType", "VUID-VkCopyMemoryToImageInfo-pRegions-parameter",
            "VUID-VkCopyMemoryToImageInfo-regionCount-arraylength");

        if (pCopyMemoryToImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyMemoryToImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyMemoryToImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= context.ValidateStructPnext(pRegions_loc, pCopyMemoryToImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryToImageCopy-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateRequiredPointer(pRegions_loc.dot(Field::pHostPointer),
                                                        pCopyMemoryToImageInfo->pRegions[regionIndex].pHostPointer,
                                                        "VUID-VkMemoryToImageCopy-pHostPointer-parameter");

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pCopyMemoryToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask,
                                              kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCopyImageToMemory(VkDevice device, const VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCopyImageToMemoryInfo), pCopyImageToMemoryInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO, true,
        "VUID-vkCopyImageToMemory-pCopyImageToMemoryInfo-parameter", "VUID-VkCopyImageToMemoryInfo-sType-sType");
    if (pCopyImageToMemoryInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageToMemoryInfo_loc = loc.dot(Field::pCopyImageToMemoryInfo);
        skip |= context.ValidateStructPnext(pCopyImageToMemoryInfo_loc, pCopyImageToMemoryInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToMemoryInfo-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateFlags(pCopyImageToMemoryInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkHostImageCopyFlagBits,
                                      AllVkHostImageCopyFlagBits, pCopyImageToMemoryInfo->flags, kOptionalFlags,
                                      "VUID-VkCopyImageToMemoryInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCopyImageToMemoryInfo_loc.dot(Field::srcImage), pCopyImageToMemoryInfo->srcImage);

        skip |= context.ValidateRangedEnum(pCopyImageToMemoryInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyImageToMemoryInfo->srcImageLayout,
                                           "VUID-VkCopyImageToMemoryInfo-srcImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(
            pCopyImageToMemoryInfo_loc.dot(Field::regionCount), pCopyImageToMemoryInfo_loc.dot(Field::pRegions),
            pCopyImageToMemoryInfo->regionCount, pCopyImageToMemoryInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY, true,
            true, "VUID-VkImageToMemoryCopy-sType-sType", "VUID-VkCopyImageToMemoryInfo-pRegions-parameter",
            "VUID-VkCopyImageToMemoryInfo-regionCount-arraylength");

        if (pCopyImageToMemoryInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToMemoryInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageToMemoryInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= context.ValidateStructPnext(pRegions_loc, pCopyImageToMemoryInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkImageToMemoryCopy-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateRequiredPointer(pRegions_loc.dot(Field::pHostPointer),
                                                        pCopyImageToMemoryInfo->pRegions[regionIndex].pHostPointer,
                                                        "VUID-VkImageToMemoryCopy-pHostPointer-parameter");

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pCopyImageToMemoryInfo->pRegions[regionIndex].imageSubresource.aspectMask,
                                              kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCopyImageToImage(VkDevice device, const VkCopyImageToImageInfo* pCopyImageToImageInfo,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pCopyImageToImageInfo), pCopyImageToImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO, true,
        "VUID-vkCopyImageToImage-pCopyImageToImageInfo-parameter", "VUID-VkCopyImageToImageInfo-sType-sType");
    if (pCopyImageToImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageToImageInfo_loc = loc.dot(Field::pCopyImageToImageInfo);
        skip |= context.ValidateStructPnext(pCopyImageToImageInfo_loc, pCopyImageToImageInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkCopyImageToImageInfo-pNext-pNext", kVUIDUndefined,
                                            true);

        skip |= context.ValidateFlags(pCopyImageToImageInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkHostImageCopyFlagBits,
                                      AllVkHostImageCopyFlagBits, pCopyImageToImageInfo->flags, kOptionalFlags,
                                      "VUID-VkCopyImageToImageInfo-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCopyImageToImageInfo_loc.dot(Field::srcImage), pCopyImageToImageInfo->srcImage);

        skip |= context.ValidateRangedEnum(pCopyImageToImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyImageToImageInfo->srcImageLayout,
                                           "VUID-VkCopyImageToImageInfo-srcImageLayout-parameter");

        skip |= context.ValidateRequiredHandle(pCopyImageToImageInfo_loc.dot(Field::dstImage), pCopyImageToImageInfo->dstImage);

        skip |= context.ValidateRangedEnum(pCopyImageToImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                           pCopyImageToImageInfo->dstImageLayout,
                                           "VUID-VkCopyImageToImageInfo-dstImageLayout-parameter");

        skip |= context.ValidateStructTypeArray(pCopyImageToImageInfo_loc.dot(Field::regionCount),
                                                pCopyImageToImageInfo_loc.dot(Field::pRegions), pCopyImageToImageInfo->regionCount,
                                                pCopyImageToImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true, true,
                                                "VUID-VkImageCopy2-sType-sType", "VUID-VkCopyImageToImageInfo-pRegions-parameter",
                                                "VUID-VkCopyImageToImageInfo-regionCount-arraylength");

        if (pCopyImageToImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageToImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= context.ValidateStructPnext(pRegions_loc, pCopyImageToImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined,
                                                    true);

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pCopyImageToImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                              kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= context.ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              pCopyImageToImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                              kRequiredFlags, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                              "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateTransitionImageLayout(VkDevice device, uint32_t transitionCount,
                                                  const VkHostImageLayoutTransitionInfo* pTransitions,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::transitionCount), loc.dot(Field::pTransitions), transitionCount, pTransitions,
        VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO, true, true, "VUID-VkHostImageLayoutTransitionInfo-sType-sType",
        "VUID-vkTransitionImageLayout-pTransitions-parameter", "VUID-vkTransitionImageLayout-transitionCount-arraylength");
    if (pTransitions != nullptr) {
        for (uint32_t transitionIndex = 0; transitionIndex < transitionCount; ++transitionIndex) {
            [[maybe_unused]] const Location pTransitions_loc = loc.dot(Field::pTransitions, transitionIndex);
            skip |= context.ValidateStructPnext(pTransitions_loc, pTransitions[transitionIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkHostImageLayoutTransitionInfo-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRequiredHandle(pTransitions_loc.dot(Field::image), pTransitions[transitionIndex].image);

            skip |= context.ValidateRangedEnum(pTransitions_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                               pTransitions[transitionIndex].oldLayout,
                                               "VUID-VkHostImageLayoutTransitionInfo-oldLayout-parameter");

            skip |= context.ValidateRangedEnum(pTransitions_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                               pTransitions[transitionIndex].newLayout,
                                               "VUID-VkHostImageLayoutTransitionInfo-newLayout-parameter");

            skip |= context.ValidateFlags(pTransitions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pTransitions[transitionIndex].subresourceRange.aspectMask,
                                          kRequiredFlags, "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                          "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool Instance::PreCallValidateDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex,
                                                                 VkSurfaceKHR surface, VkBool32* pSupported,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSupported), pSupported,
                                            "VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                      VkSurfaceCapabilitiesKHR* pSurfaceCapabilities,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurfaceCapabilities), pSurfaceCapabilities,
                                            "VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                 uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= context.ValidatePointerArray(loc.dot(Field::pSurfaceFormatCount), loc.dot(Field::pSurfaceFormats), pSurfaceFormatCount,
                                         &pSurfaceFormats, true, false, false,
                                         "VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormatCount-parameter", kVUIDUndefined,
                                         "VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter");
    if (pSurfaceFormats != nullptr) {
        for (uint32_t pSurfaceFormatIndex = 0; pSurfaceFormatIndex < *pSurfaceFormatCount; ++pSurfaceFormatIndex) {
            [[maybe_unused]] const Location pSurfaceFormats_loc = loc.dot(Field::pSurfaceFormats, pSurfaceFormatIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount,
                                                                         pSurfaceFormats, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                      uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= context.ValidatePointerArray(loc.dot(Field::pPresentModeCount), loc.dot(Field::pPresentModes), pPresentModeCount,
                                         &pPresentModes, true, false, false,
                                         "VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModeCount-parameter",
                                         kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount,
                                                                              pPresentModes, context);
    return skip;
}

bool Device::PreCallValidateCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo,
                                               const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true,
                                   "VUID-vkCreateSwapchainKHR-pCreateInfo-parameter", "VUID-VkSwapchainCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSwapchainCreateInfoKHR = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSwapchainCreateInfoKHR.size(),
                                            allowed_structs_VkSwapchainCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkSwapchainCreateInfoKHR-pNext-pNext",
                                            "VUID-VkSwapchainCreateInfoKHR-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSwapchainCreateFlagBitsKHR,
                                      AllVkSwapchainCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkSwapchainCreateInfoKHR-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::surface), pCreateInfo->surface);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageFormat), vvl::Enum::VkFormat, pCreateInfo->imageFormat,
                                           "VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageColorSpace), vvl::Enum::VkColorSpaceKHR,
                                           pCreateInfo->imageColorSpace, "VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter");

        // No xml-driven validation

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::imageUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, pCreateInfo->imageUsage, kRequiredFlags,
                                      "VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter",
                                      "VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask");

        skip |=
            context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageSharingMode), vvl::Enum::VkSharingMode,
                                       pCreateInfo->imageSharingMode, "VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::preTransform), vvl::FlagBitmask::VkSurfaceTransformFlagBitsKHR,
                                      AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->preTransform, kRequiredSingleBit,
                                      "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter",
                                      "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::compositeAlpha), vvl::FlagBitmask::VkCompositeAlphaFlagBitsKHR,
                                      AllVkCompositeAlphaFlagBitsKHR, pCreateInfo->compositeAlpha, kRequiredSingleBit,
                                      "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter",
                                      "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::presentMode), vvl::Enum::VkPresentModeKHR,
                                           pCreateInfo->presentMode, "VUID-VkSwapchainCreateInfoKHR-presentMode-parameter");

        skip |= context.ValidateBool32(pCreateInfo_loc.dot(Field::clipped), pCreateInfo->clipped);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pSwapchain), pSwapchain, "VUID-vkCreateSwapchainKHR-pSwapchain-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain, context);
    return skip;
}

bool Device::PreCallValidateDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount,
                                                  VkImage* pSwapchainImages, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidatePointerArray(loc.dot(Field::pSwapchainImageCount), loc.dot(Field::pSwapchainImages),
                                         pSwapchainImageCount, &pSwapchainImages, true, false, false,
                                         "VUID-vkGetSwapchainImagesKHR-pSwapchainImageCount-parameter", kVUIDUndefined,
                                         "VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter");
    return skip;
}

bool Device::PreCallValidateAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
                                                VkFence fence, uint32_t* pImageIndex, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pImageIndex), pImageIndex,
                                            "VUID-vkAcquireNextImageKHR-pImageIndex-parameter");
    if (!skip)
        skip |= manual_PreCallValidateAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex, context);
    return skip;
}

bool Device::PreCallValidateQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR* pPresentInfo,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= context.ValidateStructType(loc.dot(Field::pPresentInfo), pPresentInfo, VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, true,
                                       "VUID-vkQueuePresentKHR-pPresentInfo-parameter", "VUID-VkPresentInfoKHR-sType-sType");
    if (pPresentInfo != nullptr) {
        [[maybe_unused]] const Location pPresentInfo_loc = loc.dot(Field::pPresentInfo);
        constexpr std::array allowed_structs_VkPresentInfoKHR = {VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                                                                 VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
                                                                 VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
                                                                 VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
                                                                 VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
                                                                 VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV,
                                                                 VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT,
                                                                 VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT};

        skip |= context.ValidateStructPnext(pPresentInfo_loc, pPresentInfo->pNext, allowed_structs_VkPresentInfoKHR.size(),
                                            allowed_structs_VkPresentInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkPresentInfoKHR-pNext-pNext", "VUID-VkPresentInfoKHR-sType-unique", true);

        skip |= context.ValidateArray(pPresentInfo_loc.dot(Field::waitSemaphoreCount), pPresentInfo_loc.dot(Field::pWaitSemaphores),
                                      pPresentInfo->waitSemaphoreCount, &pPresentInfo->pWaitSemaphores, false, true, kVUIDUndefined,
                                      "VUID-VkPresentInfoKHR-pWaitSemaphores-parameter");

        skip |= context.ValidateHandleArray(pPresentInfo_loc.dot(Field::swapchainCount), pPresentInfo_loc.dot(Field::pSwapchains),
                                            pPresentInfo->swapchainCount, pPresentInfo->pSwapchains, true, true,
                                            "VUID-VkPresentInfoKHR-swapchainCount-arraylength");

        skip |= context.ValidateArray(pPresentInfo_loc.dot(Field::swapchainCount), pPresentInfo_loc.dot(Field::pImageIndices),
                                      pPresentInfo->swapchainCount, &pPresentInfo->pImageIndices, true, true,
                                      "VUID-VkPresentInfoKHR-swapchainCount-arraylength",
                                      "VUID-VkPresentInfoKHR-pImageIndices-parameter");

        skip |=
            context.ValidateArray(pPresentInfo_loc.dot(Field::swapchainCount), pPresentInfo_loc.dot(Field::pResults),
                                  pPresentInfo->swapchainCount, &pPresentInfo->pResults, true, false,
                                  "VUID-VkPresentInfoKHR-swapchainCount-arraylength", "VUID-VkPresentInfoKHR-pResults-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateQueuePresentKHR(queue, pPresentInfo, context);
    return skip;
}

bool Device::PreCallValidateGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_khr_swapchain) || IsExtEnabled(extensions.vk_khr_device_group)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});
    skip |= context.ValidateStructType(loc.dot(Field::pDeviceGroupPresentCapabilities), pDeviceGroupPresentCapabilities,
                                       VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR, true,
                                       "VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter",
                                       "VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType");
    if (pDeviceGroupPresentCapabilities != nullptr) {
        [[maybe_unused]] const Location pDeviceGroupPresentCapabilities_loc = loc.dot(Field::pDeviceGroupPresentCapabilities);
        skip |= context.ValidateStructPnext(pDeviceGroupPresentCapabilities_loc, pDeviceGroupPresentCapabilities->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface,
                                                                 VkDeviceGroupPresentModeFlagsKHR* pModes,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_khr_swapchain) || IsExtEnabled(extensions.vk_khr_device_group)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pModes), pModes,
                                            "VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                    uint32_t* pRectCount, VkRect2D* pRects,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= context.ValidatePointerArray(loc.dot(Field::pRectCount), loc.dot(Field::pRects), pRectCount, &pRects, true, false,
                                         false, "VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRectCount-parameter", kVUIDUndefined,
                                         "VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter");
    return skip;
}

bool Device::PreCallValidateAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo,
                                                 uint32_t* pImageIndex, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_khr_swapchain) || IsExtEnabled(extensions.vk_khr_device_group)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});
    skip |= context.ValidateStructType(loc.dot(Field::pAcquireInfo), pAcquireInfo, VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
                                       true, "VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter",
                                       "VUID-VkAcquireNextImageInfoKHR-sType-sType");
    if (pAcquireInfo != nullptr) {
        [[maybe_unused]] const Location pAcquireInfo_loc = loc.dot(Field::pAcquireInfo);
        skip |= context.ValidateStructPnext(pAcquireInfo_loc, pAcquireInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAcquireNextImageInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pAcquireInfo_loc.dot(Field::swapchain), pAcquireInfo->swapchain);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pImageIndex), pImageIndex,
                                            "VUID-vkAcquireNextImage2KHR-pImageIndex-parameter");
    if (!skip) skip |= manual_PreCallValidateAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount,
                                                                    VkDisplayPropertiesKHR* pProperties,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |=
        context.ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties,
                                     true, false, false, "VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pPropertyCount-parameter",
                                     kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount,
                                                                         VkDisplayPlanePropertiesKHR* pProperties,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= context.ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties,
                                         true, false, false,
                                         "VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pPropertyCount-parameter",
                                         kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex,
                                                                  uint32_t* pDisplayCount, VkDisplayKHR* pDisplays,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= context.ValidatePointerArray(loc.dot(Field::pDisplayCount), loc.dot(Field::pDisplays), pDisplayCount, &pDisplays, true,
                                         false, false, "VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplayCount-parameter",
                                         kVUIDUndefined, "VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter");
    return skip;
}

bool Instance::PreCallValidateGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                          uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= context.ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties,
                                         true, false, false, "VUID-vkGetDisplayModePropertiesKHR-pPropertyCount-parameter",
                                         kVUIDUndefined, "VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Instance::PreCallValidateCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                   const VkDisplayModeCreateInfoKHR* pCreateInfo,
                                                   const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter",
                                       "VUID-VkDisplayModeCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDisplayModeCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask");

        // No xml-driven validation
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMode), pMode, "VUID-vkCreateDisplayModeKHR-pMode-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode, context);
    return skip;
}

bool Instance::PreCallValidateGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode,
                                                             uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::mode), mode);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCapabilities), pCapabilities,
                                            "VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter");
    return skip;
}

bool Instance::PreCallValidateCreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter",
                                       "VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDisplaySurfaceCreateInfoKHR = {
            VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDisplaySurfaceCreateInfoKHR.size(),
            allowed_structs_VkDisplaySurfaceCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext", "VUID-VkDisplaySurfaceCreateInfoKHR-sType-unique", true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::displayMode), pCreateInfo->displayMode);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::transform), vvl::FlagBitmask::VkSurfaceTransformFlagBitsKHR,
                                      AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->transform, kRequiredSingleBit,
                                      "VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter",
                                      "VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::alphaMode), vvl::FlagBitmask::VkDisplayPlaneAlphaFlagBitsKHR,
                                      AllVkDisplayPlaneAlphaFlagBitsKHR, pCreateInfo->alphaMode, kRequiredSingleBit,
                                      "VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter",
                                      "VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter");

        // No xml-driven validation
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface,
                                            "VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter");
    return skip;
}

bool Device::PreCallValidateCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount,
                                                      const VkSwapchainCreateInfoKHR* pCreateInfos,
                                                      const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_display_swapchain))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display_swapchain});
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::swapchainCount), loc.dot(Field::pCreateInfos), swapchainCount, pCreateInfos,
        VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true, true, "VUID-VkSwapchainCreateInfoKHR-sType-sType",
        "VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter", "VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, swapchainIndex);
            constexpr std::array allowed_structs_VkSwapchainCreateInfoKHR = {
                VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
                VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
                VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[swapchainIndex].pNext, allowed_structs_VkSwapchainCreateInfoKHR.size(),
                allowed_structs_VkSwapchainCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkSwapchainCreateInfoKHR-pNext-pNext", "VUID-VkSwapchainCreateInfoKHR-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkSwapchainCreateFlagBitsKHR,
                                          AllVkSwapchainCreateFlagBitsKHR, pCreateInfos[swapchainIndex].flags, kOptionalFlags,
                                          "VUID-VkSwapchainCreateInfoKHR-flags-parameter");

            skip |= context.ValidateRequiredHandle(pCreateInfos_loc.dot(Field::surface), pCreateInfos[swapchainIndex].surface);

            skip |= context.ValidateRangedEnum(pCreateInfos_loc.dot(Field::imageFormat), vvl::Enum::VkFormat,
                                               pCreateInfos[swapchainIndex].imageFormat,
                                               "VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfos_loc.dot(Field::imageColorSpace), vvl::Enum::VkColorSpaceKHR,
                                               pCreateInfos[swapchainIndex].imageColorSpace,
                                               "VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter");

            // No xml-driven validation

            skip |= context.ValidateFlags(pCreateInfos_loc.dot(Field::imageUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                          AllVkImageUsageFlagBits, pCreateInfos[swapchainIndex].imageUsage, kRequiredFlags,
                                          "VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter",
                                          "VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask");

            skip |= context.ValidateRangedEnum(pCreateInfos_loc.dot(Field::imageSharingMode), vvl::Enum::VkSharingMode,
                                               pCreateInfos[swapchainIndex].imageSharingMode,
                                               "VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter");

            skip |= context.ValidateFlags(
                pCreateInfos_loc.dot(Field::preTransform), vvl::FlagBitmask::VkSurfaceTransformFlagBitsKHR,
                AllVkSurfaceTransformFlagBitsKHR, pCreateInfos[swapchainIndex].preTransform, kRequiredSingleBit,
                "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter", "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter");

            skip |= context.ValidateFlags(
                pCreateInfos_loc.dot(Field::compositeAlpha), vvl::FlagBitmask::VkCompositeAlphaFlagBitsKHR,
                AllVkCompositeAlphaFlagBitsKHR, pCreateInfos[swapchainIndex].compositeAlpha, kRequiredSingleBit,
                "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter", "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter");

            skip |= context.ValidateRangedEnum(pCreateInfos_loc.dot(Field::presentMode), vvl::Enum::VkPresentModeKHR,
                                               pCreateInfos[swapchainIndex].presentMode,
                                               "VUID-VkSwapchainCreateInfoKHR-presentMode-parameter");

            skip |= context.ValidateBool32(pCreateInfos_loc.dot(Field::clipped), pCreateInfos[swapchainIndex].clipped);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateArray(loc.dot(Field::swapchainCount), loc.dot(Field::pSwapchains), swapchainCount, &pSwapchains, true,
                                  true, "VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength",
                                  "VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains, context);
    return skip;
}

#ifdef VK_USE_PLATFORM_XLIB_KHR
bool Instance::PreCallValidateCreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
                                                   const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_xlib_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xlib_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter",
                                       "VUID-VkXlibSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateXlibSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                          uint32_t queueFamilyIndex, Display* dpy,
                                                                          VisualID visualID, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_xlib_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xlib_surface});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::dpy), dpy,
                                            "VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
bool Instance::PreCallValidateCreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
                                                  const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_xcb_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xcb_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter",
                                       "VUID-VkXcbSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateXcbSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex,
                                                                         xcb_connection_t* connection, xcb_visualid_t visual_id,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_xcb_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xcb_surface});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::connection), connection,
                                            "VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
bool Instance::PreCallValidateCreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_wayland_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_wayland_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter",
                                       "VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                             uint32_t queueFamilyIndex, struct wl_display* display,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_wayland_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_wayland_surface});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::display), display,
                                            "VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool Instance::PreCallValidateCreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_android_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_android_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter",
                                       "VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, context);
    return skip;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Instance::PreCallValidateCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
                                                    const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_win32_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_win32_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter",
                                       "VUID-VkWin32SurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateWin32SurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                           uint32_t queueFamilyIndex,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_win32_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_win32_surface});
    // No xml-driven validation
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool Instance::PreCallValidateGetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice,
                                                                    const VkVideoProfileInfoKHR* pVideoProfile,
                                                                    VkVideoCapabilitiesKHR* pCapabilities,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pVideoProfile), pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true,
                                       "VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-parameter",
                                       "VUID-VkVideoProfileInfoKHR-sType-sType");
    if (pVideoProfile != nullptr) {
        [[maybe_unused]] const Location pVideoProfile_loc = loc.dot(Field::pVideoProfile);
        skip |= context.ValidateFlags(
            pVideoProfile_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
            AllVkVideoCodecOperationFlagBitsKHR, pVideoProfile->videoCodecOperation, kRequiredSingleBit,
            "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

        skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::chromaSubsampling),
                                      vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR, AllVkVideoChromaSubsamplingFlagBitsKHR,
                                      pVideoProfile->chromaSubsampling, kRequiredFlags,
                                      "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                                      "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

        skip |= context.ValidateFlags(
            pVideoProfile_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
            AllVkVideoComponentBitDepthFlagBitsKHR, pVideoProfile->lumaBitDepth, kRequiredFlags,
            "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

        skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::chromaBitDepth),
                                      vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR, AllVkVideoComponentBitDepthFlagBitsKHR,
                                      pVideoProfile->chromaBitDepth, kOptionalFlags,
                                      "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pCapabilities), pCapabilities, VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR, true,
                                       "VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pCapabilities-parameter",
                                       "VUID-VkVideoCapabilitiesKHR-sType-sType");
    if (pCapabilities != nullptr) {
        [[maybe_unused]] const Location pCapabilities_loc = loc.dot(Field::pCapabilities);
        constexpr std::array allowed_structs_VkVideoCapabilitiesKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR};

        skip |= context.ValidateStructPnext(pCapabilities_loc, pCapabilities->pNext, allowed_structs_VkVideoCapabilitiesKHR.size(),
                                            allowed_structs_VkVideoCapabilitiesKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoCapabilitiesKHR-pNext-pNext", "VUID-VkVideoCapabilitiesKHR-sType-unique",
                                            false);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice,
                                                                        const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo,
                                                                        uint32_t* pVideoFormatPropertyCount,
                                                                        VkVideoFormatPropertiesKHR* pVideoFormatProperties,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pVideoFormatInfo), pVideoFormatInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR, true,
                                       "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatInfo-parameter",
                                       "VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-sType");
    if (pVideoFormatInfo != nullptr) {
        [[maybe_unused]] const Location pVideoFormatInfo_loc = loc.dot(Field::pVideoFormatInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR = {VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= context.ValidateStructPnext(
            pVideoFormatInfo_loc, pVideoFormatInfo->pNext, allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR.size(),
            allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceVideoFormatInfoKHR-pNext-pNext", "VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-unique", true);

        skip |= context.ValidateFlags(pVideoFormatInfo_loc.dot(Field::imageUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, pVideoFormatInfo->imageUsage, kRequiredFlags,
                                      "VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-parameter",
                                      "VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-requiredbitmask");
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pVideoFormatPropertyCount), loc.dot(Field::pVideoFormatProperties), pVideoFormatPropertyCount,
        pVideoFormatProperties, VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR, true, false, false,
        "VUID-VkVideoFormatPropertiesKHR-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatPropertyCount-parameter", kVUIDUndefined);
    if (pVideoFormatProperties != nullptr) {
        for (uint32_t pVideoFormatPropertyIndex = 0; pVideoFormatPropertyIndex < *pVideoFormatPropertyCount;
             ++pVideoFormatPropertyIndex) {
            [[maybe_unused]] const Location pVideoFormatProperties_loc =
                loc.dot(Field::pVideoFormatProperties, pVideoFormatPropertyIndex);
            constexpr std::array allowed_structs_VkVideoFormatPropertiesKHR = {
                VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR,
                VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR,
                VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR};

            skip |= context.ValidateStructPnext(pVideoFormatProperties_loc, pVideoFormatProperties[pVideoFormatPropertyIndex].pNext,
                                                allowed_structs_VkVideoFormatPropertiesKHR.size(),
                                                allowed_structs_VkVideoFormatPropertiesKHR.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkVideoFormatPropertiesKHR-pNext-pNext",
                                                "VUID-VkVideoFormatPropertiesKHR-sType-unique", false);
        }
    }
    return skip;
}

bool Device::PreCallValidateCreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo,
                                                  const VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
                                       true, "VUID-vkCreateVideoSessionKHR-pCreateInfo-parameter",
                                       "VUID-VkVideoSessionCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkVideoSessionCreateInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkVideoSessionCreateInfoKHR.size(),
                                            allowed_structs_VkVideoSessionCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoSessionCreateInfoKHR-pNext-pNext",
                                            "VUID-VkVideoSessionCreateInfoKHR-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoSessionCreateFlagBitsKHR,
                                      AllVkVideoSessionCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkVideoSessionCreateInfoKHR-flags-parameter");

        skip |= context.ValidateStructType(
            pCreateInfo_loc.dot(Field::pVideoProfile), pCreateInfo->pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true,
            "VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-parameter", "VUID-VkVideoProfileInfoKHR-sType-sType");

        if (pCreateInfo->pVideoProfile != nullptr) {
            [[maybe_unused]] const Location pVideoProfile_loc = pCreateInfo_loc.dot(Field::pVideoProfile);
            skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::videoCodecOperation),
                                          vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR, AllVkVideoCodecOperationFlagBitsKHR,
                                          pCreateInfo->pVideoProfile->videoCodecOperation, kRequiredSingleBit,
                                          "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                                          "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

            skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::chromaSubsampling),
                                          vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                                          AllVkVideoChromaSubsamplingFlagBitsKHR, pCreateInfo->pVideoProfile->chromaSubsampling,
                                          kRequiredFlags, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                                          "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

            skip |= context.ValidateFlags(
                pVideoProfile_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                AllVkVideoComponentBitDepthFlagBitsKHR, pCreateInfo->pVideoProfile->lumaBitDepth, kRequiredFlags,
                "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

            skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::chromaBitDepth),
                                          vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                          AllVkVideoComponentBitDepthFlagBitsKHR, pCreateInfo->pVideoProfile->chromaBitDepth,
                                          kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
        }

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::pictureFormat), vvl::Enum::VkFormat,
                                           pCreateInfo->pictureFormat, "VUID-VkVideoSessionCreateInfoKHR-pictureFormat-parameter");

        // No xml-driven validation

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::referencePictureFormat), vvl::Enum::VkFormat,
                                           pCreateInfo->referencePictureFormat,
                                           "VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-parameter");

        skip |= context.ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pStdHeaderVersion), pCreateInfo->pStdHeaderVersion,
                                                "VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pVideoSession), pVideoSession,
                                            "VUID-vkCreateVideoSessionKHR-pVideoSession-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                                   const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                                                 uint32_t* pMemoryRequirementsCount,
                                                                 VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::videoSession), videoSession);
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pMemoryRequirementsCount), loc.dot(Field::pMemoryRequirements), pMemoryRequirementsCount,
        pMemoryRequirements, VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR, true, false, false,
        "VUID-VkVideoSessionMemoryRequirementsKHR-sType-sType", kVUIDUndefined,
        "VUID-vkGetVideoSessionMemoryRequirementsKHR-pMemoryRequirementsCount-parameter", kVUIDUndefined);
    if (pMemoryRequirements != nullptr) {
        for (uint32_t pMemoryRequirementsIndex = 0; pMemoryRequirementsIndex < *pMemoryRequirementsCount;
             ++pMemoryRequirementsIndex) {
            [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements, pMemoryRequirementsIndex);
            skip |= context.ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements[pMemoryRequirementsIndex].pNext, 0,
                                                nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkVideoSessionMemoryRequirementsKHR-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateBindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                                      uint32_t bindSessionMemoryInfoCount,
                                                      const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::videoSession), videoSession);
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::bindSessionMemoryInfoCount), loc.dot(Field::pBindSessionMemoryInfos), bindSessionMemoryInfoCount,
        pBindSessionMemoryInfos, VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR, true, true,
        "VUID-VkBindVideoSessionMemoryInfoKHR-sType-sType", "VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-parameter",
        "VUID-vkBindVideoSessionMemoryKHR-bindSessionMemoryInfoCount-arraylength");
    if (pBindSessionMemoryInfos != nullptr) {
        for (uint32_t bindSessionMemoryInfoIndex = 0; bindSessionMemoryInfoIndex < bindSessionMemoryInfoCount;
             ++bindSessionMemoryInfoIndex) {
            [[maybe_unused]] const Location pBindSessionMemoryInfos_loc =
                loc.dot(Field::pBindSessionMemoryInfos, bindSessionMemoryInfoIndex);
            skip |= context.ValidateStructPnext(
                pBindSessionMemoryInfos_loc, pBindSessionMemoryInfos[bindSessionMemoryInfoIndex].pNext, 0, nullptr,
                GeneratedVulkanHeaderVersion, "VUID-VkBindVideoSessionMemoryInfoKHR-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRequiredHandle(pBindSessionMemoryInfos_loc.dot(Field::memory),
                                                   pBindSessionMemoryInfos[bindSessionMemoryInfoIndex].memory);
        }
    }
    return skip;
}

bool Device::PreCallValidateCreateVideoSessionParametersKHR(VkDevice device,
                                                            const VkVideoSessionParametersCreateInfoKHR* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            VkVideoSessionParametersKHR* pVideoSessionParameters,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR, true,
        "VUID-vkCreateVideoSessionParametersKHR-pCreateInfo-parameter", "VUID-VkVideoSessionParametersCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkVideoSessionParametersCreateInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext,
                                            allowed_structs_VkVideoSessionParametersCreateInfoKHR.size(),
                                            allowed_structs_VkVideoSessionParametersCreateInfoKHR.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionParametersCreateInfoKHR-pNext-pNext",
                                            "VUID-VkVideoSessionParametersCreateInfoKHR-sType-unique", true);

        skip |=
            context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoSessionParametersCreateFlagBitsKHR,
                                  AllVkVideoSessionParametersCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags,
                                  "VUID-VkVideoSessionParametersCreateInfoKHR-flags-parameter");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::videoSession), pCreateInfo->videoSession);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pVideoSessionParameters), pVideoSessionParameters,
                                            "VUID-vkCreateVideoSessionParametersKHR-pVideoSessionParameters-parameter");
    return skip;
}

bool Device::PreCallValidateUpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters,
                                                            const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::videoSessionParameters), videoSessionParameters);
    skip |= context.ValidateStructType(
        loc.dot(Field::pUpdateInfo), pUpdateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR, true,
        "VUID-vkUpdateVideoSessionParametersKHR-pUpdateInfo-parameter", "VUID-VkVideoSessionParametersUpdateInfoKHR-sType-sType");
    if (pUpdateInfo != nullptr) {
        [[maybe_unused]] const Location pUpdateInfo_loc = loc.dot(Field::pUpdateInfo);
        constexpr std::array allowed_structs_VkVideoSessionParametersUpdateInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR};

        skip |= context.ValidateStructPnext(pUpdateInfo_loc, pUpdateInfo->pNext,
                                            allowed_structs_VkVideoSessionParametersUpdateInfoKHR.size(),
                                            allowed_structs_VkVideoSessionParametersUpdateInfoKHR.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionParametersUpdateInfoKHR-pNext-pNext",
                                            "VUID-VkVideoSessionParametersUpdateInfoKHR-sType-unique", true);
    }
    return skip;
}

bool Device::PreCallValidateDestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR* pBeginInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateStructType(loc.dot(Field::pBeginInfo), pBeginInfo, VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR, true,
                                       "VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-parameter",
                                       "VUID-VkVideoBeginCodingInfoKHR-sType-sType");
    if (pBeginInfo != nullptr) {
        [[maybe_unused]] const Location pBeginInfo_loc = loc.dot(Field::pBeginInfo);
        constexpr std::array allowed_structs_VkVideoBeginCodingInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR};

        skip |= context.ValidateStructPnext(pBeginInfo_loc, pBeginInfo->pNext, allowed_structs_VkVideoBeginCodingInfoKHR.size(),
                                            allowed_structs_VkVideoBeginCodingInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoBeginCodingInfoKHR-pNext-pNext",
                                            "VUID-VkVideoBeginCodingInfoKHR-sType-unique", true);

        skip |= context.ValidateReservedFlags(pBeginInfo_loc.dot(Field::flags), pBeginInfo->flags,
                                              "VUID-VkVideoBeginCodingInfoKHR-flags-zerobitmask");

        skip |= context.ValidateRequiredHandle(pBeginInfo_loc.dot(Field::videoSession), pBeginInfo->videoSession);

        skip |= context.ValidateStructTypeArray(pBeginInfo_loc.dot(Field::referenceSlotCount),
                                                pBeginInfo_loc.dot(Field::pReferenceSlots), pBeginInfo->referenceSlotCount,
                                                pBeginInfo->pReferenceSlots, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false,
                                                true, "VUID-VkVideoReferenceSlotInfoKHR-sType-sType",
                                                "VUID-VkVideoBeginCodingInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pBeginInfo->pReferenceSlots != nullptr) {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pBeginInfo->referenceSlotCount; ++referenceSlotIndex) {
                [[maybe_unused]] const Location pReferenceSlots_loc =
                    pBeginInfo_loc.dot(Field::pReferenceSlots, referenceSlotIndex);
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

                skip |= context.ValidateStructPnext(pReferenceSlots_loc, pBeginInfo->pReferenceSlots[referenceSlotIndex].pNext,
                                                    allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                                    allowed_structs_VkVideoReferenceSlotInfoKHR.data(),
                                                    GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                                    "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", true);

                skip |= context.ValidateStructType(pReferenceSlots_loc.dot(Field::pPictureResource),
                                                   pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource,
                                                   VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                                                   "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter",
                                                   "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr) {
                    [[maybe_unused]] const Location pPictureResource_loc = pReferenceSlots_loc.dot(Field::pPictureResource);
                    skip |= context.ValidateStructPnext(
                        pPictureResource_loc, pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |= context.ValidateRequiredHandle(
                        pPictureResource_loc.dot(Field::imageViewBinding),
                        pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR* pEndCodingInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateStructType(loc.dot(Field::pEndCodingInfo), pEndCodingInfo, VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR,
                                       true, "VUID-vkCmdEndVideoCodingKHR-pEndCodingInfo-parameter",
                                       "VUID-VkVideoEndCodingInfoKHR-sType-sType");
    if (pEndCodingInfo != nullptr) {
        [[maybe_unused]] const Location pEndCodingInfo_loc = loc.dot(Field::pEndCodingInfo);
        skip |= context.ValidateStructPnext(pEndCodingInfo_loc, pEndCodingInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoEndCodingInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pEndCodingInfo_loc.dot(Field::flags), pEndCodingInfo->flags,
                                              "VUID-VkVideoEndCodingInfoKHR-flags-zerobitmask");
    }
    return skip;
}

bool Device::PreCallValidateCmdControlVideoCodingKHR(VkCommandBuffer commandBuffer,
                                                     const VkVideoCodingControlInfoKHR* pCodingControlInfo,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_queue)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCodingControlInfo), pCodingControlInfo, VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR, true,
        "VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-parameter", "VUID-VkVideoCodingControlInfoKHR-sType-sType");
    if (pCodingControlInfo != nullptr) {
        [[maybe_unused]] const Location pCodingControlInfo_loc = loc.dot(Field::pCodingControlInfo);
        constexpr std::array allowed_structs_VkVideoCodingControlInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR};

        skip |= context.ValidateStructPnext(
            pCodingControlInfo_loc, pCodingControlInfo->pNext, allowed_structs_VkVideoCodingControlInfoKHR.size(),
            allowed_structs_VkVideoCodingControlInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkVideoCodingControlInfoKHR-pNext-pNext", "VUID-VkVideoCodingControlInfoKHR-sType-unique", true);

        skip |= context.ValidateFlags(pCodingControlInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoCodingControlFlagBitsKHR,
                                      AllVkVideoCodingControlFlagBitsKHR, pCodingControlInfo->flags, kRequiredFlags,
                                      "VUID-VkVideoCodingControlInfoKHR-flags-parameter",
                                      "VUID-VkVideoCodingControlInfoKHR-flags-requiredbitmask");
    }
    return skip;
}

bool Device::PreCallValidateCmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_decode_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_decode_queue});
    skip |= context.ValidateStructType(loc.dot(Field::pDecodeInfo), pDecodeInfo, VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR, true,
                                       "VUID-vkCmdDecodeVideoKHR-pDecodeInfo-parameter", "VUID-VkVideoDecodeInfoKHR-sType-sType");
    if (pDecodeInfo != nullptr) {
        [[maybe_unused]] const Location pDecodeInfo_loc = loc.dot(Field::pDecodeInfo);
        constexpr std::array allowed_structs_VkVideoDecodeInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR};

        skip |=
            context.ValidateStructPnext(pDecodeInfo_loc, pDecodeInfo->pNext, allowed_structs_VkVideoDecodeInfoKHR.size(),
                                        allowed_structs_VkVideoDecodeInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkVideoDecodeInfoKHR-pNext-pNext", "VUID-VkVideoDecodeInfoKHR-sType-unique", true);

        skip |= context.ValidateReservedFlags(pDecodeInfo_loc.dot(Field::flags), pDecodeInfo->flags,
                                              "VUID-VkVideoDecodeInfoKHR-flags-zerobitmask");

        skip |= context.ValidateRequiredHandle(pDecodeInfo_loc.dot(Field::srcBuffer), pDecodeInfo->srcBuffer);

        skip |= context.ValidateStructType(pDecodeInfo_loc.dot(Field::dstPictureResource), &(pDecodeInfo->dstPictureResource),
                                           VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, kVUIDUndefined,
                                           "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

        skip |= context.ValidateStructPnext(pDecodeInfo_loc, pDecodeInfo->dstPictureResource.pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        // No xml-driven validation

        // No xml-driven validation

        skip |= context.ValidateRequiredHandle(pDecodeInfo_loc.dot(Field::imageViewBinding),
                                               pDecodeInfo->dstPictureResource.imageViewBinding);

        skip |= context.ValidateStructType(pDecodeInfo_loc.dot(Field::pSetupReferenceSlot), pDecodeInfo->pSetupReferenceSlot,
                                           VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false,
                                           "VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-parameter",
                                           "VUID-VkVideoReferenceSlotInfoKHR-sType-sType");

        if (pDecodeInfo->pSetupReferenceSlot != nullptr) {
            [[maybe_unused]] const Location pSetupReferenceSlot_loc = pDecodeInfo_loc.dot(Field::pSetupReferenceSlot);
            constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

            skip |= context.ValidateStructPnext(pSetupReferenceSlot_loc, pDecodeInfo->pSetupReferenceSlot->pNext,
                                                allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                                allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                                "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", true);

            skip |= context.ValidateStructType(
                pSetupReferenceSlot_loc.dot(Field::pPictureResource), pDecodeInfo->pSetupReferenceSlot->pPictureResource,
                VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

            if (pDecodeInfo->pSetupReferenceSlot->pPictureResource != nullptr) {
                [[maybe_unused]] const Location pPictureResource_loc = pSetupReferenceSlot_loc.dot(Field::pPictureResource);
                skip |= context.ValidateStructPnext(pPictureResource_loc, pDecodeInfo->pSetupReferenceSlot->pPictureResource->pNext,
                                                    0, nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, true);

                // No xml-driven validation

                // No xml-driven validation

                skip |= context.ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                                       pDecodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding);
            }
        }

        skip |= context.ValidateStructTypeArray(pDecodeInfo_loc.dot(Field::referenceSlotCount),
                                                pDecodeInfo_loc.dot(Field::pReferenceSlots), pDecodeInfo->referenceSlotCount,
                                                pDecodeInfo->pReferenceSlots, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
                                                false, true, "VUID-VkVideoReferenceSlotInfoKHR-sType-sType",
                                                "VUID-VkVideoDecodeInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pDecodeInfo->pReferenceSlots != nullptr) {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pDecodeInfo->referenceSlotCount; ++referenceSlotIndex) {
                [[maybe_unused]] const Location pReferenceSlots_loc =
                    pDecodeInfo_loc.dot(Field::pReferenceSlots, referenceSlotIndex);
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

                skip |= context.ValidateStructPnext(pReferenceSlots_loc, pDecodeInfo->pReferenceSlots[referenceSlotIndex].pNext,
                                                    allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                                    allowed_structs_VkVideoReferenceSlotInfoKHR.data(),
                                                    GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                                    "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", true);

                skip |= context.ValidateStructType(pReferenceSlots_loc.dot(Field::pPictureResource),
                                                   pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource,
                                                   VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                                                   "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter",
                                                   "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr) {
                    [[maybe_unused]] const Location pPictureResource_loc = pReferenceSlots_loc.dot(Field::pPictureResource);
                    skip |= context.ValidateStructPnext(
                        pPictureResource_loc, pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |= context.ValidateRequiredHandle(
                        pPictureResource_loc.dot(Field::imageViewBinding),
                        pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering});
    skip |= PreCallValidateCmdBeginRendering(commandBuffer, pRenderingInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdEndRenderingKHR(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering});
    skip |= PreCallValidateCmdEndRendering(commandBuffer, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceFeatures2(physicalDevice, pFeatures, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice,
                                                              VkPhysicalDeviceProperties2* pProperties,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceProperties2(physicalDevice, pProperties, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                    VkFormatProperties2* pFormatProperties,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                         const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
                                                                         VkImageFormatProperties2* pImageFormatProperties,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |=
        PreCallValidateGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                         uint32_t* pQueueFamilyPropertyCount,
                                                                         VkQueueFamilyProperties2* pQueueFamilyProperties,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount,
                                                                   pQueueFamilyProperties, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                    VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties,
                                                                         error_obj);
    return skip;
}

bool Device::PreCallValidateGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex,
                                                                uint32_t remoteDeviceIndex,
                                                                VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_device_group)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group});
    skip |= PreCallValidateGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex,
                                                            pPeerMemoryFeatures, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_device_group)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group});
    skip |= PreCallValidateCmdSetDeviceMask(commandBuffer, deviceMask, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                                               uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
                                               uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_device_group)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group});
    skip |= PreCallValidateCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ,
                                           error_obj);
    return skip;
}

bool Device::PreCallValidateTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance1)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance1});
    skip |= PreCallValidateTrimCommandPool(device, commandPool, flags, error_obj);
    return skip;
}

bool Instance::PreCallValidateEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount,
                                                               VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_device_group_creation))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group_creation});
    skip |= PreCallValidateEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties,
                                                         error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_memory_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_capabilities});
    skip |= PreCallValidateGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties,
                                                                     error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Device::PreCallValidateGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
                                                    HANDLE* pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_memory_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_win32});
    skip |= context.ValidateStructType(
        loc.dot(Field::pGetWin32HandleInfo), pGetWin32HandleInfo, VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR, true,
        "VUID-vkGetMemoryWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkMemoryGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetWin32HandleInfo_loc = loc.dot(Field::pGetWin32HandleInfo);
        skip |= context.ValidateStructPnext(pGetWin32HandleInfo_loc, pGetWin32HandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetWin32HandleInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetWin32HandleInfo_loc.dot(Field::memory), pGetWin32HandleInfo->memory);

        skip |= context.ValidateFlags(
            pGetWin32HandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
            AllVkExternalMemoryHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit,
            "VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter", "VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, context);
    return skip;
}

bool Device::PreCallValidateGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
                                                              HANDLE handle,
                                                              VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_memory_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_win32});
    skip |= context.ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                  AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit,
                                  "VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter",
                                  "VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryWin32HandleProperties), pMemoryWin32HandleProperties,
                                       VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR, true,
                                       "VUID-vkGetMemoryWin32HandlePropertiesKHR-pMemoryWin32HandleProperties-parameter",
                                       "VUID-VkMemoryWin32HandlePropertiesKHR-sType-sType");
    if (pMemoryWin32HandleProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryWin32HandleProperties_loc = loc.dot(Field::pMemoryWin32HandleProperties);
        skip |= context.ValidateStructPnext(pMemoryWin32HandleProperties_loc, pMemoryWin32HandleProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryWin32HandlePropertiesKHR-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties,
                                                                        context);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool Device::PreCallValidateGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_memory_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_fd});
    skip |= context.ValidateStructType(loc.dot(Field::pGetFdInfo), pGetFdInfo, VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, true,
                                       "VUID-vkGetMemoryFdKHR-pGetFdInfo-parameter", "VUID-VkMemoryGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr) {
        [[maybe_unused]] const Location pGetFdInfo_loc = loc.dot(Field::pGetFdInfo);
        skip |= context.ValidateStructPnext(pGetFdInfo_loc, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMemoryGetFdInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetFdInfo_loc.dot(Field::memory), pGetFdInfo->memory);

        skip |= context.ValidateFlags(pGetFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit,
                                      "VUID-VkMemoryGetFdInfoKHR-handleType-parameter",
                                      "VUID-VkMemoryGetFdInfoKHR-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFd), pFd, "VUID-vkGetMemoryFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetMemoryFdKHR(device, pGetFdInfo, pFd, context);
    return skip;
}

bool Device::PreCallValidateGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd,
                                                     VkMemoryFdPropertiesKHR* pMemoryFdProperties,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_memory_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_fd});
    skip |= context.ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                  AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit,
                                  "VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter",
                                  "VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter");
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryFdProperties), pMemoryFdProperties, VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR, true,
        "VUID-vkGetMemoryFdPropertiesKHR-pMemoryFdProperties-parameter", "VUID-VkMemoryFdPropertiesKHR-sType-sType");
    if (pMemoryFdProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryFdProperties_loc = loc.dot(Field::pMemoryFdProperties);
        skip |= context.ValidateStructPnext(pMemoryFdProperties_loc, pMemoryFdProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryFdPropertiesKHR-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_semaphore_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_capabilities});
    skip |= PreCallValidateGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo,
                                                                        pExternalSemaphoreProperties, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Device::PreCallValidateImportSemaphoreWin32HandleKHR(
    VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_semaphore_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_win32});
    skip |= context.ValidateStructType(loc.dot(Field::pImportSemaphoreWin32HandleInfo), pImportSemaphoreWin32HandleInfo,
                                       VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, true,
                                       "VUID-vkImportSemaphoreWin32HandleKHR-pImportSemaphoreWin32HandleInfo-parameter",
                                       "VUID-VkImportSemaphoreWin32HandleInfoKHR-sType-sType");
    if (pImportSemaphoreWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pImportSemaphoreWin32HandleInfo_loc = loc.dot(Field::pImportSemaphoreWin32HandleInfo);
        skip |= context.ValidateStructPnext(pImportSemaphoreWin32HandleInfo_loc, pImportSemaphoreWin32HandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreWin32HandleInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pImportSemaphoreWin32HandleInfo_loc.dot(Field::semaphore),
                                               pImportSemaphoreWin32HandleInfo->semaphore);

        skip |= context.ValidateFlags(pImportSemaphoreWin32HandleInfo_loc.dot(Field::flags),
                                      vvl::FlagBitmask::VkSemaphoreImportFlagBits, AllVkSemaphoreImportFlagBits,
                                      pImportSemaphoreWin32HandleInfo->flags, kOptionalFlags,
                                      "VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo, context);
    return skip;
}

bool Device::PreCallValidateGetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
                                                       HANDLE* pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_semaphore_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_win32});
    skip |= context.ValidateStructType(
        loc.dot(Field::pGetWin32HandleInfo), pGetWin32HandleInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR, true,
        "VUID-vkGetSemaphoreWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkSemaphoreGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetWin32HandleInfo_loc = loc.dot(Field::pGetWin32HandleInfo);
        skip |= context.ValidateStructPnext(pGetWin32HandleInfo_loc, pGetWin32HandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreGetWin32HandleInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetWin32HandleInfo_loc.dot(Field::semaphore), pGetWin32HandleInfo->semaphore);

        skip |= context.ValidateFlags(pGetWin32HandleInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                                      AllVkExternalSemaphoreHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit,
                                      "VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter",
                                      "VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, context);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool Device::PreCallValidateImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_semaphore_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_fd});
    skip |= context.ValidateStructType(
        loc.dot(Field::pImportSemaphoreFdInfo), pImportSemaphoreFdInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR, true,
        "VUID-vkImportSemaphoreFdKHR-pImportSemaphoreFdInfo-parameter", "VUID-VkImportSemaphoreFdInfoKHR-sType-sType");
    if (pImportSemaphoreFdInfo != nullptr) {
        [[maybe_unused]] const Location pImportSemaphoreFdInfo_loc = loc.dot(Field::pImportSemaphoreFdInfo);
        skip |= context.ValidateStructPnext(pImportSemaphoreFdInfo_loc, pImportSemaphoreFdInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreFdInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pImportSemaphoreFdInfo_loc.dot(Field::semaphore), pImportSemaphoreFdInfo->semaphore);

        skip |= context.ValidateFlags(pImportSemaphoreFdInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSemaphoreImportFlagBits,
                                      AllVkSemaphoreImportFlagBits, pImportSemaphoreFdInfo->flags, kOptionalFlags,
                                      "VUID-VkImportSemaphoreFdInfoKHR-flags-parameter");

        skip |= context.ValidateFlags(
            pImportSemaphoreFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
            AllVkExternalSemaphoreHandleTypeFlagBits, pImportSemaphoreFdInfo->handleType, kRequiredSingleBit,
            "VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter", "VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo, context);
    return skip;
}

bool Device::PreCallValidateGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_semaphore_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_fd});
    skip |= context.ValidateStructType(loc.dot(Field::pGetFdInfo), pGetFdInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, true,
                                       "VUID-vkGetSemaphoreFdKHR-pGetFdInfo-parameter", "VUID-VkSemaphoreGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr) {
        [[maybe_unused]] const Location pGetFdInfo_loc = loc.dot(Field::pGetFdInfo);
        skip |= context.ValidateStructPnext(pGetFdInfo_loc, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkSemaphoreGetFdInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetFdInfo_loc.dot(Field::semaphore), pGetFdInfo->semaphore);

        skip |= context.ValidateFlags(
            pGetFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
            AllVkExternalSemaphoreHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit,
            "VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter", "VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFd), pFd, "VUID-vkGetSemaphoreFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetSemaphoreFdKHR(device, pGetFdInfo, pFd, context);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                    VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount,
                                                    const VkWriteDescriptorSet* pDescriptorWrites,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_push_descriptor))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_push_descriptor});
    skip |= PreCallValidateCmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount,
                                                pDescriptorWrites, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer,
                                                                VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                                VkPipelineLayout layout, uint32_t set, const void* pData,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_khr_push_descriptor) || IsExtEnabled(extensions.vk_khr_descriptor_update_template)))
        skip |= OutputExtensionError(loc,
                                     {vvl::Extension::_VK_KHR_push_descriptor, vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateCmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData, error_obj);
    return skip;
}

bool Device::PreCallValidateCreateDescriptorUpdateTemplateKHR(VkDevice device,
                                                              const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator,
                                                              VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_descriptor_update_template))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, error_obj);
    return skip;
}

bool Device::PreCallValidateDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                               const VkAllocationCallbacks* pAllocator,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_descriptor_update_template))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator, error_obj);
    return skip;
}

bool Device::PreCallValidateUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet,
                                                               VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                               const void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_descriptor_update_template))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData, error_obj);
    return skip;
}

bool Device::PreCallValidateCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
                                                 const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin,
                                                   const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo,
                                               const VkSubpassEndInfo* pSubpassEndInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCmdEndRenderPass2(commandBuffer, pSubpassEndInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_shared_presentable_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_shared_presentable_image});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_fence_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_capabilities});
    skip |= PreCallValidateGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties,
                                                                    error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Device::PreCallValidateImportFenceWin32HandleKHR(VkDevice device,
                                                      const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_fence_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_win32});
    skip |= context.ValidateStructType(loc.dot(Field::pImportFenceWin32HandleInfo), pImportFenceWin32HandleInfo,
                                       VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR, true,
                                       "VUID-vkImportFenceWin32HandleKHR-pImportFenceWin32HandleInfo-parameter",
                                       "VUID-VkImportFenceWin32HandleInfoKHR-sType-sType");
    if (pImportFenceWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pImportFenceWin32HandleInfo_loc = loc.dot(Field::pImportFenceWin32HandleInfo);
        skip |= context.ValidateStructPnext(pImportFenceWin32HandleInfo_loc, pImportFenceWin32HandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImportFenceWin32HandleInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |=
            context.ValidateRequiredHandle(pImportFenceWin32HandleInfo_loc.dot(Field::fence), pImportFenceWin32HandleInfo->fence);

        skip |= context.ValidateFlags(pImportFenceWin32HandleInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFenceImportFlagBits,
                                      AllVkFenceImportFlagBits, pImportFenceWin32HandleInfo->flags, kOptionalFlags,
                                      "VUID-VkImportFenceWin32HandleInfoKHR-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo, context);
    return skip;
}

bool Device::PreCallValidateGetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
                                                   HANDLE* pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_fence_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_win32});
    skip |= context.ValidateStructType(
        loc.dot(Field::pGetWin32HandleInfo), pGetWin32HandleInfo, VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR, true,
        "VUID-vkGetFenceWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkFenceGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetWin32HandleInfo_loc = loc.dot(Field::pGetWin32HandleInfo);
        skip |= context.ValidateStructPnext(pGetWin32HandleInfo_loc, pGetWin32HandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkFenceGetWin32HandleInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetWin32HandleInfo_loc.dot(Field::fence), pGetWin32HandleInfo->fence);

        skip |= context.ValidateFlags(
            pGetWin32HandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
            AllVkExternalFenceHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit,
            "VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter", "VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetFenceWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, context);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool Device::PreCallValidateImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_fence_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_fd});
    skip |= context.ValidateStructType(
        loc.dot(Field::pImportFenceFdInfo), pImportFenceFdInfo, VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR, true,
        "VUID-vkImportFenceFdKHR-pImportFenceFdInfo-parameter", "VUID-VkImportFenceFdInfoKHR-sType-sType");
    if (pImportFenceFdInfo != nullptr) {
        [[maybe_unused]] const Location pImportFenceFdInfo_loc = loc.dot(Field::pImportFenceFdInfo);
        skip |=
            context.ValidateStructPnext(pImportFenceFdInfo_loc, pImportFenceFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkImportFenceFdInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pImportFenceFdInfo_loc.dot(Field::fence), pImportFenceFdInfo->fence);

        skip |= context.ValidateFlags(pImportFenceFdInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFenceImportFlagBits,
                                      AllVkFenceImportFlagBits, pImportFenceFdInfo->flags, kOptionalFlags,
                                      "VUID-VkImportFenceFdInfoKHR-flags-parameter");

        skip |= context.ValidateFlags(
            pImportFenceFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
            AllVkExternalFenceHandleTypeFlagBits, pImportFenceFdInfo->handleType, kRequiredSingleBit,
            "VUID-VkImportFenceFdInfoKHR-handleType-parameter", "VUID-VkImportFenceFdInfoKHR-handleType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportFenceFdKHR(device, pImportFenceFdInfo, context);
    return skip;
}

bool Device::PreCallValidateGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_external_fence_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_fd});
    skip |= context.ValidateStructType(loc.dot(Field::pGetFdInfo), pGetFdInfo, VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, true,
                                       "VUID-vkGetFenceFdKHR-pGetFdInfo-parameter", "VUID-VkFenceGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr) {
        [[maybe_unused]] const Location pGetFdInfo_loc = loc.dot(Field::pGetFdInfo);
        skip |= context.ValidateStructPnext(pGetFdInfo_loc, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkFenceGetFdInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetFdInfo_loc.dot(Field::fence), pGetFdInfo->fence);

        skip |=
            context.ValidateFlags(pGetFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                                  AllVkExternalFenceHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit,
                                  "VUID-VkFenceGetFdInfoKHR-handleType-parameter", "VUID-VkFenceGetFdInfoKHR-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFd), pFd, "VUID-vkGetFenceFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetFenceFdKHR(device, pGetFdInfo, pFd, context);
    return skip;
}

bool Instance::PreCallValidateEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters,
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pCounterCount), loc.dot(Field::pCounters), pCounterCount, pCounters,
        VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR, true, false, false, "VUID-VkPerformanceCounterKHR-sType-sType", kVUIDUndefined,
        "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterCount-parameter", kVUIDUndefined);
    if (pCounters != nullptr) {
        for (uint32_t pIndexerIndex = 0; pIndexerIndex < *pCounterCount; ++pIndexerIndex) {
            [[maybe_unused]] const Location pCounters_loc = loc.dot(Field::pCounters, pIndexerIndex);
            skip |=
                context.ValidateStructPnext(pCounters_loc, pCounters[pIndexerIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPerformanceCounterKHR-pNext-pNext", kVUIDUndefined, false);
        }
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pCounterCount), loc.dot(Field::pCounterDescriptions), pCounterCount, pCounterDescriptions,
        VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR, true, false, false,
        "VUID-VkPerformanceCounterDescriptionKHR-sType-sType", kVUIDUndefined,
        "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterCount-parameter", kVUIDUndefined);
    if (pCounterDescriptions != nullptr) {
        for (uint32_t pIndexerIndex = 0; pIndexerIndex < *pCounterCount; ++pIndexerIndex) {
            [[maybe_unused]] const Location pCounterDescriptions_loc = loc.dot(Field::pCounterDescriptions, pIndexerIndex);
            skip |= context.ValidateStructPnext(pCounterDescriptions_loc, pCounterDescriptions[pIndexerIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkPerformanceCounterDescriptionKHR-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses,
    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(
        loc.dot(Field::pPerformanceQueryCreateInfo), pPerformanceQueryCreateInfo,
        VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, true,
        "VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pPerformanceQueryCreateInfo-parameter",
        "VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType");
    if (pPerformanceQueryCreateInfo != nullptr) {
        [[maybe_unused]] const Location pPerformanceQueryCreateInfo_loc = loc.dot(Field::pPerformanceQueryCreateInfo);
        skip |= context.ValidateArray(pPerformanceQueryCreateInfo_loc.dot(Field::counterIndexCount),
                                      pPerformanceQueryCreateInfo_loc.dot(Field::pCounterIndices),
                                      pPerformanceQueryCreateInfo->counterIndexCount, &pPerformanceQueryCreateInfo->pCounterIndices,
                                      true, true, "VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength",
                                      "VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pNumPasses), pNumPasses,
                                            "VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pNumPasses-parameter");
    return skip;
}

bool Device::PreCallValidateAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_performance_query});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR, true,
                                       "VUID-vkAcquireProfilingLockKHR-pInfo-parameter",
                                       "VUID-VkAcquireProfilingLockInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAcquireProfilingLockInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pInfo_loc.dot(Field::flags), pInfo->flags,
                                              "VUID-VkAcquireProfilingLockInfoKHR-flags-zerobitmask");
    }
    return skip;
}

bool Device::PreCallValidateReleaseProfilingLockKHR(VkDevice device, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_performance_query});
    // No xml-driven validation
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice,
                                                                       const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
                                                                       VkSurfaceCapabilities2KHR* pSurfaceCapabilities,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_surface_capabilities2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_surface_capabilities2});
    skip |=
        context.ValidateStructType(loc.dot(Field::pSurfaceInfo), pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
                                   true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter",
                                   "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr) {
        [[maybe_unused]] const Location pSurfaceInfo_loc = loc.dot(Field::pSurfaceInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = {
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT};

        skip |= context.ValidateStructPnext(
            pSurfaceInfo_loc, pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(),
            allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", true);
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSurfaceCapabilities), pSurfaceCapabilities,
                                       VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR, true,
                                       "VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter",
                                       "VUID-VkSurfaceCapabilities2KHR-sType-sType");
    if (pSurfaceCapabilities != nullptr) {
        [[maybe_unused]] const Location pSurfaceCapabilities_loc = loc.dot(Field::pSurfaceCapabilities);
        constexpr std::array allowed_structs_VkSurfaceCapabilities2KHR = {
            VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV,
            VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV,
            VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT,
            VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT,
            VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR};

        skip |= context.ValidateStructPnext(
            pSurfaceCapabilities_loc, pSurfaceCapabilities->pNext, allowed_structs_VkSurfaceCapabilities2KHR.size(),
            allowed_structs_VkSurfaceCapabilities2KHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkSurfaceCapabilities2KHR-pNext-pNext", "VUID-VkSurfaceCapabilities2KHR-sType-unique", false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities,
                                                                               context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice,
                                                                  const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
                                                                  uint32_t* pSurfaceFormatCount,
                                                                  VkSurfaceFormat2KHR* pSurfaceFormats,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_surface_capabilities2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_surface_capabilities2});
    skip |= context.ValidateStructType(
        loc.dot(Field::pSurfaceInfo), pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, true,
        "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr) {
        [[maybe_unused]] const Location pSurfaceInfo_loc = loc.dot(Field::pSurfaceInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = {
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT};

        skip |= context.ValidateStructPnext(
            pSurfaceInfo_loc, pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(),
            allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", true);
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pSurfaceFormatCount), loc.dot(Field::pSurfaceFormats), pSurfaceFormatCount, pSurfaceFormats,
        VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, true, false, false, "VUID-VkSurfaceFormat2KHR-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormatCount-parameter", kVUIDUndefined);
    if (pSurfaceFormats != nullptr) {
        for (uint32_t pSurfaceFormatIndex = 0; pSurfaceFormatIndex < *pSurfaceFormatCount; ++pSurfaceFormatIndex) {
            [[maybe_unused]] const Location pSurfaceFormats_loc = loc.dot(Field::pSurfaceFormats, pSurfaceFormatIndex);
            constexpr std::array allowed_structs_VkSurfaceFormat2KHR = {VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT};

            skip |= context.ValidateStructPnext(
                pSurfaceFormats_loc, pSurfaceFormats[pSurfaceFormatIndex].pNext, allowed_structs_VkSurfaceFormat2KHR.size(),
                allowed_structs_VkSurfaceFormat2KHR.data(), GeneratedVulkanHeaderVersion, "VUID-VkSurfaceFormat2KHR-pNext-pNext",
                "VUID-VkSurfaceFormat2KHR-sType-unique", false);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount,
                                                                          pSurfaceFormats, context);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount,
                                                                     VkDisplayProperties2KHR* pProperties,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR, true, false, false, "VUID-VkDisplayProperties2KHR-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkDisplayProperties2KHR-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount,
                                                                          VkDisplayPlaneProperties2KHR* pProperties,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR, true, false, false, "VUID-VkDisplayPlaneProperties2KHR-sType-sType",
        kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkDisplayPlaneProperties2KHR-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                           uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount,
                                            pProperties, VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR, true, false, false,
                                            "VUID-VkDisplayModeProperties2KHR-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetDisplayModeProperties2KHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            constexpr std::array allowed_structs_VkDisplayModeProperties2KHR = {
                VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV};

            skip |= context.ValidateStructPnext(
                pProperties_loc, pProperties[pPropertyIndex].pNext, allowed_structs_VkDisplayModeProperties2KHR.size(),
                allowed_structs_VkDisplayModeProperties2KHR.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkDisplayModeProperties2KHR-pNext-pNext", "VUID-VkDisplayModeProperties2KHR-sType-unique", false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice,
                                                              const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
                                                              VkDisplayPlaneCapabilities2KHR* pCapabilities,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= context.ValidateStructType(
        loc.dot(Field::pDisplayPlaneInfo), pDisplayPlaneInfo, VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR, true,
        "VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter", "VUID-VkDisplayPlaneInfo2KHR-sType-sType");
    if (pDisplayPlaneInfo != nullptr) {
        [[maybe_unused]] const Location pDisplayPlaneInfo_loc = loc.dot(Field::pDisplayPlaneInfo);
        skip |=
            context.ValidateStructPnext(pDisplayPlaneInfo_loc, pDisplayPlaneInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkDisplayPlaneInfo2KHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pDisplayPlaneInfo_loc.dot(Field::mode), pDisplayPlaneInfo->mode);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pCapabilities), pCapabilities, VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR, true,
        "VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter", "VUID-VkDisplayPlaneCapabilities2KHR-sType-sType");
    if (pCapabilities != nullptr) {
        [[maybe_unused]] const Location pCapabilities_loc = loc.dot(Field::pCapabilities);
        skip |= context.ValidateStructPnext(pCapabilities_loc, pCapabilities->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
                                                           VkMemoryRequirements2* pMemoryRequirements,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_memory_requirements2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_memory_requirements2});
    skip |= PreCallValidateGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool Device::PreCallValidateGetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
                                                            VkMemoryRequirements2* pMemoryRequirements,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_memory_requirements2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_memory_requirements2});
    skip |= PreCallValidateGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool Device::PreCallValidateGetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo,
                                                                 uint32_t* pSparseMemoryRequirementCount,
                                                                 VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_get_memory_requirements2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_memory_requirements2});
    skip |= PreCallValidateGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount,
                                                             pSparseMemoryRequirements, error_obj);
    return skip;
}

bool Device::PreCallValidateCreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            VkSamplerYcbcrConversion* pYcbcrConversion,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_sampler_ycbcr_conversion});
    skip |= PreCallValidateCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion, error_obj);
    return skip;
}

bool Device::PreCallValidateDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_sampler_ycbcr_conversion))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_sampler_ycbcr_conversion});
    skip |= PreCallValidateDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator, error_obj);
    return skip;
}

bool Device::PreCallValidateBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_bind_memory2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_bind_memory2});
    skip |= PreCallValidateBindBufferMemory2(device, bindInfoCount, pBindInfos, error_obj);
    return skip;
}

bool Device::PreCallValidateBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_bind_memory2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_bind_memory2});
    skip |= PreCallValidateBindImageMemory2(device, bindInfoCount, pBindInfos, error_obj);
    return skip;
}

bool Device::PreCallValidateGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                             VkDescriptorSetLayoutSupport* pSupport,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance3)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance3});
    skip |= PreCallValidateGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                    VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                    uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride,
                                                error_obj);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                           VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                           uint32_t maxDrawCount, uint32_t stride,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                                       stride, error_obj);
    return skip;
}

bool Device::PreCallValidateGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t* pValue,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_timeline_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_timeline_semaphore});
    skip |= PreCallValidateGetSemaphoreCounterValue(device, semaphore, pValue, error_obj);
    return skip;
}

bool Device::PreCallValidateWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_timeline_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_timeline_semaphore});
    skip |= PreCallValidateWaitSemaphores(device, pWaitInfo, timeout, error_obj);
    return skip;
}

bool Device::PreCallValidateSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_timeline_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_timeline_semaphore});
    skip |= PreCallValidateSignalSemaphore(device, pSignalInfo, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceFragmentShadingRatesKHR(
    VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount,
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pFragmentShadingRateCount), loc.dot(Field::pFragmentShadingRates), pFragmentShadingRateCount,
        pFragmentShadingRates, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR, true, false, false,
        "VUID-VkPhysicalDeviceFragmentShadingRateKHR-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-pFragmentShadingRateCount-parameter", kVUIDUndefined);
    if (pFragmentShadingRates != nullptr) {
        for (uint32_t pFragmentShadingRateIndex = 0; pFragmentShadingRateIndex < *pFragmentShadingRateCount;
             ++pFragmentShadingRateIndex) {
            [[maybe_unused]] const Location pFragmentShadingRates_loc =
                loc.dot(Field::pFragmentShadingRates, pFragmentShadingRateIndex);
            skip |= context.ValidateStructPnext(pFragmentShadingRates_loc, pFragmentShadingRates[pFragmentShadingRateIndex].pNext,
                                                0, nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkPhysicalDeviceFragmentShadingRateKHR-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize,
                                                         const VkFragmentShadingRateCombinerOpKHR combinerOps[2],
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_fragment_shading_rate))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_fragment_shading_rate});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFragmentSize), pFragmentSize,
                                            "VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-parameter");
    skip |= context.ValidateRangedEnumArray(loc, loc.dot(Field::combinerOps), vvl::Enum::VkFragmentShadingRateCombinerOpKHR, 2,
                                            combinerOps, false, true, kVUIDUndefined,
                                            "VUID-vkCmdSetFragmentShadingRateKHR-combinerOps-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer,
                                                                  const VkRenderingAttachmentLocationInfo* pLocationInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering_local_read))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering_local_read});
    skip |= PreCallValidateCmdSetRenderingAttachmentLocations(commandBuffer, pLocationInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetRenderingInputAttachmentIndicesKHR(
    VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo* pInputAttachmentIndexInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_dynamic_rendering_local_read))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering_local_read});
    skip |= PreCallValidateCmdSetRenderingInputAttachmentIndices(commandBuffer, pInputAttachmentIndexInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateWaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_present_wait)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_present_wait});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}

bool Device::PreCallValidateGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_buffer_device_address});
    skip |= PreCallValidateGetBufferDeviceAddress(device, pInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_buffer_device_address});
    skip |= PreCallValidateGetBufferOpaqueCaptureAddress(device, pInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device,
                                                                   const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_buffer_device_address});
    skip |= PreCallValidateGetDeviceMemoryOpaqueCaptureAddress(device, pInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks* pAllocator,
                                                       VkDeferredOperationKHR* pDeferredOperation,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDeferredOperation), pDeferredOperation,
                                            "VUID-vkCreateDeferredOperationKHR-pDeferredOperation-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                        const VkAllocationCallbacks* pAllocator,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::operation), operation);
    return skip;
}

bool Device::PreCallValidateGetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::operation), operation);
    return skip;
}

bool Device::PreCallValidateDeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::operation), operation);
    return skip;
}

bool Device::PreCallValidateGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR* pPipelineInfo,
                                                               uint32_t* pExecutableCount,
                                                               VkPipelineExecutablePropertiesKHR* pProperties,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_executable_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_executable_properties});
    skip |= context.ValidateStructType(loc.dot(Field::pPipelineInfo), pPipelineInfo, VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR, true,
                                       "VUID-vkGetPipelineExecutablePropertiesKHR-pPipelineInfo-parameter",
                                       "VUID-VkPipelineInfoKHR-sType-sType");
    if (pPipelineInfo != nullptr) {
        [[maybe_unused]] const Location pPipelineInfo_loc = loc.dot(Field::pPipelineInfo);
        skip |= context.ValidateStructPnext(pPipelineInfo_loc, pPipelineInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pPipelineInfo_loc.dot(Field::pipeline), pPipelineInfo->pipeline);
    }
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pExecutableCount), loc.dot(Field::pProperties), pExecutableCount,
                                            pProperties, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR, true, false, false,
                                            "VUID-VkPipelineExecutablePropertiesKHR-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetPipelineExecutablePropertiesKHR-pExecutableCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pExecutableIndex = 0; pExecutableIndex < *pExecutableCount; ++pExecutableIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pExecutableIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pExecutableIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutablePropertiesKHR-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateGetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo,
                                                               uint32_t* pStatisticCount,
                                                               VkPipelineExecutableStatisticKHR* pStatistics,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_executable_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_executable_properties});
    skip |= context.ValidateStructType(
        loc.dot(Field::pExecutableInfo), pExecutableInfo, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR, true,
        "VUID-vkGetPipelineExecutableStatisticsKHR-pExecutableInfo-parameter", "VUID-VkPipelineExecutableInfoKHR-sType-sType");
    if (pExecutableInfo != nullptr) {
        [[maybe_unused]] const Location pExecutableInfo_loc = loc.dot(Field::pExecutableInfo);
        skip |= context.ValidateStructPnext(pExecutableInfo_loc, pExecutableInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineExecutableInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pExecutableInfo_loc.dot(Field::pipeline), pExecutableInfo->pipeline);
    }
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pStatisticCount), loc.dot(Field::pStatistics), pStatisticCount,
                                            pStatistics, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR, true, false, false,
                                            "VUID-VkPipelineExecutableStatisticKHR-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetPipelineExecutableStatisticsKHR-pStatisticCount-parameter", kVUIDUndefined);
    if (pStatistics != nullptr) {
        for (uint32_t pStatisticIndex = 0; pStatisticIndex < *pStatisticCount; ++pStatisticIndex) {
            [[maybe_unused]] const Location pStatistics_loc = loc.dot(Field::pStatistics, pStatisticIndex);
            skip |= context.ValidateStructPnext(pStatistics_loc, pStatistics[pStatisticIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutableStatisticKHR-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_executable_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_executable_properties});
    skip |=
        context.ValidateStructType(loc.dot(Field::pExecutableInfo), pExecutableInfo, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
                                   true, "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pExecutableInfo-parameter",
                                   "VUID-VkPipelineExecutableInfoKHR-sType-sType");
    if (pExecutableInfo != nullptr) {
        [[maybe_unused]] const Location pExecutableInfo_loc = loc.dot(Field::pExecutableInfo);
        skip |= context.ValidateStructPnext(pExecutableInfo_loc, pExecutableInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineExecutableInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pExecutableInfo_loc.dot(Field::pipeline), pExecutableInfo->pipeline);
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pInternalRepresentationCount), loc.dot(Field::pInternalRepresentations), pInternalRepresentationCount,
        pInternalRepresentations, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR, true, false, false,
        "VUID-VkPipelineExecutableInternalRepresentationKHR-sType-sType", kVUIDUndefined,
        "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pInternalRepresentationCount-parameter", kVUIDUndefined);
    if (pInternalRepresentations != nullptr) {
        for (uint32_t pInternalRepresentationIndex = 0; pInternalRepresentationIndex < *pInternalRepresentationCount;
             ++pInternalRepresentationIndex) {
            [[maybe_unused]] const Location pInternalRepresentations_loc =
                loc.dot(Field::pInternalRepresentations, pInternalRepresentationIndex);
            skip |= context.ValidateStructPnext(
                pInternalRepresentations_loc, pInternalRepresentations[pInternalRepresentationIndex].pNext, 0, nullptr,
                GeneratedVulkanHeaderVersion, "VUID-VkPipelineExecutableInternalRepresentationKHR-pNext-pNext", kVUIDUndefined,
                false);
        }
    }
    return skip;
}

bool Device::PreCallValidateMapMemory2KHR(VkDevice device, const VkMemoryMapInfo* pMemoryMapInfo, void** ppData,
                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_map_memory2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_map_memory2});
    skip |= PreCallValidateMapMemory2(device, pMemoryMapInfo, ppData, error_obj);
    return skip;
}

bool Device::PreCallValidateUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo* pMemoryUnmapInfo,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_map_memory2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_map_memory2});
    skip |= PreCallValidateUnmapMemory2(device, pMemoryUnmapInfo, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo,
    VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pQualityLevelInfo), pQualityLevelInfo,
                                       VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR, true,
                                       "VUID-vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR-pQualityLevelInfo-parameter",
                                       "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-sType-sType");
    if (pQualityLevelInfo != nullptr) {
        [[maybe_unused]] const Location pQualityLevelInfo_loc = loc.dot(Field::pQualityLevelInfo);
        skip |=
            context.ValidateStructPnext(pQualityLevelInfo_loc, pQualityLevelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(pQualityLevelInfo_loc.dot(Field::pVideoProfile), pQualityLevelInfo->pVideoProfile,
                                           VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true,
                                           "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-parameter",
                                           "VUID-VkVideoProfileInfoKHR-sType-sType");

        if (pQualityLevelInfo->pVideoProfile != nullptr) {
            [[maybe_unused]] const Location pVideoProfile_loc = pQualityLevelInfo_loc.dot(Field::pVideoProfile);
            skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::videoCodecOperation),
                                          vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR, AllVkVideoCodecOperationFlagBitsKHR,
                                          pQualityLevelInfo->pVideoProfile->videoCodecOperation, kRequiredSingleBit,
                                          "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                                          "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

            skip |= context.ValidateFlags(
                pVideoProfile_loc.dot(Field::chromaSubsampling), vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                AllVkVideoChromaSubsamplingFlagBitsKHR, pQualityLevelInfo->pVideoProfile->chromaSubsampling, kRequiredFlags,
                "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

            skip |= context.ValidateFlags(
                pVideoProfile_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                AllVkVideoComponentBitDepthFlagBitsKHR, pQualityLevelInfo->pVideoProfile->lumaBitDepth, kRequiredFlags,
                "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

            skip |= context.ValidateFlags(pVideoProfile_loc.dot(Field::chromaBitDepth),
                                          vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                          AllVkVideoComponentBitDepthFlagBitsKHR, pQualityLevelInfo->pVideoProfile->chromaBitDepth,
                                          kOptionalFlags, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
        }
    }
    skip |=
        context.ValidateStructType(loc.dot(Field::pQualityLevelProperties), pQualityLevelProperties,
                                   VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR, true,
                                   "VUID-vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR-pQualityLevelProperties-parameter",
                                   "VUID-VkVideoEncodeQualityLevelPropertiesKHR-sType-sType");
    if (pQualityLevelProperties != nullptr) {
        [[maybe_unused]] const Location pQualityLevelProperties_loc = loc.dot(Field::pQualityLevelProperties);
        constexpr std::array allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR};

        skip |= context.ValidateStructPnext(pQualityLevelProperties_loc, pQualityLevelProperties->pNext,
                                            allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR.size(),
                                            allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeQualityLevelPropertiesKHR-pNext-pNext",
                                            "VUID-VkVideoEncodeQualityLevelPropertiesKHR-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateGetEncodedVideoSessionParametersKHR(
    VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo,
    VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_encode_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_encode_queue});
    skip |= context.ValidateStructType(loc.dot(Field::pVideoSessionParametersInfo), pVideoSessionParametersInfo,
                                       VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR, true,
                                       "VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-parameter",
                                       "VUID-VkVideoEncodeSessionParametersGetInfoKHR-sType-sType");
    if (pVideoSessionParametersInfo != nullptr) {
        [[maybe_unused]] const Location pVideoSessionParametersInfo_loc = loc.dot(Field::pVideoSessionParametersInfo);
        constexpr std::array allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR};

        skip |=
            context.ValidateStructPnext(pVideoSessionParametersInfo_loc, pVideoSessionParametersInfo->pNext,
                                        allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR.size(),
                                        allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeSessionParametersGetInfoKHR-pNext-pNext",
                                        "VUID-VkVideoEncodeSessionParametersGetInfoKHR-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pVideoSessionParametersInfo_loc.dot(Field::videoSessionParameters),
                                               pVideoSessionParametersInfo->videoSessionParameters);
    }
    skip |= context.ValidateStructType(loc.dot(Field::pFeedbackInfo), pFeedbackInfo,
                                       VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR, false,
                                       "VUID-vkGetEncodedVideoSessionParametersKHR-pFeedbackInfo-parameter",
                                       "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-sType-sType");
    if (pFeedbackInfo != nullptr) {
        [[maybe_unused]] const Location pFeedbackInfo_loc = loc.dot(Field::pFeedbackInfo);
        constexpr std::array allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR};

        skip |= context.ValidateStructPnext(
            pFeedbackInfo_loc, pFeedbackInfo->pNext, allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR.size(),
            allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-pNext-pNext",
            "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-sType-unique", false);
    }
    skip |= context.ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                         "VUID-vkGetEncodedVideoSessionParametersKHR-pDataSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetEncodedVideoSessionParametersKHR-pData-parameter");
    return skip;
}

bool Device::PreCallValidateCmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR* pEncodeInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_video_encode_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_encode_queue});
    skip |= context.ValidateStructType(loc.dot(Field::pEncodeInfo), pEncodeInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR, true,
                                       "VUID-vkCmdEncodeVideoKHR-pEncodeInfo-parameter", "VUID-VkVideoEncodeInfoKHR-sType-sType");
    if (pEncodeInfo != nullptr) {
        [[maybe_unused]] const Location pEncodeInfo_loc = loc.dot(Field::pEncodeInfo);
        constexpr std::array allowed_structs_VkVideoEncodeInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR};

        skip |=
            context.ValidateStructPnext(pEncodeInfo_loc, pEncodeInfo->pNext, allowed_structs_VkVideoEncodeInfoKHR.size(),
                                        allowed_structs_VkVideoEncodeInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkVideoEncodeInfoKHR-pNext-pNext", "VUID-VkVideoEncodeInfoKHR-sType-unique", true);

        skip |= context.ValidateFlags(pEncodeInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoEncodeFlagBitsKHR,
                                      AllVkVideoEncodeFlagBitsKHR, pEncodeInfo->flags, kOptionalFlags,
                                      "VUID-VkVideoEncodeInfoKHR-flags-parameter");

        skip |= context.ValidateRequiredHandle(pEncodeInfo_loc.dot(Field::dstBuffer), pEncodeInfo->dstBuffer);

        skip |= context.ValidateStructType(pEncodeInfo_loc.dot(Field::srcPictureResource), &(pEncodeInfo->srcPictureResource),
                                           VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, kVUIDUndefined,
                                           "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

        skip |= context.ValidateStructPnext(pEncodeInfo_loc, pEncodeInfo->srcPictureResource.pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext",
                                            kVUIDUndefined, true);

        // No xml-driven validation

        // No xml-driven validation

        skip |= context.ValidateRequiredHandle(pEncodeInfo_loc.dot(Field::imageViewBinding),
                                               pEncodeInfo->srcPictureResource.imageViewBinding);

        skip |= context.ValidateStructType(pEncodeInfo_loc.dot(Field::pSetupReferenceSlot), pEncodeInfo->pSetupReferenceSlot,
                                           VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false,
                                           "VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-parameter",
                                           "VUID-VkVideoReferenceSlotInfoKHR-sType-sType");

        if (pEncodeInfo->pSetupReferenceSlot != nullptr) {
            [[maybe_unused]] const Location pSetupReferenceSlot_loc = pEncodeInfo_loc.dot(Field::pSetupReferenceSlot);
            constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

            skip |= context.ValidateStructPnext(pSetupReferenceSlot_loc, pEncodeInfo->pSetupReferenceSlot->pNext,
                                                allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                                allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                                "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", true);

            skip |= context.ValidateStructType(
                pSetupReferenceSlot_loc.dot(Field::pPictureResource), pEncodeInfo->pSetupReferenceSlot->pPictureResource,
                VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

            if (pEncodeInfo->pSetupReferenceSlot->pPictureResource != nullptr) {
                [[maybe_unused]] const Location pPictureResource_loc = pSetupReferenceSlot_loc.dot(Field::pPictureResource);
                skip |= context.ValidateStructPnext(pPictureResource_loc, pEncodeInfo->pSetupReferenceSlot->pPictureResource->pNext,
                                                    0, nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, true);

                // No xml-driven validation

                // No xml-driven validation

                skip |= context.ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                                       pEncodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding);
            }
        }

        skip |= context.ValidateStructTypeArray(pEncodeInfo_loc.dot(Field::referenceSlotCount),
                                                pEncodeInfo_loc.dot(Field::pReferenceSlots), pEncodeInfo->referenceSlotCount,
                                                pEncodeInfo->pReferenceSlots, VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
                                                false, true, "VUID-VkVideoReferenceSlotInfoKHR-sType-sType",
                                                "VUID-VkVideoEncodeInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pEncodeInfo->pReferenceSlots != nullptr) {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pEncodeInfo->referenceSlotCount; ++referenceSlotIndex) {
                [[maybe_unused]] const Location pReferenceSlots_loc =
                    pEncodeInfo_loc.dot(Field::pReferenceSlots, referenceSlotIndex);
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

                skip |= context.ValidateStructPnext(pReferenceSlots_loc, pEncodeInfo->pReferenceSlots[referenceSlotIndex].pNext,
                                                    allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                                    allowed_structs_VkVideoReferenceSlotInfoKHR.data(),
                                                    GeneratedVulkanHeaderVersion, "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                                    "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", true);

                skip |= context.ValidateStructType(pReferenceSlots_loc.dot(Field::pPictureResource),
                                                   pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource,
                                                   VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                                                   "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter",
                                                   "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr) {
                    [[maybe_unused]] const Location pPictureResource_loc = pReferenceSlots_loc.dot(Field::pPictureResource);
                    skip |= context.ValidateStructPnext(
                        pPictureResource_loc, pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |= context.ValidateRequiredHandle(
                        pPictureResource_loc.dot(Field::imageViewBinding),
                        pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo* pDependencyInfo,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdSetEvent2(commandBuffer, event, pDependencyInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdResetEvent2(commandBuffer, event, stageMask, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                                              const VkDependencyInfo* pDependencyInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdPipelineBarrier2(commandBuffer, pDependencyInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool,
                                                  uint32_t query, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdWriteTimestamp2(commandBuffer, stage, queryPool, query, error_obj);
    return skip;
}

bool Device::PreCallValidateQueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits, VkFence fence,
                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateQueueSubmit2(queue, submitCount, pSubmits, fence, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyBuffer2(commandBuffer, pCopyBufferInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyImage2(commandBuffer, pCopyImageInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer,
                                                     const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer,
                                                     const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdBlitImage2(commandBuffer, pBlitImageInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2* pResolveImageInfo,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdResolveImage2(commandBuffer, pResolveImageInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_maintenance1))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_maintenance1});
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress, context);
    return skip;
}

bool Device::PreCallValidateGetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements* pInfo,
                                                                 VkMemoryRequirements2* pMemoryRequirements,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance4)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance4});
    skip |= PreCallValidateGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool Device::PreCallValidateGetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
                                                                VkMemoryRequirements2* pMemoryRequirements,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance4)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance4});
    skip |= PreCallValidateGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool Device::PreCallValidateGetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements* pInfo,
                                                                      uint32_t* pSparseMemoryRequirementCount,
                                                                      VkSparseImageMemoryRequirements2* pSparseMemoryRequirements,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance4)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance4});
    skip |= PreCallValidateGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                                  pSparseMemoryRequirements, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                   VkDeviceSize size, VkIndexType indexType, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= PreCallValidateCmdBindIndexBuffer2(commandBuffer, buffer, offset, size, indexType, error_obj);
    return skip;
}

bool Device::PreCallValidateGetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo* pRenderingAreaInfo,
                                                           VkExtent2D* pGranularity, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= PreCallValidateGetRenderingAreaGranularity(device, pRenderingAreaInfo, pGranularity, error_obj);
    return skip;
}

bool Device::PreCallValidateGetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo* pInfo,
                                                               VkSubresourceLayout2* pLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= PreCallValidateGetDeviceImageSubresourceLayout(device, pInfo, pLayout, error_obj);
    return skip;
}

bool Device::PreCallValidateGetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource,
                                                          VkSubresourceLayout2* pLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance5)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= PreCallValidateGetImageSubresourceLayout2(device, image, pSubresource, pLayout, error_obj);
    return skip;
}

bool Device::PreCallValidateCreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator,
                                                      VkPipelineBinaryHandlesInfoKHR* pBinaries,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR,
                                       true, "VUID-vkCreatePipelineBinariesKHR-pCreateInfo-parameter",
                                       "VUID-VkPipelineBinaryCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineBinaryCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

        if (pCreateInfo->pKeysAndDataInfo != nullptr) {
            [[maybe_unused]] const Location pKeysAndDataInfo_loc = pCreateInfo_loc.dot(Field::pKeysAndDataInfo);
            skip |= context.ValidateStructTypeArray(
                pKeysAndDataInfo_loc.dot(Field::binaryCount), pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryKeys),
                pCreateInfo->pKeysAndDataInfo->binaryCount, pCreateInfo->pKeysAndDataInfo->pPipelineBinaryKeys,
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR, true, true, "VUID-VkPipelineBinaryKeyKHR-sType-sType",
                "VUID-VkPipelineBinaryKeysAndDataKHR-pPipelineBinaryKeys-parameter",
                "VUID-VkPipelineBinaryKeysAndDataKHR-binaryCount-arraylength");

            if (pCreateInfo->pKeysAndDataInfo->pPipelineBinaryKeys != nullptr) {
                for (uint32_t binaryIndex = 0; binaryIndex < pCreateInfo->pKeysAndDataInfo->binaryCount; ++binaryIndex) {
                    [[maybe_unused]] const Location pPipelineBinaryKeys_loc =
                        pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryKeys, binaryIndex);
                    skip |= context.ValidateStructPnext(
                        pPipelineBinaryKeys_loc, pCreateInfo->pKeysAndDataInfo->pPipelineBinaryKeys[binaryIndex].pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkPipelineBinaryKeyKHR-pNext-pNext", kVUIDUndefined, true);
                }
            }

            skip |= context.ValidateArray(
                pKeysAndDataInfo_loc.dot(Field::binaryCount), pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryData),
                pCreateInfo->pKeysAndDataInfo->binaryCount, &pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData, true, true,
                "VUID-VkPipelineBinaryKeysAndDataKHR-binaryCount-arraylength",
                "VUID-VkPipelineBinaryKeysAndDataKHR-pPipelineBinaryData-parameter");

            if (pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData != nullptr) {
                for (uint32_t binaryIndex = 0; binaryIndex < pCreateInfo->pKeysAndDataInfo->binaryCount; ++binaryIndex) {
                    [[maybe_unused]] const Location pPipelineBinaryData_loc =
                        pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryData, binaryIndex);
                    skip |= context.ValidateArray(
                        pPipelineBinaryData_loc.dot(Field::dataSize), pPipelineBinaryData_loc.dot(Field::pData),
                        pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData[binaryIndex].dataSize,
                        &pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData[binaryIndex].pData, true, true,
                        "VUID-VkPipelineBinaryDataKHR-dataSize-arraylength", "VUID-VkPipelineBinaryDataKHR-pData-parameter");
                }
            }
        }

        skip |= context.ValidateStructType(pCreateInfo_loc.dot(Field::pPipelineCreateInfo), pCreateInfo->pPipelineCreateInfo,
                                           VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR, false,
                                           "VUID-VkPipelineBinaryCreateInfoKHR-pPipelineCreateInfo-parameter",
                                           "VUID-VkPipelineCreateInfoKHR-sType-sType");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateStructType(loc.dot(Field::pBinaries), pBinaries, VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR,
                                       true, "VUID-vkCreatePipelineBinariesKHR-pBinaries-parameter",
                                       "VUID-VkPipelineBinaryHandlesInfoKHR-sType-sType");
    if (pBinaries != nullptr) {
        [[maybe_unused]] const Location pBinaries_loc = loc.dot(Field::pBinaries);
        skip |= context.ValidateStructPnext(pBinaries_loc, pBinaries->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineBinaryHandlesInfoKHR-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateDestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary,
                                                     const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR* pPipelineCreateInfo,
                                              VkPipelineBinaryKeyKHR* pPipelineKey, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= context.ValidateStructType(
        loc.dot(Field::pPipelineCreateInfo), pPipelineCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR, false,
        "VUID-vkGetPipelineKeyKHR-pPipelineCreateInfo-parameter", "VUID-VkPipelineCreateInfoKHR-sType-sType");
    skip |=
        context.ValidateStructType(loc.dot(Field::pPipelineKey), pPipelineKey, VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR, true,
                                   "VUID-vkGetPipelineKeyKHR-pPipelineKey-parameter", "VUID-VkPipelineBinaryKeyKHR-sType-sType");
    if (pPipelineKey != nullptr) {
        [[maybe_unused]] const Location pPipelineKey_loc = loc.dot(Field::pPipelineKey);
        skip |= context.ValidateStructPnext(pPipelineKey_loc, pPipelineKey->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineBinaryKeyKHR-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR* pInfo,
                                                     VkPipelineBinaryKeyKHR* pPipelineBinaryKey, size_t* pPipelineBinaryDataSize,
                                                     void* pPipelineBinaryData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR, true,
                                       "VUID-vkGetPipelineBinaryDataKHR-pInfo-parameter",
                                       "VUID-VkPipelineBinaryDataInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineBinaryDataInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::pipelineBinary), pInfo->pipelineBinary);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pPipelineBinaryKey), pPipelineBinaryKey, VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR, true,
        "VUID-vkGetPipelineBinaryDataKHR-pPipelineBinaryKey-parameter", "VUID-VkPipelineBinaryKeyKHR-sType-sType");
    if (pPipelineBinaryKey != nullptr) {
        [[maybe_unused]] const Location pPipelineBinaryKey_loc = loc.dot(Field::pPipelineBinaryKey);
        skip |=
            context.ValidateStructPnext(pPipelineBinaryKey_loc, pPipelineBinaryKey->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineBinaryKeyKHR-pNext-pNext", kVUIDUndefined, false);
    }
    skip |= context.ValidatePointerArray(loc.dot(Field::pPipelineBinaryDataSize), loc.dot(Field::pPipelineBinaryData),
                                         pPipelineBinaryDataSize, &pPipelineBinaryData, true, false, false,
                                         "VUID-vkGetPipelineBinaryDataKHR-pPipelineBinaryDataSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetPipelineBinaryDataKHR-pPipelineBinaryData-parameter");
    return skip;
}

bool Device::PreCallValidateReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR* pInfo,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR,
                                       true, "VUID-vkReleaseCapturedPipelineDataKHR-pInfo-parameter",
                                       "VUID-VkReleaseCapturedPipelineDataInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkReleaseCapturedPipelineDataInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::pipeline), pInfo->pipeline);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice,
                                                                              uint32_t* pPropertyCount,
                                                                              VkCooperativeMatrixPropertiesKHR* pProperties,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount,
                                            pProperties, VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR, true, false, false,
                                            "VUID-VkCooperativeMatrixPropertiesKHR-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR-pPropertyCount-parameter",
                                            kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCooperativeMatrixPropertiesKHR-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                                 uint16_t lineStipplePattern, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_line_rasterization))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_line_rasterization});
    skip |= PreCallValidateCmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice,
                                                                           uint32_t* pTimeDomainCount,
                                                                           VkTimeDomainKHR* pTimeDomains,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidatePointerArray(
        loc.dot(Field::pTimeDomainCount), loc.dot(Field::pTimeDomains), pTimeDomainCount, &pTimeDomains, true, false, false,
        "VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsKHR-pTimeDomainCount-parameter", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsKHR-pTimeDomains-parameter");
    return skip;
}

bool Device::PreCallValidateGetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount,
                                                       const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps,
                                                       uint64_t* pMaxDeviation, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_calibrated_timestamps) && loc.function == vvl::Func::vkGetCalibratedTimestampsKHR)
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_calibrated_timestamps});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::timestampCount), loc.dot(Field::pTimestampInfos), timestampCount,
                                            pTimestampInfos, VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR, true, true,
                                            "VUID-VkCalibratedTimestampInfoKHR-sType-sType",
                                            "VUID-vkGetCalibratedTimestampsKHR-pTimestampInfos-parameter",
                                            "VUID-vkGetCalibratedTimestampsKHR-timestampCount-arraylength");
    if (pTimestampInfos != nullptr) {
        for (uint32_t timestampIndex = 0; timestampIndex < timestampCount; ++timestampIndex) {
            [[maybe_unused]] const Location pTimestampInfos_loc = loc.dot(Field::pTimestampInfos, timestampIndex);
            skip |= context.ValidateStructPnext(pTimestampInfos_loc, pTimestampInfos[timestampIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCalibratedTimestampInfoKHR-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pTimestampInfos_loc.dot(Field::timeDomain), vvl::Enum::VkTimeDomainKHR,
                                               pTimestampInfos[timestampIndex].timeDomain,
                                               "VUID-VkCalibratedTimestampInfoKHR-timeDomain-parameter");
        }
    }
    skip |= context.ValidateArray(loc.dot(Field::timestampCount), loc.dot(Field::pTimestamps), timestampCount, &pTimestamps, true,
                                  true, "VUID-vkGetCalibratedTimestampsKHR-timestampCount-arraylength",
                                  "VUID-vkGetCalibratedTimestampsKHR-pTimestamps-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMaxDeviation), pMaxDeviation,
                                            "VUID-vkGetCalibratedTimestampsKHR-pMaxDeviation-parameter");
    return skip;
}

bool Device::PreCallValidateCmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer,
                                                      const VkBindDescriptorSetsInfo* pBindDescriptorSetsInfo,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance6)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= PreCallValidateCmdBindDescriptorSets2(commandBuffer, pBindDescriptorSetsInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo* pPushConstantsInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance6)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= PreCallValidateCmdPushConstants2(commandBuffer, pPushConstantsInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer,
                                                     const VkPushDescriptorSetInfo* pPushDescriptorSetInfo,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance6)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= PreCallValidateCmdPushDescriptorSet2(commandBuffer, pPushDescriptorSetInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdPushDescriptorSetWithTemplate2KHR(
    VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo* pPushDescriptorSetWithTemplateInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance6)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= PreCallValidateCmdPushDescriptorSetWithTemplate2(commandBuffer, pPushDescriptorSetWithTemplateInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDescriptorBufferOffsets2EXT(
    VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance6)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= context.ValidateStructType(loc.dot(Field::pSetDescriptorBufferOffsetsInfo), pSetDescriptorBufferOffsetsInfo,
                                       VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT, true,
                                       "VUID-vkCmdSetDescriptorBufferOffsets2EXT-pSetDescriptorBufferOffsetsInfo-parameter",
                                       "VUID-VkSetDescriptorBufferOffsetsInfoEXT-sType-sType");
    if (pSetDescriptorBufferOffsetsInfo != nullptr) {
        [[maybe_unused]] const Location pSetDescriptorBufferOffsetsInfo_loc = loc.dot(Field::pSetDescriptorBufferOffsetsInfo);
        constexpr std::array allowed_structs_VkSetDescriptorBufferOffsetsInfoEXT = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(pSetDescriptorBufferOffsetsInfo_loc, pSetDescriptorBufferOffsetsInfo->pNext,
                                            allowed_structs_VkSetDescriptorBufferOffsetsInfoEXT.size(),
                                            allowed_structs_VkSetDescriptorBufferOffsetsInfoEXT.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkSetDescriptorBufferOffsetsInfoEXT-pNext-pNext",
                                            "VUID-VkSetDescriptorBufferOffsetsInfoEXT-sType-unique", true);

        skip |= context.ValidateFlags(pSetDescriptorBufferOffsetsInfo_loc.dot(Field::stageFlags),
                                      vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                      pSetDescriptorBufferOffsetsInfo->stageFlags, kRequiredFlags,
                                      "VUID-VkSetDescriptorBufferOffsetsInfoEXT-stageFlags-parameter",
                                      "VUID-VkSetDescriptorBufferOffsetsInfoEXT-stageFlags-requiredbitmask");

        skip |= context.ValidateArray(pSetDescriptorBufferOffsetsInfo_loc.dot(Field::setCount),
                                      pSetDescriptorBufferOffsetsInfo_loc.dot(Field::pBufferIndices),
                                      pSetDescriptorBufferOffsetsInfo->setCount, &pSetDescriptorBufferOffsetsInfo->pBufferIndices,
                                      true, true, "VUID-VkSetDescriptorBufferOffsetsInfoEXT-setCount-arraylength",
                                      "VUID-VkSetDescriptorBufferOffsetsInfoEXT-pBufferIndices-parameter");

        skip |= context.ValidateArray(pSetDescriptorBufferOffsetsInfo_loc.dot(Field::setCount),
                                      pSetDescriptorBufferOffsetsInfo_loc.dot(Field::pOffsets),
                                      pSetDescriptorBufferOffsetsInfo->setCount, &pSetDescriptorBufferOffsetsInfo->pOffsets, true,
                                      true, "VUID-VkSetDescriptorBufferOffsetsInfoEXT-setCount-arraylength",
                                      "VUID-VkSetDescriptorBufferOffsetsInfoEXT-pOffsets-parameter");
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdBindDescriptorBufferEmbeddedSamplers2EXT(
    VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_maintenance6)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= context.ValidateStructType(
        loc.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo), pBindDescriptorBufferEmbeddedSamplersInfo,
        VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT, true,
        "VUID-vkCmdBindDescriptorBufferEmbeddedSamplers2EXT-pBindDescriptorBufferEmbeddedSamplersInfo-parameter",
        "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-sType-sType");
    if (pBindDescriptorBufferEmbeddedSamplersInfo != nullptr) {
        [[maybe_unused]] const Location pBindDescriptorBufferEmbeddedSamplersInfo_loc =
            loc.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo);
        constexpr std::array allowed_structs_VkBindDescriptorBufferEmbeddedSamplersInfoEXT = {
            VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(
            pBindDescriptorBufferEmbeddedSamplersInfo_loc, pBindDescriptorBufferEmbeddedSamplersInfo->pNext,
            allowed_structs_VkBindDescriptorBufferEmbeddedSamplersInfoEXT.size(),
            allowed_structs_VkBindDescriptorBufferEmbeddedSamplersInfoEXT.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-pNext-pNext",
            "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-sType-unique", true);

        skip |= context.ValidateFlags(pBindDescriptorBufferEmbeddedSamplersInfo_loc.dot(Field::stageFlags),
                                      vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                      pBindDescriptorBufferEmbeddedSamplersInfo->stageFlags, kRequiredFlags,
                                      "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-stageFlags-parameter",
                                      "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-stageFlags-requiredbitmask");
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdBindDescriptorBufferEmbeddedSamplers2EXT(
            commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo, context);
    return skip;
}

bool Instance::PreCallValidateCreateDebugReportCallbackEXT(VkInstance instance,
                                                           const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           VkDebugReportCallbackEXT* pCallback,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_report)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_report});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, true,
        "VUID-vkCreateDebugReportCallbackEXT-pCreateInfo-parameter", "VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDebugReportFlagBitsEXT,
                                      AllVkDebugReportFlagBitsEXT, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter");

        skip |= context.ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pfnCallback),
                                                reinterpret_cast<const void*>(pCreateInfo->pfnCallback),
                                                "VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCallback), pCallback,
                                            "VUID-vkCreateDebugReportCallbackEXT-pCallback-parameter");
    return skip;
}

bool Instance::PreCallValidateDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_report)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_report});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Instance::PreCallValidateDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags,
                                                    VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location,
                                                    int32_t messageCode, const char* pLayerPrefix, const char* pMessage,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_report)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_report});
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkDebugReportFlagBitsEXT, AllVkDebugReportFlagBitsEXT,
                                  flags, kRequiredFlags, "VUID-vkDebugReportMessageEXT-flags-parameter",
                                  "VUID-vkDebugReportMessageEXT-flags-requiredbitmask");
    skip |= context.ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkDebugReportObjectTypeEXT, objectType,
                                       "VUID-vkDebugReportMessageEXT-objectType-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pLayerPrefix), pLayerPrefix,
                                            "VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMessage), pMessage, "VUID-vkDebugReportMessageEXT-pMessage-parameter");
    return skip;
}

bool Device::PreCallValidateDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |= context.ValidateStructType(loc.dot(Field::pTagInfo), pTagInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT, true,
                                       "VUID-vkDebugMarkerSetObjectTagEXT-pTagInfo-parameter",
                                       "VUID-VkDebugMarkerObjectTagInfoEXT-sType-sType");
    if (pTagInfo != nullptr) {
        [[maybe_unused]] const Location pTagInfo_loc = loc.dot(Field::pTagInfo);
        skip |= context.ValidateStructPnext(pTagInfo_loc, pTagInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugMarkerObjectTagInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pTagInfo_loc.dot(Field::objectType), vvl::Enum::VkDebugReportObjectTypeEXT,
                                           pTagInfo->objectType, "VUID-VkDebugMarkerObjectTagInfoEXT-objectType-parameter");

        skip |= context.ValidateArray(pTagInfo_loc.dot(Field::tagSize), pTagInfo_loc.dot(Field::pTag), pTagInfo->tagSize,
                                      &pTagInfo->pTag, true, true, "VUID-VkDebugMarkerObjectTagInfoEXT-tagSize-arraylength",
                                      "VUID-VkDebugMarkerObjectTagInfoEXT-pTag-parameter");
    }
    return skip;
}

bool Device::PreCallValidateDebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |= context.ValidateStructType(loc.dot(Field::pNameInfo), pNameInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
                                       true, "VUID-vkDebugMarkerSetObjectNameEXT-pNameInfo-parameter",
                                       "VUID-VkDebugMarkerObjectNameInfoEXT-sType-sType");
    if (pNameInfo != nullptr) {
        [[maybe_unused]] const Location pNameInfo_loc = loc.dot(Field::pNameInfo);
        skip |= context.ValidateStructPnext(pNameInfo_loc, pNameInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugMarkerObjectNameInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pNameInfo_loc.dot(Field::objectType), vvl::Enum::VkDebugReportObjectTypeEXT,
                                           pNameInfo->objectType, "VUID-VkDebugMarkerObjectNameInfoEXT-objectType-parameter");

        skip |= context.ValidateRequiredPointer(pNameInfo_loc.dot(Field::pObjectName), pNameInfo->pObjectName,
                                                "VUID-VkDebugMarkerObjectNameInfoEXT-pObjectName-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |= context.ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
                                       true, "VUID-vkCmdDebugMarkerBeginEXT-pMarkerInfo-parameter",
                                       "VUID-VkDebugMarkerMarkerInfoEXT-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= context.ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pMarkerInfo_loc.dot(Field::pMarkerName), pMarkerInfo->pMarkerName,
                                                "VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |= context.ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
                                       true, "VUID-vkCmdDebugMarkerInsertEXT-pMarkerInfo-parameter",
                                       "VUID-VkDebugMarkerMarkerInfoEXT-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= context.ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pMarkerInfo_loc.dot(Field::pMarkerName), pMarkerInfo->pMarkerName,
                                                "VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                                               uint32_t bindingCount, const VkBuffer* pBuffers,
                                                               const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= context.ValidateHandleArray(loc.dot(Field::bindingCount), loc.dot(Field::pBuffers), bindingCount, pBuffers, true, true,
                                        "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength");
    skip |= context.ValidateArray(loc.dot(Field::bindingCount), loc.dot(Field::pOffsets), bindingCount, &pOffsets, true, true,
                                  "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength",
                                  "VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-parameter");
    skip |= context.ValidateArray(loc.dot(Field::bindingCount), loc, bindingCount, &pSizes, true, false,
                                  "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength", kVUIDUndefined);
    if (!skip)
        skip |= manual_PreCallValidateCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers,
                                                                         pOffsets, pSizes, context);
    return skip;
}

bool Device::PreCallValidateCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                                         uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                                         const VkDeviceSize* pCounterBufferOffsets,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    // No xml-driven validation
    if (!skip)
        skip |= manual_PreCallValidateCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                                                   pCounterBuffers, pCounterBufferOffsets, context);
    return skip;
}

bool Device::PreCallValidateCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                                       uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                                       const VkDeviceSize* pCounterBufferOffsets,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    // No xml-driven validation
    if (!skip)
        skip |= manual_PreCallValidateCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                                                 pCounterBuffers, pCounterBufferOffsets, context);
    return skip;
}

bool Device::PreCallValidateCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                                    VkQueryControlFlags flags, uint32_t index, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryControlFlagBits, AllVkQueryControlFlagBits, flags,
                                  kOptionalFlags, "VUID-vkCmdBeginQueryIndexedEXT-flags-parameter");
    return skip;
}

bool Device::PreCallValidateCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                                  uint32_t index, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount,
                                                        uint32_t firstInstance, VkBuffer counterBuffer,
                                                        VkDeviceSize counterBufferOffset, uint32_t counterOffset,
                                                        uint32_t vertexStride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::counterBuffer), counterBuffer);
    return skip;
}

bool Device::PreCallValidateCreateCuModuleNVX(VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX, true,
                                   "VUID-vkCreateCuModuleNVX-pCreateInfo-parameter", "VUID-VkCuModuleCreateInfoNVX-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkCuModuleCreateInfoNVX = {VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkCuModuleCreateInfoNVX.size(),
                                            allowed_structs_VkCuModuleCreateInfoNVX.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkCuModuleCreateInfoNVX-pNext-pNext", "VUID-VkCuModuleCreateInfoNVX-sType-unique",
                                            true);

        skip |=
            context.ValidateArray(pCreateInfo_loc.dot(Field::dataSize), pCreateInfo_loc.dot(Field::pData), pCreateInfo->dataSize,
                                  &pCreateInfo->pData, false, true, kVUIDUndefined, "VUID-VkCuModuleCreateInfoNVX-pData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pModule), pModule, "VUID-vkCreateCuModuleNVX-pModule-parameter");
    return skip;
}

bool Device::PreCallValidateCreateCuFunctionNVX(VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo,
                                                const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX,
                                       true, "VUID-vkCreateCuFunctionNVX-pCreateInfo-parameter",
                                       "VUID-VkCuFunctionCreateInfoNVX-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCuFunctionCreateInfoNVX-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::module), pCreateInfo->module);

        skip |= context.ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pName), pCreateInfo->pName,
                                                "VUID-VkCuFunctionCreateInfoNVX-pName-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFunction), pFunction, "VUID-vkCreateCuFunctionNVX-pFunction-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::module), module);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateDestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::function), function);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_binary_import)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= context.ValidateStructType(loc.dot(Field::pLaunchInfo), pLaunchInfo, VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX, true,
                                       "VUID-vkCmdCuLaunchKernelNVX-pLaunchInfo-parameter", "VUID-VkCuLaunchInfoNVX-sType-sType");
    if (pLaunchInfo != nullptr) {
        [[maybe_unused]] const Location pLaunchInfo_loc = loc.dot(Field::pLaunchInfo);
        skip |= context.ValidateStructPnext(pLaunchInfo_loc, pLaunchInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCuLaunchInfoNVX-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pLaunchInfo_loc.dot(Field::function), pLaunchInfo->function);

        skip |= context.ValidateArray(pLaunchInfo_loc.dot(Field::paramCount), pLaunchInfo_loc.dot(Field::pParams),
                                      pLaunchInfo->paramCount, &pLaunchInfo->pParams, false, true, kVUIDUndefined,
                                      "VUID-VkCuLaunchInfoNVX-pParams-parameter");

        skip |= context.ValidateArray(pLaunchInfo_loc.dot(Field::extraCount), pLaunchInfo_loc.dot(Field::pExtras),
                                      pLaunchInfo->extraCount, &pLaunchInfo->pExtras, false, true, kVUIDUndefined,
                                      "VUID-VkCuLaunchInfoNVX-pExtras-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX* pInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_image_view_handle))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_image_view_handle});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX, true,
                                       "VUID-vkGetImageViewHandleNVX-pInfo-parameter", "VUID-VkImageViewHandleInfoNVX-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageViewHandleInfoNVX-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::imageView), pInfo->imageView);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType, pInfo->descriptorType,
                                           "VUID-VkImageViewHandleInfoNVX-descriptorType-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetImageViewHandle64NVX(VkDevice device, const VkImageViewHandleInfoNVX* pInfo,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_image_view_handle))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_image_view_handle});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX, true,
                                   "VUID-vkGetImageViewHandle64NVX-pInfo-parameter", "VUID-VkImageViewHandleInfoNVX-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageViewHandleInfoNVX-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::imageView), pInfo->imageView);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType, pInfo->descriptorType,
                                           "VUID-VkImageViewHandleInfoNVX-descriptorType-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetImageViewAddressNVX(VkDevice device, VkImageView imageView,
                                                   VkImageViewAddressPropertiesNVX* pProperties,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nvx_image_view_handle))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_image_view_handle});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::imageView), imageView);
    skip |= context.ValidateStructType(
        loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX, true,
        "VUID-vkGetImageViewAddressNVX-pProperties-parameter", "VUID-VkImageViewAddressPropertiesNVX-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |= context.ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageViewAddressPropertiesNVX-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                    VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                    uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride,
                                                error_obj);
    return skip;
}

bool Device::PreCallValidateCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                           VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                           uint32_t maxDrawCount, uint32_t stride,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                                       stride, error_obj);
    return skip;
}

bool Device::PreCallValidateGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage,
                                             VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_shader_info)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_shader_info});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= context.ValidateFlags(loc.dot(Field::shaderStage), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                  shaderStage, kRequiredSingleBit, "VUID-vkGetShaderInfoAMD-shaderStage-parameter",
                                  "VUID-vkGetShaderInfoAMD-shaderStage-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::infoType), vvl::Enum::VkShaderInfoTypeAMD, infoType,
                                       "VUID-vkGetShaderInfoAMD-infoType-parameter");
    skip |= context.ValidatePointerArray(loc.dot(Field::pInfoSize), loc.dot(Field::pInfo), pInfoSize, &pInfo, true, false, false,
                                         "VUID-vkGetShaderInfoAMD-pInfoSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetShaderInfoAMD-pInfo-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_GGP
bool Instance::PreCallValidateCreateStreamDescriptorSurfaceGGP(VkInstance instance,
                                                               const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo,
                                                               const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ggp_stream_descriptor_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_GGP_stream_descriptor_surface});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP, true,
        "VUID-vkCreateStreamDescriptorSurfaceGGP-pCreateInfo-parameter", "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface,
                                            "VUID-vkCreateStreamDescriptorSurfaceGGP-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_GGP

bool Instance::PreCallValidateGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage,
    VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_external_memory_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_external_memory_capabilities});
    skip |= context.ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                                       "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-format-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::type), vvl::Enum::VkImageType, type,
                                       "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-type-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::tiling), vvl::Enum::VkImageTiling, tiling,
                                       "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-tiling-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits, usage,
                                  kRequiredFlags, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-parameter",
                                  "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-requiredbitmask");
    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits, flags,
                                  kOptionalFlags, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-flags-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::externalHandleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                  AllVkExternalMemoryHandleTypeFlagBitsNV, externalHandleType, kOptionalFlags,
                                  "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-externalHandleType-parameter");
    skip |= context.ValidateRequiredPointer(
        loc.dot(Field::pExternalImageFormatProperties), pExternalImageFormatProperties,
        "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-pExternalImageFormatProperties-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Device::PreCallValidateGetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory,
                                                   VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_external_memory_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_external_memory_win32});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    skip |= context.ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                  AllVkExternalMemoryHandleTypeFlagBitsNV, handleType, kRequiredFlags,
                                  "VUID-vkGetMemoryWin32HandleNV-handleType-parameter",
                                  "VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetMemoryWin32HandleNV-pHandle-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_VI_NN
bool Instance::PreCallValidateCreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo,
                                                const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nn_vi_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NN_vi_surface});
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN, true,
                                   "VUID-vkCreateViSurfaceNN-pCreateInfo-parameter", "VUID-VkViSurfaceCreateInfoNN-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkViSurfaceCreateInfoNN-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateViSurfaceNN-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_VI_NN

bool Device::PreCallValidateCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer,
                                                            const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_conditional_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_conditional_rendering});
    skip |= context.ValidateStructType(loc.dot(Field::pConditionalRenderingBegin), pConditionalRenderingBegin,
                                       VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT, true,
                                       "VUID-vkCmdBeginConditionalRenderingEXT-pConditionalRenderingBegin-parameter",
                                       "VUID-VkConditionalRenderingBeginInfoEXT-sType-sType");
    if (pConditionalRenderingBegin != nullptr) {
        [[maybe_unused]] const Location pConditionalRenderingBegin_loc = loc.dot(Field::pConditionalRenderingBegin);
        skip |= context.ValidateStructPnext(pConditionalRenderingBegin_loc, pConditionalRenderingBegin->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkConditionalRenderingBeginInfoEXT-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |=
            context.ValidateRequiredHandle(pConditionalRenderingBegin_loc.dot(Field::buffer), pConditionalRenderingBegin->buffer);

        skip |= context.ValidateFlags(pConditionalRenderingBegin_loc.dot(Field::flags),
                                      vvl::FlagBitmask::VkConditionalRenderingFlagBitsEXT, AllVkConditionalRenderingFlagBitsEXT,
                                      pConditionalRenderingBegin->flags, kOptionalFlags,
                                      "VUID-VkConditionalRenderingBeginInfoEXT-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin, context);
    return skip;
}

bool Device::PreCallValidateCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_conditional_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_conditional_rendering});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
                                                     const VkViewportWScalingNV* pViewportWScalings,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_clip_space_w_scaling))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_clip_space_w_scaling});
    skip |= context.ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewportWScalings), viewportCount,
                                  &pViewportWScalings, true, true, "VUID-vkCmdSetViewportWScalingNV-viewportCount-arraylength",
                                  "VUID-vkCmdSetViewportWScalingNV-pViewportWScalings-parameter");
    if (pViewportWScalings != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewportWScalings_loc = loc.dot(Field::pViewportWScalings, viewportIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings,
                                                               context);
    return skip;
}

bool Instance::PreCallValidateReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_direct_mode_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_direct_mode_display});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
bool Instance::PreCallValidateAcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_acquire_xlib_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::dpy), dpy, "VUID-vkAcquireXlibDisplayEXT-dpy-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

bool Instance::PreCallValidateGetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput,
                                                       VkDisplayKHR* pDisplay, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_acquire_xlib_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::dpy), dpy, "VUID-vkGetRandROutputDisplayEXT-dpy-parameter");
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pDisplay), pDisplay, "VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_XLIB_XRANDR_EXT

bool Instance::PreCallValidateGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                       VkSurfaceCapabilities2EXT* pSurfaceCapabilities,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_display_surface_counter))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_surface_counter});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= context.ValidateStructType(loc.dot(Field::pSurfaceCapabilities), pSurfaceCapabilities,
                                       VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT, true,
                                       "VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter",
                                       "VUID-VkSurfaceCapabilities2EXT-sType-sType");
    if (pSurfaceCapabilities != nullptr) {
        [[maybe_unused]] const Location pSurfaceCapabilities_loc = loc.dot(Field::pSurfaceCapabilities);
        skip |= context.ValidateStructPnext(pSurfaceCapabilities_loc, pSurfaceCapabilities->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkSurfaceCapabilities2EXT-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display,
                                                   const VkDisplayPowerInfoEXT* pDisplayPowerInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= context.ValidateStructType(
        loc.dot(Field::pDisplayPowerInfo), pDisplayPowerInfo, VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT, true,
        "VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter", "VUID-VkDisplayPowerInfoEXT-sType-sType");
    if (pDisplayPowerInfo != nullptr) {
        [[maybe_unused]] const Location pDisplayPowerInfo_loc = loc.dot(Field::pDisplayPowerInfo);
        skip |=
            context.ValidateStructPnext(pDisplayPowerInfo_loc, pDisplayPowerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkDisplayPowerInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pDisplayPowerInfo_loc.dot(Field::powerState), vvl::Enum::VkDisplayPowerStateEXT,
                                           pDisplayPowerInfo->powerState, "VUID-VkDisplayPowerInfoEXT-powerState-parameter");
    }
    return skip;
}

bool Device::PreCallValidateRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo,
                                                   const VkAllocationCallbacks* pAllocator, VkFence* pFence,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= context.ValidateStructType(loc.dot(Field::pDeviceEventInfo), pDeviceEventInfo, VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
                                       true, "VUID-vkRegisterDeviceEventEXT-pDeviceEventInfo-parameter",
                                       "VUID-VkDeviceEventInfoEXT-sType-sType");
    if (pDeviceEventInfo != nullptr) {
        [[maybe_unused]] const Location pDeviceEventInfo_loc = loc.dot(Field::pDeviceEventInfo);
        skip |= context.ValidateStructPnext(pDeviceEventInfo_loc, pDeviceEventInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceEventInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pDeviceEventInfo_loc.dot(Field::deviceEvent), vvl::Enum::VkDeviceEventTypeEXT,
                                           pDeviceEventInfo->deviceEvent, "VUID-VkDeviceEventInfoEXT-deviceEvent-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFence), pFence, "VUID-vkRegisterDeviceEventEXT-pFence-parameter");
    return skip;
}

bool Device::PreCallValidateRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display,
                                                    const VkDisplayEventInfoEXT* pDisplayEventInfo,
                                                    const VkAllocationCallbacks* pAllocator, VkFence* pFence,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= context.ValidateStructType(
        loc.dot(Field::pDisplayEventInfo), pDisplayEventInfo, VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT, true,
        "VUID-vkRegisterDisplayEventEXT-pDisplayEventInfo-parameter", "VUID-VkDisplayEventInfoEXT-sType-sType");
    if (pDisplayEventInfo != nullptr) {
        [[maybe_unused]] const Location pDisplayEventInfo_loc = loc.dot(Field::pDisplayEventInfo);
        skip |=
            context.ValidateStructPnext(pDisplayEventInfo_loc, pDisplayEventInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkDisplayEventInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pDisplayEventInfo_loc.dot(Field::displayEvent), vvl::Enum::VkDisplayEventTypeEXT,
                                           pDisplayEventInfo->displayEvent, "VUID-VkDisplayEventInfoEXT-displayEvent-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pFence), pFence, "VUID-vkRegisterDisplayEventEXT-pFence-parameter");
    return skip;
}

bool Device::PreCallValidateGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter,
                                                   uint64_t* pCounterValue, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateFlags(
        loc.dot(Field::counter), vvl::FlagBitmask::VkSurfaceCounterFlagBitsEXT, AllVkSurfaceCounterFlagBitsEXT, counter,
        kRequiredSingleBit, "VUID-vkGetSwapchainCounterEXT-counter-parameter", "VUID-vkGetSwapchainCounterEXT-counter-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCounterValue), pCounterValue,
                                            "VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter");
    return skip;
}

bool Device::PreCallValidateGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain,
                                                          VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_google_display_timing))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_GOOGLE_display_timing});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDisplayTimingProperties), pDisplayTimingProperties,
                                            "VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter");
    return skip;
}

bool Device::PreCallValidateGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain,
                                                            uint32_t* pPresentationTimingCount,
                                                            VkPastPresentationTimingGOOGLE* pPresentationTimings,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_google_display_timing))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_GOOGLE_display_timing});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidatePointerArray(loc.dot(Field::pPresentationTimingCount), loc.dot(Field::pPresentationTimings),
                                         pPresentationTimingCount, &pPresentationTimings, true, false, false,
                                         "VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimingCount-parameter",
                                         kVUIDUndefined, "VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter");
    if (pPresentationTimings != nullptr) {
        for (uint32_t pPresentationTimingIndex = 0; pPresentationTimingIndex < *pPresentationTimingCount;
             ++pPresentationTimingIndex) {
            [[maybe_unused]] const Location pPresentationTimings_loc =
                loc.dot(Field::pPresentationTimings, pPresentationTimingIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle,
                                                      uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_discard_rectangles))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_discard_rectangles});
    skip |=
        context.ValidateArray(loc.dot(Field::discardRectangleCount), loc.dot(Field::pDiscardRectangles), discardRectangleCount,
                              &pDiscardRectangles, true, true, "VUID-vkCmdSetDiscardRectangleEXT-discardRectangleCount-arraylength",
                              "VUID-vkCmdSetDiscardRectangleEXT-pDiscardRectangles-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount,
                                                                pDiscardRectangles, context);
    return skip;
}

bool Device::PreCallValidateCmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_discard_rectangles))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_discard_rectangles});
    skip |= context.ValidateBool32(loc.dot(Field::discardRectangleEnable), discardRectangleEnable);
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable, context);
    return skip;
}

bool Device::PreCallValidateCmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer,
                                                          VkDiscardRectangleModeEXT discardRectangleMode,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_discard_rectangles))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_discard_rectangles});
    skip |= context.ValidateRangedEnum(loc.dot(Field::discardRectangleMode), vvl::Enum::VkDiscardRectangleModeEXT,
                                       discardRectangleMode, "VUID-vkCmdSetDiscardRectangleModeEXT-discardRectangleMode-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode, context);
    return skip;
}

bool Device::PreCallValidateSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains,
                                              const VkHdrMetadataEXT* pMetadata, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_hdr_metadata)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_hdr_metadata});
    skip |= context.ValidateHandleArray(loc.dot(Field::swapchainCount), loc.dot(Field::pSwapchains), swapchainCount, pSwapchains,
                                        true, true, "VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength");
    skip |= context.ValidateStructTypeArray(loc.dot(Field::swapchainCount), loc.dot(Field::pMetadata), swapchainCount, pMetadata,
                                            VK_STRUCTURE_TYPE_HDR_METADATA_EXT, true, true, "VUID-VkHdrMetadataEXT-sType-sType",
                                            "VUID-vkSetHdrMetadataEXT-pMetadata-parameter",
                                            "VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength");
    if (pMetadata != nullptr) {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex) {
            [[maybe_unused]] const Location pMetadata_loc = loc.dot(Field::pMetadata, swapchainIndex);
            constexpr std::array allowed_structs_VkHdrMetadataEXT = {VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI};

            skip |=
                context.ValidateStructPnext(pMetadata_loc, pMetadata[swapchainIndex].pNext, allowed_structs_VkHdrMetadataEXT.size(),
                                            allowed_structs_VkHdrMetadataEXT.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkHdrMetadataEXT-pNext-pNext", "VUID-VkHdrMetadataEXT-sType-unique", true);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_IOS_MVK
bool Instance::PreCallValidateCreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
                                                  const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_mvk_ios_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_MVK_ios_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
                                       true, "VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter",
                                       "VUID-VkIOSSurfaceCreateInfoMVK-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateIOSSurfaceMVK-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
bool Instance::PreCallValidateCreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
                                                    const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_mvk_macos_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_MVK_macos_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
                                       true, "VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter",
                                       "VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_MACOS_MVK

bool Device::PreCallValidateSetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(loc.dot(Field::pNameInfo), pNameInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                                       true, "VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-parameter",
                                       "VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType");
    if (pNameInfo != nullptr) {
        [[maybe_unused]] const Location pNameInfo_loc = loc.dot(Field::pNameInfo);
        skip |= context.ValidateRangedEnum(pNameInfo_loc.dot(Field::objectType), vvl::Enum::VkObjectType, pNameInfo->objectType,
                                           "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateSetDebugUtilsObjectNameEXT(device, pNameInfo, context);
    return skip;
}

bool Device::PreCallValidateSetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(loc.dot(Field::pTagInfo), pTagInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT, true,
                                       "VUID-vkSetDebugUtilsObjectTagEXT-pTagInfo-parameter",
                                       "VUID-VkDebugUtilsObjectTagInfoEXT-sType-sType");
    if (pTagInfo != nullptr) {
        [[maybe_unused]] const Location pTagInfo_loc = loc.dot(Field::pTagInfo);
        skip |= context.ValidateStructPnext(pTagInfo_loc, pTagInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugUtilsObjectTagInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pTagInfo_loc.dot(Field::objectType), vvl::Enum::VkObjectType, pTagInfo->objectType,
                                           "VUID-VkDebugUtilsObjectTagInfoEXT-objectType-parameter");

        skip |= context.ValidateArray(pTagInfo_loc.dot(Field::tagSize), pTagInfo_loc.dot(Field::pTag), pTagInfo->tagSize,
                                      &pTagInfo->pTag, true, true, "VUID-VkDebugUtilsObjectTagInfoEXT-tagSize-arraylength",
                                      "VUID-VkDebugUtilsObjectTagInfoEXT-pTag-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateSetDebugUtilsObjectTagEXT(device, pTagInfo, context);
    return skip;
}

bool Device::PreCallValidateQueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                                       "VUID-vkQueueBeginDebugUtilsLabelEXT-pLabelInfo-parameter",
                                       "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= context.ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                                "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool Device::PreCallValidateQueueEndDebugUtilsLabelEXT(VkQueue queue, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateQueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                                       "VUID-vkQueueInsertDebugUtilsLabelEXT-pLabelInfo-parameter",
                                       "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= context.ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                                "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                                       "VUID-vkCmdBeginDebugUtilsLabelEXT-pLabelInfo-parameter",
                                       "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= context.ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                                "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                                       "VUID-vkCmdInsertDebugUtilsLabelEXT-pLabelInfo-parameter",
                                       "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= context.ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                                "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool Instance::PreCallValidateCreateDebugUtilsMessengerEXT(VkInstance instance,
                                                           const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           VkDebugUtilsMessengerEXT* pMessenger,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, true,
        "VUID-vkCreateDebugUtilsMessengerEXT-pCreateInfo-parameter", "VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::messageSeverity),
                                      vvl::FlagBitmask::VkDebugUtilsMessageSeverityFlagBitsEXT,
                                      AllVkDebugUtilsMessageSeverityFlagBitsEXT, pCreateInfo->messageSeverity, kRequiredFlags,
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter",
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::messageType), vvl::FlagBitmask::VkDebugUtilsMessageTypeFlagBitsEXT,
                                      AllVkDebugUtilsMessageTypeFlagBitsEXT, pCreateInfo->messageType, kRequiredFlags,
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter",
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask");

        skip |= context.ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pfnUserCallback),
                                                reinterpret_cast<const void*>(pCreateInfo->pfnUserCallback),
                                                "VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMessenger), pMessenger,
                                            "VUID-vkCreateDebugUtilsMessengerEXT-pMessenger-parameter");
    return skip;
}

bool Instance::PreCallValidateDestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Instance::PreCallValidateSubmitDebugUtilsMessageEXT(VkInstance instance,
                                                         VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                                         VkDebugUtilsMessageTypeFlagsEXT messageTypes,
                                                         const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_debug_utils)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= context.ValidateFlags(loc.dot(Field::messageSeverity), vvl::FlagBitmask::VkDebugUtilsMessageSeverityFlagBitsEXT,
                                  AllVkDebugUtilsMessageSeverityFlagBitsEXT, messageSeverity, kRequiredSingleBit,
                                  "VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter",
                                  "VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter");
    skip |= context.ValidateFlags(loc.dot(Field::messageTypes), vvl::FlagBitmask::VkDebugUtilsMessageTypeFlagBitsEXT,
                                  AllVkDebugUtilsMessageTypeFlagBitsEXT, messageTypes, kRequiredFlags,
                                  "VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-parameter",
                                  "VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask");
    skip |= context.ValidateStructType(
        loc.dot(Field::pCallbackData), pCallbackData, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, true,
        "VUID-vkSubmitDebugUtilsMessageEXT-pCallbackData-parameter", "VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-sType");
    if (pCallbackData != nullptr) {
        [[maybe_unused]] const Location pCallbackData_loc = loc.dot(Field::pCallbackData);
        constexpr std::array allowed_structs_VkDebugUtilsMessengerCallbackDataEXT = {
            VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT};

        skip |= context.ValidateStructPnext(pCallbackData_loc, pCallbackData->pNext,
                                            allowed_structs_VkDebugUtilsMessengerCallbackDataEXT.size(),
                                            allowed_structs_VkDebugUtilsMessengerCallbackDataEXT.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsMessengerCallbackDataEXT-pNext-pNext",
                                            "VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-unique", true);

        skip |= context.ValidateReservedFlags(pCallbackData_loc.dot(Field::flags), pCallbackData->flags,
                                              "VUID-VkDebugUtilsMessengerCallbackDataEXT-flags-zerobitmask");

        skip |= context.ValidateStructTypeArray(pCallbackData_loc.dot(Field::queueLabelCount),
                                                pCallbackData_loc.dot(Field::pQueueLabels), pCallbackData->queueLabelCount,
                                                pCallbackData->pQueueLabels, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, false, true,
                                                "VUID-VkDebugUtilsLabelEXT-sType-sType",
                                                "VUID-VkDebugUtilsMessengerCallbackDataEXT-pQueueLabels-parameter", kVUIDUndefined);

        if (pCallbackData->pQueueLabels != nullptr) {
            for (uint32_t queueLabelIndex = 0; queueLabelIndex < pCallbackData->queueLabelCount; ++queueLabelIndex) {
                [[maybe_unused]] const Location pQueueLabels_loc = pCallbackData_loc.dot(Field::pQueueLabels, queueLabelIndex);
                skip |= context.ValidateStructPnext(pQueueLabels_loc, pCallbackData->pQueueLabels[queueLabelIndex].pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateRequiredPointer(pQueueLabels_loc.dot(Field::pLabelName),
                                                        pCallbackData->pQueueLabels[queueLabelIndex].pLabelName,
                                                        "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
            }
        }

        skip |= context.ValidateStructTypeArray(
            pCallbackData_loc.dot(Field::cmdBufLabelCount), pCallbackData_loc.dot(Field::pCmdBufLabels),
            pCallbackData->cmdBufLabelCount, pCallbackData->pCmdBufLabels, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, false, true,
            "VUID-VkDebugUtilsLabelEXT-sType-sType", "VUID-VkDebugUtilsMessengerCallbackDataEXT-pCmdBufLabels-parameter",
            kVUIDUndefined);

        if (pCallbackData->pCmdBufLabels != nullptr) {
            for (uint32_t cmdBufLabelIndex = 0; cmdBufLabelIndex < pCallbackData->cmdBufLabelCount; ++cmdBufLabelIndex) {
                [[maybe_unused]] const Location pCmdBufLabels_loc = pCallbackData_loc.dot(Field::pCmdBufLabels, cmdBufLabelIndex);
                skip |= context.ValidateStructPnext(pCmdBufLabels_loc, pCallbackData->pCmdBufLabels[cmdBufLabelIndex].pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateRequiredPointer(pCmdBufLabels_loc.dot(Field::pLabelName),
                                                        pCallbackData->pCmdBufLabels[cmdBufLabelIndex].pLabelName,
                                                        "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
            }
        }

        skip |= context.ValidateStructTypeArray(pCallbackData_loc.dot(Field::objectCount), pCallbackData_loc.dot(Field::pObjects),
                                                pCallbackData->objectCount, pCallbackData->pObjects,
                                                VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, false, true,
                                                "VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType",
                                                "VUID-VkDebugUtilsMessengerCallbackDataEXT-pObjects-parameter", kVUIDUndefined);

        if (pCallbackData->pObjects != nullptr) {
            for (uint32_t objectIndex = 0; objectIndex < pCallbackData->objectCount; ++objectIndex) {
                [[maybe_unused]] const Location pObjects_loc = pCallbackData_loc.dot(Field::pObjects, objectIndex);
                skip |= context.ValidateRangedEnum(pObjects_loc.dot(Field::objectType), vvl::Enum::VkObjectType,
                                                   pCallbackData->pObjects[objectIndex].objectType,
                                                   "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter");
            }
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool Device::PreCallValidateGetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer* buffer,
                                                                      VkAndroidHardwareBufferPropertiesANDROID* pProperties,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_ANDROID_external_memory_android_hardware_buffer});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::buffer), buffer,
                                            "VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pProperties), pProperties,
                                       VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID, true,
                                       "VUID-vkGetAndroidHardwareBufferPropertiesANDROID-pProperties-parameter",
                                       "VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        constexpr std::array allowed_structs_VkAndroidHardwareBufferPropertiesANDROID = {
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID};

        skip |= context.ValidateStructPnext(
            pProperties_loc, pProperties->pNext, allowed_structs_VkAndroidHardwareBufferPropertiesANDROID.size(),
            allowed_structs_VkAndroidHardwareBufferPropertiesANDROID.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkAndroidHardwareBufferPropertiesANDROID-pNext-pNext",
            "VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateGetMemoryAndroidHardwareBufferANDROID(VkDevice device,
                                                                  const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo,
                                                                  struct AHardwareBuffer** pBuffer,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_android_external_memory_android_hardware_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_ANDROID_external_memory_android_hardware_buffer});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
                                   true, "VUID-vkGetMemoryAndroidHardwareBufferANDROID-pInfo-parameter",
                                   "VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::memory), pInfo->memory);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pBuffer), pBuffer,
                                            "VUID-vkGetMemoryAndroidHardwareBufferANDROID-pBuffer-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool Device::PreCallValidateCreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache,
                                                              uint32_t createInfoCount,
                                                              const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos,
                                                              const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount,
                                            pCreateInfos, VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX, true, true,
                                            "VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-sType",
                                            "VUID-vkCreateExecutionGraphPipelinesAMDX-pCreateInfos-parameter",
                                            "VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX = {
                VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO};

            skip |=
                context.ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                            allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX.size(),
                                            allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pNext-pNext",
                                            "VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-unique", true);

            skip |=
                context.ValidateStructTypeArray(pCreateInfos_loc.dot(Field::stageCount), pCreateInfos_loc.dot(Field::pStages),
                                                pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages,
                                                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, false,
                                                "VUID-VkPipelineShaderStageCreateInfo-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pStages != nullptr) {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex) {
                    [[maybe_unused]] const Location pStages_loc = pCreateInfos_loc.dot(Field::pStages, stageIndex);
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                    skip |= context.ValidateStructPnext(pStages_loc, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext,
                                                        allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                        allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                        "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

                    skip |= context.ValidateFlags(
                        pStages_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                        AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].flags,
                        kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |= context.ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                                  AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage,
                                                  kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                                  "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= context.ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                            pCreateInfos[createInfoIndex].pStages[stageIndex].pName,
                                                            "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                        [[maybe_unused]] const Location pSpecializationInfo_loc = pStages_loc.dot(Field::pSpecializationInfo);
                        skip |= context.ValidateArray(
                            pSpecializationInfo_loc.dot(Field::mapEntryCount), pSpecializationInfo_loc.dot(Field::pMapEntries),
                            pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                            &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true,
                            kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr) {
                            for (uint32_t mapEntryIndex = 0;
                                 mapEntryIndex <
                                 pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                 ++mapEntryIndex) {
                                [[maybe_unused]] const Location pMapEntries_loc =
                                    pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                // No xml-driven validation
                            }
                        }

                        skip |= context.ValidateArray(
                            pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                            pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                            &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true,
                            kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |=
                context.ValidateStructType(pCreateInfos_loc.dot(Field::pLibraryInfo), pCreateInfos[createInfoIndex].pLibraryInfo,
                                           VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, false,
                                           "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-parameter",
                                           "VUID-VkPipelineLibraryCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInfo != nullptr) {
                [[maybe_unused]] const Location pLibraryInfo_loc = pCreateInfos_loc.dot(Field::pLibraryInfo);
                skip |= context.ValidateArray(pLibraryInfo_loc.dot(Field::libraryCount), pLibraryInfo_loc.dot(Field::pLibraries),
                                              pCreateInfos[createInfoIndex].pLibraryInfo->libraryCount,
                                              &pCreateInfos[createInfoIndex].pLibraryInfo->pLibraries, false, true, kVUIDUndefined,
                                              "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }

            skip |= context.ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true,
                                  true, "VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength",
                                  "VUID-vkCreateExecutionGraphPipelinesAMDX-pPipelines-parameter");
    return skip;
}

bool Device::PreCallValidateGetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph,
                                                                     VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::executionGraph), executionGraph);
    skip |= context.ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo,
                                       VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX, true,
                                       "VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-pSizeInfo-parameter",
                                       "VUID-VkExecutionGraphPipelineScratchSizeAMDX-sType-sType");
    return skip;
}

bool Device::PreCallValidateGetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph,
                                                                   const VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo,
                                                                   uint32_t* pNodeIndex, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::executionGraph), executionGraph);
    skip |= context.ValidateStructType(loc.dot(Field::pNodeInfo), pNodeInfo,
                                       VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX, true,
                                       "VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeInfo-parameter",
                                       "VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pNodeIndex), pNodeIndex,
                                            "VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeIndex-parameter");
    return skip;
}

bool Device::PreCallValidateCmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph,
                                                                VkDeviceAddress scratch, VkDeviceSize scratchSize,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::executionGraph), executionGraph);
    return skip;
}

bool Device::PreCallValidateCmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize,
                                                 const VkDispatchGraphCountInfoAMDX* pCountInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pCountInfo), pCountInfo, "VUID-vkCmdDispatchGraphAMDX-pCountInfo-parameter");
    return skip;
}

bool Device::PreCallValidateCmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                         VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX* pCountInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCountInfo), pCountInfo,
                                            "VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-parameter");
    return skip;
}

bool Device::PreCallValidateCmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                              VkDeviceSize scratchSize, VkDeviceAddress countInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    // No xml-driven validation
    return skip;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

bool Device::PreCallValidateCmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer,
                                                     const VkSampleLocationsInfoEXT* pSampleLocationsInfo,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_sample_locations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_sample_locations});
    skip |= context.ValidateStructType(
        loc.dot(Field::pSampleLocationsInfo), pSampleLocationsInfo, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, true,
        "VUID-vkCmdSetSampleLocationsEXT-pSampleLocationsInfo-parameter", "VUID-VkSampleLocationsInfoEXT-sType-sType");
    if (pSampleLocationsInfo != nullptr) {
        [[maybe_unused]] const Location pSampleLocationsInfo_loc = loc.dot(Field::pSampleLocationsInfo);
        // No xml-driven validation

        skip |= context.ValidateArray(pSampleLocationsInfo_loc.dot(Field::sampleLocationsCount),
                                      pSampleLocationsInfo_loc.dot(Field::pSampleLocations),
                                      pSampleLocationsInfo->sampleLocationsCount, &pSampleLocationsInfo->pSampleLocations, false,
                                      true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

        if (pSampleLocationsInfo->pSampleLocations != nullptr) {
            for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < pSampleLocationsInfo->sampleLocationsCount;
                 ++sampleLocationsIndex) {
                [[maybe_unused]] const Location pSampleLocations_loc =
                    pSampleLocationsInfo_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice,
                                                                        VkSampleCountFlagBits samples,
                                                                        VkMultisamplePropertiesEXT* pMultisampleProperties,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateFlags(loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits,
                                  samples, kRequiredSingleBit, "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter",
                                  "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pMultisampleProperties), pMultisampleProperties,
                                       VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, true,
                                       "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-pMultisampleProperties-parameter",
                                       "VUID-VkMultisamplePropertiesEXT-sType-sType");
    if (pMultisampleProperties != nullptr) {
        [[maybe_unused]] const Location pMultisampleProperties_loc = loc.dot(Field::pMultisampleProperties);
        skip |= context.ValidateStructPnext(pMultisampleProperties_loc, pMultisampleProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMultisamplePropertiesEXT-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image,
                                                                   VkImageDrmFormatModifierPropertiesEXT* pProperties,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_image_drm_format_modifier))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_image_drm_format_modifier});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= context.ValidateStructType(loc.dot(Field::pProperties), pProperties,
                                       VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT, true,
                                       "VUID-vkGetImageDrmFormatModifierPropertiesEXT-pProperties-parameter",
                                       "VUID-VkImageDrmFormatModifierPropertiesEXT-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |= context.ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageDrmFormatModifierPropertiesEXT-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateCreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator,
                                                     VkValidationCacheEXT* pValidationCache, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
                                       true, "VUID-vkCreateValidationCacheEXT-pCreateInfo-parameter",
                                       "VUID-VkValidationCacheCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkValidationCacheCreateInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkValidationCacheCreateInfoEXT-flags-zerobitmask");

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::initialDataSize), pCreateInfo_loc.dot(Field::pInitialData),
                                      pCreateInfo->initialDataSize, &pCreateInfo->pInitialData, false, true, kVUIDUndefined,
                                      "VUID-VkValidationCacheCreateInfoEXT-pInitialData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pValidationCache), pValidationCache,
                                            "VUID-vkCreateValidationCacheEXT-pValidationCache-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache,
                                                      const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateMergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount,
                                                     const VkValidationCacheEXT* pSrcCaches, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstCache), dstCache);
    skip |= context.ValidateHandleArray(loc.dot(Field::srcCacheCount), loc.dot(Field::pSrcCaches), srcCacheCount, pSrcCaches, true,
                                        true, "VUID-vkMergeValidationCachesEXT-srcCacheCount-arraylength");
    return skip;
}

bool Device::PreCallValidateGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize,
                                                      void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::validationCache), validationCache);
    skip |= context.ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                         "VUID-vkGetValidationCacheDataEXT-pDataSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetValidationCacheDataEXT-pData-parameter");
    return skip;
}

bool Device::PreCallValidateCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView,
                                                      VkImageLayout imageLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_shading_rate_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_shading_rate_image});
    skip |= context.ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                                       "VUID-vkCmdBindShadingRateImageNV-imageLayout-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                               uint32_t viewportCount,
                                                               const VkShadingRatePaletteNV* pShadingRatePalettes,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_shading_rate_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_shading_rate_image});
    skip |= context.ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pShadingRatePalettes), viewportCount,
                                  &pShadingRatePalettes, true, true,
                                  "VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-arraylength",
                                  "VUID-vkCmdSetViewportShadingRatePaletteNV-pShadingRatePalettes-parameter");
    if (pShadingRatePalettes != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pShadingRatePalettes_loc = loc.dot(Field::pShadingRatePalettes, viewportIndex);
            skip |= context.ValidateRangedEnumArray(pShadingRatePalettes_loc.dot(Field::shadingRatePaletteEntryCount),
                                                    pShadingRatePalettes_loc.dot(Field::pShadingRatePaletteEntries),
                                                    vvl::Enum::VkShadingRatePaletteEntryNV,
                                                    pShadingRatePalettes[viewportIndex].shadingRatePaletteEntryCount,
                                                    pShadingRatePalettes[viewportIndex].pShadingRatePaletteEntries, true, true,
                                                    "VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-arraylength",
                                                    "VUID-VkShadingRatePaletteNV-pShadingRatePaletteEntries-parameter");
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount,
                                                                         pShadingRatePalettes, context);
    return skip;
}

bool Device::PreCallValidateCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType,
                                                      uint32_t customSampleOrderCount,
                                                      const VkCoarseSampleOrderCustomNV* pCustomSampleOrders,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_shading_rate_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_shading_rate_image});
    skip |= context.ValidateRangedEnum(loc.dot(Field::sampleOrderType), vvl::Enum::VkCoarseSampleOrderTypeNV, sampleOrderType,
                                       "VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-parameter");
    skip |= context.ValidateArray(loc.dot(Field::customSampleOrderCount), loc.dot(Field::pCustomSampleOrders),
                                  customSampleOrderCount, &pCustomSampleOrders, false, true, kVUIDUndefined,
                                  "VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-parameter");
    if (pCustomSampleOrders != nullptr) {
        for (uint32_t customSampleOrderIndex = 0; customSampleOrderIndex < customSampleOrderCount; ++customSampleOrderIndex) {
            [[maybe_unused]] const Location pCustomSampleOrders_loc = loc.dot(Field::pCustomSampleOrders, customSampleOrderIndex);
            skip |= context.ValidateRangedEnum(
                pCustomSampleOrders_loc.dot(Field::shadingRate), vvl::Enum::VkShadingRatePaletteEntryNV,
                pCustomSampleOrders[customSampleOrderIndex].shadingRate, "VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter");

            skip |= context.ValidateArray(pCustomSampleOrders_loc.dot(Field::sampleLocationCount),
                                          pCustomSampleOrders_loc.dot(Field::pSampleLocations),
                                          pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount,
                                          &pCustomSampleOrders[customSampleOrderIndex].pSampleLocations, true, true,
                                          "VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength",
                                          "VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter");

            if (pCustomSampleOrders[customSampleOrderIndex].pSampleLocations != nullptr) {
                for (uint32_t sampleLocationIndex = 0;
                     sampleLocationIndex < pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount; ++sampleLocationIndex) {
                    [[maybe_unused]] const Location pSampleLocations_loc =
                        pCustomSampleOrders_loc.dot(Field::pSampleLocations, sampleLocationIndex);
                    // No xml-driven validation
                }
            }
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount,
                                                                pCustomSampleOrders, context);
    return skip;
}

bool Device::PreCallValidateCreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          VkAccelerationStructureNV* pAccelerationStructure,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV, true,
        "VUID-vkCreateAccelerationStructureNV-pCreateInfo-parameter", "VUID-VkAccelerationStructureCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkAccelerationStructureCreateInfoNV = {
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkAccelerationStructureCreateInfoNV.size(),
            allowed_structs_VkAccelerationStructureCreateInfoNV.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkAccelerationStructureCreateInfoNV-pNext-pNext", "VUID-VkAccelerationStructureCreateInfoNV-sType-unique", true);

        skip |= context.ValidateStructType(pCreateInfo_loc.dot(Field::info), &(pCreateInfo->info),
                                           VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, false, kVUIDUndefined,
                                           "VUID-VkAccelerationStructureInfoNV-sType-sType");

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructTypeArray(pCreateInfo_loc.dot(Field::geometryCount), pCreateInfo_loc.dot(Field::pGeometries),
                                                pCreateInfo->info.geometryCount, pCreateInfo->info.pGeometries,
                                                VK_STRUCTURE_TYPE_GEOMETRY_NV, false, true, "VUID-VkGeometryNV-sType-sType",
                                                "VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", kVUIDUndefined);

        if (pCreateInfo->info.pGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pCreateInfo->info.geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location pGeometries_loc = pCreateInfo_loc.dot(Field::pGeometries, geometryIndex);
                skip |= context.ValidateStructPnext(pGeometries_loc, pCreateInfo->info.pGeometries[geometryIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkGeometryNV-pNext-pNext", kVUIDUndefined,
                                                    true);

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                   pCreateInfo->info.pGeometries[geometryIndex].geometryType,
                                                   "VUID-VkGeometryNV-geometryType-parameter");

                skip |= context.ValidateStructType(
                    pGeometries_loc.dot(Field::triangles), &(pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles),
                    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, false, kVUIDUndefined, "VUID-VkGeometryTrianglesNV-sType-sType");

                skip |= context.ValidateStructPnext(
                    pGeometries_loc, pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.pNext, 0, nullptr,
                    GeneratedVulkanHeaderVersion, "VUID-VkGeometryTrianglesNV-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat,
                                                   pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.vertexFormat,
                                                   "VUID-VkGeometryTrianglesNV-vertexFormat-parameter");

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::indexType), vvl::Enum::VkIndexType,
                                                   pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.indexType,
                                                   "VUID-VkGeometryTrianglesNV-indexType-parameter");

                skip |= context.ValidateStructType(
                    pGeometries_loc.dot(Field::aabbs), &(pCreateInfo->info.pGeometries[geometryIndex].geometry.aabbs),
                    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, false, kVUIDUndefined, "VUID-VkGeometryAABBNV-sType-sType");

                skip |= context.ValidateStructPnext(
                    pGeometries_loc, pCreateInfo->info.pGeometries[geometryIndex].geometry.aabbs.pNext, 0, nullptr,
                    GeneratedVulkanHeaderVersion, "VUID-VkGeometryAABBNV-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                              AllVkGeometryFlagBitsKHR, pCreateInfo->info.pGeometries[geometryIndex].flags,
                                              kOptionalFlags, "VUID-VkGeometryNV-flags-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pAccelerationStructure), pAccelerationStructure,
                                            "VUID-vkCreateAccelerationStructureNV-pAccelerationStructure-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure, context);
    return skip;
}

bool Device::PreCallValidateDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetAccelerationStructureMemoryRequirementsNV(
    VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV, true,
                                       "VUID-vkGetAccelerationStructureMemoryRequirementsNV-pInfo-parameter",
                                       "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |=
            context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureMemoryRequirementsTypeNV,
                                           pInfo->type, "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-type-parameter");

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::accelerationStructure), pInfo->accelerationStructure);
    }
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements,
                                       VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
                                       "VUID-vkGetAccelerationStructureMemoryRequirementsNV-pMemoryRequirements-parameter",
                                       "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount,
                                                              const VkBindAccelerationStructureMemoryInfoNV* pBindInfos,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfos), bindInfoCount, pBindInfos,
                                            VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV, true, true,
                                            "VUID-VkBindAccelerationStructureMemoryInfoNV-sType-sType",
                                            "VUID-vkBindAccelerationStructureMemoryNV-pBindInfos-parameter",
                                            "VUID-vkBindAccelerationStructureMemoryNV-bindInfoCount-arraylength");
    if (pBindInfos != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfos_loc = loc.dot(Field::pBindInfos, bindInfoIndex);
            skip |= context.ValidateStructPnext(pBindInfos_loc, pBindInfos[bindInfoIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion,
                                                "VUID-VkBindAccelerationStructureMemoryInfoNV-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRequiredHandle(pBindInfos_loc.dot(Field::accelerationStructure),
                                                   pBindInfos[bindInfoIndex].accelerationStructure);

            skip |= context.ValidateRequiredHandle(pBindInfos_loc.dot(Field::memory), pBindInfos[bindInfoIndex].memory);

            skip |= context.ValidateArray(pBindInfos_loc.dot(Field::deviceIndexCount), pBindInfos_loc.dot(Field::pDeviceIndices),
                                          pBindInfos[bindInfoIndex].deviceIndexCount, &pBindInfos[bindInfoIndex].pDeviceIndices,
                                          false, true, kVUIDUndefined,
                                          "VUID-VkBindAccelerationStructureMemoryInfoNV-pDeviceIndices-parameter");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer,
                                                            const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData,
                                                            VkDeviceSize instanceOffset, VkBool32 update,
                                                            VkAccelerationStructureNV dst, VkAccelerationStructureNV src,
                                                            VkBuffer scratch, VkDeviceSize scratchOffset,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, true,
                                       "VUID-vkCmdBuildAccelerationStructureNV-pInfo-parameter",
                                       "VUID-VkAccelerationStructureInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructTypeArray(pInfo_loc.dot(Field::geometryCount), pInfo_loc.dot(Field::pGeometries),
                                                pInfo->geometryCount, pInfo->pGeometries, VK_STRUCTURE_TYPE_GEOMETRY_NV, false,
                                                true, "VUID-VkGeometryNV-sType-sType",
                                                "VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", kVUIDUndefined);

        if (pInfo->pGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pInfo->geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location pGeometries_loc = pInfo_loc.dot(Field::pGeometries, geometryIndex);
                skip |= context.ValidateStructPnext(pGeometries_loc, pInfo->pGeometries[geometryIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion, "VUID-VkGeometryNV-pNext-pNext", kVUIDUndefined,
                                                    true);

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                   pInfo->pGeometries[geometryIndex].geometryType,
                                                   "VUID-VkGeometryNV-geometryType-parameter");

                skip |= context.ValidateStructType(
                    pGeometries_loc.dot(Field::triangles), &(pInfo->pGeometries[geometryIndex].geometry.triangles),
                    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, false, kVUIDUndefined, "VUID-VkGeometryTrianglesNV-sType-sType");

                skip |= context.ValidateStructPnext(pGeometries_loc, pInfo->pGeometries[geometryIndex].geometry.triangles.pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryTrianglesNV-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat,
                                                   pInfo->pGeometries[geometryIndex].geometry.triangles.vertexFormat,
                                                   "VUID-VkGeometryTrianglesNV-vertexFormat-parameter");

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::indexType), vvl::Enum::VkIndexType,
                                                   pInfo->pGeometries[geometryIndex].geometry.triangles.indexType,
                                                   "VUID-VkGeometryTrianglesNV-indexType-parameter");

                skip |= context.ValidateStructType(
                    pGeometries_loc.dot(Field::aabbs), &(pInfo->pGeometries[geometryIndex].geometry.aabbs),
                    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, false, kVUIDUndefined, "VUID-VkGeometryAABBNV-sType-sType");

                skip |= context.ValidateStructPnext(pGeometries_loc, pInfo->pGeometries[geometryIndex].geometry.aabbs.pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryAABBNV-pNext-pNext",
                                                    kVUIDUndefined, true);

                skip |= context.ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                              AllVkGeometryFlagBitsKHR, pInfo->pGeometries[geometryIndex].flags, kOptionalFlags,
                                              "VUID-VkGeometryNV-flags-parameter");
            }
        }
    }
    skip |= context.ValidateBool32(loc.dot(Field::update), update);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dst), dst);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::scratch), scratch);
    if (!skip)
        skip |= manual_PreCallValidateCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update,
                                                                      dst, src, scratch, scratchOffset, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst,
                                                           VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dst), dst);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::src), src);
    skip |= context.ValidateRangedEnum(loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, mode,
                                       "VUID-vkCmdCopyAccelerationStructureNV-mode-parameter");
    return skip;
}

bool Device::PreCallValidateCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer,
                                           VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer,
                                           VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride,
                                           VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset,
                                           VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer,
                                           VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride,
                                           uint32_t width, uint32_t height, uint32_t depth, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::raygenShaderBindingTableBuffer), raygenShaderBindingTableBuffer);
    return skip;
}

bool Device::PreCallValidateCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                        const VkRayTracingPipelineCreateInfoNV* pCreateInfos,
                                                        const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount,
                                            pCreateInfos, VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV, true, true,
                                            "VUID-VkRayTracingPipelineCreateInfoNV-sType-sType",
                                            "VUID-vkCreateRayTracingPipelinesNV-pCreateInfos-parameter",
                                            "VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkRayTracingPipelineCreateInfoNV = {
                VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext, allowed_structs_VkRayTracingPipelineCreateInfoNV.size(),
                allowed_structs_VkRayTracingPipelineCreateInfoNV.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkRayTracingPipelineCreateInfoNV-pNext-pNext", "VUID-VkRayTracingPipelineCreateInfoNV-sType-unique", true);

            skip |= context.ValidateStructTypeArray(pCreateInfos_loc.dot(Field::stageCount), pCreateInfos_loc.dot(Field::pStages),
                                                    pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages,
                                                    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true,
                                                    "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                                    "VUID-VkRayTracingPipelineCreateInfoNV-pStages-parameter",
                                                    "VUID-VkRayTracingPipelineCreateInfoNV-stageCount-arraylength");

            if (pCreateInfos[createInfoIndex].pStages != nullptr) {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex) {
                    [[maybe_unused]] const Location pStages_loc = pCreateInfos_loc.dot(Field::pStages, stageIndex);
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                    skip |= context.ValidateStructPnext(pStages_loc, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext,
                                                        allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                        allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                        "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

                    skip |= context.ValidateFlags(
                        pStages_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                        AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].flags,
                        kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |= context.ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                                  AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage,
                                                  kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                                  "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= context.ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                            pCreateInfos[createInfoIndex].pStages[stageIndex].pName,
                                                            "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                        [[maybe_unused]] const Location pSpecializationInfo_loc = pStages_loc.dot(Field::pSpecializationInfo);
                        skip |= context.ValidateArray(
                            pSpecializationInfo_loc.dot(Field::mapEntryCount), pSpecializationInfo_loc.dot(Field::pMapEntries),
                            pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                            &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true,
                            kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr) {
                            for (uint32_t mapEntryIndex = 0;
                                 mapEntryIndex <
                                 pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                 ++mapEntryIndex) {
                                [[maybe_unused]] const Location pMapEntries_loc =
                                    pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                // No xml-driven validation
                            }
                        }

                        skip |= context.ValidateArray(
                            pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                            pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                            &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true,
                            kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= context.ValidateStructTypeArray(pCreateInfos_loc.dot(Field::groupCount), pCreateInfos_loc.dot(Field::pGroups),
                                                    pCreateInfos[createInfoIndex].groupCount, pCreateInfos[createInfoIndex].pGroups,
                                                    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV, true, true,
                                                    "VUID-VkRayTracingShaderGroupCreateInfoNV-sType-sType",
                                                    "VUID-VkRayTracingPipelineCreateInfoNV-pGroups-parameter",
                                                    "VUID-VkRayTracingPipelineCreateInfoNV-groupCount-arraylength");

            if (pCreateInfos[createInfoIndex].pGroups != nullptr) {
                for (uint32_t groupIndex = 0; groupIndex < pCreateInfos[createInfoIndex].groupCount; ++groupIndex) {
                    [[maybe_unused]] const Location pGroups_loc = pCreateInfos_loc.dot(Field::pGroups, groupIndex);
                    skip |= context.ValidateStructPnext(
                        pGroups_loc, pCreateInfos[createInfoIndex].pGroups[groupIndex].pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkRayTracingShaderGroupCreateInfoNV-pNext-pNext", kVUIDUndefined, true);

                    skip |= context.ValidateRangedEnum(pGroups_loc.dot(Field::type), vvl::Enum::VkRayTracingShaderGroupTypeKHR,
                                                       pCreateInfos[createInfoIndex].pGroups[groupIndex].type,
                                                       "VUID-VkRayTracingShaderGroupCreateInfoNV-type-parameter");
                }
            }

            skip |= context.ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true,
                                  true, "VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength",
                                  "VUID-vkCreateRayTracingPipelinesNV-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                                  pPipelines, context);
    return skip;
}

bool Device::PreCallValidateGetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
                                                               uint32_t groupCount, size_t dataSize, void* pData,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline) && loc.function == vvl::Func::vkGetRayTracingShaderGroupHandlesKHR)
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-arraylength",
                                  "VUID-vkGetRayTracingShaderGroupHandlesKHR-pData-parameter");
    return skip;
}

bool Device::PreCallValidateGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
                                                              uint32_t groupCount, size_t dataSize, void* pData,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= PreCallValidateGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, error_obj);
    return skip;
}

bool Device::PreCallValidateGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure,
                                                             size_t dataSize, void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::accelerationStructure), accelerationStructure);
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkGetAccelerationStructureHandleNV-dataSize-arraylength",
                                  "VUID-vkGetAccelerationStructureHandleNV-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData, context);
    return skip;
}

bool Device::PreCallValidateCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer,
                                                                       uint32_t accelerationStructureCount,
                                                                       const VkAccelerationStructureNV* pAccelerationStructures,
                                                                       VkQueryType queryType, VkQueryPool queryPool,
                                                                       uint32_t firstQuery, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateHandleArray(loc.dot(Field::accelerationStructureCount), loc.dot(Field::pAccelerationStructures),
                                        accelerationStructureCount, pAccelerationStructures, true, true,
                                        "VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructureCount-arraylength");
    skip |= context.ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                                       "VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    if (!skip)
        skip |= manual_PreCallValidateCmdWriteAccelerationStructuresPropertiesNV(
            commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, context);
    return skip;
}

bool Device::PreCallValidateCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool Device::PreCallValidateGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
                                                              const void* pHostPointer,
                                                              VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_external_memory_host))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_external_memory_host});
    skip |= context.ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                  AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit,
                                  "VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter",
                                  "VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHostPointer), pHostPointer,
                                            "VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryHostPointerProperties), pMemoryHostPointerProperties,
                                       VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, true,
                                       "VUID-vkGetMemoryHostPointerPropertiesEXT-pMemoryHostPointerProperties-parameter",
                                       "VUID-VkMemoryHostPointerPropertiesEXT-sType-sType");
    if (pMemoryHostPointerProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryHostPointerProperties_loc = loc.dot(Field::pMemoryHostPointerProperties);
        skip |= context.ValidateStructPnext(pMemoryHostPointerProperties_loc, pMemoryHostPointerProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryHostPointerPropertiesEXT-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer,
                                                                        pMemoryHostPointerProperties, context);
    return skip;
}

bool Device::PreCallValidateCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
                                                    VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_buffer_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_buffer_marker});
    skip |=
        context.ValidateFlags(loc.dot(Field::pipelineStage), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                              pipelineStage, kOptionalSingleBit, "VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    return skip;
}

bool Device::PreCallValidateCmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer,
                                                     VkDeviceSize dstOffset, uint32_t marker, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_buffer_marker)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_buffer_marker});
    skip |= context.ValidateFlags(loc.dot(Field::stage), vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                  stage, kOptionalFlags, "VUID-vkCmdWriteBufferMarker2AMD-stage-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice,
                                                                           uint32_t* pTimeDomainCount,
                                                                           VkTimeDomainKHR* pTimeDomains,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains, error_obj);
    return skip;
}

bool Device::PreCallValidateGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount,
                                                       const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps,
                                                       uint64_t* pMaxDeviation, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_calibrated_timestamps))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_calibrated_timestamps});
    skip |=
        PreCallValidateGetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_mesh_shader});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                       uint32_t drawCount, uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_mesh_shader});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool Device::PreCallValidateCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                            VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                            uint32_t maxDrawCount, uint32_t stride,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_mesh_shader});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool Device::PreCallValidateCmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor,
                                                           uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_scissor_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_scissor_exclusive});
    skip |= context.ValidateBool32Array(loc.dot(Field::exclusiveScissorCount), loc.dot(Field::pExclusiveScissorEnables),
                                        exclusiveScissorCount, pExclusiveScissorEnables, true, true,
                                        "VUID-vkCmdSetExclusiveScissorEnableNV-exclusiveScissorCount-arraylength",
                                        "VUID-vkCmdSetExclusiveScissorEnableNV-pExclusiveScissorEnables-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount,
                                                                     pExclusiveScissorEnables, context);
    return skip;
}

bool Device::PreCallValidateCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor,
                                                     uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_scissor_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_scissor_exclusive});
    skip |=
        context.ValidateArray(loc.dot(Field::exclusiveScissorCount), loc.dot(Field::pExclusiveScissors), exclusiveScissorCount,
                              &pExclusiveScissors, true, true, "VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-arraylength",
                              "VUID-vkCmdSetExclusiveScissorNV-pExclusiveScissors-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount,
                                                               pExclusiveScissors, context);
    return skip;
}

bool Device::PreCallValidateCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void* pCheckpointMarker,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_diagnostic_checkpoints))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_diagnostic_checkpoints});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateGetQueueCheckpointDataNV(VkQueue queue, uint32_t* pCheckpointDataCount,
                                                     VkCheckpointDataNV* pCheckpointData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_diagnostic_checkpoints))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_diagnostic_checkpoints});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pCheckpointDataCount), loc.dot(Field::pCheckpointData),
                                            pCheckpointDataCount, pCheckpointData, VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV, true,
                                            false, false, "VUID-VkCheckpointDataNV-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetQueueCheckpointDataNV-pCheckpointDataCount-parameter", kVUIDUndefined);
    if (pCheckpointData != nullptr) {
        for (uint32_t pCheckpointDataIndex = 0; pCheckpointDataIndex < *pCheckpointDataCount; ++pCheckpointDataIndex) {
            [[maybe_unused]] const Location pCheckpointData_loc = loc.dot(Field::pCheckpointData, pCheckpointDataIndex);
            skip |= context.ValidateStructPnext(pCheckpointData_loc, pCheckpointData[pCheckpointDataIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCheckpointDataNV-pNext-pNext", kVUIDUndefined,
                                                false);
        }
    }
    return skip;
}

bool Device::PreCallValidateGetQueueCheckpointData2NV(VkQueue queue, uint32_t* pCheckpointDataCount,
                                                      VkCheckpointData2NV* pCheckpointData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_diagnostic_checkpoints))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_diagnostic_checkpoints});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pCheckpointDataCount), loc.dot(Field::pCheckpointData),
                                            pCheckpointDataCount, pCheckpointData, VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV, true,
                                            false, false, "VUID-VkCheckpointData2NV-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetQueueCheckpointData2NV-pCheckpointDataCount-parameter", kVUIDUndefined);
    if (pCheckpointData != nullptr) {
        for (uint32_t pCheckpointDataIndex = 0; pCheckpointDataIndex < *pCheckpointDataCount; ++pCheckpointDataIndex) {
            [[maybe_unused]] const Location pCheckpointData_loc = loc.dot(Field::pCheckpointData, pCheckpointDataIndex);
            skip |= context.ValidateStructPnext(pCheckpointData_loc, pCheckpointData[pCheckpointDataIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCheckpointData2NV-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateInitializePerformanceApiINTEL(VkDevice device,
                                                          const VkInitializePerformanceApiInfoINTEL* pInitializeInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateStructType(
        loc.dot(Field::pInitializeInfo), pInitializeInfo, VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL, true,
        "VUID-vkInitializePerformanceApiINTEL-pInitializeInfo-parameter", "VUID-VkInitializePerformanceApiInfoINTEL-sType-sType");
    if (pInitializeInfo != nullptr) {
        [[maybe_unused]] const Location pInitializeInfo_loc = loc.dot(Field::pInitializeInfo);
        skip |= context.ValidateStructPnext(pInitializeInfo_loc, pInitializeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkInitializePerformanceApiInfoINTEL-pNext-pNext", kVUIDUndefined, true);
    }
    return skip;
}

bool Device::PreCallValidateUninitializePerformanceApiINTEL(VkDevice device, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer,
                                                         const VkPerformanceMarkerInfoINTEL* pMarkerInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
                                       true, "VUID-vkCmdSetPerformanceMarkerINTEL-pMarkerInfo-parameter",
                                       "VUID-VkPerformanceMarkerInfoINTEL-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= context.ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPerformanceMarkerInfoINTEL-pNext-pNext", kVUIDUndefined, true);
    }
    return skip;
}

bool Device::PreCallValidateCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer,
                                                               const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateStructType(
        loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL, true,
        "VUID-vkCmdSetPerformanceStreamMarkerINTEL-pMarkerInfo-parameter", "VUID-VkPerformanceStreamMarkerInfoINTEL-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= context.ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPerformanceStreamMarkerInfoINTEL-pNext-pNext", kVUIDUndefined, true);
    }
    return skip;
}

bool Device::PreCallValidateCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer,
                                                           const VkPerformanceOverrideInfoINTEL* pOverrideInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateStructType(
        loc.dot(Field::pOverrideInfo), pOverrideInfo, VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL, true,
        "VUID-vkCmdSetPerformanceOverrideINTEL-pOverrideInfo-parameter", "VUID-VkPerformanceOverrideInfoINTEL-sType-sType");
    if (pOverrideInfo != nullptr) {
        [[maybe_unused]] const Location pOverrideInfo_loc = loc.dot(Field::pOverrideInfo);
        skip |= context.ValidateStructPnext(pOverrideInfo_loc, pOverrideInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPerformanceOverrideInfoINTEL-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pOverrideInfo_loc.dot(Field::type), vvl::Enum::VkPerformanceOverrideTypeINTEL,
                                           pOverrideInfo->type, "VUID-VkPerformanceOverrideInfoINTEL-type-parameter");

        skip |= context.ValidateBool32(pOverrideInfo_loc.dot(Field::enable), pOverrideInfo->enable);
    }
    return skip;
}

bool Device::PreCallValidateAcquirePerformanceConfigurationINTEL(VkDevice device,
                                                                 const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo,
                                                                 VkPerformanceConfigurationINTEL* pConfiguration,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateStructType(loc.dot(Field::pAcquireInfo), pAcquireInfo,
                                       VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL, true,
                                       "VUID-vkAcquirePerformanceConfigurationINTEL-pAcquireInfo-parameter",
                                       "VUID-VkPerformanceConfigurationAcquireInfoINTEL-sType-sType");
    if (pAcquireInfo != nullptr) {
        [[maybe_unused]] const Location pAcquireInfo_loc = loc.dot(Field::pAcquireInfo);
        skip |= context.ValidateStructPnext(pAcquireInfo_loc, pAcquireInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPerformanceConfigurationAcquireInfoINTEL-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pAcquireInfo_loc.dot(Field::type), vvl::Enum::VkPerformanceConfigurationTypeINTEL,
                                           pAcquireInfo->type, "VUID-VkPerformanceConfigurationAcquireInfoINTEL-type-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pConfiguration), pConfiguration,
                                            "VUID-vkAcquirePerformanceConfigurationINTEL-pConfiguration-parameter");
    return skip;
}

bool Device::PreCallValidateReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::configuration), configuration);
    return skip;
}

bool Device::PreCallValidateGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter,
                                                         VkPerformanceValueINTEL* pValue, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= context.ValidateRangedEnum(loc.dot(Field::parameter), vvl::Enum::VkPerformanceParameterTypeINTEL, parameter,
                                       "VUID-vkGetPerformanceParameterINTEL-parameter-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pValue), pValue, "VUID-vkGetPerformanceParameterINTEL-pValue-parameter");
    return skip;
}

bool Device::PreCallValidateSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_display_native_hdr))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_display_native_hdr});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapChain), swapChain);
    skip |= context.ValidateBool32(loc.dot(Field::localDimmingEnable), localDimmingEnable);
    return skip;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
bool Instance::PreCallValidateCreateImagePipeSurfaceFUCHSIA(VkInstance instance,
                                                            const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_imagepipe_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_imagepipe_surface});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA, true,
        "VUID-vkCreateImagePipeSurfaceFUCHSIA-pCreateInfo-parameter", "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface,
                                            "VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_METAL_EXT
bool Instance::PreCallValidateCreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo,
                                                    const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_metal_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_metal_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
                                       true, "VUID-vkCreateMetalSurfaceEXT-pCreateInfo-parameter",
                                       "VUID-VkMetalSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMetalSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkMetalSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateMetalSurfaceEXT-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

bool Device::PreCallValidateGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_buffer_device_address});
    skip |= PreCallValidateGetBufferDeviceAddress(device, pInfo, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                                                 VkPhysicalDeviceToolProperties* pToolProperties,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= PreCallValidateGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties, error_obj);
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice,
                                                                             uint32_t* pPropertyCount,
                                                                             VkCooperativeMatrixPropertiesNV* pProperties,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV, true, false, false, "VUID-VkCooperativeMatrixPropertiesNV-sType-sType",
        kVUIDUndefined, "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCooperativeMatrixPropertiesNV-pNext-pNext",
                                                kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations,
    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pCombinationCount), loc.dot(Field::pCombinations), pCombinationCount, pCombinations,
        VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV, true, false, false,
        "VUID-VkFramebufferMixedSamplesCombinationNV-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-pCombinationCount-parameter", kVUIDUndefined);
    if (pCombinations != nullptr) {
        for (uint32_t pCombinationIndex = 0; pCombinationIndex < *pCombinationCount; ++pCombinationIndex) {
            [[maybe_unused]] const Location pCombinations_loc = loc.dot(Field::pCombinations, pCombinationIndex);
            skip |= context.ValidateStructPnext(pCombinations_loc, pCombinations[pCombinationIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion,
                                                "VUID-VkFramebufferMixedSamplesCombinationNV-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Instance::PreCallValidateGetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice,
                                                                       const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
                                                                       uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        context.ValidateStructType(loc.dot(Field::pSurfaceInfo), pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
                                   true, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-parameter",
                                   "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr) {
        [[maybe_unused]] const Location pSurfaceInfo_loc = loc.dot(Field::pSurfaceInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = {
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT};

        skip |= context.ValidateStructPnext(
            pSurfaceInfo_loc, pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(),
            allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", true);
    }
    skip |= context.ValidatePointerArray(loc.dot(Field::pPresentModeCount), loc.dot(Field::pPresentModes), pPresentModeCount,
                                         &pPresentModes, true, false, false,
                                         "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModeCount-parameter",
                                         kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModes-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount,
                                                                               pPresentModes, context);
    return skip;
}

bool Device::PreCallValidateAcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_full_screen_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_full_screen_exclusive});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}

bool Device::PreCallValidateReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_full_screen_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_full_screen_exclusive});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool Instance::PreCallValidateCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_headless_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_headless_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
                                       true, "VUID-vkCreateHeadlessSurfaceEXT-pCreateInfo-parameter",
                                       "VUID-VkHeadlessSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkHeadlessSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkHeadlessSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateHeadlessSurfaceEXT-pSurface-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                                 uint16_t lineStipplePattern, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_line_rasterization))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_line_rasterization});
    skip |= PreCallValidateCmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern, error_obj);
    return skip;
}

bool Device::PreCallValidateResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_host_query_reset))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_query_reset});
    skip |= PreCallValidateResetQueryPool(device, queryPool, firstQuery, queryCount, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetCullMode(commandBuffer, cullMode, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetFrontFace(commandBuffer, frontFace, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetPrimitiveTopology(commandBuffer, primitiveTopology, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                                       const VkViewport* pViewports, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                                      const VkRect2D* pScissors, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
                                                     const VkBuffer* pBuffers, const VkDeviceSize* pOffsets,
                                                     const VkDeviceSize* pSizes, const VkDeviceSize* pStrides,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides,
                                                 error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthTestEnable(commandBuffer, depthTestEnable, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthCompareOp(commandBuffer, depthCompareOp, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetStencilTestEnable(commandBuffer, stencilTestEnable, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp,
                                               VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp, error_obj);
    return skip;
}

bool Device::PreCallValidateCopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo* pCopyMemoryToImageInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= PreCallValidateCopyMemoryToImage(device, pCopyMemoryToImageInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo* pCopyImageToMemoryInfo,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= PreCallValidateCopyImageToMemory(device, pCopyImageToMemoryInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateCopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo* pCopyImageToImageInfo,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= PreCallValidateCopyImageToImage(device, pCopyImageToImageInfo, error_obj);
    return skip;
}

bool Device::PreCallValidateTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount,
                                                     const VkHostImageLayoutTransitionInfo* pTransitions,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= PreCallValidateTransitionImageLayout(device, transitionCount, pTransitions, error_obj);
    return skip;
}

bool Device::PreCallValidateGetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2* pSubresource,
                                                          VkSubresourceLayout2* pLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_host_image_copy) || IsExtEnabled(extensions.vk_ext_image_compression_control)))
        skip |=
            OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy, vvl::Extension::_VK_EXT_image_compression_control});
    skip |= PreCallValidateGetImageSubresourceLayout2(device, image, pSubresource, pLayout, error_obj);
    return skip;
}

bool Device::PreCallValidateReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_swapchain_maintenance1))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_swapchain_maintenance1});
    skip |= context.ValidateStructType(
        loc.dot(Field::pReleaseInfo), pReleaseInfo, VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT, true,
        "VUID-vkReleaseSwapchainImagesEXT-pReleaseInfo-parameter", "VUID-VkReleaseSwapchainImagesInfoEXT-sType-sType");
    if (pReleaseInfo != nullptr) {
        [[maybe_unused]] const Location pReleaseInfo_loc = loc.dot(Field::pReleaseInfo);
        skip |= context.ValidateStructPnext(pReleaseInfo_loc, pReleaseInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkReleaseSwapchainImagesInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pReleaseInfo_loc.dot(Field::swapchain), pReleaseInfo->swapchain);

        skip |= context.ValidateArray(pReleaseInfo_loc.dot(Field::imageIndexCount), pReleaseInfo_loc.dot(Field::pImageIndices),
                                      pReleaseInfo->imageIndexCount, &pReleaseInfo->pImageIndices, true, true,
                                      "VUID-VkReleaseSwapchainImagesInfoEXT-imageIndexCount-arraylength",
                                      "VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateReleaseSwapchainImagesEXT(device, pReleaseInfo, context);
    return skip;
}

bool Device::PreCallValidateGetGeneratedCommandsMemoryRequirementsNV(VkDevice device,
                                                                     const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo,
                                                                     VkMemoryRequirements2* pMemoryRequirements,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
                                   true, "VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-parameter",
                                   "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pInfo->pipelineBindPoint,
                                           "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-parameter");

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::indirectCommandsLayout), pInfo->indirectCommandsLayout);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
                                                             const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= context.ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, true,
        "VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoNV-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |= context.ValidateStructPnext(pGeneratedCommandsInfo_loc, pGeneratedCommandsInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkGeneratedCommandsInfoNV-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pGeneratedCommandsInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pGeneratedCommandsInfo->pipelineBindPoint,
                                           "VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter");

        skip |= context.ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                               pGeneratedCommandsInfo->indirectCommandsLayout);

        skip |= context.ValidateArray(
            pGeneratedCommandsInfo_loc.dot(Field::streamCount), pGeneratedCommandsInfo_loc.dot(Field::pStreams),
            pGeneratedCommandsInfo->streamCount, &pGeneratedCommandsInfo->pStreams, true, true,
            "VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength", "VUID-VkGeneratedCommandsInfoNV-pStreams-parameter");

        if (pGeneratedCommandsInfo->pStreams != nullptr) {
            for (uint32_t streamIndex = 0; streamIndex < pGeneratedCommandsInfo->streamCount; ++streamIndex) {
                [[maybe_unused]] const Location pStreams_loc = pGeneratedCommandsInfo_loc.dot(Field::pStreams, streamIndex);
                skip |= context.ValidateRequiredHandle(pStreams_loc.dot(Field::buffer),
                                                       pGeneratedCommandsInfo->pStreams[streamIndex].buffer);
            }
        }

        skip |= context.ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::preprocessBuffer),
                                               pGeneratedCommandsInfo->preprocessBuffer);
    }
    return skip;
}

bool Device::PreCallValidateCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed,
                                                          const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= context.ValidateBool32(loc.dot(Field::isPreprocessed), isPreprocessed);
    skip |= context.ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, true,
        "VUID-vkCmdExecuteGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoNV-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |= context.ValidateStructPnext(pGeneratedCommandsInfo_loc, pGeneratedCommandsInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkGeneratedCommandsInfoNV-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pGeneratedCommandsInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pGeneratedCommandsInfo->pipelineBindPoint,
                                           "VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter");

        skip |= context.ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                               pGeneratedCommandsInfo->indirectCommandsLayout);

        skip |= context.ValidateArray(
            pGeneratedCommandsInfo_loc.dot(Field::streamCount), pGeneratedCommandsInfo_loc.dot(Field::pStreams),
            pGeneratedCommandsInfo->streamCount, &pGeneratedCommandsInfo->pStreams, true, true,
            "VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength", "VUID-VkGeneratedCommandsInfoNV-pStreams-parameter");

        if (pGeneratedCommandsInfo->pStreams != nullptr) {
            for (uint32_t streamIndex = 0; streamIndex < pGeneratedCommandsInfo->streamCount; ++streamIndex) {
                [[maybe_unused]] const Location pStreams_loc = pGeneratedCommandsInfo_loc.dot(Field::pStreams, streamIndex);
                skip |= context.ValidateRequiredHandle(pStreams_loc.dot(Field::buffer),
                                                       pGeneratedCommandsInfo->pStreams[streamIndex].buffer);
            }
        }

        skip |= context.ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::preprocessBuffer),
                                               pGeneratedCommandsInfo->preprocessBuffer);
    }
    return skip;
}

bool Device::PreCallValidateCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                         VkPipeline pipeline, uint32_t groupIndex,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool Device::PreCallValidateCreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           VkIndirectCommandsLayoutNV* pIndirectCommandsLayout,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV, true,
        "VUID-vkCreateIndirectCommandsLayoutNV-pCreateInfo-parameter", "VUID-VkIndirectCommandsLayoutCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkIndirectCommandsLayoutCreateInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkIndirectCommandsLayoutUsageFlagBitsNV,
                                      AllVkIndirectCommandsLayoutUsageFlagBitsNV, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkIndirectCommandsLayoutCreateInfoNV-flags-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pCreateInfo->pipelineBindPoint,
                                           "VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-parameter");

        skip |= context.ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::tokenCount), pCreateInfo_loc.dot(Field::pTokens), pCreateInfo->tokenCount,
            pCreateInfo->pTokens, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV, true, true,
            "VUID-VkIndirectCommandsLayoutTokenNV-sType-sType", "VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-parameter",
            "VUID-VkIndirectCommandsLayoutCreateInfoNV-tokenCount-arraylength");

        if (pCreateInfo->pTokens != nullptr) {
            for (uint32_t tokenIndex = 0; tokenIndex < pCreateInfo->tokenCount; ++tokenIndex) {
                [[maybe_unused]] const Location pTokens_loc = pCreateInfo_loc.dot(Field::pTokens, tokenIndex);
                skip |= context.ValidateStructPnext(pTokens_loc, pCreateInfo->pTokens[tokenIndex].pNext, 0, nullptr,
                                                    GeneratedVulkanHeaderVersion,
                                                    "VUID-VkIndirectCommandsLayoutTokenNV-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateRangedEnum(pTokens_loc.dot(Field::tokenType), vvl::Enum::VkIndirectCommandsTokenTypeNV,
                                                   pCreateInfo->pTokens[tokenIndex].tokenType,
                                                   "VUID-VkIndirectCommandsLayoutTokenNV-tokenType-parameter");

                skip |= context.ValidateBool32(pTokens_loc.dot(Field::vertexDynamicStride),
                                               pCreateInfo->pTokens[tokenIndex].vertexDynamicStride);

                skip |= context.ValidateFlags(pTokens_loc.dot(Field::pushconstantShaderStageFlags),
                                              vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                              pCreateInfo->pTokens[tokenIndex].pushconstantShaderStageFlags, kOptionalFlags,
                                              "VUID-VkIndirectCommandsLayoutTokenNV-pushconstantShaderStageFlags-parameter");

                skip |=
                    context.ValidateFlags(pTokens_loc.dot(Field::indirectStateFlags), vvl::FlagBitmask::VkIndirectStateFlagBitsNV,
                                          AllVkIndirectStateFlagBitsNV, pCreateInfo->pTokens[tokenIndex].indirectStateFlags,
                                          kOptionalFlags, "VUID-VkIndirectCommandsLayoutTokenNV-indirectStateFlags-parameter");

                skip |= context.ValidateRangedEnumArray(pTokens_loc.dot(Field::indexTypeCount), pTokens_loc.dot(Field::pIndexTypes),
                                                        vvl::Enum::VkIndexType, pCreateInfo->pTokens[tokenIndex].indexTypeCount,
                                                        pCreateInfo->pTokens[tokenIndex].pIndexTypes, false, true, kVUIDUndefined,
                                                        "VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypes-parameter");

                skip |= context.ValidateArray(pTokens_loc.dot(Field::indexTypeCount), pTokens_loc.dot(Field::pIndexTypeValues),
                                              pCreateInfo->pTokens[tokenIndex].indexTypeCount,
                                              &pCreateInfo->pTokens[tokenIndex].pIndexTypeValues, false, true, kVUIDUndefined,
                                              "VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypeValues-parameter");
            }
        }

        skip |= context.ValidateArray(pCreateInfo_loc.dot(Field::streamCount), pCreateInfo_loc.dot(Field::pStreamStrides),
                                      pCreateInfo->streamCount, &pCreateInfo->pStreamStrides, true, true,
                                      "VUID-VkIndirectCommandsLayoutCreateInfoNV-streamCount-arraylength",
                                      "VUID-VkIndirectCommandsLayoutCreateInfoNV-pStreamStrides-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pIndirectCommandsLayout), pIndirectCommandsLayout,
                                            "VUID-vkCreateIndirectCommandsLayoutNV-pIndirectCommandsLayout-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT* pDepthBiasInfo,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_depth_bias_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_depth_bias_control});
    skip |=
        context.ValidateStructType(loc.dot(Field::pDepthBiasInfo), pDepthBiasInfo, VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT, true,
                                   "VUID-vkCmdSetDepthBias2EXT-pDepthBiasInfo-parameter", "VUID-VkDepthBiasInfoEXT-sType-sType");
    if (pDepthBiasInfo != nullptr) {
        [[maybe_unused]] const Location pDepthBiasInfo_loc = loc.dot(Field::pDepthBiasInfo);
        constexpr std::array allowed_structs_VkDepthBiasInfoEXT = {VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT};

        skip |= context.ValidateStructPnext(pDepthBiasInfo_loc, pDepthBiasInfo->pNext, allowed_structs_VkDepthBiasInfoEXT.size(),
                                            allowed_structs_VkDepthBiasInfoEXT.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkDepthBiasInfoEXT-pNext-pNext", "VUID-VkDepthBiasInfoEXT-sType-unique", true);
    }
    return skip;
}

bool Instance::PreCallValidateAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_acquire_drm_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_drm_display});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

bool Instance::PreCallValidateGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId,
                                               VkDisplayKHR* display, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_acquire_drm_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_drm_display});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::display), display, "VUID-vkGetDrmDisplayEXT-display-parameter");
    return skip;
}

bool Device::PreCallValidateCreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot, error_obj);
    return skip;
}

bool Device::PreCallValidateDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                                      const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateDestroyPrivateDataSlot(device, privateDataSlot, pAllocator, error_obj);
    return skip;
}

bool Device::PreCallValidateSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                              VkPrivateDataSlot privateDataSlot, uint64_t data,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateSetPrivateData(device, objectType, objectHandle, privateDataSlot, data, error_obj);
    return skip;
}

bool Device::PreCallValidateGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                              VkPrivateDataSlot privateDataSlot, uint64_t* pData,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_private_data)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData, error_obj);
    return skip;
}

bool Device::PreCallValidateCreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV* pCreateInfo,
                                               const VkAllocationCallbacks* pAllocator, VkCudaModuleNV* pModule,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV, true,
                                   "VUID-vkCreateCudaModuleNV-pCreateInfo-parameter", "VUID-VkCudaModuleCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCudaModuleCreateInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateArray(
            pCreateInfo_loc.dot(Field::dataSize), pCreateInfo_loc.dot(Field::pData), pCreateInfo->dataSize, &pCreateInfo->pData,
            true, true, "VUID-VkCudaModuleCreateInfoNV-dataSize-arraylength", "VUID-VkCudaModuleCreateInfoNV-pData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pModule), pModule, "VUID-vkCreateCudaModuleNV-pModule-parameter");
    return skip;
}

bool Device::PreCallValidateGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t* pCacheSize, void* pCacheData,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::module), module);
    skip |= context.ValidatePointerArray(loc.dot(Field::pCacheSize), loc.dot(Field::pCacheData), pCacheSize, &pCacheData, true,
                                         false, false, "VUID-vkGetCudaModuleCacheNV-pCacheSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetCudaModuleCacheNV-pCacheData-parameter");
    return skip;
}

bool Device::PreCallValidateCreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV* pCreateInfo,
                                                 const VkAllocationCallbacks* pAllocator, VkCudaFunctionNV* pFunction,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV,
                                       true, "VUID-vkCreateCudaFunctionNV-pCreateInfo-parameter",
                                       "VUID-VkCudaFunctionCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCudaFunctionCreateInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::module), pCreateInfo->module);

        skip |= context.ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pName), pCreateInfo->pName,
                                                "VUID-VkCudaFunctionCreateInfoNV-pName-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pFunction), pFunction, "VUID-vkCreateCudaFunctionNV-pFunction-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks* pAllocator,
                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::module), module);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function,
                                                  const VkAllocationCallbacks* pAllocator, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::function), function);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV* pLaunchInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= context.ValidateStructType(loc.dot(Field::pLaunchInfo), pLaunchInfo, VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV, true,
                                       "VUID-vkCmdCudaLaunchKernelNV-pLaunchInfo-parameter", "VUID-VkCudaLaunchInfoNV-sType-sType");
    if (pLaunchInfo != nullptr) {
        [[maybe_unused]] const Location pLaunchInfo_loc = loc.dot(Field::pLaunchInfo);
        skip |= context.ValidateStructPnext(pLaunchInfo_loc, pLaunchInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCudaLaunchInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pLaunchInfo_loc.dot(Field::function), pLaunchInfo->function);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_METAL_EXT
bool Device::PreCallValidateExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT* pMetalObjectsInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_metal_objects)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_metal_objects});
    skip |= context.ValidateStructType(
        loc.dot(Field::pMetalObjectsInfo), pMetalObjectsInfo, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT, true,
        "VUID-vkExportMetalObjectsEXT-pMetalObjectsInfo-parameter", "VUID-VkExportMetalObjectsInfoEXT-sType-sType");
    if (pMetalObjectsInfo != nullptr) {
        [[maybe_unused]] const Location pMetalObjectsInfo_loc = loc.dot(Field::pMetalObjectsInfo);
        constexpr std::array allowed_structs_VkExportMetalObjectsInfoEXT = {
            VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT,       VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT,
            VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT,       VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT,
            VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT, VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT};

        skip |= context.ValidateStructPnext(
            pMetalObjectsInfo_loc, pMetalObjectsInfo->pNext, allowed_structs_VkExportMetalObjectsInfoEXT.size(),
            allowed_structs_VkExportMetalObjectsInfoEXT.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkExportMetalObjectsInfoEXT-pNext-pNext", "VUID-VkExportMetalObjectsInfoEXT-sType-unique", false);
    }
    return skip;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

bool Device::PreCallValidateGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout,
                                                          VkDeviceSize* pLayoutSizeInBytes, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pLayoutSizeInBytes), pLayoutSizeInBytes,
                                            "VUID-vkGetDescriptorSetLayoutSizeEXT-pLayoutSizeInBytes-parameter");
    return skip;
}

bool Device::PreCallValidateGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding,
                                                                   VkDeviceSize* pOffset, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pOffset), pOffset,
                                            "VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-pOffset-parameter");
    return skip;
}

bool Device::PreCallValidateGetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize,
                                             void* pDescriptor, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructType(loc.dot(Field::pDescriptorInfo), pDescriptorInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT,
                                       true, "VUID-vkGetDescriptorEXT-pDescriptorInfo-parameter",
                                       "VUID-VkDescriptorGetInfoEXT-sType-sType");
    if (pDescriptorInfo != nullptr) {
        [[maybe_unused]] const Location pDescriptorInfo_loc = loc.dot(Field::pDescriptorInfo);
        skip |= context.ValidateStructPnext(pDescriptorInfo_loc, pDescriptorInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDescriptorGetInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pDescriptorInfo_loc.dot(Field::type), vvl::Enum::VkDescriptorType, pDescriptorInfo->type,
                                           "VUID-VkDescriptorGetInfoEXT-type-parameter");
    }
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pDescriptor), dataSize, &pDescriptor, true, true,
                                  "VUID-vkGetDescriptorEXT-dataSize-arraylength", "VUID-vkGetDescriptorEXT-pDescriptor-parameter");
    if (!skip) skip |= manual_PreCallValidateGetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor, context);
    return skip;
}

bool Device::PreCallValidateCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount,
                                                        const VkDescriptorBufferBindingInfoEXT* pBindingInfos,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::bufferCount), loc.dot(Field::pBindingInfos), bufferCount, pBindingInfos,
        VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT, true, true, "VUID-VkDescriptorBufferBindingInfoEXT-sType-sType",
        "VUID-vkCmdBindDescriptorBuffersEXT-pBindingInfos-parameter", "VUID-vkCmdBindDescriptorBuffersEXT-bufferCount-arraylength");
    if (pBindingInfos != nullptr) {
        for (uint32_t bufferIndex = 0; bufferIndex < bufferCount; ++bufferIndex) {
            [[maybe_unused]] const Location pBindingInfos_loc = loc.dot(Field::pBindingInfos, bufferIndex);
            constexpr std::array allowed_structs_VkDescriptorBufferBindingInfoEXT = {
                VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT};

            skip |= context.ValidateStructPnext(
                pBindingInfos_loc, pBindingInfos[bufferIndex].pNext, allowed_structs_VkDescriptorBufferBindingInfoEXT.size(),
                allowed_structs_VkDescriptorBufferBindingInfoEXT.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkDescriptorBufferBindingInfoEXT-pNext-pNext", "VUID-VkDescriptorBufferBindingInfoEXT-sType-unique", true);
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos, context);
    return skip;
}

bool Device::PreCallValidateCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                             VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount,
                                                             const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= context.ValidateArray(loc.dot(Field::setCount), loc.dot(Field::pBufferIndices), setCount, &pBufferIndices, true, true,
                                  "VUID-vkCmdSetDescriptorBufferOffsetsEXT-setCount-arraylength",
                                  "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pBufferIndices-parameter");
    skip |= context.ValidateArray(loc.dot(Field::setCount), loc.dot(Field::pOffsets), setCount, &pOffsets, true, true,
                                  "VUID-vkCmdSetDescriptorBufferOffsetsEXT-setCount-arraylength",
                                  "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pOffsets-parameter");
    return skip;
}

bool Device::PreCallValidateCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer,
                                                                       VkPipelineBindPoint pipelineBindPoint,
                                                                       VkPipelineLayout layout, uint32_t set,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdBindDescriptorBufferEmbeddedSamplersEXT-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::layout), layout);
    return skip;
}

bool Device::PreCallValidateGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                    const VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
                                       true, "VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                                       "VUID-VkBufferCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pData), pData,
                                            "VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool Device::PreCallValidateGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                   const VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true,
                                       "VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                                       "VUID-VkImageCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pData), pData,
                                            "VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool Device::PreCallValidateGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                       const VkImageViewCaptureDescriptorDataInfoEXT* pInfo,
                                                                       void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
                                       true, "VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                                       "VUID-VkImageViewCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImageViewCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::imageView), pInfo->imageView);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pData), pData,
                                            "VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool Device::PreCallValidateGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                     const VkSamplerCaptureDescriptorDataInfoEXT* pInfo,
                                                                     void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
                                       true, "VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                                       "VUID-VkSamplerCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkSamplerCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::sampler), pInfo->sampler);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pData), pData,
                                            "VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool Device::PreCallValidateGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(
    VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true,
                                       "VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                                       "VUID-VkAccelerationStructureCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined,
                                            true);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pData), pData,
                                            "VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate,
                                                            const VkFragmentShadingRateCombinerOpKHR combinerOps[2],
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_fragment_shading_rate_enums))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_fragment_shading_rate_enums});
    skip |= context.ValidateRangedEnum(loc.dot(Field::shadingRate), vvl::Enum::VkFragmentShadingRateNV, shadingRate,
                                       "VUID-vkCmdSetFragmentShadingRateEnumNV-shadingRate-parameter");
    skip |= context.ValidateRangedEnumArray(loc, loc.dot(Field::combinerOps), vvl::Enum::VkFragmentShadingRateCombinerOpKHR, 2,
                                            combinerOps, false, true, kVUIDUndefined,
                                            "VUID-vkCmdSetFragmentShadingRateEnumNV-combinerOps-parameter");
    return skip;
}

bool Device::PreCallValidateGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts,
                                                  VkDeviceFaultInfoEXT* pFaultInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_fault)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_fault});
    skip |= context.ValidateStructType(loc.dot(Field::pFaultCounts), pFaultCounts, VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT, true,
                                       "VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-parameter",
                                       "VUID-VkDeviceFaultCountsEXT-sType-sType");
    if (pFaultCounts != nullptr) {
        [[maybe_unused]] const Location pFaultCounts_loc = loc.dot(Field::pFaultCounts);
        skip |= context.ValidateStructPnext(pFaultCounts_loc, pFaultCounts->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceFaultCountsEXT-pNext-pNext", kVUIDUndefined, false);
    }
    skip |=
        context.ValidateStructType(loc.dot(Field::pFaultInfo), pFaultInfo, VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT, false,
                                   "VUID-vkGetDeviceFaultInfoEXT-pFaultInfo-parameter", "VUID-VkDeviceFaultInfoEXT-sType-sType");
    if (pFaultInfo != nullptr) {
        [[maybe_unused]] const Location pFaultInfo_loc = loc.dot(Field::pFaultInfo);
        skip |= context.ValidateStructPnext(pFaultInfo_loc, pFaultInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceFaultInfoEXT-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool Instance::PreCallValidateAcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

bool Instance::PreCallValidateGetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR* pDisplay,
                                                const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pDisplay), pDisplay, "VUID-vkGetWinrtDisplayNV-pDisplay-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
bool Instance::PreCallValidateCreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_directfb_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_directfb_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT,
                                       true, "VUID-vkCreateDirectFBSurfaceEXT-pCreateInfo-parameter",
                                       "VUID-VkDirectFBSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDirectFBSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkDirectFBSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateDirectFBSurfaceEXT-pSurface-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice,
                                                                              uint32_t queueFamilyIndex, IDirectFB* dfb,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_directfb_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_directfb_surface});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::dfb), dfb,
                                            "VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-dfb-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_DIRECTFB_EXT

bool Device::PreCallValidateCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount,
                                                 const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions,
                                                 uint32_t vertexAttributeDescriptionCount,
                                                 const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_vertex_input_dynamic_state) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |=
            OutputExtensionError(loc, {vvl::Extension::_VK_EXT_vertex_input_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::vertexBindingDescriptionCount),
                                            loc.dot(Field::pVertexBindingDescriptions), vertexBindingDescriptionCount,
                                            pVertexBindingDescriptions, VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT,
                                            false, true, "VUID-VkVertexInputBindingDescription2EXT-sType-sType",
                                            "VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-parameter", kVUIDUndefined);
    if (pVertexBindingDescriptions != nullptr) {
        for (uint32_t vertexBindingDescriptionIndex = 0; vertexBindingDescriptionIndex < vertexBindingDescriptionCount;
             ++vertexBindingDescriptionIndex) {
            [[maybe_unused]] const Location pVertexBindingDescriptions_loc =
                loc.dot(Field::pVertexBindingDescriptions, vertexBindingDescriptionIndex);
            skip |= context.ValidateRangedEnum(pVertexBindingDescriptions_loc.dot(Field::inputRate), vvl::Enum::VkVertexInputRate,
                                               pVertexBindingDescriptions[vertexBindingDescriptionIndex].inputRate,
                                               "VUID-VkVertexInputBindingDescription2EXT-inputRate-parameter");
        }
    }
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::vertexAttributeDescriptionCount), loc.dot(Field::pVertexAttributeDescriptions),
        vertexAttributeDescriptionCount, pVertexAttributeDescriptions, VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT,
        false, true, "VUID-VkVertexInputAttributeDescription2EXT-sType-sType",
        "VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-parameter", kVUIDUndefined);
    if (pVertexAttributeDescriptions != nullptr) {
        for (uint32_t vertexAttributeDescriptionIndex = 0; vertexAttributeDescriptionIndex < vertexAttributeDescriptionCount;
             ++vertexAttributeDescriptionIndex) {
            [[maybe_unused]] const Location pVertexAttributeDescriptions_loc =
                loc.dot(Field::pVertexAttributeDescriptions, vertexAttributeDescriptionIndex);
            skip |= context.ValidateRangedEnum(pVertexAttributeDescriptions_loc.dot(Field::format), vvl::Enum::VkFormat,
                                               pVertexAttributeDescriptions[vertexAttributeDescriptionIndex].format,
                                               "VUID-VkVertexInputAttributeDescription2EXT-format-parameter");
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions,
                                                           vertexAttributeDescriptionCount, pVertexAttributeDescriptions, context);
    return skip;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
bool Device::PreCallValidateGetMemoryZirconHandleFUCHSIA(VkDevice device,
                                                         const VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo,
                                                         zx_handle_t* pZirconHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_external_memory))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_memory});
    skip |= context.ValidateStructType(loc.dot(Field::pGetZirconHandleInfo), pGetZirconHandleInfo,
                                       VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA, true,
                                       "VUID-vkGetMemoryZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter",
                                       "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-sType-sType");
    if (pGetZirconHandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetZirconHandleInfo_loc = loc.dot(Field::pGetZirconHandleInfo);
        skip |= context.ValidateStructPnext(pGetZirconHandleInfo_loc, pGetZirconHandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetZirconHandleInfo_loc.dot(Field::memory), pGetZirconHandleInfo->memory);

        skip |= context.ValidateFlags(pGetZirconHandleInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits, AllVkExternalMemoryHandleTypeFlagBits,
                                      pGetZirconHandleInfo->handleType, kRequiredSingleBit,
                                      "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter",
                                      "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pZirconHandle), pZirconHandle,
                                            "VUID-vkGetMemoryZirconHandleFUCHSIA-pZirconHandle-parameter");
    return skip;
}

bool Device::PreCallValidateGetMemoryZirconHandlePropertiesFUCHSIA(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle,
    VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_external_memory))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_memory});
    skip |= context.ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                  AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit,
                                  "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter",
                                  "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryZirconHandleProperties), pMemoryZirconHandleProperties,
                                       VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA, true,
                                       "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-pMemoryZirconHandleProperties-parameter",
                                       "VUID-VkMemoryZirconHandlePropertiesFUCHSIA-sType-sType");
    if (pMemoryZirconHandleProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryZirconHandleProperties_loc = loc.dot(Field::pMemoryZirconHandleProperties);
        skip |= context.ValidateStructPnext(pMemoryZirconHandleProperties_loc, pMemoryZirconHandleProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryZirconHandlePropertiesFUCHSIA-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateImportSemaphoreZirconHandleFUCHSIA(
    VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_external_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_semaphore});
    skip |= context.ValidateStructType(loc.dot(Field::pImportSemaphoreZirconHandleInfo), pImportSemaphoreZirconHandleInfo,
                                       VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA, true,
                                       "VUID-vkImportSemaphoreZirconHandleFUCHSIA-pImportSemaphoreZirconHandleInfo-parameter",
                                       "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-sType-sType");
    if (pImportSemaphoreZirconHandleInfo != nullptr) {
        [[maybe_unused]] const Location pImportSemaphoreZirconHandleInfo_loc = loc.dot(Field::pImportSemaphoreZirconHandleInfo);
        skip |= context.ValidateStructPnext(pImportSemaphoreZirconHandleInfo_loc, pImportSemaphoreZirconHandleInfo->pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pImportSemaphoreZirconHandleInfo_loc.dot(Field::semaphore),
                                               pImportSemaphoreZirconHandleInfo->semaphore);

        skip |= context.ValidateFlags(pImportSemaphoreZirconHandleInfo_loc.dot(Field::flags),
                                      vvl::FlagBitmask::VkSemaphoreImportFlagBits, AllVkSemaphoreImportFlagBits,
                                      pImportSemaphoreZirconHandleInfo->flags, kOptionalFlags,
                                      "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-flags-parameter");

        skip |= context.ValidateFlags(pImportSemaphoreZirconHandleInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                                      AllVkExternalSemaphoreHandleTypeFlagBits, pImportSemaphoreZirconHandleInfo->handleType,
                                      kRequiredSingleBit, "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter",
                                      "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetSemaphoreZirconHandleFUCHSIA(VkDevice device,
                                                            const VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo,
                                                            zx_handle_t* pZirconHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_external_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_semaphore});
    skip |= context.ValidateStructType(loc.dot(Field::pGetZirconHandleInfo), pGetZirconHandleInfo,
                                       VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA, true,
                                       "VUID-vkGetSemaphoreZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter",
                                       "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-sType-sType");
    if (pGetZirconHandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetZirconHandleInfo_loc = loc.dot(Field::pGetZirconHandleInfo);
        skip |= context.ValidateStructPnext(pGetZirconHandleInfo_loc, pGetZirconHandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetZirconHandleInfo_loc.dot(Field::semaphore), pGetZirconHandleInfo->semaphore);

        skip |= context.ValidateFlags(pGetZirconHandleInfo_loc.dot(Field::handleType),
                                      vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                                      AllVkExternalSemaphoreHandleTypeFlagBits, pGetZirconHandleInfo->handleType,
                                      kRequiredSingleBit, "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter",
                                      "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pZirconHandle), pZirconHandle,
                                            "VUID-vkGetSemaphoreZirconHandleFUCHSIA-pZirconHandle-parameter");
    return skip;
}

bool Device::PreCallValidateCreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          VkBufferCollectionFUCHSIA* pCollection,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA, true,
        "VUID-vkCreateBufferCollectionFUCHSIA-pCreateInfo-parameter", "VUID-VkBufferCollectionCreateInfoFUCHSIA-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCollectionCreateInfoFUCHSIA-pNext-pNext", kVUIDUndefined, true);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCollection), pCollection,
                                            "VUID-vkCreateBufferCollectionFUCHSIA-pCollection-parameter");
    return skip;
}

bool Device::PreCallValidateSetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                                       const VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::collection), collection);
    skip |= context.ValidateStructType(loc.dot(Field::pImageConstraintsInfo), pImageConstraintsInfo,
                                       VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA, true,
                                       "VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-pImageConstraintsInfo-parameter",
                                       "VUID-VkImageConstraintsInfoFUCHSIA-sType-sType");
    if (pImageConstraintsInfo != nullptr) {
        [[maybe_unused]] const Location pImageConstraintsInfo_loc = loc.dot(Field::pImageConstraintsInfo);
        skip |= context.ValidateStructPnext(pImageConstraintsInfo_loc, pImageConstraintsInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageConstraintsInfoFUCHSIA-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateStructTypeArray(
            pImageConstraintsInfo_loc.dot(Field::formatConstraintsCount), pImageConstraintsInfo_loc.dot(Field::pFormatConstraints),
            pImageConstraintsInfo->formatConstraintsCount, pImageConstraintsInfo->pFormatConstraints,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA, true, true,
            "VUID-VkImageFormatConstraintsInfoFUCHSIA-sType-sType",
            "VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-parameter",
            "VUID-VkImageConstraintsInfoFUCHSIA-formatConstraintsCount-arraylength");

        if (pImageConstraintsInfo->pFormatConstraints != nullptr) {
            for (uint32_t formatConstraintsIndex = 0; formatConstraintsIndex < pImageConstraintsInfo->formatConstraintsCount;
                 ++formatConstraintsIndex) {
                [[maybe_unused]] const Location pFormatConstraints_loc =
                    pImageConstraintsInfo_loc.dot(Field::pFormatConstraints, formatConstraintsIndex);
                skip |= context.ValidateStructPnext(
                    pFormatConstraints_loc, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pNext, 0, nullptr,
                    GeneratedVulkanHeaderVersion, "VUID-VkImageFormatConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateStructType(
                    pFormatConstraints_loc.dot(Field::imageCreateInfo),
                    &(pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo),
                    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, false, kVUIDUndefined, "VUID-VkImageCreateInfo-sType-sType");

                constexpr std::array allowed_structs_VkImageCreateInfo = {
                    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                    VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                    VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                    VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                    VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                    VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

                skip |= context.ValidateStructPnext(
                    pFormatConstraints_loc, pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.pNext,
                    allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique",
                    true);

                skip |= context.ValidateFlags(
                    pFormatConstraints_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.flags, kOptionalFlags,
                    "VUID-VkImageCreateInfo-flags-parameter");

                skip |= context.ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::imageType), vvl::Enum::VkImageType,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.imageType,
                    "VUID-VkImageCreateInfo-imageType-parameter");

                skip |= context.ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::format), vvl::Enum::VkFormat,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.format,
                    "VUID-VkImageCreateInfo-format-parameter");

                // No xml-driven validation

                skip |= context.ValidateFlags(
                    pFormatConstraints_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.samples, kRequiredSingleBit,
                    "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

                skip |= context.ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::tiling), vvl::Enum::VkImageTiling,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.tiling,
                    "VUID-VkImageCreateInfo-tiling-parameter");

                skip |= context.ValidateFlags(
                    pFormatConstraints_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.usage, kRequiredFlags,
                    "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

                skip |= context.ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.sharingMode,
                    "VUID-VkImageCreateInfo-sharingMode-parameter");

                skip |= context.ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.initialLayout,
                    "VUID-VkImageCreateInfo-initialLayout-parameter");

                skip |= context.ValidateFlags(
                    pFormatConstraints_loc.dot(Field::requiredFormatFeatures), vvl::FlagBitmask::VkFormatFeatureFlagBits,
                    AllVkFormatFeatureFlagBits,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].requiredFormatFeatures, kRequiredFlags,
                    "VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter",
                    "VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-requiredbitmask");

                skip |= context.ValidateReservedFlags(pFormatConstraints_loc.dot(Field::flags),
                                                      pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].flags,
                                                      "VUID-VkImageFormatConstraintsInfoFUCHSIA-flags-zerobitmask");

                skip |= context.ValidateStructTypeArray(
                    pFormatConstraints_loc.dot(Field::colorSpaceCount), pFormatConstraints_loc.dot(Field::pColorSpaces),
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].colorSpaceCount,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces,
                    VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA, true, true, "VUID-VkSysmemColorSpaceFUCHSIA-sType-sType",
                    "VUID-VkImageFormatConstraintsInfoFUCHSIA-pColorSpaces-parameter",
                    "VUID-VkImageFormatConstraintsInfoFUCHSIA-colorSpaceCount-arraylength");

                if (pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces != nullptr) {
                    for (uint32_t colorSpaceIndex = 0;
                         colorSpaceIndex < pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].colorSpaceCount;
                         ++colorSpaceIndex) {
                        [[maybe_unused]] const Location pColorSpaces_loc =
                            pFormatConstraints_loc.dot(Field::pColorSpaces, colorSpaceIndex);
                        skip |= context.ValidateStructPnext(
                            pColorSpaces_loc,
                            pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces[colorSpaceIndex].pNext,
                            0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSysmemColorSpaceFUCHSIA-pNext-pNext", kVUIDUndefined,
                            true);
                    }
                }
            }
        }

        skip |= context.ValidateStructType(pImageConstraintsInfo_loc.dot(Field::bufferCollectionConstraints),
                                           &(pImageConstraintsInfo->bufferCollectionConstraints),
                                           VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA, false, kVUIDUndefined,
                                           "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType");

        skip |= context.ValidateStructPnext(pImageConstraintsInfo_loc, pImageConstraintsInfo->bufferCollectionConstraints.pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pImageConstraintsInfo_loc.dot(Field::flags),
                                      vvl::FlagBitmask::VkImageConstraintsInfoFlagBitsFUCHSIA,
                                      AllVkImageConstraintsInfoFlagBitsFUCHSIA, pImageConstraintsInfo->flags, kOptionalFlags,
                                      "VUID-VkImageConstraintsInfoFUCHSIA-flags-parameter");
    }
    return skip;
}

bool Device::PreCallValidateSetBufferCollectionBufferConstraintsFUCHSIA(
    VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::collection), collection);
    skip |= context.ValidateStructType(loc.dot(Field::pBufferConstraintsInfo), pBufferConstraintsInfo,
                                       VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA, true,
                                       "VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-pBufferConstraintsInfo-parameter",
                                       "VUID-VkBufferConstraintsInfoFUCHSIA-sType-sType");
    if (pBufferConstraintsInfo != nullptr) {
        [[maybe_unused]] const Location pBufferConstraintsInfo_loc = loc.dot(Field::pBufferConstraintsInfo);
        skip |= context.ValidateStructPnext(pBufferConstraintsInfo_loc, pBufferConstraintsInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkBufferConstraintsInfoFUCHSIA-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateStructType(pBufferConstraintsInfo_loc.dot(Field::createInfo), &(pBufferConstraintsInfo->createInfo),
                                           VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, false, kVUIDUndefined,
                                           "VUID-VkBufferCreateInfo-sType-sType");

        constexpr std::array allowed_structs_VkBufferCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                                                                   VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
                                                                   VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= context.ValidateStructPnext(pBufferConstraintsInfo_loc, pBufferConstraintsInfo->createInfo.pNext,
                                            allowed_structs_VkBufferCreateInfo.size(), allowed_structs_VkBufferCreateInfo.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkBufferCreateInfo-pNext-pNext",
                                            "VUID-VkBufferCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pBufferConstraintsInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                                      AllVkBufferCreateFlagBits, pBufferConstraintsInfo->createInfo.flags, kOptionalFlags,
                                      "VUID-VkBufferCreateInfo-flags-parameter");

        skip |= context.ValidateRangedEnum(pBufferConstraintsInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                           pBufferConstraintsInfo->createInfo.sharingMode,
                                           "VUID-VkBufferCreateInfo-sharingMode-parameter");

        skip |= context.ValidateFlags(pBufferConstraintsInfo_loc.dot(Field::requiredFormatFeatures),
                                      vvl::FlagBitmask::VkFormatFeatureFlagBits, AllVkFormatFeatureFlagBits,
                                      pBufferConstraintsInfo->requiredFormatFeatures, kOptionalFlags,
                                      "VUID-VkBufferConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter");

        skip |= context.ValidateStructType(pBufferConstraintsInfo_loc.dot(Field::bufferCollectionConstraints),
                                           &(pBufferConstraintsInfo->bufferCollectionConstraints),
                                           VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA, false, kVUIDUndefined,
                                           "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType");

        skip |= context.ValidateStructPnext(pBufferConstraintsInfo_loc, pBufferConstraintsInfo->bufferCollectionConstraints.pNext,
                                            0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, true);
    }
    return skip;
}

bool Device::PreCallValidateDestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::collection), collection);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                                 VkBufferCollectionPropertiesFUCHSIA* pProperties,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::collection), collection);
    skip |=
        context.ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
                                   true, "VUID-vkGetBufferCollectionPropertiesFUCHSIA-pProperties-parameter",
                                   "VUID-VkBufferCollectionPropertiesFUCHSIA-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |= context.ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBufferCollectionPropertiesFUCHSIA-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

bool Device::PreCallValidateGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass,
                                                                          VkExtent2D* pMaxWorkgroupSize,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_huawei_subpass_shading))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_subpass_shading});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::renderpass), renderpass);
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMaxWorkgroupSize), pMaxWorkgroupSize,
                                            "VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-pMaxWorkgroupSize-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_huawei_subpass_shading))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_subpass_shading});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView,
                                                        VkImageLayout imageLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_huawei_invocation_mask))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_invocation_mask});
    skip |= context.ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                                       "VUID-vkCmdBindInvocationMaskHUAWEI-imageLayout-parameter");
    return skip;
}

bool Device::PreCallValidateGetMemoryRemoteAddressNV(VkDevice device,
                                                     const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo,
                                                     VkRemoteAddressNV* pAddress, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_external_memory_rdma))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_external_memory_rdma});
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryGetRemoteAddressInfo), pMemoryGetRemoteAddressInfo,
                                       VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV, true,
                                       "VUID-vkGetMemoryRemoteAddressNV-pMemoryGetRemoteAddressInfo-parameter",
                                       "VUID-VkMemoryGetRemoteAddressInfoNV-sType-sType");
    if (pMemoryGetRemoteAddressInfo != nullptr) {
        [[maybe_unused]] const Location pMemoryGetRemoteAddressInfo_loc = loc.dot(Field::pMemoryGetRemoteAddressInfo);
        skip |= context.ValidateStructPnext(pMemoryGetRemoteAddressInfo_loc, pMemoryGetRemoteAddressInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetRemoteAddressInfoNV-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |=
            context.ValidateRequiredHandle(pMemoryGetRemoteAddressInfo_loc.dot(Field::memory), pMemoryGetRemoteAddressInfo->memory);

        skip |= context.ValidateFlags(
            pMemoryGetRemoteAddressInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
            AllVkExternalMemoryHandleTypeFlagBits, pMemoryGetRemoteAddressInfo->handleType, kRequiredSingleBit,
            "VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter", "VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter");
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pAddress), pAddress, "VUID-vkGetMemoryRemoteAddressNV-pAddress-parameter");
    return skip;
}

bool Device::PreCallValidateGetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT* pPipelineInfo,
                                                     VkBaseOutStructure* pPipelineProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_pipeline_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_pipeline_properties});
    skip |=
        context.ValidateStructType(loc.dot(Field::pPipelineInfo), pPipelineInfo, VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR, true,
                                   "VUID-vkGetPipelinePropertiesEXT-pPipelineInfo-parameter", "VUID-VkPipelineInfoKHR-sType-sType");
    if (pPipelineInfo != nullptr) {
        [[maybe_unused]] const Location pPipelineInfo_loc = loc.dot(Field::pPipelineInfo);
        skip |= context.ValidateStructPnext(pPipelineInfo_loc, pPipelineInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pPipelineInfo_loc.dot(Field::pipeline), pPipelineInfo->pipeline);
    }
    if (!skip) skip |= manual_PreCallValidateGetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties, context);
    return skip;
}

bool Device::PreCallValidateCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable, error_obj);
    return skip;
}

bool Device::PreCallValidateCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRangedEnum(loc.dot(Field::logicOp), vvl::Enum::VkLogicOp, logicOp,
                                       "VUID-vkCmdSetLogicOpEXT-logicOp-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool Instance::PreCallValidateCreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_qnx_screen_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_screen_surface});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX,
                                       true, "VUID-vkCreateScreenSurfaceQNX-pCreateInfo-parameter",
                                       "VUID-VkScreenSurfaceCreateInfoQNX-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkScreenSurfaceCreateInfoQNX-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkScreenSurfaceCreateInfoQNX-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateScreenSurfaceQNX-pSurface-parameter");
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice,
                                                                            uint32_t queueFamilyIndex,
                                                                            struct _screen_window* window,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_qnx_screen_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_screen_surface});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::window), window,
                                            "VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-window-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

bool Device::PreCallValidateCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                                      const VkBool32* pColorWriteEnables, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_color_write_enable))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_color_write_enable});
    skip |=
        context.ValidateBool32Array(loc.dot(Field::attachmentCount), loc.dot(Field::pColorWriteEnables), attachmentCount,
                                    pColorWriteEnables, true, true, "VUID-vkCmdSetColorWriteEnableEXT-attachmentCount-arraylength",
                                    "VUID-vkCmdSetColorWriteEnableEXT-pColorWriteEnables-parameter");
    return skip;
}

bool Device::PreCallValidateCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                            const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance,
                                            uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_multi_draw)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_multi_draw});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                                   const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount,
                                                   uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_multi_draw)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_multi_draw});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo,
                                              const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |=
        context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT, true,
                                   "VUID-vkCreateMicromapEXT-pCreateInfo-parameter", "VUID-VkMicromapCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMicromapCreateInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::createFlags), vvl::FlagBitmask::VkMicromapCreateFlagBitsEXT,
                                      AllVkMicromapCreateFlagBitsEXT, pCreateInfo->createFlags, kOptionalFlags,
                                      "VUID-VkMicromapCreateInfoEXT-createFlags-parameter");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::buffer), pCreateInfo->buffer);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pCreateInfo->type,
                                           "VUID-VkMicromapCreateInfoEXT-type-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMicromap), pMicromap, "VUID-vkCreateMicromapEXT-pMicromap-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap, context);
    return skip;
}

bool Device::PreCallValidateDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    if (!skip) skip |= manual_PreCallValidateDestroyMicromapEXT(device, micromap, pAllocator, context);
    return skip;
}

bool Device::PreCallValidateCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                 const VkMicromapBuildInfoEXT* pInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos, VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, true,
        "VUID-VkMicromapBuildInfoEXT-sType-sType", "VUID-vkCmdBuildMicromapsEXT-pInfos-parameter",
        "VUID-vkCmdBuildMicromapsEXT-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= context.ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pInfos[infoIndex].type,
                                               "VUID-VkMicromapBuildInfoEXT-type-parameter");

            skip |= context.ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildMicromapFlagBitsEXT,
                                          AllVkBuildMicromapFlagBitsEXT, pInfos[infoIndex].flags, kOptionalFlags,
                                          "VUID-VkMicromapBuildInfoEXT-flags-parameter");

            if (pInfos[infoIndex].pUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location pUsageCounts_loc = pInfos_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }

            if (pInfos[infoIndex].ppUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location ppUsageCounts_loc = pInfos_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos, context);
    return skip;
}

bool Device::PreCallValidateBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount,
                                              const VkMicromapBuildInfoEXT* pInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                            VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, true,
                                            "VUID-VkMicromapBuildInfoEXT-sType-sType", "VUID-vkBuildMicromapsEXT-pInfos-parameter",
                                            "VUID-vkBuildMicromapsEXT-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= context.ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pInfos[infoIndex].type,
                                               "VUID-VkMicromapBuildInfoEXT-type-parameter");

            skip |= context.ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildMicromapFlagBitsEXT,
                                          AllVkBuildMicromapFlagBitsEXT, pInfos[infoIndex].flags, kOptionalFlags,
                                          "VUID-VkMicromapBuildInfoEXT-flags-parameter");

            if (pInfos[infoIndex].pUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location pUsageCounts_loc = pInfos_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }

            if (pInfos[infoIndex].ppUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location ppUsageCounts_loc = pInfos_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateBuildMicromapsEXT(device, deferredOperation, infoCount, pInfos, context);
    return skip;
}

bool Device::PreCallValidateCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                            const VkCopyMicromapInfoEXT* pInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, true,
                                       "VUID-vkCopyMicromapEXT-pInfo-parameter", "VUID-VkCopyMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMicromapInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                           "VUID-VkCopyMicromapInfoEXT-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyMicromapEXT(device, deferredOperation, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                    const VkCopyMicromapToMemoryInfoEXT* pInfo,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, true,
                                       "VUID-vkCopyMicromapToMemoryEXT-pInfo-parameter",
                                       "VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                           "VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyMicromapToMemoryEXT(device, deferredOperation, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                    const VkCopyMemoryToMicromapInfoEXT* pInfo,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, true,
                                       "VUID-vkCopyMemoryToMicromapEXT-pInfo-parameter",
                                       "VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                           "VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyMemoryToMicromapEXT(device, deferredOperation, pInfo, context);
    return skip;
}

bool Device::PreCallValidateWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps,
                                                        VkQueryType queryType, size_t dataSize, void* pData, size_t stride,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateHandleArray(loc.dot(Field::micromapCount), loc.dot(Field::pMicromaps), micromapCount, pMicromaps, true,
                                        true, "VUID-vkWriteMicromapsPropertiesEXT-micromapCount-arraylength");
    skip |= context.ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                                       "VUID-vkWriteMicromapsPropertiesEXT-queryType-parameter");
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkWriteMicromapsPropertiesEXT-dataSize-arraylength",
                                  "VUID-vkWriteMicromapsPropertiesEXT-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateWriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData,
                                                                  stride, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, true,
                                       "VUID-vkCmdCopyMicromapEXT-pInfo-parameter", "VUID-VkCopyMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMicromapInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                           "VUID-VkCopyMicromapInfoEXT-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyMicromapEXT(commandBuffer, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, true,
                                       "VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-parameter",
                                       "VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                           "VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyMicromapToMemoryEXT(commandBuffer, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, true,
                                       "VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-parameter",
                                       "VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                           "VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyMemoryToMicromapEXT(commandBuffer, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount,
                                                           const VkMicromapEXT* pMicromaps, VkQueryType queryType,
                                                           VkQueryPool queryPool, uint32_t firstQuery,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateHandleArray(loc.dot(Field::micromapCount), loc.dot(Field::pMicromaps), micromapCount, pMicromaps, true,
                                        true, "VUID-vkCmdWriteMicromapsPropertiesEXT-micromapCount-arraylength");
    skip |= context.ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                                       "VUID-vkCmdWriteMicromapsPropertiesEXT-queryType-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    if (!skip)
        skip |= manual_PreCallValidateCmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool,
                                                                     firstQuery, context);
    return skip;
}

bool Device::PreCallValidateGetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT* pVersionInfo,
                                                              VkAccelerationStructureCompatibilityKHR* pCompatibility,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateStructType(loc.dot(Field::pVersionInfo), pVersionInfo, VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT,
                                       true, "VUID-vkGetDeviceMicromapCompatibilityEXT-pVersionInfo-parameter",
                                       "VUID-VkMicromapVersionInfoEXT-sType-sType");
    if (pVersionInfo != nullptr) {
        [[maybe_unused]] const Location pVersionInfo_loc = loc.dot(Field::pVersionInfo);
        skip |= context.ValidateStructPnext(pVersionInfo_loc, pVersionInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMicromapVersionInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pVersionInfo_loc.dot(Field::pVersionData), pVersionInfo->pVersionData,
                                                "VUID-VkMicromapVersionInfoEXT-pVersionData-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCompatibility), pCompatibility,
                                            "VUID-vkGetDeviceMicromapCompatibilityEXT-pCompatibility-parameter");
    if (!skip) skip |= manual_PreCallValidateGetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility, context);
    return skip;
}

bool Device::PreCallValidateGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
                                                     const VkMicromapBuildInfoEXT* pBuildInfo,
                                                     VkMicromapBuildSizesInfoEXT* pSizeInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= context.ValidateRangedEnum(loc.dot(Field::buildType), vvl::Enum::VkAccelerationStructureBuildTypeKHR, buildType,
                                       "VUID-vkGetMicromapBuildSizesEXT-buildType-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pBuildInfo), pBuildInfo, VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true,
                                       "VUID-vkGetMicromapBuildSizesEXT-pBuildInfo-parameter",
                                       "VUID-VkMicromapBuildInfoEXT-sType-sType");
    if (pBuildInfo != nullptr) {
        [[maybe_unused]] const Location pBuildInfo_loc = loc.dot(Field::pBuildInfo);
        skip |= context.ValidateStructPnext(pBuildInfo_loc, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pBuildInfo_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pBuildInfo->type,
                                           "VUID-VkMicromapBuildInfoEXT-type-parameter");

        skip |= context.ValidateFlags(pBuildInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildMicromapFlagBitsEXT,
                                      AllVkBuildMicromapFlagBitsEXT, pBuildInfo->flags, kOptionalFlags,
                                      "VUID-VkMicromapBuildInfoEXT-flags-parameter");

        if (pBuildInfo->pUsageCounts != nullptr) {
            for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pBuildInfo->usageCountsCount; ++usageIndexsIndex) {
                [[maybe_unused]] const Location pUsageCounts_loc = pBuildInfo_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                // No xml-driven validation
            }
        }

        if (pBuildInfo->ppUsageCounts != nullptr) {
            for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pBuildInfo->usageCountsCount; ++usageIndexsIndex) {
                [[maybe_unused]] const Location ppUsageCounts_loc = pBuildInfo_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                // No xml-driven validation
            }
        }
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo, VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT, true,
                                       "VUID-vkGetMicromapBuildSizesEXT-pSizeInfo-parameter",
                                       "VUID-VkMicromapBuildSizesInfoEXT-sType-sType");
    if (pSizeInfo != nullptr) {
        [[maybe_unused]] const Location pSizeInfo_loc = loc.dot(Field::pSizeInfo);
        skip |= context.ValidateStructPnext(pSizeInfo_loc, pSizeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkMicromapBuildSizesInfoEXT-pNext-pNext", kVUIDUndefined, false);

        skip |= context.ValidateBool32(pSizeInfo_loc.dot(Field::discardable), pSizeInfo->discardable);
    }
    if (!skip) skip |= manual_PreCallValidateGetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                                                 uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_huawei_cluster_culling_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_cluster_culling_shader});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_huawei_cluster_culling_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_cluster_culling_shader});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool Device::PreCallValidateSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_pageable_device_local_memory))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_pageable_device_local_memory});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::memory), memory);
    if (!skip) skip |= manual_PreCallValidateSetDeviceMemoryPriorityEXT(device, memory, priority, context);
    return skip;
}

bool Device::PreCallValidateGetDescriptorSetLayoutHostMappingInfoVALVE(
    VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference,
    VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_valve_descriptor_set_host_mapping))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_VALVE_descriptor_set_host_mapping});
    skip |= context.ValidateStructType(loc.dot(Field::pBindingReference), pBindingReference,
                                       VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE, true,
                                       "VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter",
                                       "VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType");
    if (pBindingReference != nullptr) {
        [[maybe_unused]] const Location pBindingReference_loc = loc.dot(Field::pBindingReference);
        skip |=
            context.ValidateStructPnext(pBindingReference_loc, pBindingReference->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pBindingReference_loc.dot(Field::descriptorSetLayout),
                                               pBindingReference->descriptorSetLayout);
    }
    skip |= context.ValidateStructType(loc.dot(Field::pHostMapping), pHostMapping,
                                       VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE, true,
                                       "VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter",
                                       "VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType");
    if (pHostMapping != nullptr) {
        [[maybe_unused]] const Location pHostMapping_loc = loc.dot(Field::pHostMapping);
        skip |= context.ValidateStructPnext(pHostMapping_loc, pHostMapping->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void** ppData,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_valve_descriptor_set_host_mapping))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_VALVE_descriptor_set_host_mapping});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::descriptorSet), descriptorSet);
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::ppData), ppData, "VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter");
    return skip;
}

bool Device::PreCallValidateCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress,
                                                    uint32_t copyCount, uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_copy_memory_indirect))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_copy_memory_indirect});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress,
                                                           uint32_t copyCount, uint32_t stride, VkImage dstImage,
                                                           VkImageLayout dstImageLayout,
                                                           const VkImageSubresourceLayers* pImageSubresources,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_copy_memory_indirect))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_copy_memory_indirect});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= context.ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                                       "VUID-vkCmdCopyMemoryToImageIndirectNV-dstImageLayout-parameter");
    skip |= context.ValidateArray(loc.dot(Field::copyCount), loc.dot(Field::pImageSubresources), copyCount, &pImageSubresources,
                                  true, true, "VUID-vkCmdCopyMemoryToImageIndirectNV-copyCount-arraylength",
                                  "VUID-vkCmdCopyMemoryToImageIndirectNV-pImageSubresources-parameter");
    if (pImageSubresources != nullptr) {
        for (uint32_t copyIndex = 0; copyIndex < copyCount; ++copyIndex) {
            [[maybe_unused]] const Location pImageSubresources_loc = loc.dot(Field::pImageSubresources, copyIndex);
            skip |= context.ValidateFlags(pImageSubresources_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                          AllVkImageAspectFlagBits, pImageSubresources[copyIndex].aspectMask, kRequiredFlags,
                                          "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                          "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount,
                                                  const VkDecompressMemoryRegionNV* pDecompressMemoryRegions,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_memory_decompression))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_memory_decompression});
    skip |= context.ValidateArray(loc.dot(Field::decompressRegionCount), loc.dot(Field::pDecompressMemoryRegions),
                                  decompressRegionCount, &pDecompressMemoryRegions, true, true,
                                  "VUID-vkCmdDecompressMemoryNV-decompressRegionCount-arraylength",
                                  "VUID-vkCmdDecompressMemoryNV-pDecompressMemoryRegions-parameter");
    if (pDecompressMemoryRegions != nullptr) {
        for (uint32_t decompressRegionIndex = 0; decompressRegionIndex < decompressRegionCount; ++decompressRegionIndex) {
            [[maybe_unused]] const Location pDecompressMemoryRegions_loc =
                loc.dot(Field::pDecompressMemoryRegions, decompressRegionIndex);
            skip |= context.ValidateFlags(pDecompressMemoryRegions_loc.dot(Field::decompressionMethod),
                                          vvl::FlagBitmask::VkMemoryDecompressionMethodFlagBitsNV,
                                          AllVkMemoryDecompressionMethodFlagBitsNV,
                                          pDecompressMemoryRegions[decompressRegionIndex].decompressionMethod, kRequiredFlags,
                                          "VUID-VkDecompressMemoryRegionNV-decompressionMethod-parameter",
                                          "VUID-VkDecompressMemoryRegionNV-decompressionMethod-requiredbitmask");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer,
                                                               VkDeviceAddress indirectCommandsAddress,
                                                               VkDeviceAddress indirectCommandsCountAddress, uint32_t stride,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_memory_decompression))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_memory_decompression});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateGetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo,
                                                                    VkMemoryRequirements2* pMemoryRequirements,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands_compute))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands_compute});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
                                       true, "VUID-vkGetPipelineIndirectMemoryRequirementsNV-pCreateInfo-parameter",
                                       "VUID-VkComputePipelineCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkComputePipelineCreateInfo = {
            VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,   VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,  VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
            VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,     VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkComputePipelineCreateInfo.size(),
                                            allowed_structs_VkComputePipelineCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkComputePipelineCreateInfo-pNext-pNext",
                                            "VUID-VkComputePipelineCreateInfo-sType-unique", true);

        skip |= context.ValidateStructType(pCreateInfo_loc.dot(Field::stage), &(pCreateInfo->stage),
                                           VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, kVUIDUndefined,
                                           "VUID-VkPipelineShaderStageCreateInfo-sType-sType");

        constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
            VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->stage.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(),
            allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                      AllVkPipelineShaderStageCreateFlagBits, pCreateInfo->stage.flags, kOptionalFlags,
                                      "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfo->stage.stage, kRequiredSingleBit,
                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

        skip |= context.ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pName), pCreateInfo->stage.pName,
                                                "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

        if (pCreateInfo->stage.pSpecializationInfo != nullptr) {
            [[maybe_unused]] const Location pSpecializationInfo_loc = pCreateInfo_loc.dot(Field::pSpecializationInfo);
            skip |= context.ValidateArray(
                pSpecializationInfo_loc.dot(Field::mapEntryCount), pSpecializationInfo_loc.dot(Field::pMapEntries),
                pCreateInfo->stage.pSpecializationInfo->mapEntryCount, &pCreateInfo->stage.pSpecializationInfo->pMapEntries, false,
                true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

            if (pCreateInfo->stage.pSpecializationInfo->pMapEntries != nullptr) {
                for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfo->stage.pSpecializationInfo->mapEntryCount;
                     ++mapEntryIndex) {
                    [[maybe_unused]] const Location pMapEntries_loc =
                        pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                    // No xml-driven validation
                }
            }

            skip |= context.ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                          pCreateInfo->stage.pSpecializationInfo->dataSize,
                                          &pCreateInfo->stage.pSpecializationInfo->pData, false, true, kVUIDUndefined,
                                          "VUID-VkSpecializationInfo-pData-parameter");
        }

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::layout), pCreateInfo->layout);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetPipelineIndirectMemoryRequirementsNV-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                              VkPipeline pipeline, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands_compute))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands_compute});
    skip |= context.ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                                       "VUID-vkCmdUpdatePipelineIndirectBufferNV-pipelineBindPoint-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool Device::PreCallValidateGetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_device_generated_commands_compute))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands_compute});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV,
                                       true, "VUID-vkGetPipelineIndirectDeviceAddressNV-pInfo-parameter",
                                       "VUID-VkPipelineIndirectDeviceAddressInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkPipelineIndirectDeviceAddressInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pInfo->pipelineBindPoint,
                                           "VUID-VkPipelineIndirectDeviceAddressInfoNV-pipelineBindPoint-parameter");

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::pipeline), pInfo->pipeline);
    }
    return skip;
}

bool Device::PreCallValidateCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::depthClampEnable), depthClampEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode,
                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRangedEnum(loc.dot(Field::polygonMode), vvl::Enum::VkPolygonMode, polygonMode,
                                       "VUID-vkCmdSetPolygonModeEXT-polygonMode-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateFlags(loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                  AllVkSampleCountFlagBits, rasterizationSamples, kRequiredSingleBit,
                                  "VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter",
                                  "VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples,
                                                const VkSampleMask* pSampleMask, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateFlags(loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits,
                                  samples, kRequiredSingleBit, "VUID-vkCmdSetSampleMaskEXT-samples-parameter",
                                  "VUID-vkCmdSetSampleMaskEXT-samples-parameter");
    skip |= context.ValidateArray(loc.dot(Field::samples), loc.dot(Field::pSampleMask), (samples + 31) / 32, &pSampleMask, true,
                                  true, kVUIDUndefined, "VUID-vkCmdSetSampleMaskEXT-pSampleMask-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::alphaToCoverageEnable), alphaToCoverageEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::alphaToOneEnable), alphaToOneEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::logicOpEnable), logicOpEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                      uint32_t attachmentCount, const VkBool32* pColorBlendEnables,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |=
        context.ValidateBool32Array(loc.dot(Field::attachmentCount), loc.dot(Field::pColorBlendEnables), attachmentCount,
                                    pColorBlendEnables, true, true, "VUID-vkCmdSetColorBlendEnableEXT-attachmentCount-arraylength",
                                    "VUID-vkCmdSetColorBlendEnableEXT-pColorBlendEnables-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                        uint32_t attachmentCount,
                                                        const VkColorBlendEquationEXT* pColorBlendEquations,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |=
        context.ValidateArray(loc.dot(Field::attachmentCount), loc.dot(Field::pColorBlendEquations), attachmentCount,
                              &pColorBlendEquations, true, true, "VUID-vkCmdSetColorBlendEquationEXT-attachmentCount-arraylength",
                              "VUID-vkCmdSetColorBlendEquationEXT-pColorBlendEquations-parameter");
    if (pColorBlendEquations != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pColorBlendEquations_loc = loc.dot(Field::pColorBlendEquations, attachmentIndex);
            skip |= context.ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::srcColorBlendFactor), vvl::Enum::VkBlendFactor,
                                               pColorBlendEquations[attachmentIndex].srcColorBlendFactor,
                                               "VUID-VkColorBlendEquationEXT-srcColorBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::dstColorBlendFactor), vvl::Enum::VkBlendFactor,
                                               pColorBlendEquations[attachmentIndex].dstColorBlendFactor,
                                               "VUID-VkColorBlendEquationEXT-dstColorBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::colorBlendOp), vvl::Enum::VkBlendOp,
                                               pColorBlendEquations[attachmentIndex].colorBlendOp,
                                               "VUID-VkColorBlendEquationEXT-colorBlendOp-parameter");

            skip |= context.ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::srcAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                               pColorBlendEquations[attachmentIndex].srcAlphaBlendFactor,
                                               "VUID-VkColorBlendEquationEXT-srcAlphaBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::dstAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                               pColorBlendEquations[attachmentIndex].dstAlphaBlendFactor,
                                               "VUID-VkColorBlendEquationEXT-dstAlphaBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::alphaBlendOp), vvl::Enum::VkBlendOp,
                                               pColorBlendEquations[attachmentIndex].alphaBlendOp,
                                               "VUID-VkColorBlendEquationEXT-alphaBlendOp-parameter");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                    uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateFlagsArray(loc.dot(Field::attachmentCount), loc.dot(Field::pColorWriteMasks),
                                       vvl::FlagBitmask::VkColorComponentFlagBits, AllVkColorComponentFlagBits, attachmentCount,
                                       pColorWriteMasks, true, "VUID-vkCmdSetColorWriteMaskEXT-attachmentCount-arraylength",
                                       "VUID-vkCmdSetColorWriteMaskEXT-pColorWriteMasks-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer,
                                                              VkTessellationDomainOrigin domainOrigin,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRangedEnum(loc.dot(Field::domainOrigin), vvl::Enum::VkTessellationDomainOrigin, domainOrigin,
                                       "VUID-vkCmdSetTessellationDomainOriginEXT-domainOrigin-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer,
                                                                   VkConservativeRasterizationModeEXT conservativeRasterizationMode,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRangedEnum(loc.dot(Field::conservativeRasterizationMode), vvl::Enum::VkConservativeRasterizationModeEXT,
                                       conservativeRasterizationMode,
                                       "VUID-vkCmdSetConservativeRasterizationModeEXT-conservativeRasterizationMode-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer,
                                                                      float extraPrimitiveOverestimationSize,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::depthClipEnable), depthClipEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::sampleLocationsEnable), sampleLocationsEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                        uint32_t attachmentCount,
                                                        const VkColorBlendAdvancedEXT* pColorBlendAdvanced,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |=
        context.ValidateArray(loc.dot(Field::attachmentCount), loc.dot(Field::pColorBlendAdvanced), attachmentCount,
                              &pColorBlendAdvanced, true, true, "VUID-vkCmdSetColorBlendAdvancedEXT-attachmentCount-arraylength",
                              "VUID-vkCmdSetColorBlendAdvancedEXT-pColorBlendAdvanced-parameter");
    if (pColorBlendAdvanced != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pColorBlendAdvanced_loc = loc.dot(Field::pColorBlendAdvanced, attachmentIndex);
            skip |= context.ValidateRangedEnum(pColorBlendAdvanced_loc.dot(Field::advancedBlendOp), vvl::Enum::VkBlendOp,
                                               pColorBlendAdvanced[attachmentIndex].advancedBlendOp,
                                               "VUID-VkColorBlendAdvancedEXT-advancedBlendOp-parameter");

            skip |= context.ValidateBool32(pColorBlendAdvanced_loc.dot(Field::srcPremultiplied),
                                           pColorBlendAdvanced[attachmentIndex].srcPremultiplied);

            skip |= context.ValidateBool32(pColorBlendAdvanced_loc.dot(Field::dstPremultiplied),
                                           pColorBlendAdvanced[attachmentIndex].dstPremultiplied);

            skip |= context.ValidateRangedEnum(pColorBlendAdvanced_loc.dot(Field::blendOverlap), vvl::Enum::VkBlendOverlapEXT,
                                               pColorBlendAdvanced[attachmentIndex].blendOverlap,
                                               "VUID-VkColorBlendAdvancedEXT-blendOverlap-parameter");

            skip |= context.ValidateBool32(pColorBlendAdvanced_loc.dot(Field::clampResults),
                                           pColorBlendAdvanced[attachmentIndex].clampResults);
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer,
                                                         VkProvokingVertexModeEXT provokingVertexMode,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRangedEnum(loc.dot(Field::provokingVertexMode), vvl::Enum::VkProvokingVertexModeEXT,
                                       provokingVertexMode, "VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer,
                                                           VkLineRasterizationModeEXT lineRasterizationMode,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::stippledLineEnable), stippledLineEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::negativeOneToOne), negativeOneToOne);
    return skip;
}

bool Device::PreCallValidateCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::viewportWScalingEnable), viewportWScalingEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
                                                    const VkViewportSwizzleNV* pViewportSwizzles,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewportSwizzles), viewportCount,
                                  &pViewportSwizzles, true, true, "VUID-vkCmdSetViewportSwizzleNV-viewportCount-arraylength",
                                  "VUID-vkCmdSetViewportSwizzleNV-pViewportSwizzles-parameter");
    if (pViewportSwizzles != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewportSwizzles_loc = loc.dot(Field::pViewportSwizzles, viewportIndex);
            skip |= context.ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::x), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                               pViewportSwizzles[viewportIndex].x, "VUID-VkViewportSwizzleNV-x-parameter");

            skip |= context.ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::y), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                               pViewportSwizzles[viewportIndex].y, "VUID-VkViewportSwizzleNV-y-parameter");

            skip |= context.ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::z), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                               pViewportSwizzles[viewportIndex].z, "VUID-VkViewportSwizzleNV-z-parameter");

            skip |= context.ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::w), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                               pViewportSwizzles[viewportIndex].w, "VUID-VkViewportSwizzleNV-w-parameter");
        }
    }
    return skip;
}

bool Device::PreCallValidateCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::coverageToColorEnable), coverageToColorEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer,
                                                           VkCoverageModulationModeNV coverageModulationMode,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRangedEnum(loc.dot(Field::coverageModulationMode), vvl::Enum::VkCoverageModulationModeNV,
                                       coverageModulationMode,
                                       "VUID-vkCmdSetCoverageModulationModeNV-coverageModulationMode-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer,
                                                                  VkBool32 coverageModulationTableEnable,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::coverageModulationTableEnable), coverageModulationTableEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount,
                                                            const float* pCoverageModulationTable,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateArray(loc.dot(Field::coverageModulationTableCount), loc.dot(Field::pCoverageModulationTable),
                                  coverageModulationTableCount, &pCoverageModulationTable, true, true,
                                  "VUID-vkCmdSetCoverageModulationTableNV-coverageModulationTableCount-arraylength",
                                  "VUID-vkCmdSetCoverageModulationTableNV-pCoverageModulationTable-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::shadingRateImageEnable), shadingRateImageEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer,
                                                                     VkBool32 representativeFragmentTestEnable,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateBool32(loc.dot(Field::representativeFragmentTestEnable), representativeFragmentTestEnable);
    return skip;
}

bool Device::PreCallValidateCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer,
                                                          VkCoverageReductionModeNV coverageReductionMode,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |=
        context.ValidateRangedEnum(loc.dot(Field::coverageReductionMode), vvl::Enum::VkCoverageReductionModeNV,
                                   coverageReductionMode, "VUID-vkCmdSetCoverageReductionModeNV-coverageReductionMode-parameter");
    return skip;
}

bool Device::PreCallValidateGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule,
                                                         VkShaderModuleIdentifierEXT* pIdentifier,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_shader_module_identifier))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_module_identifier});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::shaderModule), shaderModule);
    skip |= context.ValidateStructType(loc.dot(Field::pIdentifier), pIdentifier, VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT,
                                       true, "VUID-vkGetShaderModuleIdentifierEXT-pIdentifier-parameter",
                                       "VUID-VkShaderModuleIdentifierEXT-sType-sType");
    if (pIdentifier != nullptr) {
        [[maybe_unused]] const Location pIdentifier_loc = loc.dot(Field::pIdentifier);
        skip |= context.ValidateStructPnext(pIdentifier_loc, pIdentifier->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkShaderModuleIdentifierEXT-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo,
                                                                   VkShaderModuleIdentifierEXT* pIdentifier,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_shader_module_identifier))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_module_identifier});
    skip |= context.ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true,
                                       "VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pCreateInfo-parameter",
                                       "VUID-VkShaderModuleCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                              "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

        skip |= context.ValidateArray(
            pCreateInfo_loc.dot(Field::codeSize), pCreateInfo_loc.dot(Field::pCode), pCreateInfo->codeSize / 4, &pCreateInfo->pCode,
            true, true, "VUID-VkShaderModuleCreateInfo-codeSize-01085", "VUID-VkShaderModuleCreateInfo-pCode-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pIdentifier), pIdentifier, VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT,
                                       true, "VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pIdentifier-parameter",
                                       "VUID-VkShaderModuleIdentifierEXT-sType-sType");
    if (pIdentifier != nullptr) {
        [[maybe_unused]] const Location pIdentifier_loc = loc.dot(Field::pIdentifier);
        skip |= context.ValidateStructPnext(pIdentifier_loc, pIdentifier->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkShaderModuleIdentifierEXT-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceOpticalFlowImageFormatsNV(
    VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount,
    VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructType(loc.dot(Field::pOpticalFlowImageFormatInfo), pOpticalFlowImageFormatInfo,
                                       VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, true,
                                       "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pOpticalFlowImageFormatInfo-parameter",
                                       "VUID-VkOpticalFlowImageFormatInfoNV-sType-sType");
    if (pOpticalFlowImageFormatInfo != nullptr) {
        [[maybe_unused]] const Location pOpticalFlowImageFormatInfo_loc = loc.dot(Field::pOpticalFlowImageFormatInfo);
        skip |= context.ValidateFlags(
            pOpticalFlowImageFormatInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkOpticalFlowUsageFlagBitsNV,
            AllVkOpticalFlowUsageFlagBitsNV, pOpticalFlowImageFormatInfo->usage, kRequiredFlags,
            "VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter", "VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask");
    }
    skip |=
        context.ValidateStructTypeArray(loc.dot(Field::pFormatCount), loc.dot(Field::pImageFormatProperties), pFormatCount,
                                        pImageFormatProperties, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV, true,
                                        false, false, "VUID-VkOpticalFlowImageFormatPropertiesNV-sType-sType", kVUIDUndefined,
                                        "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pFormatCount-parameter", kVUIDUndefined);
    if (pImageFormatProperties != nullptr) {
        for (uint32_t pFormatIndex = 0; pFormatIndex < *pFormatCount; ++pFormatIndex) {
            [[maybe_unused]] const Location pImageFormatProperties_loc = loc.dot(Field::pImageFormatProperties, pFormatIndex);
            skip |= context.ValidateStructPnext(pImageFormatProperties_loc, pImageFormatProperties[pFormatIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion,
                                                "VUID-VkOpticalFlowImageFormatPropertiesNV-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

bool Device::PreCallValidateCreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV, true,
        "VUID-vkCreateOpticalFlowSessionNV-pCreateInfo-parameter", "VUID-VkOpticalFlowSessionCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkOpticalFlowSessionCreateInfoNV = {
            VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV};

        skip |= context.ValidateStructPnext(
            pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkOpticalFlowSessionCreateInfoNV.size(),
            allowed_structs_VkOpticalFlowSessionCreateInfoNV.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkOpticalFlowSessionCreateInfoNV-pNext-pNext", "VUID-VkOpticalFlowSessionCreateInfoNV-sType-unique", true);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageFormat), vvl::Enum::VkFormat, pCreateInfo->imageFormat,
                                           "VUID-VkOpticalFlowSessionCreateInfoNV-imageFormat-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::flowVectorFormat), vvl::Enum::VkFormat,
                                           pCreateInfo->flowVectorFormat,
                                           "VUID-VkOpticalFlowSessionCreateInfoNV-flowVectorFormat-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::costFormat), vvl::Enum::VkFormat, pCreateInfo->costFormat,
                                           "VUID-VkOpticalFlowSessionCreateInfoNV-costFormat-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::outputGridSize), vvl::FlagBitmask::VkOpticalFlowGridSizeFlagBitsNV,
                                      AllVkOpticalFlowGridSizeFlagBitsNV, pCreateInfo->outputGridSize, kRequiredFlags,
                                      "VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-parameter",
                                      "VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-requiredbitmask");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::hintGridSize), vvl::FlagBitmask::VkOpticalFlowGridSizeFlagBitsNV,
                                      AllVkOpticalFlowGridSizeFlagBitsNV, pCreateInfo->hintGridSize, kOptionalFlags,
                                      "VUID-VkOpticalFlowSessionCreateInfoNV-hintGridSize-parameter");

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::performanceLevel), vvl::Enum::VkOpticalFlowPerformanceLevelNV,
                                           pCreateInfo->performanceLevel,
                                           "VUID-VkOpticalFlowSessionCreateInfoNV-performanceLevel-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkOpticalFlowSessionCreateFlagBitsNV,
                                      AllVkOpticalFlowSessionCreateFlagBitsNV, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkOpticalFlowSessionCreateInfoNV-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pSession), pSession, "VUID-vkCreateOpticalFlowSessionNV-pSession-parameter");
    return skip;
}

bool Device::PreCallValidateDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session,
                                                        const VkAllocationCallbacks* pAllocator,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::session), session);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session,
                                                          VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view,
                                                          VkImageLayout layout, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::session), session);
    skip |= context.ValidateRangedEnum(loc.dot(Field::bindingPoint), vvl::Enum::VkOpticalFlowSessionBindingPointNV, bindingPoint,
                                       "VUID-vkBindOpticalFlowSessionImageNV-bindingPoint-parameter");
    skip |= context.ValidateRangedEnum(loc.dot(Field::layout), vvl::Enum::VkImageLayout, layout,
                                       "VUID-vkBindOpticalFlowSessionImageNV-layout-parameter");
    return skip;
}

bool Device::PreCallValidateCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session,
                                                    const VkOpticalFlowExecuteInfoNV* pExecuteInfo,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_optical_flow)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::session), session);
    skip |= context.ValidateStructType(loc.dot(Field::pExecuteInfo), pExecuteInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV,
                                       true, "VUID-vkCmdOpticalFlowExecuteNV-pExecuteInfo-parameter",
                                       "VUID-VkOpticalFlowExecuteInfoNV-sType-sType");
    if (pExecuteInfo != nullptr) {
        [[maybe_unused]] const Location pExecuteInfo_loc = loc.dot(Field::pExecuteInfo);
        skip |= context.ValidateStructPnext(pExecuteInfo_loc, pExecuteInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkOpticalFlowExecuteInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pExecuteInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkOpticalFlowExecuteFlagBitsNV,
                                      AllVkOpticalFlowExecuteFlagBitsNV, pExecuteInfo->flags, kOptionalFlags,
                                      "VUID-VkOpticalFlowExecuteInfoNV-flags-parameter");

        skip |= context.ValidateArray(pExecuteInfo_loc.dot(Field::regionCount), pExecuteInfo_loc.dot(Field::pRegions),
                                      pExecuteInfo->regionCount, &pExecuteInfo->pRegions, false, true, kVUIDUndefined,
                                      "VUID-VkOpticalFlowExecuteInfoNV-pRegions-parameter");
    }
    return skip;
}

bool Device::PreCallValidateAntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_amd_anti_lag)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_anti_lag});
    skip |= context.ValidateStructType(loc.dot(Field::pData), pData, VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD, true,
                                       "VUID-vkAntiLagUpdateAMD-pData-parameter", "VUID-VkAntiLagDataAMD-sType-sType");
    if (pData != nullptr) {
        [[maybe_unused]] const Location pData_loc = loc.dot(Field::pData);
        skip |= context.ValidateRangedEnum(pData_loc.dot(Field::mode), vvl::Enum::VkAntiLagModeAMD, pData->mode,
                                           "VUID-VkAntiLagDataAMD-mode-parameter");

        skip |= context.ValidateStructType(
            pData_loc.dot(Field::pPresentationInfo), pData->pPresentationInfo, VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD,
            false, "VUID-VkAntiLagDataAMD-pPresentationInfo-parameter", "VUID-VkAntiLagPresentationInfoAMD-sType-sType");

        if (pData->pPresentationInfo != nullptr) {
            [[maybe_unused]] const Location pPresentationInfo_loc = pData_loc.dot(Field::pPresentationInfo);
            skip |=
                context.ValidateRangedEnum(pPresentationInfo_loc.dot(Field::stage), vvl::Enum::VkAntiLagStageAMD,
                                           pData->pPresentationInfo->stage, "VUID-VkAntiLagPresentationInfoAMD-stage-parameter");
        }
    }
    return skip;
}

bool Device::PreCallValidateCreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos,
                                             const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
        VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT, true, true, "VUID-VkShaderCreateInfoEXT-sType-sType",
        "VUID-vkCreateShadersEXT-pCreateInfos-parameter", "VUID-vkCreateShadersEXT-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkShaderCreateInfoEXT = {
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext, allowed_structs_VkShaderCreateInfoEXT.size(),
                allowed_structs_VkShaderCreateInfoEXT.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkShaderCreateInfoEXT-pNext-pNext", "VUID-VkShaderCreateInfoEXT-sType-unique", true);

            skip |= context.ValidateFlags(pCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkShaderCreateFlagBitsEXT,
                                          AllVkShaderCreateFlagBitsEXT, pCreateInfos[createInfoIndex].flags, kOptionalFlags,
                                          "VUID-VkShaderCreateInfoEXT-flags-parameter");

            skip |=
                context.ValidateFlags(pCreateInfos_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage, kRequiredSingleBit,
                                      "VUID-VkShaderCreateInfoEXT-stage-parameter", "VUID-VkShaderCreateInfoEXT-stage-parameter");

            skip |= context.ValidateFlags(pCreateInfos_loc.dot(Field::nextStage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                          AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].nextStage, kOptionalFlags,
                                          "VUID-VkShaderCreateInfoEXT-nextStage-parameter");

            skip |=
                context.ValidateRangedEnum(pCreateInfos_loc.dot(Field::codeType), vvl::Enum::VkShaderCodeTypeEXT,
                                           pCreateInfos[createInfoIndex].codeType, "VUID-VkShaderCreateInfoEXT-codeType-parameter");

            skip |= context.ValidateArray(pCreateInfos_loc.dot(Field::codeSize), pCreateInfos_loc.dot(Field::pCode),
                                          pCreateInfos[createInfoIndex].codeSize, &pCreateInfos[createInfoIndex].pCode, true, true,
                                          "VUID-VkShaderCreateInfoEXT-codeSize-arraylength",
                                          "VUID-VkShaderCreateInfoEXT-pCode-parameter");

            if (pCreateInfos[createInfoIndex].pPushConstantRanges != nullptr) {
                for (uint32_t pushConstantRangeIndex = 0;
                     pushConstantRangeIndex < pCreateInfos[createInfoIndex].pushConstantRangeCount; ++pushConstantRangeIndex) {
                    [[maybe_unused]] const Location pPushConstantRanges_loc =
                        pCreateInfos_loc.dot(Field::pPushConstantRanges, pushConstantRangeIndex);
                    skip |= context.ValidateFlags(
                        pPushConstantRanges_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                        AllVkShaderStageFlagBits,
                        pCreateInfos[createInfoIndex].pPushConstantRanges[pushConstantRangeIndex].stageFlags, kRequiredFlags,
                        "VUID-VkPushConstantRange-stageFlags-parameter", "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
                }
            }

            if (pCreateInfos[createInfoIndex].pSpecializationInfo != nullptr) {
                [[maybe_unused]] const Location pSpecializationInfo_loc = pCreateInfos_loc.dot(Field::pSpecializationInfo);
                skip |= context.ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                              pSpecializationInfo_loc.dot(Field::pMapEntries),
                                              pCreateInfos[createInfoIndex].pSpecializationInfo->mapEntryCount,
                                              &pCreateInfos[createInfoIndex].pSpecializationInfo->pMapEntries, false, true,
                                              kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                if (pCreateInfos[createInfoIndex].pSpecializationInfo->pMapEntries != nullptr) {
                    for (uint32_t mapEntryIndex = 0;
                         mapEntryIndex < pCreateInfos[createInfoIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex) {
                        [[maybe_unused]] const Location pMapEntries_loc =
                            pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                        // No xml-driven validation
                    }
                }

                skip |=
                    context.ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                          pCreateInfos[createInfoIndex].pSpecializationInfo->dataSize,
                                          &pCreateInfos[createInfoIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined,
                                          "VUID-VkSpecializationInfo-pData-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        context.ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pShaders), createInfoCount, &pShaders, true, true,
                              "VUID-vkCreateShadersEXT-createInfoCount-arraylength", "VUID-vkCreateShadersEXT-pShaders-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders, context);
    return skip;
}

bool Device::PreCallValidateDestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator,
                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::shader), shader);
    skip |= context.ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                         "VUID-vkGetShaderBinaryDataEXT-pDataSize-parameter", kVUIDUndefined,
                                         "VUID-vkGetShaderBinaryDataEXT-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateGetShaderBinaryDataEXT(device, shader, pDataSize, pData, context);
    return skip;
}

bool Device::PreCallValidateCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount,
                                              const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders,
                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_shader_object)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    skip |= context.ValidateArray(loc.dot(Field::stageCount), loc.dot(Field::pStages), stageCount, &pStages, true, true,
                                  "VUID-vkCmdBindShadersEXT-stageCount-arraylength", "VUID-vkCmdBindShadersEXT-pStages-parameter");
    skip |= context.ValidateArray(loc.dot(Field::stageCount), loc.dot(Field::pShaders), stageCount, &pShaders, true, false,
                                  "VUID-vkCmdBindShadersEXT-stageCount-arraylength", "VUID-vkCmdBindShadersEXT-pShaders-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode,
                                                     const VkDepthClampRangeEXT* pDepthClampRange,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(extensions.vk_ext_shader_object) || IsExtEnabled(extensions.vk_ext_depth_clamp_control)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object, vvl::Extension::_VK_EXT_depth_clamp_control});
    skip |= context.ValidateRangedEnum(loc.dot(Field::depthClampMode), vvl::Enum::VkDepthClampModeEXT, depthClampMode,
                                       "VUID-vkCmdSetDepthClampRangeEXT-depthClampMode-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange, context);
    return skip;
}

bool Device::PreCallValidateGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount,
                                                             VkTilePropertiesQCOM* pProperties,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_qcom_tile_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QCOM_tile_properties});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::framebuffer), framebuffer);
    skip |= context.ValidateStructTypeArray(loc.dot(Field::pPropertiesCount), loc.dot(Field::pProperties), pPropertiesCount,
                                            pProperties, VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, true, false, false,
                                            "VUID-VkTilePropertiesQCOM-sType-sType", kVUIDUndefined,
                                            "VUID-vkGetFramebufferTilePropertiesQCOM-pPropertiesCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertiesIndex = 0; pPropertiesIndex < *pPropertiesCount; ++pPropertiesIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertiesIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertiesIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkTilePropertiesQCOM-pNext-pNext",
                                                kVUIDUndefined, false);

            // No xml-driven validation

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool Device::PreCallValidateGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo* pRenderingInfo,
                                                                  VkTilePropertiesQCOM* pProperties,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_qcom_tile_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QCOM_tile_properties});
    skip |= context.ValidateStructType(loc.dot(Field::pRenderingInfo), pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true,
                                       "VUID-vkGetDynamicRenderingTilePropertiesQCOM-pRenderingInfo-parameter",
                                       "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr) {
        [[maybe_unused]] const Location pRenderingInfo_loc = loc.dot(Field::pRenderingInfo);
        constexpr std::array allowed_structs_VkRenderingInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR};

        skip |= context.ValidateStructPnext(pRenderingInfo_loc, pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(),
                                            allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", true);

        skip |= context.ValidateFlags(pRenderingInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderingFlagBits,
                                      AllVkRenderingFlagBits, pRenderingInfo->flags, kOptionalFlags,
                                      "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= context.ValidateStructTypeArray(
            pRenderingInfo_loc.dot(Field::colorAttachmentCount), pRenderingInfo_loc.dot(Field::pColorAttachments),
            pRenderingInfo->colorAttachmentCount, pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO,
            false, true, "VUID-VkRenderingAttachmentInfo-sType-sType", "VUID-VkRenderingInfo-pColorAttachments-parameter",
            kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr) {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount;
                 ++colorAttachmentIndex) {
                [[maybe_unused]] const Location pColorAttachments_loc =
                    pRenderingInfo_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                skip |= context.ValidateStructPnext(
                    pColorAttachments_loc, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0, nullptr,
                    GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout,
                                                   "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

                skip |= context.ValidateFlags(pColorAttachments_loc.dot(Field::resolveMode),
                                              vvl::FlagBitmask::VkResolveModeFlagBits, AllVkResolveModeFlagBits,
                                              pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode,
                                              kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout,
                                                   "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp,
                                                   "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

                skip |= context.ValidateRangedEnum(pColorAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                                   pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp,
                                                   "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

                // No xml-driven validation
            }
        }

        skip |= context.ValidateStructType(pRenderingInfo_loc.dot(Field::pDepthAttachment), pRenderingInfo->pDepthAttachment,
                                           VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                                           "VUID-VkRenderingInfo-pDepthAttachment-parameter",
                                           "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr) {
            [[maybe_unused]] const Location pDepthAttachment_loc = pRenderingInfo_loc.dot(Field::pDepthAttachment);
            skip |= context.ValidateStructPnext(pDepthAttachment_loc, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pDepthAttachment->imageLayout,
                                               "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= context.ValidateFlags(pDepthAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                          AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode,
                                          kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pDepthAttachment->resolveImageLayout,
                                               "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                               pRenderingInfo->pDepthAttachment->loadOp,
                                               "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= context.ValidateRangedEnum(pDepthAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                               pRenderingInfo->pDepthAttachment->storeOp,
                                               "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }

        skip |= context.ValidateStructType(pRenderingInfo_loc.dot(Field::pStencilAttachment), pRenderingInfo->pStencilAttachment,
                                           VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                                           "VUID-VkRenderingInfo-pStencilAttachment-parameter",
                                           "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr) {
            [[maybe_unused]] const Location pStencilAttachment_loc = pRenderingInfo_loc.dot(Field::pStencilAttachment);
            skip |= context.ValidateStructPnext(pStencilAttachment_loc, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pStencilAttachment->imageLayout,
                                               "VUID-VkRenderingAttachmentInfo-imageLayout-parameter");

            skip |= context.ValidateFlags(pStencilAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                          AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode,
                                          kOptionalSingleBit, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                               pRenderingInfo->pStencilAttachment->resolveImageLayout,
                                               "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter");

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                               pRenderingInfo->pStencilAttachment->loadOp,
                                               "VUID-VkRenderingAttachmentInfo-loadOp-parameter");

            skip |= context.ValidateRangedEnum(pStencilAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                               pRenderingInfo->pStencilAttachment->storeOp,
                                               "VUID-VkRenderingAttachmentInfo-storeOp-parameter");

            // No xml-driven validation
        }
    }
    skip |= context.ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, true,
                                       "VUID-vkGetDynamicRenderingTilePropertiesQCOM-pProperties-parameter",
                                       "VUID-VkTilePropertiesQCOM-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |= context.ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkTilePropertiesQCOM-pNext-pNext", kVUIDUndefined, false);

        // No xml-driven validation

        // No xml-driven validation

        // No xml-driven validation
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice,
                                                                             uint32_t* pPropertyCount,
                                                                             VkCooperativeVectorPropertiesNV* pProperties,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV, true, false, false, "VUID-VkCooperativeVectorPropertiesNV-sType-sType",
        kVUIDUndefined, "VUID-vkGetPhysicalDeviceCooperativeVectorPropertiesNV-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkCooperativeVectorPropertiesNV-pNext-pNext",
                                                kVUIDUndefined, false);

            skip |= context.ValidateRangedEnum(pProperties_loc.dot(Field::inputType), vvl::Enum::VkComponentTypeKHR,
                                               pProperties[pPropertyIndex].inputType,
                                               "VUID-VkCooperativeVectorPropertiesNV-inputType-parameter");

            skip |= context.ValidateRangedEnum(pProperties_loc.dot(Field::inputInterpretation), vvl::Enum::VkComponentTypeKHR,
                                               pProperties[pPropertyIndex].inputInterpretation,
                                               "VUID-VkCooperativeVectorPropertiesNV-inputInterpretation-parameter");

            skip |= context.ValidateRangedEnum(pProperties_loc.dot(Field::matrixInterpretation), vvl::Enum::VkComponentTypeKHR,
                                               pProperties[pPropertyIndex].matrixInterpretation,
                                               "VUID-VkCooperativeVectorPropertiesNV-matrixInterpretation-parameter");

            skip |= context.ValidateRangedEnum(pProperties_loc.dot(Field::biasInterpretation), vvl::Enum::VkComponentTypeKHR,
                                               pProperties[pPropertyIndex].biasInterpretation,
                                               "VUID-VkCooperativeVectorPropertiesNV-biasInterpretation-parameter");

            skip |= context.ValidateRangedEnum(pProperties_loc.dot(Field::resultType), vvl::Enum::VkComponentTypeKHR,
                                               pProperties[pPropertyIndex].resultType,
                                               "VUID-VkCooperativeVectorPropertiesNV-resultType-parameter");

            skip |= context.ValidateBool32(pProperties_loc.dot(Field::transpose), pProperties[pPropertyIndex].transpose);
        }
    }
    return skip;
}

bool Device::PreCallValidateConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV* pInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cooperative_vector))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cooperative_vector});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV,
                                       true, "VUID-vkConvertCooperativeVectorMatrixNV-pInfo-parameter",
                                       "VUID-VkConvertCooperativeVectorMatrixInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkConvertCooperativeVectorMatrixInfoNV-pNext-pNext", kVUIDUndefined, true);

        // No xml-driven validation

        skip |= context.ValidateRequiredPointer(pInfo_loc.dot(Field::pDstSize), pInfo->pDstSize,
                                                "VUID-VkConvertCooperativeVectorMatrixInfoNV-pDstSize-parameter");

        // No xml-driven validation

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::srcComponentType), vvl::Enum::VkComponentTypeKHR,
                                           pInfo->srcComponentType,
                                           "VUID-VkConvertCooperativeVectorMatrixInfoNV-srcComponentType-parameter");

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::dstComponentType), vvl::Enum::VkComponentTypeKHR,
                                           pInfo->dstComponentType,
                                           "VUID-VkConvertCooperativeVectorMatrixInfoNV-dstComponentType-parameter");

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::srcLayout), vvl::Enum::VkCooperativeVectorMatrixLayoutNV,
                                           pInfo->srcLayout, "VUID-VkConvertCooperativeVectorMatrixInfoNV-srcLayout-parameter");

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::dstLayout), vvl::Enum::VkCooperativeVectorMatrixLayoutNV,
                                           pInfo->dstLayout, "VUID-VkConvertCooperativeVectorMatrixInfoNV-dstLayout-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateConvertCooperativeVectorMatrixNV(device, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                                const VkConvertCooperativeVectorMatrixInfoNV* pInfos,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cooperative_vector))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cooperative_vector});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                            VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV, true, true,
                                            "VUID-VkConvertCooperativeVectorMatrixInfoNV-sType-sType",
                                            "VUID-vkCmdConvertCooperativeVectorMatrixNV-pInfos-parameter",
                                            "VUID-vkCmdConvertCooperativeVectorMatrixNV-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= context.ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkConvertCooperativeVectorMatrixInfoNV-pNext-pNext", kVUIDUndefined, true);

            // No xml-driven validation

            skip |= context.ValidateRequiredPointer(pInfos_loc.dot(Field::pDstSize), pInfos[infoIndex].pDstSize,
                                                    "VUID-VkConvertCooperativeVectorMatrixInfoNV-pDstSize-parameter");

            // No xml-driven validation

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::srcComponentType), vvl::Enum::VkComponentTypeKHR,
                                               pInfos[infoIndex].srcComponentType,
                                               "VUID-VkConvertCooperativeVectorMatrixInfoNV-srcComponentType-parameter");

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::dstComponentType), vvl::Enum::VkComponentTypeKHR,
                                               pInfos[infoIndex].dstComponentType,
                                               "VUID-VkConvertCooperativeVectorMatrixInfoNV-dstComponentType-parameter");

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::srcLayout), vvl::Enum::VkCooperativeVectorMatrixLayoutNV,
                                               pInfos[infoIndex].srcLayout,
                                               "VUID-VkConvertCooperativeVectorMatrixInfoNV-srcLayout-parameter");

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::dstLayout), vvl::Enum::VkCooperativeVectorMatrixLayoutNV,
                                               pInfos[infoIndex].dstLayout,
                                               "VUID-VkConvertCooperativeVectorMatrixInfoNV-dstLayout-parameter");
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos, context);
    return skip;
}

bool Device::PreCallValidateSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain,
                                                  const VkLatencySleepModeInfoNV* pSleepModeInfo,
                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_low_latency2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateStructType(loc.dot(Field::pSleepModeInfo), pSleepModeInfo, VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV,
                                       true, "VUID-vkSetLatencySleepModeNV-pSleepModeInfo-parameter",
                                       "VUID-VkLatencySleepModeInfoNV-sType-sType");
    if (pSleepModeInfo != nullptr) {
        [[maybe_unused]] const Location pSleepModeInfo_loc = loc.dot(Field::pSleepModeInfo);
        skip |= context.ValidateBool32(pSleepModeInfo_loc.dot(Field::lowLatencyMode), pSleepModeInfo->lowLatencyMode);

        skip |= context.ValidateBool32(pSleepModeInfo_loc.dot(Field::lowLatencyBoost), pSleepModeInfo->lowLatencyBoost);
    }
    return skip;
}

bool Device::PreCallValidateLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV* pSleepInfo,
                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_low_latency2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateStructType(loc.dot(Field::pSleepInfo), pSleepInfo, VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV, true,
                                       "VUID-vkLatencySleepNV-pSleepInfo-parameter", "VUID-VkLatencySleepInfoNV-sType-sType");
    if (pSleepInfo != nullptr) {
        [[maybe_unused]] const Location pSleepInfo_loc = loc.dot(Field::pSleepInfo);
        skip |= context.ValidateRequiredHandle(pSleepInfo_loc.dot(Field::signalSemaphore), pSleepInfo->signalSemaphore);
    }
    return skip;
}

bool Device::PreCallValidateSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain,
                                               const VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo,
                                               const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_low_latency2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateStructType(
        loc.dot(Field::pLatencyMarkerInfo), pLatencyMarkerInfo, VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV, true,
        "VUID-vkSetLatencyMarkerNV-pLatencyMarkerInfo-parameter", "VUID-VkSetLatencyMarkerInfoNV-sType-sType");
    if (pLatencyMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pLatencyMarkerInfo_loc = loc.dot(Field::pLatencyMarkerInfo);
        skip |= context.ValidateRangedEnum(pLatencyMarkerInfo_loc.dot(Field::marker), vvl::Enum::VkLatencyMarkerNV,
                                           pLatencyMarkerInfo->marker, "VUID-VkSetLatencyMarkerInfoNV-marker-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain,
                                                VkGetLatencyMarkerInfoNV* pLatencyMarkerInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_low_latency2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= context.ValidateStructType(
        loc.dot(Field::pLatencyMarkerInfo), pLatencyMarkerInfo, VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV, true,
        "VUID-vkGetLatencyTimingsNV-pLatencyMarkerInfo-parameter", "VUID-VkGetLatencyMarkerInfoNV-sType-sType");
    if (pLatencyMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pLatencyMarkerInfo_loc = loc.dot(Field::pLatencyMarkerInfo);
        skip |= context.ValidateStructTypeArray(
            pLatencyMarkerInfo_loc.dot(Field::timingCount), pLatencyMarkerInfo_loc.dot(Field::pTimings),
            pLatencyMarkerInfo->timingCount, pLatencyMarkerInfo->pTimings, VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV, false,
            false, "VUID-VkLatencyTimingsFrameReportNV-sType-sType", kVUIDUndefined, kVUIDUndefined);

        if (pLatencyMarkerInfo->pTimings != nullptr) {
            for (uint32_t timingIndex = 0; timingIndex < pLatencyMarkerInfo->timingCount; ++timingIndex) {
                [[maybe_unused]] const Location pTimings_loc = pLatencyMarkerInfo_loc.dot(Field::pTimings, timingIndex);
                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool Device::PreCallValidateQueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo,
                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_low_latency2)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= context.ValidateStructType(
        loc.dot(Field::pQueueTypeInfo), pQueueTypeInfo, VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV, true,
        "VUID-vkQueueNotifyOutOfBandNV-pQueueTypeInfo-parameter", "VUID-VkOutOfBandQueueTypeInfoNV-sType-sType");
    if (pQueueTypeInfo != nullptr) {
        [[maybe_unused]] const Location pQueueTypeInfo_loc = loc.dot(Field::pQueueTypeInfo);
        skip |= context.ValidateRangedEnum(pQueueTypeInfo_loc.dot(Field::queueType), vvl::Enum::VkOutOfBandQueueTypeNV,
                                           pQueueTypeInfo->queueType, "VUID-VkOutOfBandQueueTypeInfoNV-queueType-parameter");
    }
    return skip;
}

bool Device::PreCallValidateCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_attachment_feedback_loop_dynamic_state))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_attachment_feedback_loop_dynamic_state});
    skip |= context.ValidateFlags(loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                                  aspectMask, kOptionalFlags, "VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-aspectMask-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool Device::PreCallValidateGetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer* buffer,
                                                         VkScreenBufferPropertiesQNX* pProperties,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_qnx_external_memory_screen_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_external_memory_screen_buffer});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::buffer), buffer, "VUID-vkGetScreenBufferPropertiesQNX-buffer-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX,
                                       true, "VUID-vkGetScreenBufferPropertiesQNX-pProperties-parameter",
                                       "VUID-VkScreenBufferPropertiesQNX-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        constexpr std::array allowed_structs_VkScreenBufferPropertiesQNX = {VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX};

        skip |= context.ValidateStructPnext(pProperties_loc, pProperties->pNext, allowed_structs_VkScreenBufferPropertiesQNX.size(),
                                            allowed_structs_VkScreenBufferPropertiesQNX.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkScreenBufferPropertiesQNX-pNext-pNext",
                                            "VUID-VkScreenBufferPropertiesQNX-sType-unique", false);
    }
    return skip;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

bool Device::PreCallValidateGetClusterAccelerationStructureBuildSizesNV(VkDevice device,
                                                                        const VkClusterAccelerationStructureInputInfoNV* pInfo,
                                                                        VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cluster_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cluster_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV,
                                       true, "VUID-vkGetClusterAccelerationStructureBuildSizesNV-pInfo-parameter",
                                       "VUID-VkClusterAccelerationStructureInputInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkClusterAccelerationStructureInputInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateFlags(pInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                      AllVkBuildAccelerationStructureFlagBitsKHR, pInfo->flags, kOptionalFlags,
                                      "VUID-VkClusterAccelerationStructureInputInfoNV-flags-parameter");

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::opType), vvl::Enum::VkClusterAccelerationStructureOpTypeNV,
                                           pInfo->opType, "VUID-VkClusterAccelerationStructureInputInfoNV-opType-parameter");

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::opMode), vvl::Enum::VkClusterAccelerationStructureOpModeNV,
                                           pInfo->opMode, "VUID-VkClusterAccelerationStructureInputInfoNV-opMode-parameter");

        skip |=
            context.ValidateStructType(pInfo_loc.dot(Field::pClustersBottomLevel), pInfo->opInput.pClustersBottomLevel,
                                       VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV, true,
                                       kVUIDUndefined, "VUID-VkClusterAccelerationStructureClustersBottomLevelInputNV-sType-sType");

        if (pInfo->opInput.pClustersBottomLevel != nullptr) {
            [[maybe_unused]] const Location pClustersBottomLevel_loc = pInfo_loc.dot(Field::pClustersBottomLevel);
            skip |= context.ValidateStructPnext(
                pClustersBottomLevel_loc, pInfo->opInput.pClustersBottomLevel->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                "VUID-VkClusterAccelerationStructureClustersBottomLevelInputNV-pNext-pNext", kVUIDUndefined, true);
        }

        skip |= context.ValidateStructType(pInfo_loc.dot(Field::pTriangleClusters), pInfo->opInput.pTriangleClusters,
                                           VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV, true,
                                           kVUIDUndefined, "VUID-VkClusterAccelerationStructureTriangleClusterInputNV-sType-sType");

        if (pInfo->opInput.pTriangleClusters != nullptr) {
            [[maybe_unused]] const Location pTriangleClusters_loc = pInfo_loc.dot(Field::pTriangleClusters);
            skip |= context.ValidateStructPnext(
                pTriangleClusters_loc, pInfo->opInput.pTriangleClusters->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                "VUID-VkClusterAccelerationStructureTriangleClusterInputNV-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pTriangleClusters_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat,
                                               pInfo->opInput.pTriangleClusters->vertexFormat,
                                               "VUID-VkClusterAccelerationStructureTriangleClusterInputNV-vertexFormat-parameter");
        }

        skip |= context.ValidateStructType(pInfo_loc.dot(Field::pMoveObjects), pInfo->opInput.pMoveObjects,
                                           VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV, true,
                                           kVUIDUndefined, "VUID-VkClusterAccelerationStructureMoveObjectsInputNV-sType-sType");

        if (pInfo->opInput.pMoveObjects != nullptr) {
            [[maybe_unused]] const Location pMoveObjects_loc = pInfo_loc.dot(Field::pMoveObjects);
            skip |= context.ValidateStructPnext(
                pMoveObjects_loc, pInfo->opInput.pMoveObjects->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                "VUID-VkClusterAccelerationStructureMoveObjectsInputNV-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pMoveObjects_loc.dot(Field::type), vvl::Enum::VkClusterAccelerationStructureTypeNV,
                                               pInfo->opInput.pMoveObjects->type,
                                               "VUID-VkClusterAccelerationStructureMoveObjectsInputNV-type-parameter");

            skip |= context.ValidateBool32(pMoveObjects_loc.dot(Field::noMoveOverlap), pInfo->opInput.pMoveObjects->noMoveOverlap);
        }
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, true,
                                       "VUID-vkGetClusterAccelerationStructureBuildSizesNV-pSizeInfo-parameter",
                                       "VUID-VkAccelerationStructureBuildSizesInfoKHR-sType-sType");
    if (pSizeInfo != nullptr) {
        [[maybe_unused]] const Location pSizeInfo_loc = loc.dot(Field::pSizeInfo);
        skip |= context.ValidateStructPnext(pSizeInfo_loc, pSizeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildSizesInfoKHR-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateCmdBuildClusterAccelerationStructureIndirectNV(
    VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV* pCommandInfos,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_cluster_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cluster_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pCommandInfos), pCommandInfos,
                                       VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV, true,
                                       "VUID-vkCmdBuildClusterAccelerationStructureIndirectNV-pCommandInfos-parameter",
                                       "VUID-VkClusterAccelerationStructureCommandsInfoNV-sType-sType");
    if (pCommandInfos != nullptr) {
        [[maybe_unused]] const Location pCommandInfos_loc = loc.dot(Field::pCommandInfos);
        skip |= context.ValidateStructPnext(pCommandInfos_loc, pCommandInfos->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkClusterAccelerationStructureCommandsInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(pCommandInfos_loc.dot(Field::input), &(pCommandInfos->input),
                                           VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV, false, kVUIDUndefined,
                                           "VUID-VkClusterAccelerationStructureInputInfoNV-sType-sType");

        skip |= context.ValidateStructPnext(pCommandInfos_loc, pCommandInfos->input.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkClusterAccelerationStructureInputInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |=
            context.ValidateFlags(pCommandInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                  AllVkBuildAccelerationStructureFlagBitsKHR, pCommandInfos->input.flags, kOptionalFlags,
                                  "VUID-VkClusterAccelerationStructureInputInfoNV-flags-parameter");

        skip |= context.ValidateRangedEnum(pCommandInfos_loc.dot(Field::opType), vvl::Enum::VkClusterAccelerationStructureOpTypeNV,
                                           pCommandInfos->input.opType,
                                           "VUID-VkClusterAccelerationStructureInputInfoNV-opType-parameter");

        skip |= context.ValidateRangedEnum(pCommandInfos_loc.dot(Field::opMode), vvl::Enum::VkClusterAccelerationStructureOpModeNV,
                                           pCommandInfos->input.opMode,
                                           "VUID-VkClusterAccelerationStructureInputInfoNV-opMode-parameter");

        skip |= context.ValidateStructType(
            pCommandInfos_loc.dot(Field::pClustersBottomLevel), pCommandInfos->input.opInput.pClustersBottomLevel,
            VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV, true, kVUIDUndefined,
            "VUID-VkClusterAccelerationStructureClustersBottomLevelInputNV-sType-sType");

        if (pCommandInfos->input.opInput.pClustersBottomLevel != nullptr) {
            [[maybe_unused]] const Location pClustersBottomLevel_loc = pCommandInfos_loc.dot(Field::pClustersBottomLevel);
            skip |= context.ValidateStructPnext(pClustersBottomLevel_loc, pCommandInfos->input.opInput.pClustersBottomLevel->pNext,
                                                0, nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkClusterAccelerationStructureClustersBottomLevelInputNV-pNext-pNext",
                                                kVUIDUndefined, true);
        }

        skip |= context.ValidateStructType(pCommandInfos_loc.dot(Field::pTriangleClusters),
                                           pCommandInfos->input.opInput.pTriangleClusters,
                                           VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV, true,
                                           kVUIDUndefined, "VUID-VkClusterAccelerationStructureTriangleClusterInputNV-sType-sType");

        if (pCommandInfos->input.opInput.pTriangleClusters != nullptr) {
            [[maybe_unused]] const Location pTriangleClusters_loc = pCommandInfos_loc.dot(Field::pTriangleClusters);
            skip |= context.ValidateStructPnext(pTriangleClusters_loc, pCommandInfos->input.opInput.pTriangleClusters->pNext, 0,
                                                nullptr, GeneratedVulkanHeaderVersion,
                                                "VUID-VkClusterAccelerationStructureTriangleClusterInputNV-pNext-pNext",
                                                kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pTriangleClusters_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat,
                                               pCommandInfos->input.opInput.pTriangleClusters->vertexFormat,
                                               "VUID-VkClusterAccelerationStructureTriangleClusterInputNV-vertexFormat-parameter");
        }

        skip |= context.ValidateStructType(pCommandInfos_loc.dot(Field::pMoveObjects), pCommandInfos->input.opInput.pMoveObjects,
                                           VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV, true,
                                           kVUIDUndefined, "VUID-VkClusterAccelerationStructureMoveObjectsInputNV-sType-sType");

        if (pCommandInfos->input.opInput.pMoveObjects != nullptr) {
            [[maybe_unused]] const Location pMoveObjects_loc = pCommandInfos_loc.dot(Field::pMoveObjects);
            skip |= context.ValidateStructPnext(
                pMoveObjects_loc, pCommandInfos->input.opInput.pMoveObjects->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                "VUID-VkClusterAccelerationStructureMoveObjectsInputNV-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pMoveObjects_loc.dot(Field::type), vvl::Enum::VkClusterAccelerationStructureTypeNV,
                                               pCommandInfos->input.opInput.pMoveObjects->type,
                                               "VUID-VkClusterAccelerationStructureMoveObjectsInputNV-type-parameter");

            skip |= context.ValidateBool32(pMoveObjects_loc.dot(Field::noMoveOverlap),
                                           pCommandInfos->input.opInput.pMoveObjects->noMoveOverlap);
        }

        // No xml-driven validation

        // No xml-driven validation

        // No xml-driven validation

        skip |= context.ValidateFlags(pCommandInfos_loc.dot(Field::addressResolutionFlags),
                                      vvl::FlagBitmask::VkClusterAccelerationStructureAddressResolutionFlagBitsNV,
                                      AllVkClusterAccelerationStructureAddressResolutionFlagBitsNV,
                                      pCommandInfos->addressResolutionFlags, kOptionalFlags,
                                      "VUID-VkClusterAccelerationStructureCommandsInfoNV-addressResolutionFlags-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetPartitionedAccelerationStructuresBuildSizesNV(
    VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV* pInfo,
    VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_partitioned_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_partitioned_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo,
                                       VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV, true,
                                       "VUID-vkGetPartitionedAccelerationStructuresBuildSizesNV-pInfo-parameter",
                                       "VUID-VkPartitionedAccelerationStructureInstancesInputNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        constexpr std::array allowed_structs_VkPartitionedAccelerationStructureInstancesInputNV = {
            VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV};

        skip |= context.ValidateStructPnext(
            pInfo_loc, pInfo->pNext, allowed_structs_VkPartitionedAccelerationStructureInstancesInputNV.size(),
            allowed_structs_VkPartitionedAccelerationStructureInstancesInputNV.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPartitionedAccelerationStructureInstancesInputNV-pNext-pNext",
            "VUID-VkPartitionedAccelerationStructureInstancesInputNV-sType-unique", true);

        skip |= context.ValidateFlags(pInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                      AllVkBuildAccelerationStructureFlagBitsKHR, pInfo->flags, kOptionalFlags,
                                      "VUID-VkPartitionedAccelerationStructureInstancesInputNV-flags-parameter");
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, true,
                                       "VUID-vkGetPartitionedAccelerationStructuresBuildSizesNV-pSizeInfo-parameter",
                                       "VUID-VkAccelerationStructureBuildSizesInfoKHR-sType-sType");
    if (pSizeInfo != nullptr) {
        [[maybe_unused]] const Location pSizeInfo_loc = loc.dot(Field::pSizeInfo);
        skip |= context.ValidateStructPnext(pSizeInfo_loc, pSizeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildSizesInfoKHR-pNext-pNext", kVUIDUndefined, false);
    }
    return skip;
}

bool Device::PreCallValidateCmdBuildPartitionedAccelerationStructuresNV(
    VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV* pBuildInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_nv_partitioned_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_partitioned_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pBuildInfo), pBuildInfo,
                                       VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV, true,
                                       "VUID-vkCmdBuildPartitionedAccelerationStructuresNV-pBuildInfo-parameter",
                                       "VUID-VkBuildPartitionedAccelerationStructureInfoNV-sType-sType");
    if (pBuildInfo != nullptr) {
        [[maybe_unused]] const Location pBuildInfo_loc = loc.dot(Field::pBuildInfo);
        skip |= context.ValidateStructPnext(pBuildInfo_loc, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkBuildPartitionedAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateStructType(pBuildInfo_loc.dot(Field::input), &(pBuildInfo->input),
                                           VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV, false,
                                           kVUIDUndefined, "VUID-VkPartitionedAccelerationStructureInstancesInputNV-sType-sType");

        constexpr std::array allowed_structs_VkPartitionedAccelerationStructureInstancesInputNV = {
            VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV};

        skip |= context.ValidateStructPnext(
            pBuildInfo_loc, pBuildInfo->input.pNext, allowed_structs_VkPartitionedAccelerationStructureInstancesInputNV.size(),
            allowed_structs_VkPartitionedAccelerationStructureInstancesInputNV.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPartitionedAccelerationStructureInstancesInputNV-pNext-pNext",
            "VUID-VkPartitionedAccelerationStructureInstancesInputNV-sType-unique", true);

        skip |= context.ValidateFlags(pBuildInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                      AllVkBuildAccelerationStructureFlagBitsKHR, pBuildInfo->input.flags, kOptionalFlags,
                                      "VUID-VkPartitionedAccelerationStructureInstancesInputNV-flags-parameter");
    }
    return skip;
}

bool Device::PreCallValidateGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device,
                                                                      const VkGeneratedCommandsMemoryRequirementsInfoEXT* pInfo,
                                                                      VkMemoryRequirements2* pMemoryRequirements,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
                                   true, "VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-pInfo-parameter",
                                   "VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        constexpr std::array allowed_structs_VkGeneratedCommandsMemoryRequirementsInfoEXT = {
            VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT};

        skip |= context.ValidateStructPnext(
            pInfo_loc, pInfo->pNext, allowed_structs_VkGeneratedCommandsMemoryRequirementsInfoEXT.size(),
            allowed_structs_VkGeneratedCommandsMemoryRequirementsInfoEXT.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-pNext-pNext",
            "VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-sType-unique", true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::indirectCommandsLayout), pInfo->indirectCommandsLayout);
    }
    skip |= context.ValidateStructType(
        loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, true,
        "VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-pMemoryRequirements-parameter", "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= context.ValidateStructPnext(
            pMemoryRequirements_loc, pMemoryRequirements->pNext, allowed_structs_VkMemoryRequirements2.size(),
            allowed_structs_VkMemoryRequirements2.data(), GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
            "VUID-VkMemoryRequirements2-sType-unique", false);
    }
    return skip;
}

bool Device::PreCallValidateCmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer,
                                                              const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo,
                                                              VkCommandBuffer stateCommandBuffer,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= context.ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT, true,
        "VUID-vkCmdPreprocessGeneratedCommandsEXT-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoEXT-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |= context.ValidateFlags(pGeneratedCommandsInfo_loc.dot(Field::shaderStages), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pGeneratedCommandsInfo->shaderStages, kRequiredFlags,
                                      "VUID-VkGeneratedCommandsInfoEXT-shaderStages-parameter",
                                      "VUID-VkGeneratedCommandsInfoEXT-shaderStages-requiredbitmask");

        skip |= context.ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                               pGeneratedCommandsInfo->indirectCommandsLayout);
    }
    skip |= context.ValidateRequiredHandle(loc.dot(Field::stateCommandBuffer), stateCommandBuffer);
    if (!skip)
        skip |= manual_PreCallValidateCmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer,
                                                                        context);
    return skip;
}

bool Device::PreCallValidateCmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed,
                                                           const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= context.ValidateBool32(loc.dot(Field::isPreprocessed), isPreprocessed);
    skip |= context.ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT, true,
        "VUID-vkCmdExecuteGeneratedCommandsEXT-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoEXT-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |= context.ValidateFlags(pGeneratedCommandsInfo_loc.dot(Field::shaderStages), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pGeneratedCommandsInfo->shaderStages, kRequiredFlags,
                                      "VUID-VkGeneratedCommandsInfoEXT-shaderStages-parameter",
                                      "VUID-VkGeneratedCommandsInfoEXT-shaderStages-requiredbitmask");

        skip |= context.ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                               pGeneratedCommandsInfo->indirectCommandsLayout);
    }
    if (!skip)
        skip |=
            manual_PreCallValidateCmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo, context);
    return skip;
}

bool Device::PreCallValidateCreateIndirectCommandsLayoutEXT(VkDevice device,
                                                            const VkIndirectCommandsLayoutCreateInfoEXT* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            VkIndirectCommandsLayoutEXT* pIndirectCommandsLayout,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT, true,
        "VUID-vkCreateIndirectCommandsLayoutEXT-pCreateInfo-parameter", "VUID-VkIndirectCommandsLayoutCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkIndirectCommandsLayoutCreateInfoEXT = {
            VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext,
                                            allowed_structs_VkIndirectCommandsLayoutCreateInfoEXT.size(),
                                            allowed_structs_VkIndirectCommandsLayoutCreateInfoEXT.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkIndirectCommandsLayoutCreateInfoEXT-pNext-pNext",
                                            "VUID-VkIndirectCommandsLayoutCreateInfoEXT-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkIndirectCommandsLayoutUsageFlagBitsEXT,
                                      AllVkIndirectCommandsLayoutUsageFlagBitsEXT, pCreateInfo->flags, kOptionalFlags,
                                      "VUID-VkIndirectCommandsLayoutCreateInfoEXT-flags-parameter");

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::shaderStages), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfo->shaderStages, kRequiredFlags,
                                      "VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-parameter",
                                      "VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-requiredbitmask");

        skip |= context.ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::tokenCount), pCreateInfo_loc.dot(Field::pTokens), pCreateInfo->tokenCount,
            pCreateInfo->pTokens, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT, true, true,
            "VUID-VkIndirectCommandsLayoutTokenEXT-sType-sType", "VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-parameter",
            "VUID-VkIndirectCommandsLayoutCreateInfoEXT-tokenCount-arraylength");

        if (pCreateInfo->pTokens != nullptr) {
            for (uint32_t tokenIndex = 0; tokenIndex < pCreateInfo->tokenCount; ++tokenIndex) {
                [[maybe_unused]] const Location pTokens_loc = pCreateInfo_loc.dot(Field::pTokens, tokenIndex);
                skip |= context.ValidateRangedEnum(pTokens_loc.dot(Field::type), vvl::Enum::VkIndirectCommandsTokenTypeEXT,
                                                   pCreateInfo->pTokens[tokenIndex].type,
                                                   "VUID-VkIndirectCommandsLayoutTokenEXT-type-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pIndirectCommandsLayout), pIndirectCommandsLayout,
                                            "VUID-vkCreateIndirectCommandsLayoutEXT-pIndirectCommandsLayout-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout,
                                                                      context);
    return skip;
}

bool Device::PreCallValidateDestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateCreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT* pCreateInfo,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          VkIndirectExecutionSetEXT* pIndirectExecutionSet,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT, true,
        "VUID-vkCreateIndirectExecutionSetEXT-pCreateInfo-parameter", "VUID-VkIndirectExecutionSetCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::type), vvl::Enum::VkIndirectExecutionSetInfoTypeEXT,
                                           pCreateInfo->type, "VUID-VkIndirectExecutionSetCreateInfoEXT-type-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pIndirectExecutionSet), pIndirectExecutionSet,
                                            "VUID-vkCreateIndirectExecutionSetEXT-pIndirectExecutionSet-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet, context);
    return skip;
}

bool Device::PreCallValidateDestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool Device::PreCallValidateUpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet,
                                                                  uint32_t executionSetWriteCount,
                                                                  const VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::indirectExecutionSet), indirectExecutionSet);
    skip |= context.ValidateStructTypeArray(loc.dot(Field::executionSetWriteCount), loc.dot(Field::pExecutionSetWrites),
                                            executionSetWriteCount, pExecutionSetWrites,
                                            VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT, true, true,
                                            "VUID-VkWriteIndirectExecutionSetPipelineEXT-sType-sType",
                                            "VUID-vkUpdateIndirectExecutionSetPipelineEXT-pExecutionSetWrites-parameter",
                                            "VUID-vkUpdateIndirectExecutionSetPipelineEXT-executionSetWriteCount-arraylength");
    if (pExecutionSetWrites != nullptr) {
        for (uint32_t executionSetWriteIndex = 0; executionSetWriteIndex < executionSetWriteCount; ++executionSetWriteIndex) {
            [[maybe_unused]] const Location pExecutionSetWrites_loc = loc.dot(Field::pExecutionSetWrites, executionSetWriteIndex);
            skip |= context.ValidateRequiredHandle(pExecutionSetWrites_loc.dot(Field::pipeline),
                                                   pExecutionSetWrites[executionSetWriteIndex].pipeline);
        }
    }
    return skip;
}

bool Device::PreCallValidateUpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet,
                                                                uint32_t executionSetWriteCount,
                                                                const VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::indirectExecutionSet), indirectExecutionSet);
    skip |= context.ValidateStructTypeArray(loc.dot(Field::executionSetWriteCount), loc.dot(Field::pExecutionSetWrites),
                                            executionSetWriteCount, pExecutionSetWrites,
                                            VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT, true, true,
                                            "VUID-VkWriteIndirectExecutionSetShaderEXT-sType-sType",
                                            "VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-parameter",
                                            "VUID-vkUpdateIndirectExecutionSetShaderEXT-executionSetWriteCount-arraylength");
    if (pExecutionSetWrites != nullptr) {
        for (uint32_t executionSetWriteIndex = 0; executionSetWriteIndex < executionSetWriteCount; ++executionSetWriteIndex) {
            [[maybe_unused]] const Location pExecutionSetWrites_loc = loc.dot(Field::pExecutionSetWrites, executionSetWriteIndex);
            skip |= context.ValidateRequiredHandle(pExecutionSetWrites_loc.dot(Field::shader),
                                                   pExecutionSetWrites[executionSetWriteIndex].shader);
        }
    }
    return skip;
}

bool Instance::PreCallValidateGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(
    VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;

    const auto& physdev_extensions = physical_device_extensions.at(physicalDevice);
    Context context(*this, error_obj, physdev_extensions, IsExtEnabled(physdev_extensions.vk_khr_maintenance5));
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= context.ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV, true, false, false,
        "VUID-VkCooperativeMatrixFlexibleDimensionsPropertiesNV-sType-sType", kVUIDUndefined,
        "VUID-vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |= context.ValidateStructPnext(
                pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                "VUID-VkCooperativeMatrixFlexibleDimensionsPropertiesNV-pNext-pNext", kVUIDUndefined, false);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_METAL_EXT
bool Device::PreCallValidateGetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT* pGetMetalHandleInfo,
                                                    void** pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_external_memory_metal))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_external_memory_metal});
    skip |= context.ValidateStructType(
        loc.dot(Field::pGetMetalHandleInfo), pGetMetalHandleInfo, VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT, true,
        "VUID-vkGetMemoryMetalHandleEXT-pGetMetalHandleInfo-parameter", "VUID-VkMemoryGetMetalHandleInfoEXT-sType-sType");
    if (pGetMetalHandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetMetalHandleInfo_loc = loc.dot(Field::pGetMetalHandleInfo);
        skip |= context.ValidateStructPnext(pGetMetalHandleInfo_loc, pGetMetalHandleInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetMetalHandleInfoEXT-pNext-pNext",
                                            kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pGetMetalHandleInfo_loc.dot(Field::memory), pGetMetalHandleInfo->memory);

        skip |= context.ValidateFlags(
            pGetMetalHandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
            AllVkExternalMemoryHandleTypeFlagBits, pGetMetalHandleInfo->handleType, kRequiredSingleBit,
            "VUID-VkMemoryGetMetalHandleInfoEXT-handleType-parameter", "VUID-VkMemoryGetMetalHandleInfoEXT-handleType-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetMemoryMetalHandleEXT-pHandle-parameter");
    return skip;
}

bool Device::PreCallValidateGetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
                                                              const void* pHandle,
                                                              VkMemoryMetalHandlePropertiesEXT* pMemoryMetalHandleProperties,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_external_memory_metal))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_external_memory_metal});
    skip |= context.ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                  AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit,
                                  "VUID-vkGetMemoryMetalHandlePropertiesEXT-handleType-parameter",
                                  "VUID-vkGetMemoryMetalHandlePropertiesEXT-handleType-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle,
                                            "VUID-vkGetMemoryMetalHandlePropertiesEXT-pHandle-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pMemoryMetalHandleProperties), pMemoryMetalHandleProperties,
                                       VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT, true,
                                       "VUID-vkGetMemoryMetalHandlePropertiesEXT-pMemoryMetalHandleProperties-parameter",
                                       "VUID-VkMemoryMetalHandlePropertiesEXT-sType-sType");
    if (pMemoryMetalHandleProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryMetalHandleProperties_loc = loc.dot(Field::pMemoryMetalHandleProperties);
        skip |= context.ValidateStructPnext(pMemoryMetalHandleProperties_loc, pMemoryMetalHandleProperties->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryMetalHandlePropertiesEXT-pNext-pNext",
                                            kVUIDUndefined, false);
    }
    return skip;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

bool Device::PreCallValidateCreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           VkAccelerationStructureKHR* pAccelerationStructure,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR, true,
        "VUID-vkCreateAccelerationStructureKHR-pCreateInfo-parameter", "VUID-VkAccelerationStructureCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkAccelerationStructureCreateInfoKHR = {
            VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV,
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT};

        skip |= context.ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext,
                                            allowed_structs_VkAccelerationStructureCreateInfoKHR.size(),
                                            allowed_structs_VkAccelerationStructureCreateInfoKHR.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureCreateInfoKHR-pNext-pNext",
                                            "VUID-VkAccelerationStructureCreateInfoKHR-sType-unique", true);

        skip |= context.ValidateFlags(pCreateInfo_loc.dot(Field::createFlags),
                                      vvl::FlagBitmask::VkAccelerationStructureCreateFlagBitsKHR,
                                      AllVkAccelerationStructureCreateFlagBitsKHR, pCreateInfo->createFlags, kOptionalFlags,
                                      "VUID-VkAccelerationStructureCreateInfoKHR-createFlags-parameter");

        skip |= context.ValidateRequiredHandle(pCreateInfo_loc.dot(Field::buffer), pCreateInfo->buffer);

        skip |= context.ValidateRangedEnum(pCreateInfo_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR,
                                           pCreateInfo->type, "VUID-VkAccelerationStructureCreateInfoKHR-type-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pAccelerationStructure), pAccelerationStructure,
                                            "VUID-vkCreateAccelerationStructureKHR-pAccelerationStructure-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure, context);
    return skip;
}

bool Device::PreCallValidateDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    if (!skip) skip |= manual_PreCallValidateDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator, context);
    return skip;
}

bool Device::PreCallValidateCmdBuildAccelerationStructuresKHR(
    VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                            VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType",
                                            "VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-parameter",
                                            "VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |=
                context.ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR,
                                               pInfos[infoIndex].type,
                                               "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

            skip |= context.ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                          AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags,
                                          "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= context.ValidateStructTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::pGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location pGeometries_loc = pInfos_loc.dot(Field::pGeometries, geometryIndex);
                    constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                    skip |= context.ValidateStructPnext(pGeometries_loc, pInfos[infoIndex].pGeometries[geometryIndex].pNext,
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                        "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                    skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                       pInfos[infoIndex].pGeometries[geometryIndex].geometryType,
                                                       "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= context.ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                                  AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags,
                                                  kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= context.ValidateStructPointerTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::ppGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location ppGeometries_loc = pInfos_loc.dot(Field::ppGeometries, geometryIndex);
                    constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                    skip |= context.ValidateStructPnext(ppGeometries_loc, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext,
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                        "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                    skip |= context.ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                       pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType,
                                                       "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= context.ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                                  AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags,
                                                  kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= context.ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::ppBuildRangeInfos), infoCount, &ppBuildRangeInfos, true,
                                  true, "VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength",
                                  "VUID-vkCmdBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter");
    if (ppBuildRangeInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location ppBuildRangeInfos_loc = loc.dot(Field::ppBuildRangeInfos, infoIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |=
            manual_PreCallValidateCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos, context);
    return skip;
}

bool Device::PreCallValidateCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                                      const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
                                                                      const VkDeviceAddress* pIndirectDeviceAddresses,
                                                                      const uint32_t* pIndirectStrides,
                                                                      const uint32_t* const* ppMaxPrimitiveCounts,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                            VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType",
                                            "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-parameter",
                                            "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |=
                context.ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR,
                                               pInfos[infoIndex].type,
                                               "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

            skip |= context.ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                          AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags,
                                          "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= context.ValidateStructTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::pGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location pGeometries_loc = pInfos_loc.dot(Field::pGeometries, geometryIndex);
                    constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                    skip |= context.ValidateStructPnext(pGeometries_loc, pInfos[infoIndex].pGeometries[geometryIndex].pNext,
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                        "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                    skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                       pInfos[infoIndex].pGeometries[geometryIndex].geometryType,
                                                       "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= context.ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                                  AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags,
                                                  kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= context.ValidateStructPointerTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::ppGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location ppGeometries_loc = pInfos_loc.dot(Field::ppGeometries, geometryIndex);
                    constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                    skip |= context.ValidateStructPnext(ppGeometries_loc, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext,
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                        "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                    skip |= context.ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                       pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType,
                                                       "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= context.ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                                  AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags,
                                                  kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= context.ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::pIndirectDeviceAddresses), infoCount,
                                  &pIndirectDeviceAddresses, true, true,
                                  "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength",
                                  "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-parameter");
    skip |= context.ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::pIndirectStrides), infoCount, &pIndirectStrides, true,
                                  true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength",
                                  "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-parameter");
    skip |= context.ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::ppMaxPrimitiveCounts), infoCount, &ppMaxPrimitiveCounts,
                                  true, true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength",
                                  "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdBuildAccelerationStructuresIndirectKHR(
            commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts, context);
    return skip;
}

bool Device::PreCallValidateBuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                           uint32_t infoCount,
                                                           const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
                                                           const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                            VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType",
                                            "VUID-vkBuildAccelerationStructuresKHR-pInfos-parameter",
                                            "VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |=
                context.ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, true);

            skip |= context.ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR,
                                               pInfos[infoIndex].type,
                                               "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

            skip |= context.ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                          AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags,
                                          "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= context.ValidateStructTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::pGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location pGeometries_loc = pInfos_loc.dot(Field::pGeometries, geometryIndex);
                    constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                    skip |= context.ValidateStructPnext(pGeometries_loc, pInfos[infoIndex].pGeometries[geometryIndex].pNext,
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                        "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                    skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                       pInfos[infoIndex].pGeometries[geometryIndex].geometryType,
                                                       "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= context.ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                                  AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags,
                                                  kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= context.ValidateStructPointerTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::ppGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location ppGeometries_loc = pInfos_loc.dot(Field::ppGeometries, geometryIndex);
                    constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                    skip |= context.ValidateStructPnext(ppGeometries_loc, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext,
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                        allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                        "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                    skip |= context.ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                       pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType,
                                                       "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                    skip |= context.ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                                  AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags,
                                                  kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= context.ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::ppBuildRangeInfos), infoCount, &ppBuildRangeInfos, true,
                                  true, "VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength",
                                  "VUID-vkBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter");
    if (ppBuildRangeInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location ppBuildRangeInfos_loc = loc.dot(Field::ppBuildRangeInfos, infoIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos,
                                                                     ppBuildRangeInfos, context);
    return skip;
}

bool Device::PreCallValidateCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                         const VkCopyAccelerationStructureInfoKHR* pInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, true,
                                       "VUID-vkCopyAccelerationStructureKHR-pInfo-parameter",
                                       "VUID-VkCopyAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                           "VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyAccelerationStructureKHR(device, deferredOperation, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                                 const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
                                   true, "VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-parameter",
                                   "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                           "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                                 const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
                                   true, "VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-parameter",
                                   "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                           "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo, context);
    return skip;
}

bool Device::PreCallValidateWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount,
                                                                     const VkAccelerationStructureKHR* pAccelerationStructures,
                                                                     VkQueryType queryType, size_t dataSize, void* pData,
                                                                     size_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateHandleArray(loc.dot(Field::accelerationStructureCount), loc.dot(Field::pAccelerationStructures),
                                        accelerationStructureCount, pAccelerationStructures, true, true,
                                        "VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength");
    skip |= context.ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                                       "VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-parameter");
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-arraylength",
                                  "VUID-vkWriteAccelerationStructuresPropertiesKHR-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateWriteAccelerationStructuresPropertiesKHR(
            device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer,
                                                            const VkCopyAccelerationStructureInfoKHR* pInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, true,
                                       "VUID-vkCmdCopyAccelerationStructureKHR-pInfo-parameter",
                                       "VUID-VkCopyAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                           "VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyAccelerationStructureKHR(commandBuffer, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer,
                                                                    const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
                                   true, "VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-parameter",
                                   "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                           "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer,
                                                                    const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
                                   true, "VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-parameter",
                                   "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= context.ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                           "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo, context);
    return skip;
}

bool Device::PreCallValidateGetAccelerationStructureDeviceAddressKHR(VkDevice device,
                                                                     const VkAccelerationStructureDeviceAddressInfoKHR* pInfo,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        context.ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
                                   true, "VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-parameter",
                                   "VUID-VkAccelerationStructureDeviceAddressInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= context.ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureDeviceAddressInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredHandle(pInfo_loc.dot(Field::accelerationStructure), pInfo->accelerationStructure);
    }
    return skip;
}

bool Device::PreCallValidateCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer,
                                                                        uint32_t accelerationStructureCount,
                                                                        const VkAccelerationStructureKHR* pAccelerationStructures,
                                                                        VkQueryType queryType, VkQueryPool queryPool,
                                                                        uint32_t firstQuery, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        context.ValidateHandleArray(loc.dot(Field::accelerationStructureCount), loc.dot(Field::pAccelerationStructures),
                                    accelerationStructureCount, pAccelerationStructures, true, true,
                                    "VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength");
    skip |= context.ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                                       "VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-parameter");
    skip |= context.ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    if (!skip)
        skip |= manual_PreCallValidateCmdWriteAccelerationStructuresPropertiesKHR(
            commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, context);
    return skip;
}

bool Device::PreCallValidateGetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo,
    VkAccelerationStructureCompatibilityKHR* pCompatibility, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateStructType(loc.dot(Field::pVersionInfo), pVersionInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR, true,
                                       "VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pVersionInfo-parameter",
                                       "VUID-VkAccelerationStructureVersionInfoKHR-sType-sType");
    if (pVersionInfo != nullptr) {
        [[maybe_unused]] const Location pVersionInfo_loc = loc.dot(Field::pVersionInfo);
        skip |= context.ValidateStructPnext(pVersionInfo_loc, pVersionInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureVersionInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRequiredPointer(pVersionInfo_loc.dot(Field::pVersionData), pVersionInfo->pVersionData,
                                                "VUID-VkAccelerationStructureVersionInfoKHR-pVersionData-parameter");
    }
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCompatibility), pCompatibility,
                                            "VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pCompatibility-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility, context);
    return skip;
}

bool Device::PreCallValidateGetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
                                                                  const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,
                                                                  const uint32_t* pMaxPrimitiveCounts,
                                                                  VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= context.ValidateRangedEnum(loc.dot(Field::buildType), vvl::Enum::VkAccelerationStructureBuildTypeKHR, buildType,
                                       "VUID-vkGetAccelerationStructureBuildSizesKHR-buildType-parameter");
    skip |= context.ValidateStructType(loc.dot(Field::pBuildInfo), pBuildInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true,
                                       "VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-parameter",
                                       "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType");
    if (pBuildInfo != nullptr) {
        [[maybe_unused]] const Location pBuildInfo_loc = loc.dot(Field::pBuildInfo);
        skip |= context.ValidateStructPnext(pBuildInfo_loc, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, true);

        skip |= context.ValidateRangedEnum(pBuildInfo_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR,
                                           pBuildInfo->type, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter");

        skip |= context.ValidateFlags(pBuildInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                      AllVkBuildAccelerationStructureFlagBitsKHR, pBuildInfo->flags, kOptionalFlags,
                                      "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

        skip |= context.ValidateStructTypeArray(
            pBuildInfo_loc.dot(Field::geometryCount), pBuildInfo_loc.dot(Field::pGeometries), pBuildInfo->geometryCount,
            pBuildInfo->pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
            "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

        if (pBuildInfo->pGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pBuildInfo->geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location pGeometries_loc = pBuildInfo_loc.dot(Field::pGeometries, geometryIndex);
                constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                skip |=
                    context.ValidateStructPnext(pGeometries_loc, pBuildInfo->pGeometries[geometryIndex].pNext,
                                                allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                skip |= context.ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                   pBuildInfo->pGeometries[geometryIndex].geometryType,
                                                   "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                skip |= context.ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                              AllVkGeometryFlagBitsKHR, pBuildInfo->pGeometries[geometryIndex].flags,
                                              kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
            }
        }

        skip |= context.ValidateStructPointerTypeArray(
            pBuildInfo_loc.dot(Field::geometryCount), pBuildInfo_loc.dot(Field::ppGeometries), pBuildInfo->geometryCount,
            pBuildInfo->ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
            "VUID-VkAccelerationStructureGeometryKHR-sType-sType", kVUIDUndefined, kVUIDUndefined);

        if (pBuildInfo->ppGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pBuildInfo->geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location ppGeometries_loc = pBuildInfo_loc.dot(Field::ppGeometries, geometryIndex);
                constexpr std::array allowed_structs_VkAccelerationStructureGeometryKHR = {
                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV};

                skip |=
                    context.ValidateStructPnext(ppGeometries_loc, pBuildInfo->ppGeometries[geometryIndex]->pNext,
                                                allowed_structs_VkAccelerationStructureGeometryKHR.size(),
                                                allowed_structs_VkAccelerationStructureGeometryKHR.data(),
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                "VUID-VkAccelerationStructureGeometryKHR-sType-unique", true);

                skip |= context.ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                                   pBuildInfo->ppGeometries[geometryIndex]->geometryType,
                                                   "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter");

                skip |= context.ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                              AllVkGeometryFlagBitsKHR, pBuildInfo->ppGeometries[geometryIndex]->flags,
                                              kOptionalFlags, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
            }
        }
    }
    skip |= context.ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo,
                                       VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, true,
                                       "VUID-vkGetAccelerationStructureBuildSizesKHR-pSizeInfo-parameter",
                                       "VUID-VkAccelerationStructureBuildSizesInfoKHR-sType-sType");
    if (pSizeInfo != nullptr) {
        [[maybe_unused]] const Location pSizeInfo_loc = loc.dot(Field::pSizeInfo);
        skip |= context.ValidateStructPnext(pSizeInfo_loc, pSizeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                            "VUID-VkAccelerationStructureBuildSizesInfoKHR-pNext-pNext", kVUIDUndefined, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts,
                                                                            pSizeInfo, context);
    return skip;
}

bool Device::PreCallValidateCmdTraceRaysKHR(VkCommandBuffer commandBuffer,
                                            const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                                            const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                                            const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                                            const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width,
                                            uint32_t height, uint32_t depth, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pRaygenShaderBindingTable), pRaygenShaderBindingTable,
                                            "VUID-vkCmdTraceRaysKHR-pRaygenShaderBindingTable-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMissShaderBindingTable), pMissShaderBindingTable,
                                            "VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHitShaderBindingTable), pHitShaderBindingTable,
                                            "VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCallableShaderBindingTable), pCallableShaderBindingTable,
                                            "VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable,
                                                      pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth,
                                                      context);
    return skip;
}

bool Device::PreCallValidateCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                         VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                         const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
                                                         const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= context.ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount,
                                            pCreateInfos, VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR, true, true,
                                            "VUID-VkRayTracingPipelineCreateInfoKHR-sType-sType",
                                            "VUID-vkCreateRayTracingPipelinesKHR-pCreateInfos-parameter",
                                            "VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkRayTracingPipelineCreateInfoKHR = {
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV};

            skip |= context.ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext, allowed_structs_VkRayTracingPipelineCreateInfoKHR.size(),
                allowed_structs_VkRayTracingPipelineCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkRayTracingPipelineCreateInfoKHR-pNext-pNext", "VUID-VkRayTracingPipelineCreateInfoKHR-sType-unique", true);

            skip |= context.ValidateStructTypeArray(pCreateInfos_loc.dot(Field::stageCount), pCreateInfos_loc.dot(Field::pStages),
                                                    pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages,
                                                    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, true,
                                                    "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                                    "VUID-VkRayTracingPipelineCreateInfoKHR-pStages-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pStages != nullptr) {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex) {
                    [[maybe_unused]] const Location pStages_loc = pCreateInfos_loc.dot(Field::pStages, stageIndex);
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                    skip |= context.ValidateStructPnext(pStages_loc, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext,
                                                        allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                        allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                        GeneratedVulkanHeaderVersion,
                                                        "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                        "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

                    skip |= context.ValidateFlags(
                        pStages_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                        AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].flags,
                        kOptionalFlags, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |= context.ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                                  AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage,
                                                  kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                                  "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= context.ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                            pCreateInfos[createInfoIndex].pStages[stageIndex].pName,
                                                            "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                        [[maybe_unused]] const Location pSpecializationInfo_loc = pStages_loc.dot(Field::pSpecializationInfo);
                        skip |= context.ValidateArray(
                            pSpecializationInfo_loc.dot(Field::mapEntryCount), pSpecializationInfo_loc.dot(Field::pMapEntries),
                            pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                            &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false, true,
                            kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr) {
                            for (uint32_t mapEntryIndex = 0;
                                 mapEntryIndex <
                                 pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                 ++mapEntryIndex) {
                                [[maybe_unused]] const Location pMapEntries_loc =
                                    pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                // No xml-driven validation
                            }
                        }

                        skip |= context.ValidateArray(
                            pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                            pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                            &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true,
                            kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= context.ValidateStructTypeArray(pCreateInfos_loc.dot(Field::groupCount), pCreateInfos_loc.dot(Field::pGroups),
                                                    pCreateInfos[createInfoIndex].groupCount, pCreateInfos[createInfoIndex].pGroups,
                                                    VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR, false, true,
                                                    "VUID-VkRayTracingShaderGroupCreateInfoKHR-sType-sType",
                                                    "VUID-VkRayTracingPipelineCreateInfoKHR-pGroups-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pGroups != nullptr) {
                for (uint32_t groupIndex = 0; groupIndex < pCreateInfos[createInfoIndex].groupCount; ++groupIndex) {
                    [[maybe_unused]] const Location pGroups_loc = pCreateInfos_loc.dot(Field::pGroups, groupIndex);
                    skip |=
                        context.ValidateStructPnext(pGroups_loc, pCreateInfos[createInfoIndex].pGroups[groupIndex].pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkRayTracingShaderGroupCreateInfoKHR-pNext-pNext", kVUIDUndefined, true);

                    skip |= context.ValidateRangedEnum(pGroups_loc.dot(Field::type), vvl::Enum::VkRayTracingShaderGroupTypeKHR,
                                                       pCreateInfos[createInfoIndex].pGroups[groupIndex].type,
                                                       "VUID-VkRayTracingShaderGroupCreateInfoKHR-type-parameter");
                }
            }

            skip |= context.ValidateStructType(
                pCreateInfos_loc.dot(Field::pLibraryInfo), pCreateInfos[createInfoIndex].pLibraryInfo,
                VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, false,
                "VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-parameter", "VUID-VkPipelineLibraryCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInfo != nullptr) {
                [[maybe_unused]] const Location pLibraryInfo_loc = pCreateInfos_loc.dot(Field::pLibraryInfo);
                skip |= context.ValidateArray(pLibraryInfo_loc.dot(Field::libraryCount), pLibraryInfo_loc.dot(Field::pLibraries),
                                              pCreateInfos[createInfoIndex].pLibraryInfo->libraryCount,
                                              &pCreateInfos[createInfoIndex].pLibraryInfo->pLibraries, false, true, kVUIDUndefined,
                                              "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }

            skip |= context.ValidateStructType(pCreateInfos_loc.dot(Field::pLibraryInterface),
                                               pCreateInfos[createInfoIndex].pLibraryInterface,
                                               VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR, false,
                                               "VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInterface-parameter",
                                               "VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInterface != nullptr) {
                [[maybe_unused]] const Location pLibraryInterface_loc = pCreateInfos_loc.dot(Field::pLibraryInterface);
                skip |= context.ValidateStructPnext(pLibraryInterface_loc, pCreateInfos[createInfoIndex].pLibraryInterface->pNext,
                                                    0, nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined,
                                                    true);
            }

            skip |=
                context.ValidateStructType(pCreateInfos_loc.dot(Field::pDynamicState), pCreateInfos[createInfoIndex].pDynamicState,
                                           VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false,
                                           "VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicState-parameter",
                                           "VUID-VkPipelineDynamicStateCreateInfo-sType-sType");

            if (pCreateInfos[createInfoIndex].pDynamicState != nullptr) {
                [[maybe_unused]] const Location pDynamicState_loc = pCreateInfos_loc.dot(Field::pDynamicState);
                skip |= context.ValidateStructPnext(pDynamicState_loc, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0,
                                                    nullptr, GeneratedVulkanHeaderVersion,
                                                    "VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext", kVUIDUndefined, true);

                skip |= context.ValidateReservedFlags(pDynamicState_loc.dot(Field::flags),
                                                      pCreateInfos[createInfoIndex].pDynamicState->flags,
                                                      "VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask");

                skip |= context.ValidateRangedEnumArray(
                    pDynamicState_loc.dot(Field::dynamicStateCount), pDynamicState_loc.dot(Field::pDynamicStates),
                    vvl::Enum::VkDynamicState, pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount,
                    pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, false, true, kVUIDUndefined,
                    "VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter");
            }

            skip |= context.ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= context.ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= context.ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true,
                                  true, "VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength",
                                  "VUID-vkCreateRayTracingPipelinesKHR-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount,
                                                                   pCreateInfos, pAllocator, pPipelines, context);
    return skip;
}

bool Device::PreCallValidateGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline,
                                                                            uint32_t firstGroup, uint32_t groupCount,
                                                                            size_t dataSize, void* pData,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= context.ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                                  "VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-arraylength",
                                  "VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount,
                                                                                      dataSize, pData, context);
    return skip;
}

bool Device::PreCallValidateCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer,
                                                    const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                                                    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                                                    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                                                    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
                                                    VkDeviceAddress indirectDeviceAddress, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pRaygenShaderBindingTable), pRaygenShaderBindingTable,
                                            "VUID-vkCmdTraceRaysIndirectKHR-pRaygenShaderBindingTable-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pMissShaderBindingTable), pMissShaderBindingTable,
                                            "VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pHitShaderBindingTable), pHitShaderBindingTable,
                                            "VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-parameter");
    skip |= context.ValidateRequiredPointer(loc.dot(Field::pCallableShaderBindingTable), pCallableShaderBindingTable,
                                            "VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable,
                                                              pHitShaderBindingTable, pCallableShaderBindingTable,
                                                              indirectDeviceAddress, context);
    return skip;
}

bool Device::PreCallValidateGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group,
                                                                 VkShaderGroupShaderKHR groupShader,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= context.ValidateRangedEnum(loc.dot(Field::groupShader), vvl::Enum::VkShaderGroupShaderKHR, groupShader,
                                       "VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-parameter");
    return skip;
}

bool Device::PreCallValidateCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                                                uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_mesh_shader});
    // No xml-driven validation
    return skip;
}

bool Device::PreCallValidateCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                        uint32_t drawCount, uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_mesh_shader});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool Device::PreCallValidateCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                             VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                             uint32_t maxDrawCount, uint32_t stride,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    Context context(*this, error_obj, extensions);
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(extensions.vk_ext_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_mesh_shader});
    skip |= context.ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= context.ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool Device::ValidatePipelineViewportStateCreateInfo(const Context& context, const VkPipelineViewportStateCreateInfo& info,
                                                     const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, false, kVUIDUndefined,
                                       "VUID-VkPipelineViewportStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineViewportStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineViewportStateCreateInfo.size(),
                                        allowed_structs_VkPipelineViewportStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineViewportStateCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineViewportStateCreateInfo-sType-unique", true);

    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), info.flags,
                                          "VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask");
    return skip;
}
bool Device::ValidatePipelineTessellationStateCreateInfo(const Context& context, const VkPipelineTessellationStateCreateInfo& info,
                                                         const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO, false, kVUIDUndefined,
                                       "VUID-VkPipelineTessellationStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineTessellationStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineTessellationStateCreateInfo.size(),
                                        allowed_structs_VkPipelineTessellationStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineTessellationStateCreateInfo-sType-unique", true);

    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), info.flags,
                                          "VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask");
    return skip;
}
bool Device::ValidatePipelineVertexInputStateCreateInfo(const Context& context, const VkPipelineVertexInputStateCreateInfo& info,
                                                        const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, false, kVUIDUndefined,
                                       "VUID-VkPipelineVertexInputStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineVertexInputStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineVertexInputStateCreateInfo.size(),
                                        allowed_structs_VkPipelineVertexInputStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineVertexInputStateCreateInfo-sType-unique", true);

    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), info.flags,
                                          "VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask");

    skip |= context.ValidateArray(loc.dot(Field::vertexBindingDescriptionCount), loc.dot(Field::pVertexBindingDescriptions),
                                  info.vertexBindingDescriptionCount, &info.pVertexBindingDescriptions, false, true, kVUIDUndefined,
                                  "VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter");

    if (info.pVertexBindingDescriptions != nullptr) {
        for (uint32_t vertexBindingDescriptionIndex = 0; vertexBindingDescriptionIndex < info.vertexBindingDescriptionCount;
             ++vertexBindingDescriptionIndex) {
            [[maybe_unused]] const Location pVertexBindingDescriptions_loc =
                loc.dot(Field::pVertexBindingDescriptions, vertexBindingDescriptionIndex);
            skip |= context.ValidateRangedEnum(pVertexBindingDescriptions_loc.dot(Field::inputRate), vvl::Enum::VkVertexInputRate,
                                               info.pVertexBindingDescriptions[vertexBindingDescriptionIndex].inputRate,
                                               "VUID-VkVertexInputBindingDescription-inputRate-parameter");
        }
    }

    skip |=
        context.ValidateArray(loc.dot(Field::vertexAttributeDescriptionCount), loc.dot(Field::pVertexAttributeDescriptions),
                              info.vertexAttributeDescriptionCount, &info.pVertexAttributeDescriptions, false, true, kVUIDUndefined,
                              "VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter");

    if (info.pVertexAttributeDescriptions != nullptr) {
        for (uint32_t vertexAttributeDescriptionIndex = 0; vertexAttributeDescriptionIndex < info.vertexAttributeDescriptionCount;
             ++vertexAttributeDescriptionIndex) {
            [[maybe_unused]] const Location pVertexAttributeDescriptions_loc =
                loc.dot(Field::pVertexAttributeDescriptions, vertexAttributeDescriptionIndex);
            skip |= context.ValidateRangedEnum(pVertexAttributeDescriptions_loc.dot(Field::format), vvl::Enum::VkFormat,
                                               info.pVertexAttributeDescriptions[vertexAttributeDescriptionIndex].format,
                                               "VUID-VkVertexInputAttributeDescription-format-parameter");
        }
    }
    return skip;
}
bool Device::ValidatePipelineMultisampleStateCreateInfo(const Context& context, const VkPipelineMultisampleStateCreateInfo& info,
                                                        const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, false, kVUIDUndefined,
                                       "VUID-VkPipelineMultisampleStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineMultisampleStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineMultisampleStateCreateInfo.size(),
                                        allowed_structs_VkPipelineMultisampleStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineMultisampleStateCreateInfo-sType-unique", true);

    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), info.flags,
                                          "VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask");

    skip |= context.ValidateFlags(loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                  AllVkSampleCountFlagBits, info.rasterizationSamples, kRequiredSingleBit,
                                  "VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter",
                                  "VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::sampleShadingEnable), info.sampleShadingEnable);

    skip |= context.ValidateArray(loc.dot(Field::rasterizationSamples), loc.dot(Field::pSampleMask), info.rasterizationSamples,
                                  &info.pSampleMask, true, false, kVUIDUndefined,
                                  "VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::alphaToCoverageEnable), info.alphaToCoverageEnable);

    skip |= context.ValidateBool32(loc.dot(Field::alphaToOneEnable), info.alphaToOneEnable);
    return skip;
}
bool Device::ValidatePipelineColorBlendStateCreateInfo(const Context& context, const VkPipelineColorBlendStateCreateInfo& info,
                                                       const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, false, kVUIDUndefined,
                                       "VUID-VkPipelineColorBlendStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineColorBlendStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineColorBlendStateCreateInfo.size(),
                                        allowed_structs_VkPipelineColorBlendStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineColorBlendStateCreateInfo-sType-unique", true);

    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineColorBlendStateCreateFlagBits,
                                  AllVkPipelineColorBlendStateCreateFlagBits, info.flags, kOptionalFlags,
                                  "VUID-VkPipelineColorBlendStateCreateInfo-flags-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::logicOpEnable), info.logicOpEnable);

    if (info.pAttachments != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < info.attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pAttachments_loc = loc.dot(Field::pAttachments, attachmentIndex);
            skip |=
                context.ValidateBool32(pAttachments_loc.dot(Field::blendEnable), info.pAttachments[attachmentIndex].blendEnable);

            skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::srcColorBlendFactor), vvl::Enum::VkBlendFactor,
                                               info.pAttachments[attachmentIndex].srcColorBlendFactor,
                                               "VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::dstColorBlendFactor), vvl::Enum::VkBlendFactor,
                                               info.pAttachments[attachmentIndex].dstColorBlendFactor,
                                               "VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::colorBlendOp), vvl::Enum::VkBlendOp,
                                               info.pAttachments[attachmentIndex].colorBlendOp,
                                               "VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter");

            skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::srcAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                               info.pAttachments[attachmentIndex].srcAlphaBlendFactor,
                                               "VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::dstAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                               info.pAttachments[attachmentIndex].dstAlphaBlendFactor,
                                               "VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter");

            skip |= context.ValidateRangedEnum(pAttachments_loc.dot(Field::alphaBlendOp), vvl::Enum::VkBlendOp,
                                               info.pAttachments[attachmentIndex].alphaBlendOp,
                                               "VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter");

            skip |= context.ValidateFlags(pAttachments_loc.dot(Field::colorWriteMask), vvl::FlagBitmask::VkColorComponentFlagBits,
                                          AllVkColorComponentFlagBits, info.pAttachments[attachmentIndex].colorWriteMask,
                                          kOptionalFlags, "VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter");
        }
    }
    return skip;
}
bool Device::ValidatePipelineDepthStencilStateCreateInfo(const Context& context, const VkPipelineDepthStencilStateCreateInfo& info,
                                                         const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, false,
                                       kVUIDUndefined, "VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType");

    skip |= context.ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext", kVUIDUndefined, true);

    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineDepthStencilStateCreateFlagBits,
                                  AllVkPipelineDepthStencilStateCreateFlagBits, info.flags, kOptionalFlags,
                                  "VUID-VkPipelineDepthStencilStateCreateInfo-flags-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::depthTestEnable), info.depthTestEnable);

    skip |= context.ValidateBool32(loc.dot(Field::depthWriteEnable), info.depthWriteEnable);

    skip |= context.ValidateRangedEnum(loc.dot(Field::depthCompareOp), vvl::Enum::VkCompareOp, info.depthCompareOp,
                                       "VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::depthBoundsTestEnable), info.depthBoundsTestEnable);

    skip |= context.ValidateBool32(loc.dot(Field::stencilTestEnable), info.stencilTestEnable);

    skip |= context.ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, info.front.failOp,
                                       "VUID-VkStencilOpState-failOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, info.front.passOp,
                                       "VUID-VkStencilOpState-passOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::depthFailOp), vvl::Enum::VkStencilOp, info.front.depthFailOp,
                                       "VUID-VkStencilOpState-depthFailOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::compareOp), vvl::Enum::VkCompareOp, info.front.compareOp,
                                       "VUID-VkStencilOpState-compareOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, info.back.failOp,
                                       "VUID-VkStencilOpState-failOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, info.back.passOp,
                                       "VUID-VkStencilOpState-passOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::depthFailOp), vvl::Enum::VkStencilOp, info.back.depthFailOp,
                                       "VUID-VkStencilOpState-depthFailOp-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::compareOp), vvl::Enum::VkCompareOp, info.back.compareOp,
                                       "VUID-VkStencilOpState-compareOp-parameter");
    return skip;
}
bool Device::ValidatePipelineInputAssemblyStateCreateInfo(const Context& context,
                                                          const VkPipelineInputAssemblyStateCreateInfo& info,
                                                          const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, false,
                                       kVUIDUndefined, "VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType");

    skip |= context.ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext", kVUIDUndefined, true);

    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), info.flags,
                                          "VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask");

    skip |= context.ValidateRangedEnum(loc.dot(Field::topology), vvl::Enum::VkPrimitiveTopology, info.topology,
                                       "VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::primitiveRestartEnable), info.primitiveRestartEnable);
    return skip;
}
bool Device::ValidatePipelineRasterizationStateCreateInfo(const Context& context,
                                                          const VkPipelineRasterizationStateCreateInfo& info,
                                                          const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, false,
                                       kVUIDUndefined, "VUID-VkPipelineRasterizationStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineRasterizationStateCreateInfo = {
        VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineRasterizationStateCreateInfo.size(),
                                        allowed_structs_VkPipelineRasterizationStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineRasterizationStateCreateInfo-sType-unique", true);

    skip |= context.ValidateReservedFlags(loc.dot(Field::flags), info.flags,
                                          "VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask");

    skip |= context.ValidateBool32(loc.dot(Field::depthClampEnable), info.depthClampEnable);

    skip |= context.ValidateBool32(loc.dot(Field::rasterizerDiscardEnable), info.rasterizerDiscardEnable);

    skip |= context.ValidateRangedEnum(loc.dot(Field::polygonMode), vvl::Enum::VkPolygonMode, info.polygonMode,
                                       "VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter");

    skip |= context.ValidateFlags(loc.dot(Field::cullMode), vvl::FlagBitmask::VkCullModeFlagBits, AllVkCullModeFlagBits,
                                  info.cullMode, kOptionalFlags, "VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::frontFace), vvl::Enum::VkFrontFace, info.frontFace,
                                       "VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter");

    skip |= context.ValidateBool32(loc.dot(Field::depthBiasEnable), info.depthBiasEnable);
    return skip;
}
bool Device::ValidatePipelineShaderStageCreateInfo(const Context& context, const VkPipelineShaderStageCreateInfo& info,
                                                   const Location& loc) const {
    bool skip = false;
    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                        allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineShaderStageCreateInfo-sType-unique", true);

    skip |= context.ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                  AllVkPipelineShaderStageCreateFlagBits, info.flags, kOptionalFlags,
                                  "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

    skip |= context.ValidateFlags(loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                  info.stage, kRequiredSingleBit, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                  "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

    skip |=
        context.ValidateRequiredPointer(loc.dot(Field::pName), info.pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

    if (info.pSpecializationInfo != nullptr) {
        [[maybe_unused]] const Location pSpecializationInfo_loc = loc.dot(Field::pSpecializationInfo);
        skip |= context.ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                      pSpecializationInfo_loc.dot(Field::pMapEntries), info.pSpecializationInfo->mapEntryCount,
                                      &info.pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined,
                                      "VUID-VkSpecializationInfo-pMapEntries-parameter");

        if (info.pSpecializationInfo->pMapEntries != nullptr) {
            for (uint32_t mapEntryIndex = 0; mapEntryIndex < info.pSpecializationInfo->mapEntryCount; ++mapEntryIndex) {
                [[maybe_unused]] const Location pMapEntries_loc = pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                // No xml-driven validation
            }
        }

        skip |= context.ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                      info.pSpecializationInfo->dataSize, &info.pSpecializationInfo->pData, false, true,
                                      kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
    }
    return skip;
}
bool Device::ValidateCommandBufferInheritanceInfo(const Context& context, const VkCommandBufferInheritanceInfo& info,
                                                  const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO, false, kVUIDUndefined,
                                       "VUID-VkCommandBufferInheritanceInfo-sType-sType");

    constexpr std::array allowed_structs_VkCommandBufferInheritanceInfo = {
        VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
        VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
        VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
        VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
        VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkCommandBufferInheritanceInfo.size(),
                                        allowed_structs_VkCommandBufferInheritanceInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkCommandBufferInheritanceInfo-pNext-pNext",
                                        "VUID-VkCommandBufferInheritanceInfo-sType-unique", true);

    skip |= context.ValidateBool32(loc.dot(Field::occlusionQueryEnable), info.occlusionQueryEnable);
    return skip;
}
bool Device::ValidateDescriptorAddressInfoEXT(const Context& context, const VkDescriptorAddressInfoEXT& info,
                                              const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT, false, kVUIDUndefined,
                                       "VUID-VkDescriptorAddressInfoEXT-sType-sType");

    skip |= context.ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkDescriptorAddressInfoEXT-pNext-pNext", kVUIDUndefined, false);

    skip |= context.ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, info.format,
                                       "VUID-VkDescriptorAddressInfoEXT-format-parameter");
    return skip;
}
bool Device::ValidateAccelerationStructureGeometryTrianglesDataKHR(const Context& context,
                                                                   const VkAccelerationStructureGeometryTrianglesDataKHR& info,
                                                                   const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR, false,
                                       kVUIDUndefined, "VUID-VkAccelerationStructureGeometryTrianglesDataKHR-sType-sType");

    constexpr std::array allowed_structs_VkAccelerationStructureGeometryTrianglesDataKHR = {
        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV,
        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT};

    skip |= context.ValidateStructPnext(loc, info.pNext, allowed_structs_VkAccelerationStructureGeometryTrianglesDataKHR.size(),
                                        allowed_structs_VkAccelerationStructureGeometryTrianglesDataKHR.data(),
                                        GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureGeometryTrianglesDataKHR-pNext-pNext",
                                        "VUID-VkAccelerationStructureGeometryTrianglesDataKHR-sType-unique", true);

    skip |= context.ValidateRangedEnum(loc.dot(Field::vertexFormat), vvl::Enum::VkFormat, info.vertexFormat,
                                       "VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-parameter");

    skip |= context.ValidateRangedEnum(loc.dot(Field::indexType), vvl::Enum::VkIndexType, info.indexType,
                                       "VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-parameter");
    return skip;
}
bool Device::ValidateAccelerationStructureGeometryInstancesDataKHR(const Context& context,
                                                                   const VkAccelerationStructureGeometryInstancesDataKHR& info,
                                                                   const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR, false,
                                       kVUIDUndefined, "VUID-VkAccelerationStructureGeometryInstancesDataKHR-sType-sType");

    skip |= context.ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureGeometryInstancesDataKHR-pNext-pNext", kVUIDUndefined, true);

    skip |= context.ValidateBool32(loc.dot(Field::arrayOfPointers), info.arrayOfPointers);
    return skip;
}
bool Device::ValidateAccelerationStructureGeometryAabbsDataKHR(const Context& context,
                                                               const VkAccelerationStructureGeometryAabbsDataKHR& info,
                                                               const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR, false,
                                       kVUIDUndefined, "VUID-VkAccelerationStructureGeometryAabbsDataKHR-sType-sType");

    skip |= context.ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureGeometryAabbsDataKHR-pNext-pNext", kVUIDUndefined, true);
    return skip;
}
bool Device::ValidateIndirectExecutionSetPipelineInfoEXT(const Context& context, const VkIndirectExecutionSetPipelineInfoEXT& info,
                                                         const Location& loc) const {
    bool skip = false;
    skip |= context.ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT, false,
                                       kVUIDUndefined, "VUID-VkIndirectExecutionSetPipelineInfoEXT-sType-sType");

    skip |= context.ValidateRequiredHandle(loc.dot(Field::initialPipeline), info.initialPipeline);
    return skip;
}

}  // namespace stateless

// NOLINTEND
