// *** THIS FILE IS GENERATED - DO NOT EDIT ***
// See stateless_validation_helper_generator.py for modifications

/***************************************************************************
 *
 * Copyright (c) 2015-2024 The Khronos Group Inc.
 * Copyright (c) 2015-2024 Valve Corporation
 * Copyright (c) 2015-2024 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ****************************************************************************/

// NOLINTBEGIN

#include "chassis.h"

#include "stateless/stateless_validation.h"
#include "generated/enum_flag_bits.h"
#include "generated/layer_chassis_dispatch.h"

bool StatelessValidation::ValidatePnextFeatureStructContents(const Location& loc, const VkBaseOutStructure* header,
                                                             const char* pnext_vuid, const VkPhysicalDevice physicalDevice,
                                                             bool is_const_param) const {
    bool skip = false;
    const bool is_physdev_api = physicalDevice != VK_NULL_HANDLE;
    switch (header->sType) {
        // Validation code for VkPhysicalDevice16BitStorageFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: {  // Covers
                                                                          // VUID-VkPhysicalDevice16BitStorageFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_16bit_storage)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_16bit_storage))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES), but its parent extension "
                                 "VK_KHR_16bit_storage has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevice16BitStorageFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_16bit_storage)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevice16BitStorageFeatures, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_16bit_storage) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevice16BitStorageFeatures* structure = (VkPhysicalDevice16BitStorageFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer16BitAccess), structure->storageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer16BitAccess),
                                       structure->uniformAndStorageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant16), structure->storagePushConstant16);

                skip |= ValidateBool32(pNext_loc.dot(Field::storageInputOutput16), structure->storageInputOutput16);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: {  // Covers VUID-VkPhysicalDeviceMultiviewFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_multiview)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_multiview))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES), "
                                 "but its parent extension "
                                 "VK_KHR_multiview has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMultiviewFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_multiview)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMultiviewFeatures, but when creating VkDevice, the "
                                     "parent extension "
                                     "(VK_KHR_multiview) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMultiviewFeatures* structure = (VkPhysicalDeviceMultiviewFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiview), structure->multiview);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewGeometryShader), structure->multiviewGeometryShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewTessellationShader), structure->multiviewTessellationShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceVariablePointersFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: {  // Covers
                                                                              // VUID-VkPhysicalDeviceVariablePointersFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_variable_pointers)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_variable_pointers))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES), but its parent extension "
                                 "VK_KHR_variable_pointers has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVariablePointersFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_variable_pointers)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceVariablePointersFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_variable_pointers) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceVariablePointersFeatures* structure = (VkPhysicalDeviceVariablePointersFeatures*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::variablePointersStorageBuffer), structure->variablePointersStorageBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::variablePointers), structure->variablePointers);
            }
        } break;

        // Validation code for VkPhysicalDeviceProtectedMemoryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceProtectedMemoryFeatures-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_1) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(
                        pnext_vuid, instance, loc.dot(Field::pNext),
                        "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES) "
                        "which was added in VK_API_VERSION_1_1 but the "
                        "current effective API version is %s.",
                        StringAPIVersion(device_api_version).c_str());
                }
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceProtectedMemoryFeatures);
                VkPhysicalDeviceProtectedMemoryFeatures* structure = (VkPhysicalDeviceProtectedMemoryFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::protectedMemory), structure->protectedMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceSamplerYcbcrConversionFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceSamplerYcbcrConversionFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_sampler_ycbcr_conversion)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES), but its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSamplerYcbcrConversionFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSamplerYcbcrConversionFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_sampler_ycbcr_conversion) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSamplerYcbcrConversionFeatures* structure = (VkPhysicalDeviceSamplerYcbcrConversionFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::samplerYcbcrConversion), structure->samplerYcbcrConversion);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderDrawParametersFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceShaderDrawParametersFeatures-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_1) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType "
                                     "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES) which was added in "
                                     "VK_API_VERSION_1_1 but the "
                                     "current effective API version is %s.",
                                     StringAPIVersion(device_api_version).c_str());
                }
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderDrawParametersFeatures);
                VkPhysicalDeviceShaderDrawParametersFeatures* structure = (VkPhysicalDeviceShaderDrawParametersFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderDrawParameters), structure->shaderDrawParameters);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan11Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan11Features-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_2) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |=
                        LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES) "
                                 "which was added in VK_API_VERSION_1_2 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(device_api_version).c_str());
                }
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan11Features);
                VkPhysicalDeviceVulkan11Features* structure = (VkPhysicalDeviceVulkan11Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer16BitAccess), structure->storageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer16BitAccess),
                                       structure->uniformAndStorageBuffer16BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant16), structure->storagePushConstant16);

                skip |= ValidateBool32(pNext_loc.dot(Field::storageInputOutput16), structure->storageInputOutput16);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiview), structure->multiview);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewGeometryShader), structure->multiviewGeometryShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewTessellationShader), structure->multiviewTessellationShader);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::variablePointersStorageBuffer), structure->variablePointersStorageBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::variablePointers), structure->variablePointers);

                skip |= ValidateBool32(pNext_loc.dot(Field::protectedMemory), structure->protectedMemory);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerYcbcrConversion), structure->samplerYcbcrConversion);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderDrawParameters), structure->shaderDrawParameters);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan12Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan12Features-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_2) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |=
                        LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES) "
                                 "which was added in VK_API_VERSION_1_2 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(device_api_version).c_str());
                }
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan12Features);
                VkPhysicalDeviceVulkan12Features* structure = (VkPhysicalDeviceVulkan12Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::samplerMirrorClampToEdge), structure->samplerMirrorClampToEdge);

                skip |= ValidateBool32(pNext_loc.dot(Field::drawIndirectCount), structure->drawIndirectCount);

                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer8BitAccess), structure->storageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer8BitAccess),
                                       structure->uniformAndStorageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant8), structure->storagePushConstant8);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferInt64Atomics), structure->shaderBufferInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedInt64Atomics), structure->shaderSharedInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat16), structure->shaderFloat16);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt8), structure->shaderInt8);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorIndexing), structure->descriptorIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayDynamicIndexing),
                                       structure->shaderInputAttachmentArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayDynamicIndexing),
                                       structure->shaderUniformTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayDynamicIndexing),
                                       structure->shaderStorageTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformBufferArrayNonUniformIndexing),
                                       structure->shaderUniformBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampledImageArrayNonUniformIndexing),
                                       structure->shaderSampledImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageBufferArrayNonUniformIndexing),
                                       structure->shaderStorageBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageArrayNonUniformIndexing),
                                       structure->shaderStorageImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayNonUniformIndexing),
                                       structure->shaderInputAttachmentArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayNonUniformIndexing),
                                       structure->shaderUniformTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayNonUniformIndexing),
                                       structure->shaderStorageTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingSampledImageUpdateAfterBind),
                                       structure->descriptorBindingSampledImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageImageUpdateAfterBind),
                                       structure->descriptorBindingStorageImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUpdateUnusedWhilePending),
                                       structure->descriptorBindingUpdateUnusedWhilePending);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingPartiallyBound),
                                       structure->descriptorBindingPartiallyBound);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingVariableDescriptorCount),
                                       structure->descriptorBindingVariableDescriptorCount);

                skip |= ValidateBool32(pNext_loc.dot(Field::runtimeDescriptorArray), structure->runtimeDescriptorArray);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerFilterMinmax), structure->samplerFilterMinmax);

                skip |= ValidateBool32(pNext_loc.dot(Field::scalarBlockLayout), structure->scalarBlockLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::imagelessFramebuffer), structure->imagelessFramebuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformBufferStandardLayout), structure->uniformBufferStandardLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupExtendedTypes), structure->shaderSubgroupExtendedTypes);

                skip |= ValidateBool32(pNext_loc.dot(Field::separateDepthStencilLayouts), structure->separateDepthStencilLayouts);

                skip |= ValidateBool32(pNext_loc.dot(Field::hostQueryReset), structure->hostQueryReset);

                skip |= ValidateBool32(pNext_loc.dot(Field::timelineSemaphore), structure->timelineSemaphore);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddress), structure->bufferDeviceAddress);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressCaptureReplay),
                                       structure->bufferDeviceAddressCaptureReplay);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressMultiDevice), structure->bufferDeviceAddressMultiDevice);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModel), structure->vulkanMemoryModel);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelDeviceScope), structure->vulkanMemoryModelDeviceScope);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelAvailabilityVisibilityChains),
                                       structure->vulkanMemoryModelAvailabilityVisibilityChains);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderOutputViewportIndex), structure->shaderOutputViewportIndex);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderOutputLayer), structure->shaderOutputLayer);

                skip |= ValidateBool32(pNext_loc.dot(Field::subgroupBroadcastDynamicId), structure->subgroupBroadcastDynamicId);
            }
        } break;

        // Validation code for VkPhysicalDevice8BitStorageFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: {  // Covers
                                                                         // VUID-VkPhysicalDevice8BitStorageFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_8bit_storage)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_8bit_storage))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES), but its parent extension "
                                 "VK_KHR_8bit_storage has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevice8BitStorageFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_8bit_storage)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevice8BitStorageFeatures, but when creating VkDevice, the "
                                     "parent extension "
                                     "(VK_KHR_8bit_storage) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevice8BitStorageFeatures* structure = (VkPhysicalDevice8BitStorageFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::storageBuffer8BitAccess), structure->storageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::uniformAndStorageBuffer8BitAccess),
                                       structure->uniformAndStorageBuffer8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::storagePushConstant8), structure->storagePushConstant8);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicInt64Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceShaderAtomicInt64Features-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_atomic_int64)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_atomic_int64))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES), but its parent extension "
                                 "VK_KHR_shader_atomic_int64 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicInt64Features);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_atomic_int64)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderAtomicInt64Features, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_atomic_int64) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderAtomicInt64Features* structure = (VkPhysicalDeviceShaderAtomicInt64Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferInt64Atomics), structure->shaderBufferInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedInt64Atomics), structure->shaderSharedInt64Atomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderFloat16Int8Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceShaderFloat16Int8Features-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_float16_int8)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_float16_int8))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES), but its parent extension "
                                 "VK_KHR_shader_float16_int8 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderFloat16Int8Features);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_float16_int8)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderFloat16Int8Features, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_float16_int8) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderFloat16Int8Features* structure = (VkPhysicalDeviceShaderFloat16Int8Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat16), structure->shaderFloat16);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt8), structure->shaderInt8);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorIndexingFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceDescriptorIndexingFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_descriptor_indexing)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES), but its parent extension "
                                 "VK_EXT_descriptor_indexing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDescriptorIndexingFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_descriptor_indexing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDescriptorIndexingFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_descriptor_indexing) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDescriptorIndexingFeatures* structure = (VkPhysicalDeviceDescriptorIndexingFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayDynamicIndexing),
                                       structure->shaderInputAttachmentArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayDynamicIndexing),
                                       structure->shaderUniformTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayDynamicIndexing),
                                       structure->shaderStorageTexelBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformBufferArrayNonUniformIndexing),
                                       structure->shaderUniformBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampledImageArrayNonUniformIndexing),
                                       structure->shaderSampledImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageBufferArrayNonUniformIndexing),
                                       structure->shaderStorageBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageArrayNonUniformIndexing),
                                       structure->shaderStorageImageArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInputAttachmentArrayNonUniformIndexing),
                                       structure->shaderInputAttachmentArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformTexelBufferArrayNonUniformIndexing),
                                       structure->shaderUniformTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageTexelBufferArrayNonUniformIndexing),
                                       structure->shaderStorageTexelBufferArrayNonUniformIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingSampledImageUpdateAfterBind),
                                       structure->descriptorBindingSampledImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageImageUpdateAfterBind),
                                       structure->descriptorBindingStorageImageUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUniformTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingUniformTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingStorageTexelBufferUpdateAfterBind),
                                       structure->descriptorBindingStorageTexelBufferUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingUpdateUnusedWhilePending),
                                       structure->descriptorBindingUpdateUnusedWhilePending);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingPartiallyBound),
                                       structure->descriptorBindingPartiallyBound);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingVariableDescriptorCount),
                                       structure->descriptorBindingVariableDescriptorCount);

                skip |= ValidateBool32(pNext_loc.dot(Field::runtimeDescriptorArray), structure->runtimeDescriptorArray);
            }
        } break;

        // Validation code for VkPhysicalDeviceScalarBlockLayoutFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceScalarBlockLayoutFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_scalar_block_layout)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_scalar_block_layout))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES), but its parent extension "
                                 "VK_EXT_scalar_block_layout has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceScalarBlockLayoutFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_scalar_block_layout)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceScalarBlockLayoutFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_scalar_block_layout) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceScalarBlockLayoutFeatures* structure = (VkPhysicalDeviceScalarBlockLayoutFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::scalarBlockLayout), structure->scalarBlockLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkanMemoryModelFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: {  // Covers
                                                                                // VUID-VkPhysicalDeviceVulkanMemoryModelFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_vulkan_memory_model)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_vulkan_memory_model))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES), but its parent extension "
                                 "VK_KHR_vulkan_memory_model has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkanMemoryModelFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_vulkan_memory_model)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceVulkanMemoryModelFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_vulkan_memory_model) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceVulkanMemoryModelFeatures* structure = (VkPhysicalDeviceVulkanMemoryModelFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModel), structure->vulkanMemoryModel);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelDeviceScope), structure->vulkanMemoryModelDeviceScope);

                skip |= ValidateBool32(pNext_loc.dot(Field::vulkanMemoryModelAvailabilityVisibilityChains),
                                       structure->vulkanMemoryModelAvailabilityVisibilityChains);
            }
        } break;

        // Validation code for VkPhysicalDeviceImagelessFramebufferFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceImagelessFramebufferFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_imageless_framebuffer)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES), but its parent extension "
                                 "VK_KHR_imageless_framebuffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImagelessFramebufferFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImagelessFramebufferFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_imageless_framebuffer) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImagelessFramebufferFeatures* structure = (VkPhysicalDeviceImagelessFramebufferFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imagelessFramebuffer), structure->imagelessFramebuffer);
            }
        } break;

        // Validation code for VkPhysicalDeviceUniformBufferStandardLayoutFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceUniformBufferStandardLayoutFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_uniform_buffer_standard_layout)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_uniform_buffer_standard_layout))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES), but its parent extension "
                    "VK_KHR_uniform_buffer_standard_layout has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceUniformBufferStandardLayoutFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_uniform_buffer_standard_layout)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceUniformBufferStandardLayoutFeatures, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_uniform_buffer_standard_layout) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceUniformBufferStandardLayoutFeatures* structure =
                    (VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::uniformBufferStandardLayout), structure->uniformBufferStandardLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_subgroup_extended_types)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_subgroup_extended_types))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES), but its parent extension "
                    "VK_KHR_shader_subgroup_extended_types has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_separate_depth_stencil_layouts)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES), but its parent extension "
                    "VK_KHR_separate_depth_stencil_layouts has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_separate_depth_stencil_layouts) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* structure =
                    (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::separateDepthStencilLayouts), structure->separateDepthStencilLayouts);
            }
        } break;

        // Validation code for VkPhysicalDeviceHostQueryResetFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceHostQueryResetFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_host_query_reset)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_host_query_reset))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES), but its parent extension "
                                 "VK_EXT_host_query_reset has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceHostQueryResetFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_host_query_reset)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceHostQueryResetFeatures, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_host_query_reset) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceHostQueryResetFeatures* structure = (VkPhysicalDeviceHostQueryResetFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::hostQueryReset), structure->hostQueryReset);
            }
        } break;

        // Validation code for VkPhysicalDeviceTimelineSemaphoreFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: {  // Covers
                                                                               // VUID-VkPhysicalDeviceTimelineSemaphoreFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_timeline_semaphore)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES), but its parent extension "
                                 "VK_KHR_timeline_semaphore has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTimelineSemaphoreFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceTimelineSemaphoreFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_timeline_semaphore) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceTimelineSemaphoreFeatures* structure = (VkPhysicalDeviceTimelineSemaphoreFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::timelineSemaphore), structure->timelineSemaphore);
            }
        } break;

        // Validation code for VkPhysicalDeviceBufferDeviceAddressFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceBufferDeviceAddressFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_buffer_device_address)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_buffer_device_address))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES), but its parent extension "
                                 "VK_KHR_buffer_device_address has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBufferDeviceAddressFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceBufferDeviceAddressFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_buffer_device_address) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceBufferDeviceAddressFeatures* structure = (VkPhysicalDeviceBufferDeviceAddressFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddress), structure->bufferDeviceAddress);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressCaptureReplay),
                                       structure->bufferDeviceAddressCaptureReplay);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressMultiDevice), structure->bufferDeviceAddressMultiDevice);
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan13Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: {  // Covers VUID-VkPhysicalDeviceVulkan13Features-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_3) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |=
                        LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES) "
                                 "which was added in VK_API_VERSION_1_3 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(device_api_version).c_str());
                }
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVulkan13Features);
                VkPhysicalDeviceVulkan13Features* structure = (VkPhysicalDeviceVulkan13Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustImageAccess), structure->robustImageAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::inlineUniformBlock), structure->inlineUniformBlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingInlineUniformBlockUpdateAfterBind),
                                       structure->descriptorBindingInlineUniformBlockUpdateAfterBind);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineCreationCacheControl), structure->pipelineCreationCacheControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::privateData), structure->privateData);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderDemoteToHelperInvocation), structure->shaderDemoteToHelperInvocation);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTerminateInvocation), structure->shaderTerminateInvocation);

                skip |= ValidateBool32(pNext_loc.dot(Field::subgroupSizeControl), structure->subgroupSizeControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::computeFullSubgroups), structure->computeFullSubgroups);

                skip |= ValidateBool32(pNext_loc.dot(Field::synchronization2), structure->synchronization2);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionASTC_HDR), structure->textureCompressionASTC_HDR);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderZeroInitializeWorkgroupMemory),
                                       structure->shaderZeroInitializeWorkgroupMemory);

                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRendering), structure->dynamicRendering);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderIntegerDotProduct), structure->shaderIntegerDotProduct);

                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance4), structure->maintenance4);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderTerminateInvocationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceShaderTerminateInvocationFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_terminate_invocation)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_terminate_invocation))) {
                skip |=
                    LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                             "includes a pointer to a VkStructureType "
                             "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES), but its parent extension "
                             "VK_KHR_shader_terminate_invocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderTerminateInvocationFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_terminate_invocation)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderTerminateInvocationFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_terminate_invocation) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderTerminateInvocationFeatures* structure =
                    (VkPhysicalDeviceShaderTerminateInvocationFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTerminateInvocation), structure->shaderTerminateInvocation);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES: {  // Covers
                                                                                               // VUID-VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_shader_demote_to_helper_invocation)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_shader_demote_to_helper_invocation))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES), but its parent extension "
                    "VK_EXT_shader_demote_to_helper_invocation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_demote_to_helper_invocation)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_shader_demote_to_helper_invocation) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* structure =
                    (VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderDemoteToHelperInvocation), structure->shaderDemoteToHelperInvocation);
            }
        } break;

        // Validation code for VkPhysicalDevicePrivateDataFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: {  // Covers
                                                                         // VUID-VkPhysicalDevicePrivateDataFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_private_data)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_private_data))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES), but its parent extension "
                                 "VK_EXT_private_data has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePrivateDataFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_private_data)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePrivateDataFeatures, but when creating VkDevice, the "
                                     "parent extension "
                                     "(VK_EXT_private_data) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePrivateDataFeatures* structure = (VkPhysicalDevicePrivateDataFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::privateData), structure->privateData);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineCreationCacheControlFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES: {  // Covers
                                                                                            // VUID-VkPhysicalDevicePipelineCreationCacheControlFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_pipeline_creation_cache_control)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_pipeline_creation_cache_control))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES), but its parent extension "
                    "VK_EXT_pipeline_creation_cache_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineCreationCacheControlFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_creation_cache_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelineCreationCacheControlFeatures, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_pipeline_creation_cache_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelineCreationCacheControlFeatures* structure =
                    (VkPhysicalDevicePipelineCreationCacheControlFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineCreationCacheControl), structure->pipelineCreationCacheControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceSynchronization2Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: {  // Covers
                                                                              // VUID-VkPhysicalDeviceSynchronization2Features-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_synchronization2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_synchronization2))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES), but its parent extension "
                                 "VK_KHR_synchronization2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSynchronization2Features);
                if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSynchronization2Features, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_synchronization2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSynchronization2Features* structure = (VkPhysicalDeviceSynchronization2Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::synchronization2), structure->synchronization2);
            }
        } break;

        // Validation code for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_zero_initialize_workgroup_memory)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_zero_initialize_workgroup_memory))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES), but its parent extension "
                    "VK_KHR_zero_initialize_workgroup_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_zero_initialize_workgroup_memory)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_zero_initialize_workgroup_memory) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* structure =
                    (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderZeroInitializeWorkgroupMemory),
                                       structure->shaderZeroInitializeWorkgroupMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageRobustnessFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceImageRobustnessFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_image_robustness)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_image_robustness))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES), but its parent extension "
                                 "VK_EXT_image_robustness has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageRobustnessFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_image_robustness)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageRobustnessFeatures, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_image_robustness) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageRobustnessFeatures* structure = (VkPhysicalDeviceImageRobustnessFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustImageAccess), structure->robustImageAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubgroupSizeControlFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceSubgroupSizeControlFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_subgroup_size_control)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_subgroup_size_control))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES), but its parent extension "
                                 "VK_EXT_subgroup_size_control has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSubgroupSizeControlFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_subgroup_size_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSubgroupSizeControlFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_subgroup_size_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSubgroupSizeControlFeatures* structure = (VkPhysicalDeviceSubgroupSizeControlFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::subgroupSizeControl), structure->subgroupSizeControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::computeFullSubgroups), structure->computeFullSubgroups);
            }
        } break;

        // Validation code for VkPhysicalDeviceInlineUniformBlockFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceInlineUniformBlockFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_inline_uniform_block)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES), but its parent extension "
                                 "VK_EXT_inline_uniform_block has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceInlineUniformBlockFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_inline_uniform_block)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceInlineUniformBlockFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_inline_uniform_block) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceInlineUniformBlockFeatures* structure = (VkPhysicalDeviceInlineUniformBlockFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::inlineUniformBlock), structure->inlineUniformBlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingInlineUniformBlockUpdateAfterBind),
                                       structure->descriptorBindingInlineUniformBlockUpdateAfterBind);
            }
        } break;

        // Validation code for VkPhysicalDeviceTextureCompressionASTCHDRFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceTextureCompressionASTCHDRFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_texture_compression_astc_hdr)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_texture_compression_astc_hdr))) {
                skip |=
                    LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                             "includes a pointer to a VkStructureType "
                             "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES), but its parent extension "
                             "VK_EXT_texture_compression_astc_hdr has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTextureCompressionASTCHDRFeatures);
                if (!IsExtEnabled(device_extensions.vk_ext_texture_compression_astc_hdr)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceTextureCompressionASTCHDRFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_texture_compression_astc_hdr) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceTextureCompressionASTCHDRFeatures* structure =
                    (VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionASTC_HDR), structure->textureCompressionASTC_HDR);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: {  // Covers
                                                                              // VUID-VkPhysicalDeviceDynamicRenderingFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_dynamic_rendering)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES), but its parent extension "
                                 "VK_KHR_dynamic_rendering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDynamicRenderingFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDynamicRenderingFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_dynamic_rendering) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDynamicRenderingFeatures* structure = (VkPhysicalDeviceDynamicRenderingFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRendering), structure->dynamicRendering);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerDotProductFeatures structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceShaderIntegerDotProductFeatures-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_integer_dot_product)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_integer_dot_product))) {
                skip |=
                    LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                             "includes a pointer to a VkStructureType "
                             "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES), but its parent extension "
                             "VK_KHR_shader_integer_dot_product has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderIntegerDotProductFeatures);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_integer_dot_product)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderIntegerDotProductFeatures, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_integer_dot_product) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderIntegerDotProductFeatures* structure =
                    (VkPhysicalDeviceShaderIntegerDotProductFeatures*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderIntegerDotProduct), structure->shaderIntegerDotProduct);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance4Features structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: {  // Covers
                                                                          // VUID-VkPhysicalDeviceMaintenance4Features-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance4)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance4))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES), but its parent extension "
                                 "VK_KHR_maintenance4 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance4Features);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance4)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMaintenance4Features, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_maintenance4) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMaintenance4Features* structure = (VkPhysicalDeviceMaintenance4Features*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance4), structure->maintenance4);
            }
        } break;

        // Validation code for VkPhysicalDevicePerformanceQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: {  // Covers
                                                                                  // VUID-VkPhysicalDevicePerformanceQueryFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePerformanceQueryFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_performance_query)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePerformanceQueryFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_performance_query) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePerformanceQueryFeaturesKHR* structure = (VkPhysicalDevicePerformanceQueryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::performanceCounterQueryPools), structure->performanceCounterQueryPools);

                skip |= ValidateBool32(pNext_loc.dot(Field::performanceCounterMultipleQueryPools),
                                       structure->performanceCounterMultipleQueryPools);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDevicePortabilitySubsetFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR: {  // Covers
                                                                                   // VUID-VkPhysicalDevicePortabilitySubsetFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePortabilitySubsetFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_portability_subset)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePortabilitySubsetFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_portability_subset) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePortabilitySubsetFeaturesKHR* structure = (VkPhysicalDevicePortabilitySubsetFeaturesKHR*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::constantAlphaColorBlendFactors), structure->constantAlphaColorBlendFactors);

                skip |= ValidateBool32(pNext_loc.dot(Field::events), structure->events);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageViewFormatReinterpretation),
                                       structure->imageViewFormatReinterpretation);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageViewFormatSwizzle), structure->imageViewFormatSwizzle);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageView2DOn3DImage), structure->imageView2DOn3DImage);

                skip |= ValidateBool32(pNext_loc.dot(Field::multisampleArrayImage), structure->multisampleArrayImage);

                skip |= ValidateBool32(pNext_loc.dot(Field::mutableComparisonSamplers), structure->mutableComparisonSamplers);

                skip |= ValidateBool32(pNext_loc.dot(Field::pointPolygons), structure->pointPolygons);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerMipLodBias), structure->samplerMipLodBias);

                skip |= ValidateBool32(pNext_loc.dot(Field::separateStencilMaskRef), structure->separateStencilMaskRef);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampleRateInterpolationFunctions),
                                       structure->shaderSampleRateInterpolationFunctions);

                skip |= ValidateBool32(pNext_loc.dot(Field::tessellationIsolines), structure->tessellationIsolines);

                skip |= ValidateBool32(pNext_loc.dot(Field::tessellationPointMode), structure->tessellationPointMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::triangleFans), structure->triangleFans);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeAccessBeyondStride),
                                       structure->vertexAttributeAccessBeyondStride);
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceShaderClockFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: {  // Covers
                                                                             // VUID-VkPhysicalDeviceShaderClockFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderClockFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_clock)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderClockFeaturesKHR, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_shader_clock) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderClockFeaturesKHR* structure = (VkPhysicalDeviceShaderClockFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupClock), structure->shaderSubgroupClock);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderDeviceClock), structure->shaderDeviceClock);
            }
        } break;

        // Validation code for VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_global_priority) &&
                    !IsExtEnabled(device_extensions.vk_ext_global_priority_query)) {
                    skip |= LogError(
                        pnext_vuid, instance, pNext_loc,
                        "includes a pointer to a VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, but when creating VkDevice, the "
                        "parent extension "
                        "(VK_KHR_global_priority or VK_EXT_global_priority_query) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* structure = (VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::globalPriorityQuery), structure->globalPriorityQuery);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceFragmentShadingRateFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShadingRateFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_fragment_shading_rate)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentShadingRateFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_fragment_shading_rate) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentShadingRateFeaturesKHR* structure = (VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineFragmentShadingRate), structure->pipelineFragmentShadingRate);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveFragmentShadingRate), structure->primitiveFragmentShadingRate);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::attachmentFragmentShadingRate), structure->attachmentFragmentShadingRate);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering_local_read)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_dynamic_rendering_local_read) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR* structure =
                    (VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRenderingLocalRead), structure->dynamicRenderingLocalRead);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderQuadControlFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceShaderQuadControlFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderQuadControlFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_quad_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderQuadControlFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_quad_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderQuadControlFeaturesKHR* structure = (VkPhysicalDeviceShaderQuadControlFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderQuadControl), structure->shaderQuadControl);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentWaitFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: {  // Covers
                                                                             // VUID-VkPhysicalDevicePresentWaitFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentWaitFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_present_wait)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePresentWaitFeaturesKHR, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_present_wait) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePresentWaitFeaturesKHR* structure = (VkPhysicalDevicePresentWaitFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentWait), structure->presentWait);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR: {  // Covers
                                                                                               // VUID-VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_pipeline_executable_properties) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* structure =
                    (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineExecutableInfo), structure->pipelineExecutableInfo);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentIdFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: {  // Covers
                                                                           // VUID-VkPhysicalDevicePresentIdFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentIdFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_present_id)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePresentIdFeaturesKHR, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_present_id) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePresentIdFeaturesKHR* structure = (VkPhysicalDevicePresentIdFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentId), structure->presentId);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_fragment_shader_barycentric) &&
                    !IsExtEnabled(device_extensions.vk_nv_fragment_shader_barycentric)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_fragment_shader_barycentric or VK_NV_fragment_shader_barycentric) was not included "
                                     "in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* structure =
                    (VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShaderBarycentric), structure->fragmentShaderBarycentric);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR: {  // Covers
                                                                                                     // VUID-VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_subgroup_uniform_control_flow)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, but "
                                     "when creating VkDevice, the parent extension "
                                     "(VK_KHR_shader_subgroup_uniform_control_flow) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupUniformControlFlow),
                                       structure->shaderSubgroupUniformControlFlow);
            }
        } break;

        // Validation code for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR: {  // Covers
                                                                                                 // VUID-VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_workgroup_memory_explicit_layout)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_workgroup_memory_explicit_layout) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* structure =
                    (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayout), structure->workgroupMemoryExplicitLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayoutScalarBlockLayout),
                                       structure->workgroupMemoryExplicitLayoutScalarBlockLayout);

                skip |= ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayout8BitAccess),
                                       structure->workgroupMemoryExplicitLayout8BitAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::workgroupMemoryExplicitLayout16BitAccess),
                                       structure->workgroupMemoryExplicitLayout16BitAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_maintenance1)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_ray_tracing_maintenance1) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* structure =
                    (VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingMaintenance1), structure->rayTracingMaintenance1);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineTraceRaysIndirect2),
                                       structure->rayTracingPipelineTraceRaysIndirect2);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_subgroup_rotate)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_subgroup_rotate) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSubgroupRotate), structure->shaderSubgroupRotate);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderSubgroupRotateClustered), structure->shaderSubgroupRotateClustered);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_maximal_reconvergence)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_shader_maximal_reconvergence) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderMaximalReconvergence), structure->shaderMaximalReconvergence);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance5FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR: {  // Covers
                                                                              // VUID-VkPhysicalDeviceMaintenance5FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance5FeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance5)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMaintenance5FeaturesKHR, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_maintenance5) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMaintenance5FeaturesKHR* structure = (VkPhysicalDeviceMaintenance5FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance5), structure->maintenance5);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_position_fetch)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_ray_tracing_position_fetch) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* structure =
                    (VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPositionFetch), structure->rayTracingPositionFetch);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineBinaryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR: {  // Covers
                                                                                // VUID-VkPhysicalDevicePipelineBinaryFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineBinaryFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelineBinaryFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_pipeline_binary) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelineBinaryFeaturesKHR* structure = (VkPhysicalDevicePipelineBinaryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaries), structure->pipelineBinaries);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrixFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceCooperativeMatrixFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCooperativeMatrixFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_cooperative_matrix)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCooperativeMatrixFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_cooperative_matrix) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCooperativeMatrixFeaturesKHR* structure = (VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrix), structure->cooperativeMatrix);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixRobustBufferAccess),
                                       structure->cooperativeMatrixRobustBufferAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_compute_shader_derivatives) &&
                    !IsExtEnabled(device_extensions.vk_nv_compute_shader_derivatives)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_KHR_compute_shader_derivatives or VK_NV_compute_shader_derivatives) was not included in "
                                     "ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* structure =
                    (VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::computeDerivativeGroupQuads), structure->computeDerivativeGroupQuads);

                skip |= ValidateBool32(pNext_loc.dot(Field::computeDerivativeGroupLinear), structure->computeDerivativeGroupLinear);
            }
        } break;

        // Validation code for VkPhysicalDeviceVideoMaintenance1FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceVideoMaintenance1FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVideoMaintenance1FeaturesKHR);
                VkPhysicalDeviceVideoMaintenance1FeaturesKHR* structure = (VkPhysicalDeviceVideoMaintenance1FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::videoMaintenance1), structure->videoMaintenance1);
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_vertex_attribute_divisor) &&
                    !IsExtEnabled(device_extensions.vk_ext_vertex_attribute_divisor)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_vertex_attribute_divisor or VK_EXT_vertex_attribute_divisor) was not included in "
                                     "ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR* structure =
                    (VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeInstanceRateDivisor),
                                       structure->vertexAttributeInstanceRateDivisor);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexAttributeInstanceRateZeroDivisor),
                                       structure->vertexAttributeInstanceRateZeroDivisor);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderFloatControls2FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceShaderFloatControls2FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderFloatControls2FeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_float_controls2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderFloatControls2FeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_float_controls2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderFloatControls2FeaturesKHR* structure =
                    (VkPhysicalDeviceShaderFloatControls2FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloatControls2), structure->shaderFloatControls2);
            }
        } break;

        // Validation code for VkPhysicalDeviceIndexTypeUint8FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceIndexTypeUint8FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceIndexTypeUint8FeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_index_type_uint8) &&
                    !IsExtEnabled(device_extensions.vk_ext_index_type_uint8)) {
                    skip |= LogError(
                        pnext_vuid, instance, pNext_loc,
                        "includes a pointer to a VkPhysicalDeviceIndexTypeUint8FeaturesKHR, but when creating VkDevice, the parent "
                        "extension "
                        "(VK_KHR_index_type_uint8 or VK_EXT_index_type_uint8) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceIndexTypeUint8FeaturesKHR* structure = (VkPhysicalDeviceIndexTypeUint8FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::indexTypeUint8), structure->indexTypeUint8);
            }
        } break;

        // Validation code for VkPhysicalDeviceLineRasterizationFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceLineRasterizationFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_line_rasterization) &&
                    !IsExtEnabled(device_extensions.vk_ext_line_rasterization)) {
                    skip |= LogError(
                        pnext_vuid, instance, pNext_loc,
                        "includes a pointer to a VkPhysicalDeviceLineRasterizationFeaturesKHR, but when creating VkDevice, the "
                        "parent extension "
                        "(VK_KHR_line_rasterization or VK_EXT_line_rasterization) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceLineRasterizationFeaturesKHR* structure = (VkPhysicalDeviceLineRasterizationFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rectangularLines), structure->rectangularLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::bresenhamLines), structure->bresenhamLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::smoothLines), structure->smoothLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledRectangularLines), structure->stippledRectangularLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledBresenhamLines), structure->stippledBresenhamLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledSmoothLines), structure->stippledSmoothLines);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderExpectAssumeFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceShaderExpectAssumeFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderExpectAssumeFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_expect_assume)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderExpectAssumeFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_shader_expect_assume) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderExpectAssumeFeaturesKHR* structure = (VkPhysicalDeviceShaderExpectAssumeFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderExpectAssume), structure->shaderExpectAssume);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance6FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR: {  // Covers
                                                                              // VUID-VkPhysicalDeviceMaintenance6FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance6FeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance6)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMaintenance6FeaturesKHR, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_maintenance6) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMaintenance6FeaturesKHR* structure = (VkPhysicalDeviceMaintenance6FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance6), structure->maintenance6);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR: {  // Covers
                                                                                                    // VUID-VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_shader_relaxed_extended_instruction)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, but "
                                     "when creating VkDevice, the parent extension "
                                     "(VK_KHR_shader_relaxed_extended_instruction) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* structure =
                    (VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderRelaxedExtendedInstruction),
                                       structure->shaderRelaxedExtendedInstruction);
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance7FeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR: {  // Covers
                                                                              // VUID-VkPhysicalDeviceMaintenance7FeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMaintenance7FeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance7)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMaintenance7FeaturesKHR, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_KHR_maintenance7) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMaintenance7FeaturesKHR* structure = (VkPhysicalDeviceMaintenance7FeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::maintenance7), structure->maintenance7);
            }
        } break;

        // Validation code for VkPhysicalDeviceTransformFeedbackFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceTransformFeedbackFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTransformFeedbackFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceTransformFeedbackFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_transform_feedback) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceTransformFeedbackFeaturesEXT* structure = (VkPhysicalDeviceTransformFeedbackFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::transformFeedback), structure->transformFeedback);

                skip |= ValidateBool32(pNext_loc.dot(Field::geometryStreams), structure->geometryStreams);
            }
        } break;

        // Validation code for VkPhysicalDeviceCornerSampledImageFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCornerSampledImageFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCornerSampledImageFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_corner_sampled_image)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCornerSampledImageFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_corner_sampled_image) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCornerSampledImageFeaturesNV* structure = (VkPhysicalDeviceCornerSampledImageFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cornerSampledImage), structure->cornerSampledImage);
            }
        } break;

        // Validation code for VkPhysicalDeviceASTCDecodeFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: {  // Covers
                                                                            // VUID-VkPhysicalDeviceASTCDecodeFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceASTCDecodeFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_astc_decode_mode)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceASTCDecodeFeaturesEXT, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_astc_decode_mode) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceASTCDecodeFeaturesEXT* structure = (VkPhysicalDeviceASTCDecodeFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::decodeModeSharedExponent), structure->decodeModeSharedExponent);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineRobustnessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDevicePipelineRobustnessFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineRobustnessFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_robustness)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelineRobustnessFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_pipeline_robustness) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelineRobustnessFeaturesEXT* structure = (VkPhysicalDevicePipelineRobustnessFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineRobustness), structure->pipelineRobustness);
            }
        } break;

        // Validation code for VkPhysicalDeviceConditionalRenderingFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceConditionalRenderingFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceConditionalRenderingFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_conditional_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceConditionalRenderingFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_conditional_rendering) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceConditionalRenderingFeaturesEXT* structure =
                    (VkPhysicalDeviceConditionalRenderingFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::conditionalRendering), structure->conditionalRendering);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::inheritedConditionalRendering), structure->inheritedConditionalRendering);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClipEnableFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDepthClipEnableFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClipEnableFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clip_enable)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDepthClipEnableFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_depth_clip_enable) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDepthClipEnableFeaturesEXT* structure = (VkPhysicalDeviceDepthClipEnableFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClipEnable), structure->depthClipEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG);
                if (!IsExtEnabled(device_extensions.vk_img_relaxed_line_rasterization)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_IMG_relaxed_line_rasterization) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* structure =
                    (VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::relaxedLineRasterization), structure->relaxedLineRasterization);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceShaderEnqueueFeaturesAMDX structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX: {  // Covers
                                                                                // VUID-VkPhysicalDeviceShaderEnqueueFeaturesAMDX-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderEnqueueFeaturesAMDX);
                if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderEnqueueFeaturesAMDX, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_AMDX_shader_enqueue) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderEnqueueFeaturesAMDX* structure = (VkPhysicalDeviceShaderEnqueueFeaturesAMDX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderEnqueue), structure->shaderEnqueue);
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_blend_operation_advanced)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_blend_operation_advanced) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structure =
                    (VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::advancedBlendCoherentOperations),
                                       structure->advancedBlendCoherentOperations);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceShaderSMBuiltinsFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_shader_sm_builtins)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_shader_sm_builtins) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* structure = (VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSMBuiltins), structure->shaderSMBuiltins);
            }
        } break;

        // Validation code for VkPhysicalDeviceShadingRateImageFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceShadingRateImageFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShadingRateImageFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShadingRateImageFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_shading_rate_image) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShadingRateImageFeaturesNV* structure = (VkPhysicalDeviceShadingRateImageFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shadingRateImage), structure->shadingRateImage);

                skip |= ValidateBool32(pNext_loc.dot(Field::shadingRateCoarseSampleOrder), structure->shadingRateCoarseSampleOrder);
            }
        } break;

        // Validation code for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_representative_fragment_test)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_representative_fragment_test) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* structure =
                    (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::representativeFragmentTest), structure->representativeFragmentTest);
            }
        } break;

        // Validation code for VkPhysicalDeviceMeshShaderFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: {  // Covers
                                                                           // VUID-VkPhysicalDeviceMeshShaderFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMeshShaderFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMeshShaderFeaturesNV, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_NV_mesh_shader) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMeshShaderFeaturesNV* structure = (VkPhysicalDeviceMeshShaderFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::taskShader), structure->taskShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::meshShader), structure->meshShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderImageFootprintFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceShaderImageFootprintFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderImageFootprintFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_shader_image_footprint)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderImageFootprintFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_shader_image_footprint) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderImageFootprintFeaturesNV* structure = (VkPhysicalDeviceShaderImageFootprintFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageFootprint), structure->imageFootprint);
            }
        } break;

        // Validation code for VkPhysicalDeviceExclusiveScissorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceExclusiveScissorFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExclusiveScissorFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_scissor_exclusive)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExclusiveScissorFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_scissor_exclusive) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExclusiveScissorFeaturesNV* structure = (VkPhysicalDeviceExclusiveScissorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::exclusiveScissor), structure->exclusiveScissor);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
                if (!IsExtEnabled(device_extensions.vk_intel_shader_integer_functions2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_INTEL_shader_integer_functions2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* structure =
                    (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderIntegerFunctions2), structure->shaderIntegerFunctions2);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceFragmentDensityMapFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_fragment_density_map)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentDensityMapFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_fragment_density_map) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentDensityMapFeaturesEXT* structure = (VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMap), structure->fragmentDensityMap);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapDynamic), structure->fragmentDensityMapDynamic);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapNonSubsampledImages),
                                       structure->fragmentDensityMapNonSubsampledImages);
            }
        } break;

        // Validation code for VkPhysicalDeviceCoherentMemoryFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: {  // Covers
                                                                                // VUID-VkPhysicalDeviceCoherentMemoryFeaturesAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCoherentMemoryFeaturesAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_device_coherent_memory)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCoherentMemoryFeaturesAMD, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_AMD_device_coherent_memory) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCoherentMemoryFeaturesAMD* structure = (VkPhysicalDeviceCoherentMemoryFeaturesAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceCoherentMemory), structure->deviceCoherentMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_image_atomic_int64)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_shader_image_atomic_int64) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* structure =
                    (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderImageInt64Atomics), structure->shaderImageInt64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseImageInt64Atomics), structure->sparseImageInt64Atomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceMemoryPriorityFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: {  // Covers
                                                                                // VUID-VkPhysicalDeviceMemoryPriorityFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMemoryPriorityFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_memory_priority)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMemoryPriorityFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_memory_priority) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMemoryPriorityFeaturesEXT* structure = (VkPhysicalDeviceMemoryPriorityFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::memoryPriority), structure->memoryPriority);
            }
        } break;

        // Validation code for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV: {  // Covers
                                                                                                   // VUID-VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_dedicated_allocation_image_aliasing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_dedicated_allocation_image_aliasing) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* structure =
                    (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dedicatedAllocationImageAliasing),
                                       structure->dedicatedAllocationImageAliasing);
            }
        } break;

        // Validation code for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceBufferDeviceAddressFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_buffer_device_address)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_buffer_device_address) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* structure = (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddress), structure->bufferDeviceAddress);

                skip |= ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressCaptureReplay),
                                       structure->bufferDeviceAddressCaptureReplay);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::bufferDeviceAddressMultiDevice), structure->bufferDeviceAddressMultiDevice);
            }
        } break;

        // Validation code for VkPhysicalDeviceCooperativeMatrixFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceCooperativeMatrixFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCooperativeMatrixFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_cooperative_matrix)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCooperativeMatrixFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_cooperative_matrix) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCooperativeMatrixFeaturesNV* structure = (VkPhysicalDeviceCooperativeMatrixFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrix), structure->cooperativeMatrix);

                skip |= ValidateBool32(pNext_loc.dot(Field::cooperativeMatrixRobustBufferAccess),
                                       structure->cooperativeMatrixRobustBufferAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceCoverageReductionModeFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceCoverageReductionModeFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCoverageReductionModeFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_coverage_reduction_mode)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCoverageReductionModeFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_coverage_reduction_mode) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCoverageReductionModeFeaturesNV* structure =
                    (VkPhysicalDeviceCoverageReductionModeFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::coverageReductionMode), structure->coverageReductionMode);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_fragment_shader_interlock)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_fragment_shader_interlock) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* structure =
                    (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::fragmentShaderSampleInterlock), structure->fragmentShaderSampleInterlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShaderPixelInterlock), structure->fragmentShaderPixelInterlock);

                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShaderShadingRateInterlock),
                                       structure->fragmentShaderShadingRateInterlock);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceYcbcrImageArraysFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_ycbcr_image_arrays)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_ycbcr_image_arrays) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* structure = (VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::ycbcrImageArrays), structure->ycbcrImageArrays);
            }
        } break;

        // Validation code for VkPhysicalDeviceProvokingVertexFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceProvokingVertexFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceProvokingVertexFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_provoking_vertex)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceProvokingVertexFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_provoking_vertex) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceProvokingVertexFeaturesEXT* structure = (VkPhysicalDeviceProvokingVertexFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::provokingVertexLast), structure->provokingVertexLast);

                skip |= ValidateBool32(pNext_loc.dot(Field::transformFeedbackPreservesProvokingVertex),
                                       structure->transformFeedbackPreservesProvokingVertex);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceShaderAtomicFloatFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicFloatFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_atomic_float)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_shader_atomic_float) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* structure = (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat32Atomics), structure->shaderBufferFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat32AtomicAdd), structure->shaderBufferFloat32AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat64Atomics), structure->shaderBufferFloat64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat64AtomicAdd), structure->shaderBufferFloat64AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat32Atomics), structure->shaderSharedFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat32AtomicAdd), structure->shaderSharedFloat32AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat64Atomics), structure->shaderSharedFloat64Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat64AtomicAdd), structure->shaderSharedFloat64AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderImageFloat32Atomics), structure->shaderImageFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderImageFloat32AtomicAdd), structure->shaderImageFloat32AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseImageFloat32Atomics), structure->sparseImageFloat32Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseImageFloat32AtomicAdd), structure->sparseImageFloat32AtomicAdd);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceExtendedDynamicStateFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicStateFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_extended_dynamic_state) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState), structure->extendedDynamicState);
            }
        } break;

        // Validation code for VkPhysicalDeviceHostImageCopyFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT: {  // Covers
                                                                                // VUID-VkPhysicalDeviceHostImageCopyFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceHostImageCopyFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceHostImageCopyFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_host_image_copy) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceHostImageCopyFeaturesEXT* structure = (VkPhysicalDeviceHostImageCopyFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::hostImageCopy), structure->hostImageCopy);
            }
        } break;

        // Validation code for VkPhysicalDeviceMapMemoryPlacedFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceMapMemoryPlacedFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMapMemoryPlacedFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_map_memory_placed)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_map_memory_placed) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* structure = (VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::memoryMapPlaced), structure->memoryMapPlaced);

                skip |= ValidateBool32(pNext_loc.dot(Field::memoryMapRangePlaced), structure->memoryMapRangePlaced);

                skip |= ValidateBool32(pNext_loc.dot(Field::memoryUnmapReserve), structure->memoryUnmapReserve);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_atomic_float2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_shader_atomic_float2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* structure = (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat16Atomics), structure->shaderBufferFloat16Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat16AtomicAdd), structure->shaderBufferFloat16AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat16AtomicMinMax),
                                       structure->shaderBufferFloat16AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat32AtomicMinMax),
                                       structure->shaderBufferFloat32AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderBufferFloat64AtomicMinMax),
                                       structure->shaderBufferFloat64AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat16Atomics), structure->shaderSharedFloat16Atomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat16AtomicAdd), structure->shaderSharedFloat16AtomicAdd);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat16AtomicMinMax),
                                       structure->shaderSharedFloat16AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat32AtomicMinMax),
                                       structure->shaderSharedFloat32AtomicMinMax);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSharedFloat64AtomicMinMax),
                                       structure->shaderSharedFloat64AtomicMinMax);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderImageFloat32AtomicMinMax), structure->shaderImageFloat32AtomicMinMax);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::sparseImageFloat32AtomicMinMax), structure->sparseImageFloat32AtomicMinMax);
            }
        } break;

        // Validation code for VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_swapchain_maintenance1) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* structure =
                    (VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::swapchainMaintenance1), structure->swapchainMaintenance1);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_device_generated_commands) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* structure =
                    (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedCommands), structure->deviceGeneratedCommands);
            }
        } break;

        // Validation code for VkPhysicalDeviceInheritedViewportScissorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceInheritedViewportScissorFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceInheritedViewportScissorFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_inherited_viewport_scissor)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceInheritedViewportScissorFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_inherited_viewport_scissor) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceInheritedViewportScissorFeaturesNV* structure =
                    (VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::inheritedViewportScissor2D), structure->inheritedViewportScissor2D);
            }
        } break;

        // Validation code for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_texel_buffer_alignment)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_texel_buffer_alignment) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* structure =
                    (VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::texelBufferAlignment), structure->texelBufferAlignment);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthBiasControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceDepthBiasControlFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthBiasControlFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_bias_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDepthBiasControlFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_depth_bias_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDepthBiasControlFeaturesEXT* structure = (VkPhysicalDeviceDepthBiasControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasControl), structure->depthBiasControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::leastRepresentableValueForceUnormRepresentation),
                                       structure->leastRepresentableValueForceUnormRepresentation);

                skip |= ValidateBool32(pNext_loc.dot(Field::floatRepresentation), structure->floatRepresentation);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasExact), structure->depthBiasExact);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceDeviceMemoryReportFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDeviceMemoryReportFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_memory_report)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_device_memory_report) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* structure = (VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceMemoryReport), structure->deviceMemoryReport);
            }
        } break;

        // Validation code for VkPhysicalDeviceRobustness2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: {  // Covers
                                                                             // VUID-VkPhysicalDeviceRobustness2FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRobustness2FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_robustness2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRobustness2FeaturesEXT, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_robustness2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRobustness2FeaturesEXT* structure = (VkPhysicalDeviceRobustness2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustBufferAccess2), structure->robustBufferAccess2);

                skip |= ValidateBool32(pNext_loc.dot(Field::robustImageAccess2), structure->robustImageAccess2);

                skip |= ValidateBool32(pNext_loc.dot(Field::nullDescriptor), structure->nullDescriptor);
            }
        } break;

        // Validation code for VkPhysicalDeviceCustomBorderColorFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCustomBorderColorFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCustomBorderColorFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_custom_border_color)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCustomBorderColorFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_custom_border_color) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCustomBorderColorFeaturesEXT* structure = (VkPhysicalDeviceCustomBorderColorFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::customBorderColors), structure->customBorderColors);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::customBorderColorWithoutFormat), structure->customBorderColorWithoutFormat);
            }
        } break;

        // Validation code for VkPhysicalDevicePresentBarrierFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: {  // Covers
                                                                               // VUID-VkPhysicalDevicePresentBarrierFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePresentBarrierFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_present_barrier)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePresentBarrierFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_present_barrier) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePresentBarrierFeaturesNV* structure = (VkPhysicalDevicePresentBarrierFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentBarrier), structure->presentBarrier);
            }
        } break;

        // Validation code for VkPhysicalDeviceDiagnosticsConfigFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDiagnosticsConfigFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDiagnosticsConfigFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_device_diagnostics_config)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDiagnosticsConfigFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_device_diagnostics_config) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDiagnosticsConfigFeaturesNV* structure = (VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::diagnosticsConfig), structure->diagnosticsConfig);
            }
        } break;

        // Validation code for VkPhysicalDeviceCudaKernelLaunchFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceCudaKernelLaunchFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCudaKernelLaunchFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCudaKernelLaunchFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_cuda_kernel_launch) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCudaKernelLaunchFeaturesNV* structure = (VkPhysicalDeviceCudaKernelLaunchFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cudaKernelLaunchFeatures), structure->cudaKernelLaunchFeatures);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorBufferFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDescriptorBufferFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDescriptorBufferFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDescriptorBufferFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_descriptor_buffer) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDescriptorBufferFeaturesEXT* structure = (VkPhysicalDeviceDescriptorBufferFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBuffer), structure->descriptorBuffer);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::descriptorBufferCaptureReplay), structure->descriptorBufferCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBufferImageLayoutIgnored),
                                       structure->descriptorBufferImageLayoutIgnored);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBufferPushDescriptors),
                                       structure->descriptorBufferPushDescriptors);
            }
        } break;

        // Validation code for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_graphics_pipeline_library)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_graphics_pipeline_library) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* structure =
                    (VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::graphicsPipelineLibrary), structure->graphicsPipelineLibrary);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD: {  // Covers
                                                                                                     // VUID-VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_shader_early_and_late_fragment_tests)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_AMD_shader_early_and_late_fragment_tests) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* structure =
                    (VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderEarlyAndLateFragmentTests),
                                       structure->shaderEarlyAndLateFragmentTests);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_fragment_shading_rate_enums)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_fragment_shading_rate_enums) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* structure =
                    (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentShadingRateEnums), structure->fragmentShadingRateEnums);

                skip |= ValidateBool32(pNext_loc.dot(Field::supersampleFragmentShadingRates),
                                       structure->supersampleFragmentShadingRates);

                skip |= ValidateBool32(pNext_loc.dot(Field::noInvocationFragmentShadingRates),
                                       structure->noInvocationFragmentShadingRates);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceRayTracingMotionBlurFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingMotionBlurFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing_motion_blur)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_ray_tracing_motion_blur) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* structure = (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingMotionBlur), structure->rayTracingMotionBlur);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingMotionBlurPipelineTraceRaysIndirect),
                                       structure->rayTracingMotionBlurPipelineTraceRaysIndirect);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_ycbcr_2plane_444_formats)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_ycbcr_2plane_444_formats) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* structure =
                    (VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::ycbcr2plane444Formats), structure->ycbcr2plane444Formats);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceFragmentDensityMap2FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentDensityMap2FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_fragment_density_map2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_fragment_density_map2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* structure = (VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapDeferred), structure->fragmentDensityMapDeferred);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageCompressionControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceImageCompressionControlFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageCompressionControlFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_compression_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageCompressionControlFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_image_compression_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageCompressionControlFeaturesEXT* structure =
                    (VkPhysicalDeviceImageCompressionControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageCompressionControl), structure->imageCompressionControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT: {  // Covers
                                                                                                // VUID-VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_attachment_feedback_loop_layout)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_attachment_feedback_loop_layout) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* structure =
                    (VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::attachmentFeedbackLoopLayout), structure->attachmentFeedbackLoopLayout);
            }
        } break;

        // Validation code for VkPhysicalDevice4444FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: {  // Covers
                                                                             // VUID-VkPhysicalDevice4444FormatsFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevice4444FormatsFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_4444_formats)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevice4444FormatsFeaturesEXT, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_4444_formats) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevice4444FormatsFeaturesEXT* structure = (VkPhysicalDevice4444FormatsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::formatA4R4G4B4), structure->formatA4R4G4B4);

                skip |= ValidateBool32(pNext_loc.dot(Field::formatA4B4G4R4), structure->formatA4B4G4R4);
            }
        } break;

        // Validation code for VkPhysicalDeviceFaultFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: {  // Covers VUID-VkPhysicalDeviceFaultFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFaultFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_fault)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFaultFeaturesEXT, but when creating VkDevice, the "
                                     "parent extension "
                                     "(VK_EXT_device_fault) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFaultFeaturesEXT* structure = (VkPhysicalDeviceFaultFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceFault), structure->deviceFault);

                skip |= ValidateBool32(pNext_loc.dot(Field::deviceFaultVendorBinary), structure->deviceFaultVendorBinary);
            }
        } break;

        // Validation code for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT: {  // Covers
                                                                                                      // VUID-VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_arm_rasterization_order_attachment_access) &&
                    !IsExtEnabled(device_extensions.vk_ext_rasterization_order_attachment_access)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, but "
                                     "when creating VkDevice, the parent extension "
                                     "(VK_ARM_rasterization_order_attachment_access or "
                                     "VK_EXT_rasterization_order_attachment_access) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* structure =
                    (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rasterizationOrderColorAttachmentAccess),
                                       structure->rasterizationOrderColorAttachmentAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::rasterizationOrderDepthAttachmentAccess),
                                       structure->rasterizationOrderDepthAttachmentAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::rasterizationOrderStencilAttachmentAccess),
                                       structure->rasterizationOrderStencilAttachmentAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_rgba10x6_formats)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_rgba10x6_formats) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* structure = (VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::formatRgba10x6WithoutYCbCrSampler),
                                       structure->formatRgba10x6WithoutYCbCrSampler);
            }
        } break;

        // Validation code for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_valve_mutable_descriptor_type) &&
                    !IsExtEnabled(device_extensions.vk_ext_mutable_descriptor_type)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_VALVE_mutable_descriptor_type or VK_EXT_mutable_descriptor_type) was not included in "
                                     "ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* structure =
                    (VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::mutableDescriptorType), structure->mutableDescriptorType);
            }
        } break;

        // Validation code for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_vertex_input_dynamic_state)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_vertex_input_dynamic_state) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* structure =
                    (VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::vertexInputDynamicState), structure->vertexInputDynamicState);
            }
        } break;

        // Validation code for VkPhysicalDeviceAddressBindingReportFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceAddressBindingReportFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAddressBindingReportFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_address_binding_report)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceAddressBindingReportFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_device_address_binding_report) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceAddressBindingReportFeaturesEXT* structure =
                    (VkPhysicalDeviceAddressBindingReportFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::reportAddressBinding), structure->reportAddressBinding);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClipControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceDepthClipControlFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClipControlFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clip_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDepthClipControlFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_depth_clip_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDepthClipControlFeaturesEXT* structure = (VkPhysicalDeviceDepthClipControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClipControl), structure->depthClipControl);
            }
        } break;

        // Validation code for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT: {  // Covers
                                                                                                // VUID-VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_primitive_topology_list_restart)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_primitive_topology_list_restart) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* structure =
                    (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveTopologyListRestart), structure->primitiveTopologyListRestart);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveTopologyPatchListRestart),
                                       structure->primitiveTopologyPatchListRestart);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceSubpassShadingFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSubpassShadingFeaturesHUAWEI);
                if (!IsExtEnabled(device_extensions.vk_huawei_subpass_shading)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_HUAWEI_subpass_shading) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* structure = (VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::subpassShading), structure->subpassShading);
            }
        } break;

        // Validation code for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceInvocationMaskFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceInvocationMaskFeaturesHUAWEI);
                if (!IsExtEnabled(device_extensions.vk_huawei_invocation_mask)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_HUAWEI_invocation_mask) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* structure = (VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::invocationMask), structure->invocationMask);
            }
        } break;

        // Validation code for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceExternalMemoryRDMAFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExternalMemoryRDMAFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_external_memory_rdma)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_external_memory_rdma) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* structure = (VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::externalMemoryRDMA), structure->externalMemoryRDMA);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelinePropertiesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDevicePipelinePropertiesFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelinePropertiesFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_properties)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelinePropertiesFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_pipeline_properties) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelinePropertiesFeaturesEXT* structure = (VkPhysicalDevicePipelinePropertiesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelinePropertiesIdentifier), structure->pipelinePropertiesIdentifier);
            }
        } break;

        // Validation code for VkPhysicalDeviceFrameBoundaryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT: {  // Covers
                                                                               // VUID-VkPhysicalDeviceFrameBoundaryFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFrameBoundaryFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_frame_boundary)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFrameBoundaryFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_frame_boundary) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFrameBoundaryFeaturesEXT* structure = (VkPhysicalDeviceFrameBoundaryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::frameBoundary), structure->frameBoundary);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT: {  // Covers
                                                                                                      // VUID-VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_multisampled_render_to_single_sampled)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, but "
                                     "when creating VkDevice, the parent extension "
                                     "(VK_EXT_multisampled_render_to_single_sampled) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* structure =
                    (VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multisampledRenderToSingleSampled),
                                       structure->multisampledRenderToSingleSampled);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceExtendedDynamicState2FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicState2FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_extended_dynamic_state2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState2), structure->extendedDynamicState2);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState2LogicOp), structure->extendedDynamicState2LogicOp);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState2PatchControlPoints),
                                       structure->extendedDynamicState2PatchControlPoints);
            }
        } break;

        // Validation code for VkPhysicalDeviceColorWriteEnableFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceColorWriteEnableFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceColorWriteEnableFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_color_write_enable)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceColorWriteEnableFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_color_write_enable) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceColorWriteEnableFeaturesEXT* structure = (VkPhysicalDeviceColorWriteEnableFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::colorWriteEnable), structure->colorWriteEnable);
            }
        } break;

        // Validation code for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT: {  // Covers
                                                                                           // VUID-VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_primitives_generated_query)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_primitives_generated_query) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* structure =
                    (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::primitivesGeneratedQuery), structure->primitivesGeneratedQuery);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitivesGeneratedQueryWithRasterizerDiscard),
                                       structure->primitivesGeneratedQueryWithRasterizerDiscard);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitivesGeneratedQueryWithNonZeroStreams),
                                       structure->primitivesGeneratedQueryWithNonZeroStreams);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageViewMinLodFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceImageViewMinLodFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageViewMinLodFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_view_min_lod)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageViewMinLodFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_image_view_min_lod) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageViewMinLodFeaturesEXT* structure = (VkPhysicalDeviceImageViewMinLodFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::minLod), structure->minLod);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiDrawFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: {  // Covers
                                                                           // VUID-VkPhysicalDeviceMultiDrawFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMultiDrawFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_multi_draw)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMultiDrawFeaturesEXT, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_multi_draw) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMultiDrawFeaturesEXT* structure = (VkPhysicalDeviceMultiDrawFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiDraw), structure->multiDraw);
            }
        } break;

        // Validation code for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceImage2DViewOf3DFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImage2DViewOf3DFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_2d_view_of_3d)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_image_2d_view_of_3d) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* structure = (VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::image2DViewOf3D), structure->image2DViewOf3D);

                skip |= ValidateBool32(pNext_loc.dot(Field::sampler2DViewOf3D), structure->sampler2DViewOf3D);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderTileImageFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceShaderTileImageFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderTileImageFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_tile_image)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderTileImageFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_shader_tile_image) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderTileImageFeaturesEXT* structure = (VkPhysicalDeviceShaderTileImageFeaturesEXT*)header;
                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderTileImageColorReadAccess), structure->shaderTileImageColorReadAccess);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderTileImageDepthReadAccess), structure->shaderTileImageDepthReadAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTileImageStencilReadAccess),
                                       structure->shaderTileImageStencilReadAccess);
            }
        } break;

        // Validation code for VkPhysicalDeviceOpacityMicromapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceOpacityMicromapFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceOpacityMicromapFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceOpacityMicromapFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_opacity_micromap) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceOpacityMicromapFeaturesEXT* structure = (VkPhysicalDeviceOpacityMicromapFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::micromap), structure->micromap);

                skip |= ValidateBool32(pNext_loc.dot(Field::micromapCaptureReplay), structure->micromapCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::micromapHostCommands), structure->micromapHostCommands);
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceDisplacementMicromapFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceDisplacementMicromapFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDisplacementMicromapFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_displacement_micromap)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDisplacementMicromapFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_displacement_micromap) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDisplacementMicromapFeaturesNV* structure = (VkPhysicalDeviceDisplacementMicromapFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::displacementMicromap), structure->displacementMicromap);
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI);
                if (!IsExtEnabled(device_extensions.vk_huawei_cluster_culling_shader)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_HUAWEI_cluster_culling_shader) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* structure =
                    (VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::clustercullingShader), structure->clustercullingShader);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::multiviewClusterCullingShader), structure->multiviewClusterCullingShader);
            }
        } break;

        // Validation code for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceBorderColorSwizzleFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceBorderColorSwizzleFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_border_color_swizzle)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_border_color_swizzle) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* structure = (VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::borderColorSwizzle), structure->borderColorSwizzle);

                skip |= ValidateBool32(pNext_loc.dot(Field::borderColorSwizzleFromImage), structure->borderColorSwizzleFromImage);
            }
        } break;

        // Validation code for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT: {  // Covers
                                                                                             // VUID-VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_pageable_device_local_memory)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_pageable_device_local_memory) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* structure =
                    (VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pageableDeviceLocalMemory), structure->pageableDeviceLocalMemory);
            }
        } break;

        // Validation code for VkPhysicalDeviceSchedulingControlsFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceSchedulingControlsFeaturesARM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSchedulingControlsFeaturesARM);
                if (!IsExtEnabled(device_extensions.vk_arm_scheduling_controls)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSchedulingControlsFeaturesARM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_ARM_scheduling_controls) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSchedulingControlsFeaturesARM* structure = (VkPhysicalDeviceSchedulingControlsFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::schedulingControls), structure->schedulingControls);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT: {  // Covers
                                                                                        // VUID-VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_sliced_view_of_3d)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_image_sliced_view_of_3d) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* structure = (VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageSlicedViewOf3D), structure->imageSlicedViewOf3D);
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE);
                if (!IsExtEnabled(device_extensions.vk_valve_descriptor_set_host_mapping)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_VALVE_descriptor_set_host_mapping) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* structure =
                    (VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorSetHostMapping), structure->descriptorSetHostMapping);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClampZeroOneFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceDepthClampZeroOneFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClampZeroOneFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clamp_zero_one)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_depth_clamp_zero_one) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* structure = (VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClampZeroOne), structure->depthClampZeroOne);
            }
        } break;

        // Validation code for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_non_seamless_cube_map)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_non_seamless_cube_map) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* structure = (VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::nonSeamlessCubeMap), structure->nonSeamlessCubeMap);
            }
        } break;

        // Validation code for VkPhysicalDeviceRenderPassStripedFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceRenderPassStripedFeaturesARM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRenderPassStripedFeaturesARM);
                if (!IsExtEnabled(device_extensions.vk_arm_render_pass_striped)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRenderPassStripedFeaturesARM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_ARM_render_pass_striped) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRenderPassStripedFeaturesARM* structure = (VkPhysicalDeviceRenderPassStripedFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::renderPassStriped), structure->renderPassStriped);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_fragment_density_map_offset)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_QCOM_fragment_density_map_offset) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* structure =
                    (VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::fragmentDensityMapOffset), structure->fragmentDensityMapOffset);
            }
        } break;

        // Validation code for VkPhysicalDeviceCopyMemoryIndirectFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceCopyMemoryIndirectFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCopyMemoryIndirectFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_copy_memory_indirect)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_copy_memory_indirect) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* structure = (VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::indirectCopy), structure->indirectCopy);
            }
        } break;

        // Validation code for VkPhysicalDeviceMemoryDecompressionFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceMemoryDecompressionFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMemoryDecompressionFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_memory_decompression)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMemoryDecompressionFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_memory_decompression) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMemoryDecompressionFeaturesNV* structure = (VkPhysicalDeviceMemoryDecompressionFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::memoryDecompression), structure->memoryDecompression);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV: {  // Covers
                                                                                                 // VUID-VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_device_generated_commands_compute) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* structure =
                    (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedCompute), structure->deviceGeneratedCompute);

                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedComputePipelines),
                                       structure->deviceGeneratedComputePipelines);

                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedComputeCaptureReplay),
                                       structure->deviceGeneratedComputeCaptureReplay);
            }
        } break;

        // Validation code for VkPhysicalDeviceLinearColorAttachmentFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceLinearColorAttachmentFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLinearColorAttachmentFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_linear_color_attachment)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceLinearColorAttachmentFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_linear_color_attachment) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceLinearColorAttachmentFeaturesNV* structure =
                    (VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::linearColorAttachment), structure->linearColorAttachment);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT: {  // Covers
                                                                                                    // VUID-VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_compression_control_swapchain)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, but "
                                     "when creating VkDevice, the parent extension "
                                     "(VK_EXT_image_compression_control_swapchain) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* structure =
                    (VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageCompressionControlSwapchain),
                                       structure->imageCompressionControlSwapchain);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageProcessingFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceImageProcessingFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageProcessingFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_image_processing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageProcessingFeaturesQCOM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_QCOM_image_processing) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageProcessingFeaturesQCOM* structure = (VkPhysicalDeviceImageProcessingFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::textureSampleWeighted), structure->textureSampleWeighted);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureBoxFilter), structure->textureBoxFilter);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureBlockMatch), structure->textureBlockMatch);
            }
        } break;

        // Validation code for VkPhysicalDeviceNestedCommandBufferFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceNestedCommandBufferFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceNestedCommandBufferFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_nested_command_buffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceNestedCommandBufferFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_nested_command_buffer) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceNestedCommandBufferFeaturesEXT* structure = (VkPhysicalDeviceNestedCommandBufferFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::nestedCommandBuffer), structure->nestedCommandBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::nestedCommandBufferRendering), structure->nestedCommandBufferRendering);

                skip |= ValidateBool32(pNext_loc.dot(Field::nestedCommandBufferSimultaneousUse),
                                       structure->nestedCommandBufferSimultaneousUse);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceExtendedDynamicState3FeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicState3FeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_extended_dynamic_state3) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3TessellationDomainOrigin),
                                       structure->extendedDynamicState3TessellationDomainOrigin);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3DepthClampEnable),
                                       structure->extendedDynamicState3DepthClampEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3PolygonMode),
                                       structure->extendedDynamicState3PolygonMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3RasterizationSamples),
                                       structure->extendedDynamicState3RasterizationSamples);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3SampleMask),
                                       structure->extendedDynamicState3SampleMask);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3AlphaToCoverageEnable),
                                       structure->extendedDynamicState3AlphaToCoverageEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3AlphaToOneEnable),
                                       structure->extendedDynamicState3AlphaToOneEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3LogicOpEnable),
                                       structure->extendedDynamicState3LogicOpEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorBlendEnable),
                                       structure->extendedDynamicState3ColorBlendEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorBlendEquation),
                                       structure->extendedDynamicState3ColorBlendEquation);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorWriteMask),
                                       structure->extendedDynamicState3ColorWriteMask);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3RasterizationStream),
                                       structure->extendedDynamicState3RasterizationStream);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ConservativeRasterizationMode),
                                       structure->extendedDynamicState3ConservativeRasterizationMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ExtraPrimitiveOverestimationSize),
                                       structure->extendedDynamicState3ExtraPrimitiveOverestimationSize);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3DepthClipEnable),
                                       structure->extendedDynamicState3DepthClipEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3SampleLocationsEnable),
                                       structure->extendedDynamicState3SampleLocationsEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ColorBlendAdvanced),
                                       structure->extendedDynamicState3ColorBlendAdvanced);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ProvokingVertexMode),
                                       structure->extendedDynamicState3ProvokingVertexMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3LineRasterizationMode),
                                       structure->extendedDynamicState3LineRasterizationMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3LineStippleEnable),
                                       structure->extendedDynamicState3LineStippleEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3DepthClipNegativeOneToOne),
                                       structure->extendedDynamicState3DepthClipNegativeOneToOne);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ViewportWScalingEnable),
                                       structure->extendedDynamicState3ViewportWScalingEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ViewportSwizzle),
                                       structure->extendedDynamicState3ViewportSwizzle);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageToColorEnable),
                                       structure->extendedDynamicState3CoverageToColorEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageToColorLocation),
                                       structure->extendedDynamicState3CoverageToColorLocation);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageModulationMode),
                                       structure->extendedDynamicState3CoverageModulationMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageModulationTableEnable),
                                       structure->extendedDynamicState3CoverageModulationTableEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageModulationTable),
                                       structure->extendedDynamicState3CoverageModulationTable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3CoverageReductionMode),
                                       structure->extendedDynamicState3CoverageReductionMode);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3RepresentativeFragmentTestEnable),
                                       structure->extendedDynamicState3RepresentativeFragmentTestEnable);

                skip |= ValidateBool32(pNext_loc.dot(Field::extendedDynamicState3ShadingRateImageEnable),
                                       structure->extendedDynamicState3ShadingRateImageEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_subpass_merge_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_subpass_merge_feedback) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* structure =
                    (VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::subpassMergeFeedback), structure->subpassMergeFeedback);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_module_identifier)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_shader_module_identifier) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* structure =
                    (VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderModuleIdentifier), structure->shaderModuleIdentifier);
            }
        } break;

        // Validation code for VkPhysicalDeviceOpticalFlowFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: {  // Covers
                                                                            // VUID-VkPhysicalDeviceOpticalFlowFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceOpticalFlowFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_optical_flow)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceOpticalFlowFeaturesNV, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_NV_optical_flow) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceOpticalFlowFeaturesNV* structure = (VkPhysicalDeviceOpticalFlowFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::opticalFlow), structure->opticalFlow);
            }
        } break;

        // Validation code for VkPhysicalDeviceLegacyDitheringFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceLegacyDitheringFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLegacyDitheringFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_legacy_dithering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceLegacyDitheringFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_legacy_dithering) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceLegacyDitheringFeaturesEXT* structure = (VkPhysicalDeviceLegacyDitheringFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::legacyDithering), structure->legacyDithering);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineProtectedAccessFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDevicePipelineProtectedAccessFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineProtectedAccessFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_protected_access)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_pipeline_protected_access) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* structure =
                    (VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineProtectedAccess), structure->pipelineProtectedAccess);
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkPhysicalDeviceExternalFormatResolveFeaturesANDROID structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceExternalFormatResolveFeaturesANDROID-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExternalFormatResolveFeaturesANDROID);
                if (!IsExtEnabled(device_extensions.vk_android_external_format_resolve)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_ANDROID_external_format_resolve) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* structure =
                    (VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::externalFormatResolve), structure->externalFormatResolve);
            }
        } break;
#endif  // VK_USE_PLATFORM_ANDROID_KHR

        // Validation code for VkPhysicalDeviceAntiLagFeaturesAMD structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD: {  // Covers
                                                                         // VUID-VkPhysicalDeviceAntiLagFeaturesAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAntiLagFeaturesAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_anti_lag)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceAntiLagFeaturesAMD, but when creating VkDevice, the "
                                     "parent extension "
                                     "(VK_AMD_anti_lag) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceAntiLagFeaturesAMD* structure = (VkPhysicalDeviceAntiLagFeaturesAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::antiLag), structure->antiLag);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderObjectFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT: {  // Covers
                                                                              // VUID-VkPhysicalDeviceShaderObjectFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderObjectFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_object)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderObjectFeaturesEXT, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_shader_object) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderObjectFeaturesEXT* structure = (VkPhysicalDeviceShaderObjectFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderObject), structure->shaderObject);
            }
        } break;

        // Validation code for VkPhysicalDeviceTilePropertiesFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceTilePropertiesFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceTilePropertiesFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_tile_properties)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceTilePropertiesFeaturesQCOM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_QCOM_tile_properties) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceTilePropertiesFeaturesQCOM* structure = (VkPhysicalDeviceTilePropertiesFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::tileProperties), structure->tileProperties);
            }
        } break;

        // Validation code for VkPhysicalDeviceAmigoProfilingFeaturesSEC structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC: {  // Covers
                                                                                // VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAmigoProfilingFeaturesSEC);
                if (!IsExtEnabled(device_extensions.vk_sec_amigo_profiling)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceAmigoProfilingFeaturesSEC, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_SEC_amigo_profiling) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceAmigoProfilingFeaturesSEC* structure = (VkPhysicalDeviceAmigoProfilingFeaturesSEC*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::amigoProfiling), structure->amigoProfiling);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_multiview_per_view_viewports)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_QCOM_multiview_per_view_viewports) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* structure =
                    (VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewPerViewViewports), structure->multiviewPerViewViewports);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing_invocation_reorder)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_ray_tracing_invocation_reorder) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* structure =
                    (VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingInvocationReorder), structure->rayTracingInvocationReorder);
            }
        } break;

        // Validation code for VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_extended_sparse_address_space)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_extended_sparse_address_space) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* structure =
                    (VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::extendedSparseAddressSpace), structure->extendedSparseAddressSpace);
            }
        } break;

        // Validation code for VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_legacy_vertex_attributes)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_legacy_vertex_attributes) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* structure =
                    (VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::legacyVertexAttributes), structure->legacyVertexAttributes);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM);
                if (!IsExtEnabled(device_extensions.vk_arm_shader_core_builtins)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_ARM_shader_core_builtins) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* structure = (VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderCoreBuiltins), structure->shaderCoreBuiltins);
            }
        } break;

        // Validation code for VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT: {  // Covers
                                                                                               // VUID-VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_library_group_handles)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_pipeline_library_group_handles) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* structure =
                    (VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineLibraryGroupHandles), structure->pipelineLibraryGroupHandles);
            }
        } break;

        // Validation code for VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT: {  // Covers
                                                                                                     // VUID-VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_dynamic_rendering_unused_attachments)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, but "
                                     "when creating VkDevice, the parent extension "
                                     "(VK_EXT_dynamic_rendering_unused_attachments) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* structure =
                    (VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicRenderingUnusedAttachments),
                                       structure->dynamicRenderingUnusedAttachments);
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM: {  // Covers
                                                                                                 // VUID-VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_multiview_per_view_render_areas)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_QCOM_multiview_per_view_render_areas) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* structure =
                    (VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewPerViewRenderAreas), structure->multiviewPerViewRenderAreas);
            }
        } break;

        // Validation code for VkPhysicalDevicePerStageDescriptorSetFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV: {  // Covers
                                                                                        // VUID-VkPhysicalDevicePerStageDescriptorSetFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePerStageDescriptorSetFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_per_stage_descriptor_set)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDevicePerStageDescriptorSetFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_per_stage_descriptor_set) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDevicePerStageDescriptorSetFeaturesNV* structure =
                    (VkPhysicalDevicePerStageDescriptorSetFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::perStageDescriptorSet), structure->perStageDescriptorSet);

                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicPipelineLayout), structure->dynamicPipelineLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageProcessing2FeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceImageProcessing2FeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageProcessing2FeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_image_processing2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageProcessing2FeaturesQCOM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_QCOM_image_processing2) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageProcessing2FeaturesQCOM* structure = (VkPhysicalDeviceImageProcessing2FeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::textureBlockMatch2), structure->textureBlockMatch2);
            }
        } break;

        // Validation code for VkPhysicalDeviceCubicWeightsFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM: {  // Covers
                                                                               // VUID-VkPhysicalDeviceCubicWeightsFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCubicWeightsFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_filter_cubic_weights)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCubicWeightsFeaturesQCOM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_QCOM_filter_cubic_weights) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCubicWeightsFeaturesQCOM* structure = (VkPhysicalDeviceCubicWeightsFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::selectableCubicWeights), structure->selectableCubicWeights);
            }
        } break;

        // Validation code for VkPhysicalDeviceYcbcrDegammaFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM: {  // Covers
                                                                               // VUID-VkPhysicalDeviceYcbcrDegammaFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceYcbcrDegammaFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_ycbcr_degamma)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceYcbcrDegammaFeaturesQCOM, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_QCOM_ycbcr_degamma) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* structure = (VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::ycbcrDegamma), structure->ycbcrDegamma);
            }
        } break;

        // Validation code for VkPhysicalDeviceCubicClampFeaturesQCOM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM: {  // Covers
                                                                             // VUID-VkPhysicalDeviceCubicClampFeaturesQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCubicClampFeaturesQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_filter_cubic_clamp)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCubicClampFeaturesQCOM, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_QCOM_filter_cubic_clamp) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCubicClampFeaturesQCOM* structure = (VkPhysicalDeviceCubicClampFeaturesQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::cubicRangeClamp), structure->cubicRangeClamp);
            }
        } break;

        // Validation code for VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT: {  // Covers
                                                                                                       // VUID-VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_attachment_feedback_loop_dynamic_state)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc,
                                 "includes a pointer to a VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, but when "
                                 "creating VkDevice, the parent extension "
                                 "(VK_EXT_attachment_feedback_loop_dynamic_state) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* structure =
                    (VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::attachmentFeedbackLoopDynamicState),
                                       structure->attachmentFeedbackLoopDynamicState);
            }
        } break;
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX);
                if (!IsExtEnabled(device_extensions.vk_qnx_external_memory_screen_buffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_QNX_external_memory_screen_buffer) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX* structure =
                    (VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::screenBufferImport), structure->screenBufferImport);
            }
        } break;
#endif  // VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_descriptor_pool_overallocation)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_descriptor_pool_overallocation) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* structure =
                    (VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorPoolOverallocation), structure->descriptorPoolOverallocation);
            }
        } break;

        // Validation code for VkPhysicalDeviceRawAccessChainsFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceRawAccessChainsFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRawAccessChainsFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_raw_access_chains)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRawAccessChainsFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_raw_access_chains) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRawAccessChainsFeaturesNV* structure = (VkPhysicalDeviceRawAccessChainsFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderRawAccessChains), structure->shaderRawAccessChains);
            }
        } break;

        // Validation code for VkPhysicalDeviceCommandBufferInheritanceFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceCommandBufferInheritanceFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceCommandBufferInheritanceFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_command_buffer_inheritance)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceCommandBufferInheritanceFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_command_buffer_inheritance) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* structure =
                    (VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::commandBufferInheritance), structure->commandBufferInheritance);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_shader_atomic_float16_vector)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_NV_shader_atomic_float16_vector) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* structure =
                    (VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat16VectorAtomics), structure->shaderFloat16VectorAtomics);
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_replicated_composites)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_shader_replicated_composites) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* structure =
                    (VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shaderReplicatedComposites), structure->shaderReplicatedComposites);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingValidationFeaturesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceRayTracingValidationFeaturesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingValidationFeaturesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing_validation)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayTracingValidationFeaturesNV, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_NV_ray_tracing_validation) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayTracingValidationFeaturesNV* structure = (VkPhysicalDeviceRayTracingValidationFeaturesNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingValidation), structure->rayTracingValidation);
            }
        } break;

        // Validation code for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT: {  // Covers
                                                                                          // VUID-VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, but when "
                                     "creating VkDevice, the parent extension "
                                     "(VK_EXT_device_generated_commands) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* structure =
                    (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::deviceGeneratedCommands), structure->deviceGeneratedCommands);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::dynamicGeneratedPipelineLayout), structure->dynamicGeneratedPipelineLayout);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageAlignmentControlFeaturesMESA structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceImageAlignmentControlFeaturesMESA-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageAlignmentControlFeaturesMESA);
                if (!IsExtEnabled(device_extensions.vk_mesa_image_alignment_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceImageAlignmentControlFeaturesMESA, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_MESA_image_alignment_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceImageAlignmentControlFeaturesMESA* structure =
                    (VkPhysicalDeviceImageAlignmentControlFeaturesMESA*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::imageAlignmentControl), structure->imageAlignmentControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthClampControlFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceDepthClampControlFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceDepthClampControlFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clamp_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceDepthClampControlFeaturesEXT, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_EXT_depth_clamp_control) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceDepthClampControlFeaturesEXT* structure = (VkPhysicalDeviceDepthClampControlFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::depthClampControl), structure->depthClampControl);
            }
        } break;

        // Validation code for VkPhysicalDeviceAccelerationStructureFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: {  // Covers
                                                                                       // VUID-VkPhysicalDeviceAccelerationStructureFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceAccelerationStructureFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceAccelerationStructureFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_acceleration_structure) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceAccelerationStructureFeaturesKHR* structure =
                    (VkPhysicalDeviceAccelerationStructureFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructure), structure->accelerationStructure);

                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructureCaptureReplay),
                                       structure->accelerationStructureCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructureIndirectBuild),
                                       structure->accelerationStructureIndirectBuild);

                skip |= ValidateBool32(pNext_loc.dot(Field::accelerationStructureHostCommands),
                                       structure->accelerationStructureHostCommands);

                skip |= ValidateBool32(pNext_loc.dot(Field::descriptorBindingAccelerationStructureUpdateAfterBind),
                                       structure->descriptorBindingAccelerationStructureUpdateAfterBind);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayTracingPipelineFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayTracingPipelineFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayTracingPipelineFeaturesKHR, but when creating "
                                     "VkDevice, the parent extension "
                                     "(VK_KHR_ray_tracing_pipeline) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayTracingPipelineFeaturesKHR* structure = (VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipeline), structure->rayTracingPipeline);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineShaderGroupHandleCaptureReplay),
                                       structure->rayTracingPipelineShaderGroupHandleCaptureReplay);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineShaderGroupHandleCaptureReplayMixed),
                                       structure->rayTracingPipelineShaderGroupHandleCaptureReplayMixed);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTracingPipelineTraceRaysIndirect),
                                       structure->rayTracingPipelineTraceRaysIndirect);

                skip |= ValidateBool32(pNext_loc.dot(Field::rayTraversalPrimitiveCulling), structure->rayTraversalPrimitiveCulling);
            }
        } break;

        // Validation code for VkPhysicalDeviceRayQueryFeaturesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: {  // Covers
                                                                          // VUID-VkPhysicalDeviceRayQueryFeaturesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceRayQueryFeaturesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_ray_query)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceRayQueryFeaturesKHR, but when creating VkDevice, the "
                                     "parent extension "
                                     "(VK_KHR_ray_query) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceRayQueryFeaturesKHR* structure = (VkPhysicalDeviceRayQueryFeaturesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::rayQuery), structure->rayQuery);
            }
        } break;

        // Validation code for VkPhysicalDeviceMeshShaderFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: {  // Covers
                                                                            // VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceMeshShaderFeaturesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "includes a pointer to a VkPhysicalDeviceMeshShaderFeaturesEXT, but when creating VkDevice, "
                                     "the parent extension "
                                     "(VK_EXT_mesh_shader) was not included in ppEnabledExtensionNames.");
                }
                VkPhysicalDeviceMeshShaderFeaturesEXT* structure = (VkPhysicalDeviceMeshShaderFeaturesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::taskShader), structure->taskShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::meshShader), structure->meshShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiviewMeshShader), structure->multiviewMeshShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::primitiveFragmentShadingRateMeshShader),
                                       structure->primitiveFragmentShadingRateMeshShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::meshShaderQueries), structure->meshShaderQueries);
            }
        } break;

        default:
            skip = false;
    }
    return skip;
}

bool StatelessValidation::ValidatePnextPropertyStructContents(const Location& loc, const VkBaseOutStructure* header,
                                                              const char* pnext_vuid, const VkPhysicalDevice physicalDevice,
                                                              bool is_const_param) const {
    bool skip = false;
    const bool is_physdev_api = physicalDevice != VK_NULL_HANDLE;
    switch (header->sType) {
        // Validation code for VkPhysicalDeviceSubgroupProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: {  // Covers VUID-VkPhysicalDeviceSubgroupProperties-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_1) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |=
                        LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES) "
                                 "which was added in VK_API_VERSION_1_1 but the "
                                 "current effective API version is %s.",
                                 StringAPIVersion(device_api_version).c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDevicePointClippingProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: {  // Covers
                                                                             // VUID-VkPhysicalDevicePointClippingProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES), but its parent extension "
                                 "VK_KHR_maintenance2 has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceMultiviewProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: {  // Covers
                                                                        // VUID-VkPhysicalDeviceMultiviewProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_multiview)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_multiview))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES), but its parent extension "
                                 "VK_KHR_multiview has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceProtectedMemoryProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: {  // Covers
                                                                               // VUID-VkPhysicalDeviceProtectedMemoryProperties-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_1) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(
                        pnext_vuid, instance, loc.dot(Field::pNext),
                        "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES) "
                        "which was added in VK_API_VERSION_1_1 but the "
                        "current effective API version is %s.",
                        StringAPIVersion(device_api_version).c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceIDProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: {  // Covers VUID-VkPhysicalDeviceIDProperties-sType-sType

            if (!IsExtEnabled(instance_extensions.vk_khr_external_fence_capabilities) &&
                !IsExtEnabled(instance_extensions.vk_khr_external_memory_capabilities) &&
                !IsExtEnabled(instance_extensions.vk_khr_external_semaphore_capabilities)) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES), but "
                                 "its parent extension "
                                 "VK_KHR_external_fence_capabilities, VK_KHR_external_memory_capabilities, or "
                                 "VK_KHR_external_semaphore_capabilities has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance3Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: {  // Covers
                                                                            // VUID-VkPhysicalDeviceMaintenance3Properties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance3)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance3))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES), but its parent extension "
                                 "VK_KHR_maintenance3 has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan11Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: {  // Covers
                                                                         // VUID-VkPhysicalDeviceVulkan11Properties-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_2) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(
                        pnext_vuid, instance, loc.dot(Field::pNext),
                        "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES) which "
                        "was added in VK_API_VERSION_1_2 but the "
                        "current effective API version is %s.",
                        StringAPIVersion(device_api_version).c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan12Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: {  // Covers
                                                                         // VUID-VkPhysicalDeviceVulkan12Properties-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_2) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(
                        pnext_vuid, instance, loc.dot(Field::pNext),
                        "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES) which "
                        "was added in VK_API_VERSION_1_2 but the "
                        "current effective API version is %s.",
                        StringAPIVersion(device_api_version).c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceDriverProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: {  // Covers VUID-VkPhysicalDeviceDriverProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_driver_properties)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_driver_properties))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES), "
                                 "but its parent extension "
                                 "VK_KHR_driver_properties has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceFloatControlsProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: {  // Covers
                                                                             // VUID-VkPhysicalDeviceFloatControlsProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_float_controls)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_float_controls))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES), but its parent extension "
                                 "VK_KHR_shader_float_controls has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceDescriptorIndexingProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceDescriptorIndexingProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_descriptor_indexing)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES), but its parent extension "
                                 "VK_EXT_descriptor_indexing has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceDepthStencilResolveProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceDepthStencilResolveProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_depth_stencil_resolve)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_depth_stencil_resolve))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES), but its parent extension "
                                 "VK_KHR_depth_stencil_resolve has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceSamplerFilterMinmaxProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceSamplerFilterMinmaxProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_sampler_filter_minmax)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_sampler_filter_minmax))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES), but its parent extension "
                                 "VK_EXT_sampler_filter_minmax has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceTimelineSemaphoreProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: {  // Covers
                                                                                 // VUID-VkPhysicalDeviceTimelineSemaphoreProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_timeline_semaphore)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES), but its parent extension "
                                 "VK_KHR_timeline_semaphore has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceVulkan13Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: {  // Covers
                                                                         // VUID-VkPhysicalDeviceVulkan13Properties-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_3) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(
                        pnext_vuid, instance, loc.dot(Field::pNext),
                        "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES) which "
                        "was added in VK_API_VERSION_1_3 but the "
                        "current effective API version is %s.",
                        StringAPIVersion(device_api_version).c_str());
                }
            }
        } break;

        // Validation code for VkPhysicalDeviceSubgroupSizeControlProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceSubgroupSizeControlProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_subgroup_size_control)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_subgroup_size_control))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES), but its parent extension "
                                 "VK_EXT_subgroup_size_control has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceInlineUniformBlockProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceInlineUniformBlockProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_inline_uniform_block)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES), but its parent extension "
                                 "VK_EXT_inline_uniform_block has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceShaderIntegerDotProductProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: {  // Covers
                                                                                         // VUID-VkPhysicalDeviceShaderIntegerDotProductProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_shader_integer_dot_product)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_shader_integer_dot_product))) {
                skip |=
                    LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                             "includes a pointer to a VkStructureType "
                             "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES), but its parent extension "
                             "VK_KHR_shader_integer_dot_product has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceTexelBufferAlignmentProperties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: {  // Covers
                                                                                     // VUID-VkPhysicalDeviceTexelBufferAlignmentProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_texel_buffer_alignment)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_texel_buffer_alignment))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES), but its parent extension "
                                 "VK_EXT_texel_buffer_alignment has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceMaintenance4Properties structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: {  // Covers
                                                                            // VUID-VkPhysicalDeviceMaintenance4Properties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance4)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance4))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES), but its parent extension "
                                 "VK_KHR_maintenance4 has not been enabled.");
            }
        } break;

        // No Validation code for VkPhysicalDevicePushDescriptorPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDevicePushDescriptorPropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDevicePerformanceQueryPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDevicePerformanceQueryPropertiesKHR-sType-sType
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDevicePortabilitySubsetPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDevicePortabilitySubsetPropertiesKHR-sType-sType
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceFragmentShadingRatePropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceFragmentShadingRatePropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceMaintenance5PropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceMaintenance5PropertiesKHR-sType-sType

        // Validation code for VkPhysicalDevicePipelineBinaryPropertiesKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR: {  // Covers
                                                                                  // VUID-VkPhysicalDevicePipelineBinaryPropertiesKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDevicePipelineBinaryPropertiesKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_pipeline_binary");
                }
                VkPhysicalDevicePipelineBinaryPropertiesKHR* structure = (VkPhysicalDevicePipelineBinaryPropertiesKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaryInternalCache), structure->pipelineBinaryInternalCache);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaryInternalCacheControl),
                                       structure->pipelineBinaryInternalCacheControl);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaryPrefersInternalCache),
                                       structure->pipelineBinaryPrefersInternalCache);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaryPrecompiledInternalCache),
                                       structure->pipelineBinaryPrecompiledInternalCache);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineBinaryCompressedData), structure->pipelineBinaryCompressedData);
            }
        } break;

        // No Validation code for VkPhysicalDeviceCooperativeMatrixPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceCooperativeMatrixPropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceLineRasterizationPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceLineRasterizationPropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceMaintenance6PropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceMaintenance6PropertiesKHR-sType-sType

        // No Validation code for VkPhysicalDeviceMaintenance7PropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceMaintenance7PropertiesKHR-sType-sType

        // Validation code for VkPhysicalDeviceLayeredApiPropertiesListKHR structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR: {  // Covers
                                                                                   // VUID-VkPhysicalDeviceLayeredApiPropertiesListKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLayeredApiPropertiesListKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance7)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance7");
                }
                VkPhysicalDeviceLayeredApiPropertiesListKHR* structure = (VkPhysicalDeviceLayeredApiPropertiesListKHR*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::layeredApiCount), pNext_loc.dot(Field::pLayeredApis), structure->layeredApiCount,
                    structure->pLayeredApis, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR, false, false,
                    "VUID-VkPhysicalDeviceLayeredApiPropertiesKHR-sType-sType",
                    "VUID-VkPhysicalDeviceLayeredApiPropertiesListKHR-pLayeredApis-parameter", kVUIDUndefined);

                if (structure->pLayeredApis != nullptr) {
                    for (uint32_t layeredApiIndex = 0; layeredApiIndex < structure->layeredApiCount; ++layeredApiIndex) {
                        [[maybe_unused]] const Location pLayeredApis_loc = pNext_loc.dot(Field::pLayeredApis, layeredApiIndex);
                    }
                }
            }
        } break;

        // No Validation code for VkPhysicalDeviceTransformFeedbackPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceTransformFeedbackPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDevicePipelineRobustnessPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDevicePipelineRobustnessPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX structure members  -- Covers
        // VUID-VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX-sType-sType

        // No Validation code for VkPhysicalDeviceDiscardRectanglePropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceDiscardRectanglePropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceConservativeRasterizationPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceConservativeRasterizationPropertiesEXT-sType-sType
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceShaderEnqueuePropertiesAMDX structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderEnqueuePropertiesAMDX-sType-sType
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceSampleLocationsPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceSampleLocationsPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderSMBuiltinsPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceShadingRateImagePropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceShadingRateImagePropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceRayTracingPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceRayTracingPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceExternalMemoryHostPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceExternalMemoryHostPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceShaderCorePropertiesAMD structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderCorePropertiesAMD-sType-sType

        // No Validation code for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceMeshShaderPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceMeshShaderPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDevicePCIBusInfoPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDevicePCIBusInfoPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceFragmentDensityMapPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceFragmentDensityMapPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceShaderCoreProperties2AMD structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderCoreProperties2AMD-sType-sType

        // No Validation code for VkPhysicalDeviceCooperativeMatrixPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceCooperativeMatrixPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceProvokingVertexPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceProvokingVertexPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceHostImageCopyPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT: {  // Covers
                                                                                  // VUID-VkPhysicalDeviceHostImageCopyPropertiesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceHostImageCopyPropertiesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_host_image_copy");
                }
                VkPhysicalDeviceHostImageCopyPropertiesEXT* structure = (VkPhysicalDeviceHostImageCopyPropertiesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::identicalMemoryTypeRequirements),
                                       structure->identicalMemoryTypeRequirements);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMapMemoryPlacedPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceMapMemoryPlacedPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceRobustness2PropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceRobustness2PropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceCustomBorderColorPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceCustomBorderColorPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceCudaKernelLaunchPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceCudaKernelLaunchPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceDescriptorBufferPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceDescriptorBufferPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT: {  // Covers
                                                                                            // VUID-VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_graphics_pipeline_library)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_graphics_pipeline_library");
                }
                VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* structure =
                    (VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::graphicsPipelineLibraryFastLinking),
                                       structure->graphicsPipelineLibraryFastLinking);

                skip |= ValidateBool32(pNext_loc.dot(Field::graphicsPipelineLibraryIndependentInterpolationDecoration),
                                       structure->graphicsPipelineLibraryIndependentInterpolationDecoration);
            }
        } break;

        // Validation code for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV: {  // Covers
                                                                                             // VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV);
                if (!IsExtEnabled(device_extensions.vk_nv_fragment_shading_rate_enums)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_fragment_shading_rate_enums");
                }
                VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* structure =
                    (VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)header;
                skip |= ValidateFlags(
                    pNext_loc.dot(Field::maxFragmentShadingRateInvocationCount), vvl::FlagBitmask::VkSampleCountFlagBits,
                    AllVkSampleCountFlagBits, structure->maxFragmentShadingRateInvocationCount, kRequiredSingleBit, physicalDevice,
                    "VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-maxFragmentShadingRateInvocationCount-parameter",
                    "VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-maxFragmentShadingRateInvocationCount-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceFragmentDensityMap2PropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceDrmPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceDrmPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI structure members  -- Covers
        // VUID-VkPhysicalDeviceSubpassShadingPropertiesHUAWEI-sType-sType

        // No Validation code for VkPhysicalDeviceMultiDrawPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceMultiDrawPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceShaderTileImagePropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderTileImagePropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceOpacityMicromapPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceOpacityMicromapPropertiesEXT-sType-sType
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceDisplacementMicromapPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceDisplacementMicromapPropertiesNV-sType-sType
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI structure members  -- Covers
        // VUID-VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI-sType-sType

        // No Validation code for VkPhysicalDeviceShaderCorePropertiesARM structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderCorePropertiesARM-sType-sType

        // Validation code for VkPhysicalDeviceSchedulingControlsPropertiesARM structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceSchedulingControlsPropertiesARM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceSchedulingControlsPropertiesARM);
                if (!IsExtEnabled(device_extensions.vk_arm_scheduling_controls)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_ARM_scheduling_controls");
                }
                VkPhysicalDeviceSchedulingControlsPropertiesARM* structure =
                    (VkPhysicalDeviceSchedulingControlsPropertiesARM*)header;
                skip |= ValidateFlags(
                    pNext_loc.dot(Field::schedulingControlsFlags), vvl::FlagBitmask::VkPhysicalDeviceSchedulingControlsFlagBitsARM,
                    AllVkPhysicalDeviceSchedulingControlsFlagBitsARM, structure->schedulingControlsFlags, kRequiredFlags,
                    physicalDevice, "VUID-VkPhysicalDeviceSchedulingControlsPropertiesARM-schedulingControlsFlags-parameter",
                    "VUID-VkPhysicalDeviceSchedulingControlsPropertiesARM-schedulingControlsFlags-requiredbitmask");
            }
        } break;

        // No Validation code for VkPhysicalDeviceRenderPassStripedPropertiesARM structure members  -- Covers
        // VUID-VkPhysicalDeviceRenderPassStripedPropertiesARM-sType-sType

        // No Validation code for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM structure members  -- Covers
        // VUID-VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM-sType-sType

        // No Validation code for VkPhysicalDeviceCopyMemoryIndirectPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceCopyMemoryIndirectPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceMemoryDecompressionPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceMemoryDecompressionPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceImageProcessingPropertiesQCOM structure members  -- Covers
        // VUID-VkPhysicalDeviceImageProcessingPropertiesQCOM-sType-sType

        // No Validation code for VkPhysicalDeviceNestedCommandBufferPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceNestedCommandBufferPropertiesEXT-sType-sType

        // Validation code for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceExtendedDynamicState3PropertiesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExtendedDynamicState3PropertiesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_extended_dynamic_state3");
                }
                VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* structure =
                    (VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dynamicPrimitiveTopologyUnrestricted),
                                       structure->dynamicPrimitiveTopologyUnrestricted);
            }
        } break;

        // No Validation code for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceOpticalFlowPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceOpticalFlowPropertiesNV-sType-sType
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkPhysicalDeviceExternalFormatResolvePropertiesANDROID structure members  -- Covers
        // VUID-VkPhysicalDeviceExternalFormatResolvePropertiesANDROID-sType-sType
#endif  // VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkPhysicalDeviceShaderObjectPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceShaderObjectPropertiesEXT-sType-sType

        // No Validation code for VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV-sType-sType

        // No Validation code for VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV structure members  -- Covers
        // VUID-VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV-sType-sType

        // Validation code for VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT: {  // Covers
                                                                                           // VUID-VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_legacy_vertex_attributes)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_legacy_vertex_attributes");
                }
                VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* structure =
                    (VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::nativeUnalignedPerformance), structure->nativeUnalignedPerformance);
            }
        } break;

            // No Validation code for VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM structure members  -- Covers
            // VUID-VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM-sType-sType

            // No Validation code for VkPhysicalDeviceImageProcessing2PropertiesQCOM structure members  -- Covers
            // VUID-VkPhysicalDeviceImageProcessing2PropertiesQCOM-sType-sType

            // No Validation code for VkPhysicalDeviceLayeredDriverPropertiesMSFT structure members  -- Covers
            // VUID-VkPhysicalDeviceLayeredDriverPropertiesMSFT-sType-sType

            // No Validation code for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT structure members  -- Covers
            // VUID-VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT-sType-sType

            // No Validation code for VkPhysicalDeviceImageAlignmentControlPropertiesMESA structure members  -- Covers
            // VUID-VkPhysicalDeviceImageAlignmentControlPropertiesMESA-sType-sType

            // No Validation code for VkPhysicalDeviceAccelerationStructurePropertiesKHR structure members  -- Covers
            // VUID-VkPhysicalDeviceAccelerationStructurePropertiesKHR-sType-sType

            // No Validation code for VkPhysicalDeviceRayTracingPipelinePropertiesKHR structure members  -- Covers
            // VUID-VkPhysicalDeviceRayTracingPipelinePropertiesKHR-sType-sType

            // No Validation code for VkPhysicalDeviceMeshShaderPropertiesEXT structure members  -- Covers
            // VUID-VkPhysicalDeviceMeshShaderPropertiesEXT-sType-sType

        default:
            skip = false;
    }
    return skip;
}

// All structs that are not a Feature or Property struct
bool StatelessValidation::ValidatePnextStructContents(const Location& loc, const VkBaseOutStructure* header, const char* pnext_vuid,
                                                      const VkPhysicalDevice physicalDevice, bool is_const_param) const {
    bool skip = false;
    const bool is_physdev_api = physicalDevice != VK_NULL_HANDLE;
    switch (header->sType) {
        // Validation code for VkShaderModuleCreateInfo structure members
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: {  // Covers VUID-VkShaderModuleCreateInfo-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkShaderModuleCreateInfo);
                VkShaderModuleCreateInfo* structure = (VkShaderModuleCreateInfo*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

                skip |= ValidateArray(pNext_loc.dot(Field::codeSize), pNext_loc.dot(Field::pCode), structure->codeSize / 4,
                                      &structure->pCode, true, true, "VUID-VkShaderModuleCreateInfo-codeSize-01085",
                                      "VUID-VkShaderModuleCreateInfo-pCode-parameter");
            }
        } break;

        // Validation code for VkPipelineLayoutCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {  // Covers VUID-VkPipelineLayoutCreateInfo-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineLayoutCreateInfo);
                VkPipelineLayoutCreateInfo* structure = (VkPipelineLayoutCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineLayoutCreateFlagBits,
                                      AllVkPipelineLayoutCreateFlagBits, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkPipelineLayoutCreateInfo-flags-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::pushConstantRangeCount), pNext_loc.dot(Field::pPushConstantRanges),
                                      structure->pushConstantRangeCount, &structure->pPushConstantRanges, false, true,
                                      kVUIDUndefined, "VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter");

                if (structure->pPushConstantRanges != nullptr) {
                    for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < structure->pushConstantRangeCount;
                         ++pushConstantRangeIndex) {
                        [[maybe_unused]] const Location pPushConstantRanges_loc =
                            pNext_loc.dot(Field::pPushConstantRanges, pushConstantRangeIndex);
                        skip |= ValidateFlags(pPushConstantRanges_loc.dot(Field::stageFlags),
                                              vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                                              structure->pPushConstantRanges[pushConstantRangeIndex].stageFlags, kRequiredFlags,
                                              VK_NULL_HANDLE, "VUID-VkPushConstantRange-stageFlags-parameter",
                                              "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
                    }
                }
            }
        } break;

        // Validation code for VkMemoryDedicatedRequirements structure members
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: {  // Covers VUID-VkMemoryDedicatedRequirements-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_dedicated_allocation)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dedicated_allocation))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS), but "
                                 "its parent extension "
                                 "VK_KHR_dedicated_allocation has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryDedicatedAllocateInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: {  // Covers VUID-VkMemoryDedicatedAllocateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_dedicated_allocation)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dedicated_allocation))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_dedicated_allocation has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryAllocateFlagsInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: {  // Covers VUID-VkMemoryAllocateFlagsInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO), but its "
                                 "parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMemoryAllocateFlagsInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_device_group");
                }
                VkMemoryAllocateFlagsInfo* structure = (VkMemoryAllocateFlagsInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryAllocateFlagBits,
                                      AllVkMemoryAllocateFlagBits, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkMemoryAllocateFlagsInfo-flags-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupRenderPassBeginInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: {  // Covers VUID-VkDeviceGroupRenderPassBeginInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupRenderPassBeginInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_device_group");
                }
                VkDeviceGroupRenderPassBeginInfo* structure = (VkDeviceGroupRenderPassBeginInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::deviceRenderAreaCount), pNext_loc.dot(Field::pDeviceRenderAreas),
                                      structure->deviceRenderAreaCount, &structure->pDeviceRenderAreas, false, true, kVUIDUndefined,
                                      "VUID-VkDeviceGroupRenderPassBeginInfo-pDeviceRenderAreas-parameter");

                if (structure->pDeviceRenderAreas != nullptr) {
                    for (uint32_t deviceRenderAreaIndex = 0; deviceRenderAreaIndex < structure->deviceRenderAreaCount;
                         ++deviceRenderAreaIndex) {
                        [[maybe_unused]] const Location pDeviceRenderAreas_loc =
                            pNext_loc.dot(Field::pDeviceRenderAreas, deviceRenderAreaIndex);
                    }
                }
            }
        } break;

        // Validation code for VkDeviceGroupCommandBufferBeginInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: {  // Covers
                                                                          // VUID-VkDeviceGroupCommandBufferBeginInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO), but its parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
        } break;

        // Validation code for VkDeviceGroupSubmitInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: {  // Covers VUID-VkDeviceGroupSubmitInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO), but its "
                                 "parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupSubmitInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_device_group");
                }
                VkDeviceGroupSubmitInfo* structure = (VkDeviceGroupSubmitInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::waitSemaphoreCount), pNext_loc.dot(Field::pWaitSemaphoreDeviceIndices),
                                      structure->waitSemaphoreCount, &structure->pWaitSemaphoreDeviceIndices, false, true,
                                      kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::commandBufferCount), pNext_loc.dot(Field::pCommandBufferDeviceMasks),
                                      structure->commandBufferCount, &structure->pCommandBufferDeviceMasks, false, true,
                                      kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::signalSemaphoreCount), pNext_loc.dot(Field::pSignalSemaphoreDeviceIndices),
                                  structure->signalSemaphoreCount, &structure->pSignalSemaphoreDeviceIndices, false, true,
                                  kVUIDUndefined, "VUID-VkDeviceGroupSubmitInfo-pSignalSemaphoreDeviceIndices-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupBindSparseInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: {  // Covers VUID-VkDeviceGroupBindSparseInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
        } break;

        // Validation code for VkBindBufferMemoryDeviceGroupInfo structure members
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: {  // Covers VUID-VkBindBufferMemoryDeviceGroupInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO), but its parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindBufferMemoryDeviceGroupInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_device_group");
                }
                VkBindBufferMemoryDeviceGroupInfo* structure = (VkBindBufferMemoryDeviceGroupInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::deviceIndexCount), pNext_loc.dot(Field::pDeviceIndices),
                                      structure->deviceIndexCount, &structure->pDeviceIndices, false, true, kVUIDUndefined,
                                      "VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-parameter");
            }
        } break;

        // Validation code for VkBindImageMemoryDeviceGroupInfo structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: {  // Covers VUID-VkBindImageMemoryDeviceGroupInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_device_group)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_device_group))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_device_group has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindImageMemoryDeviceGroupInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_device_group");
                }
                VkBindImageMemoryDeviceGroupInfo* structure = (VkBindImageMemoryDeviceGroupInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::deviceIndexCount), pNext_loc.dot(Field::pDeviceIndices),
                                      structure->deviceIndexCount, &structure->pDeviceIndices, false, true, kVUIDUndefined,
                                      "VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::splitInstanceBindRegionCount),
                                      pNext_loc.dot(Field::pSplitInstanceBindRegions), structure->splitInstanceBindRegionCount,
                                      &structure->pSplitInstanceBindRegions, false, true, kVUIDUndefined,
                                      "VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-parameter");

                if (structure->pSplitInstanceBindRegions != nullptr) {
                    for (uint32_t splitInstanceBindRegionIndex = 0;
                         splitInstanceBindRegionIndex < structure->splitInstanceBindRegionCount; ++splitInstanceBindRegionIndex) {
                        [[maybe_unused]] const Location pSplitInstanceBindRegions_loc =
                            pNext_loc.dot(Field::pSplitInstanceBindRegions, splitInstanceBindRegionIndex);
                    }
                }
            }
        } break;

        // Validation code for VkDeviceGroupDeviceCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {  // Covers VUID-VkDeviceGroupDeviceCreateInfo-sType-sType

            if (!IsExtEnabled(instance_extensions.vk_khr_device_group_creation)) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_device_group_creation has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupDeviceCreateInfo);
                VkDeviceGroupDeviceCreateInfo* structure = (VkDeviceGroupDeviceCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::physicalDeviceCount), pNext_loc.dot(Field::pPhysicalDevices),
                                      structure->physicalDeviceCount, &structure->pPhysicalDevices, false, true, kVUIDUndefined,
                                      "VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter");
            }
        } break;

        // Validation code for VkPhysicalDeviceFeatures2 structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: {  // Covers VUID-VkPhysicalDeviceFeatures2-sType-sType

            if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2)) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2), but its "
                                 "parent extension "
                                 "VK_KHR_get_physical_device_properties2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceFeatures2);
                VkPhysicalDeviceFeatures2* structure = (VkPhysicalDeviceFeatures2*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::robustBufferAccess), structure->features.robustBufferAccess);

                skip |= ValidateBool32(pNext_loc.dot(Field::fullDrawIndexUint32), structure->features.fullDrawIndexUint32);

                skip |= ValidateBool32(pNext_loc.dot(Field::imageCubeArray), structure->features.imageCubeArray);

                skip |= ValidateBool32(pNext_loc.dot(Field::independentBlend), structure->features.independentBlend);

                skip |= ValidateBool32(pNext_loc.dot(Field::geometryShader), structure->features.geometryShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::tessellationShader), structure->features.tessellationShader);

                skip |= ValidateBool32(pNext_loc.dot(Field::sampleRateShading), structure->features.sampleRateShading);

                skip |= ValidateBool32(pNext_loc.dot(Field::dualSrcBlend), structure->features.dualSrcBlend);

                skip |= ValidateBool32(pNext_loc.dot(Field::logicOp), structure->features.logicOp);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiDrawIndirect), structure->features.multiDrawIndirect);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::drawIndirectFirstInstance), structure->features.drawIndirectFirstInstance);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthClamp), structure->features.depthClamp);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasClamp), structure->features.depthBiasClamp);

                skip |= ValidateBool32(pNext_loc.dot(Field::fillModeNonSolid), structure->features.fillModeNonSolid);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBounds), structure->features.depthBounds);

                skip |= ValidateBool32(pNext_loc.dot(Field::wideLines), structure->features.wideLines);

                skip |= ValidateBool32(pNext_loc.dot(Field::largePoints), structure->features.largePoints);

                skip |= ValidateBool32(pNext_loc.dot(Field::alphaToOne), structure->features.alphaToOne);

                skip |= ValidateBool32(pNext_loc.dot(Field::multiViewport), structure->features.multiViewport);

                skip |= ValidateBool32(pNext_loc.dot(Field::samplerAnisotropy), structure->features.samplerAnisotropy);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionETC2), structure->features.textureCompressionETC2);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionASTC_LDR),
                                       structure->features.textureCompressionASTC_LDR);

                skip |= ValidateBool32(pNext_loc.dot(Field::textureCompressionBC), structure->features.textureCompressionBC);

                skip |= ValidateBool32(pNext_loc.dot(Field::occlusionQueryPrecise), structure->features.occlusionQueryPrecise);

                skip |= ValidateBool32(pNext_loc.dot(Field::pipelineStatisticsQuery), structure->features.pipelineStatisticsQuery);

                skip |= ValidateBool32(pNext_loc.dot(Field::vertexPipelineStoresAndAtomics),
                                       structure->features.vertexPipelineStoresAndAtomics);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::fragmentStoresAndAtomics), structure->features.fragmentStoresAndAtomics);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderTessellationAndGeometryPointSize),
                                       structure->features.shaderTessellationAndGeometryPointSize);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::shaderImageGatherExtended), structure->features.shaderImageGatherExtended);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageExtendedFormats),
                                       structure->features.shaderStorageImageExtendedFormats);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageMultisample),
                                       structure->features.shaderStorageImageMultisample);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageReadWithoutFormat),
                                       structure->features.shaderStorageImageReadWithoutFormat);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageWriteWithoutFormat),
                                       structure->features.shaderStorageImageWriteWithoutFormat);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderUniformBufferArrayDynamicIndexing),
                                       structure->features.shaderUniformBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderSampledImageArrayDynamicIndexing),
                                       structure->features.shaderSampledImageArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageBufferArrayDynamicIndexing),
                                       structure->features.shaderStorageBufferArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderStorageImageArrayDynamicIndexing),
                                       structure->features.shaderStorageImageArrayDynamicIndexing);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderClipDistance), structure->features.shaderClipDistance);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderCullDistance), structure->features.shaderCullDistance);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderFloat64), structure->features.shaderFloat64);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt64), structure->features.shaderInt64);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderInt16), structure->features.shaderInt16);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderResourceResidency), structure->features.shaderResourceResidency);

                skip |= ValidateBool32(pNext_loc.dot(Field::shaderResourceMinLod), structure->features.shaderResourceMinLod);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseBinding), structure->features.sparseBinding);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyBuffer), structure->features.sparseResidencyBuffer);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyImage2D), structure->features.sparseResidencyImage2D);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyImage3D), structure->features.sparseResidencyImage3D);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidency2Samples), structure->features.sparseResidency2Samples);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidency4Samples), structure->features.sparseResidency4Samples);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidency8Samples), structure->features.sparseResidency8Samples);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::sparseResidency16Samples), structure->features.sparseResidency16Samples);

                skip |= ValidateBool32(pNext_loc.dot(Field::sparseResidencyAliased), structure->features.sparseResidencyAliased);

                skip |= ValidateBool32(pNext_loc.dot(Field::variableMultisampleRate), structure->features.variableMultisampleRate);

                skip |= ValidateBool32(pNext_loc.dot(Field::inheritedQueries), structure->features.inheritedQueries);
            }
        } break;

        // Validation code for VkRenderPassInputAttachmentAspectCreateInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: {  // Covers
                                                                                   // VUID-VkRenderPassInputAttachmentAspectCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO), but its parent extension "
                                 "VK_KHR_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassInputAttachmentAspectCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance2)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance2");
                }
                VkRenderPassInputAttachmentAspectCreateInfo* structure = (VkRenderPassInputAttachmentAspectCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::aspectReferenceCount), pNext_loc.dot(Field::pAspectReferences),
                                      structure->aspectReferenceCount, &structure->pAspectReferences, true, true,
                                      "VUID-VkRenderPassInputAttachmentAspectCreateInfo-aspectReferenceCount-arraylength",
                                      "VUID-VkRenderPassInputAttachmentAspectCreateInfo-pAspectReferences-parameter");

                if (structure->pAspectReferences != nullptr) {
                    for (uint32_t aspectReferenceIndex = 0; aspectReferenceIndex < structure->aspectReferenceCount;
                         ++aspectReferenceIndex) {
                        [[maybe_unused]] const Location pAspectReferences_loc =
                            pNext_loc.dot(Field::pAspectReferences, aspectReferenceIndex);
                        skip |= ValidateFlags(pAspectReferences_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                              AllVkImageAspectFlagBits,
                                              structure->pAspectReferences[aspectReferenceIndex].aspectMask, kRequiredFlags,
                                              VK_NULL_HANDLE, "VUID-VkInputAttachmentAspectReference-aspectMask-parameter",
                                              "VUID-VkInputAttachmentAspectReference-aspectMask-requiredbitmask");
                    }
                }
            }
        } break;

        // Validation code for VkImageViewUsageCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: {  // Covers VUID-VkImageViewUsageCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageViewUsageCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance2)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance2");
                }
                VkImageViewUsageCreateInfo* structure = (VkImageViewUsageCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits,
                                      structure->usage, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkImageViewUsageCreateInfo-usage-parameter",
                                      "VUID-VkImageViewUsageCreateInfo-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkPipelineTessellationDomainOriginStateCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: {  // Covers
                                                                                         // VUID-VkPipelineTessellationDomainOriginStateCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_maintenance2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance2))) {
                skip |=
                    LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                             "includes a pointer to a VkStructureType "
                             "(VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO), but its parent extension "
                             "VK_KHR_maintenance2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineTessellationDomainOriginStateCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance2)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance2");
                }
                VkPipelineTessellationDomainOriginStateCreateInfo* structure =
                    (VkPipelineTessellationDomainOriginStateCreateInfo*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::domainOrigin), vvl::Enum::VkTessellationDomainOrigin, structure->domainOrigin,
                    "VUID-VkPipelineTessellationDomainOriginStateCreateInfo-domainOrigin-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkRenderPassMultiviewCreateInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: {  // Covers VUID-VkRenderPassMultiviewCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_multiview)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_multiview))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_multiview has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassMultiviewCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_multiview)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_multiview");
                }
                VkRenderPassMultiviewCreateInfo* structure = (VkRenderPassMultiviewCreateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::subpassCount), pNext_loc.dot(Field::pViewMasks), structure->subpassCount,
                                      &structure->pViewMasks, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::dependencyCount), pNext_loc.dot(Field::pViewOffsets),
                                      structure->dependencyCount, &structure->pViewOffsets, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassMultiviewCreateInfo-pViewOffsets-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::correlationMaskCount), pNext_loc.dot(Field::pCorrelationMasks),
                                      structure->correlationMaskCount, &structure->pCorrelationMasks, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-parameter");
            }
        } break;

        // Validation code for VkProtectedSubmitInfo structure members
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: {  // Covers VUID-VkProtectedSubmitInfo-sType-sType

            if (is_physdev_api) {
                VkPhysicalDeviceProperties device_properties = {};
                DispatchGetPhysicalDeviceProperties(physicalDevice, &device_properties);
                if (device_properties.apiVersion < VK_API_VERSION_1_1) {
                    APIVersion device_api_version(static_cast<uint32_t>(device_properties.apiVersion));
                    skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                     "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO) which was "
                                     "added in VK_API_VERSION_1_1 but the "
                                     "current effective API version is %s.",
                                     StringAPIVersion(device_api_version).c_str());
                }
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkProtectedSubmitInfo);
                VkProtectedSubmitInfo* structure = (VkProtectedSubmitInfo*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::protectedSubmit), structure->protectedSubmit);
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionInfo structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: {  // Covers VUID-VkSamplerYcbcrConversionInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_sampler_ycbcr_conversion)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerYcbcrConversionInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_sampler_ycbcr_conversion");
                }
                VkSamplerYcbcrConversionInfo* structure = (VkSamplerYcbcrConversionInfo*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::conversion), structure->conversion);
            }
        } break;

        // Validation code for VkBindImagePlaneMemoryInfo structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: {  // Covers VUID-VkBindImagePlaneMemoryInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_sampler_ycbcr_conversion)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindImagePlaneMemoryInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_sampler_ycbcr_conversion");
                }
                VkBindImagePlaneMemoryInfo* structure = (VkBindImagePlaneMemoryInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, structure->planeAspect, kRequiredSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter",
                                      "VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter");
            }
        } break;

        // Validation code for VkImagePlaneMemoryRequirementsInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: {  // Covers
                                                                        // VUID-VkImagePlaneMemoryRequirementsInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_sampler_ycbcr_conversion)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO), but its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImagePlaneMemoryRequirementsInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_sampler_ycbcr_conversion");
                }
                VkImagePlaneMemoryRequirementsInfo* structure = (VkImagePlaneMemoryRequirementsInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, structure->planeAspect, kRequiredSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter",
                                      "VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter");
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionImageFormatProperties structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: {  // Covers
                                                                                    // VUID-VkSamplerYcbcrConversionImageFormatProperties-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_sampler_ycbcr_conversion)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES), but its parent extension "
                                 "VK_KHR_sampler_ycbcr_conversion has not been enabled.");
            }
        } break;

        // Validation code for VkPhysicalDeviceExternalImageFormatInfo structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: {  // Covers
                                                                              // VUID-VkPhysicalDeviceExternalImageFormatInfo-sType-sType

            if (!IsExtEnabled(instance_extensions.vk_khr_external_memory_capabilities)) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO), but its parent extension "
                                 "VK_KHR_external_memory_capabilities has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceExternalImageFormatInfo);
                VkPhysicalDeviceExternalImageFormatInfo* structure = (VkPhysicalDeviceExternalImageFormatInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      physicalDevice, "VUID-VkPhysicalDeviceExternalImageFormatInfo-handleType-parameter");
            }
        } break;

        // Validation code for VkExternalImageFormatProperties structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: {  // Covers VUID-VkExternalImageFormatProperties-sType-sType

            if (!IsExtEnabled(instance_extensions.vk_khr_external_memory_capabilities)) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES), "
                                 "but its parent extension "
                                 "VK_KHR_external_memory_capabilities has not been enabled.");
            }
        } break;

        // Validation code for VkExternalMemoryImageCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: {  // Covers VUID-VkExternalMemoryImageCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_external_memory)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_memory))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryImageCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_external_memory)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_external_memory");
                }
                VkExternalMemoryImageCreateInfo* structure = (VkExternalMemoryImageCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkExternalMemoryImageCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExternalMemoryBufferCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: {  // Covers VUID-VkExternalMemoryBufferCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_external_memory)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_memory))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryBufferCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_external_memory)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_external_memory");
                }
                VkExternalMemoryBufferCreateInfo* structure = (VkExternalMemoryBufferCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkExternalMemoryBufferCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportMemoryAllocateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: {  // Covers VUID-VkExportMemoryAllocateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_external_memory)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_memory))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO), but its "
                                 "parent extension "
                                 "VK_KHR_external_memory has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMemoryAllocateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_external_memory)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_external_memory");
                }
                VkExportMemoryAllocateInfo* structure = (VkExportMemoryAllocateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkExportMemoryAllocateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportFenceCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: {  // Covers VUID-VkExportFenceCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_external_fence)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_fence))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO), but its "
                                 "parent extension "
                                 "VK_KHR_external_fence has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportFenceCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_external_fence)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_external_fence");
                }
                VkExportFenceCreateInfo* structure = (VkExportFenceCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                                      AllVkExternalFenceHandleTypeFlagBits, structure->handleTypes, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkExportFenceCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportSemaphoreCreateInfo structure members
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: {  // Covers VUID-VkExportSemaphoreCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_external_semaphore)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_external_semaphore))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_external_semaphore has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportSemaphoreCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_external_semaphore");
                }
                VkExportSemaphoreCreateInfo* structure = (VkExportSemaphoreCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                                      AllVkExternalSemaphoreHandleTypeFlagBits, structure->handleTypes, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkExportSemaphoreCreateInfo-handleTypes-parameter");
            }
        } break;

        // Validation code for VkImageFormatListCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: {  // Covers VUID-VkImageFormatListCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_image_format_list)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_image_format_list))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_image_format_list has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageFormatListCreateInfo);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_image_format_list))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_image_format_list");
                }
                VkImageFormatListCreateInfo* structure = (VkImageFormatListCreateInfo*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::viewFormatCount), pNext_loc.dot(Field::pViewFormats),
                                                vvl::Enum::VkFormat, structure->viewFormatCount, structure->pViewFormats, false,
                                                true, kVUIDUndefined, "VUID-VkImageFormatListCreateInfo-pViewFormats-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetLayoutBindingFlagsCreateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: {  // Covers
                                                                                   // VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_descriptor_indexing)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO), but its parent extension "
                                 "VK_EXT_descriptor_indexing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDescriptorSetLayoutBindingFlagsCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_ext_descriptor_indexing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_descriptor_indexing");
                }
                VkDescriptorSetLayoutBindingFlagsCreateInfo* structure = (VkDescriptorSetLayoutBindingFlagsCreateInfo*)header;
                skip |= ValidateFlagsArray(pNext_loc.dot(Field::bindingCount), pNext_loc.dot(Field::pBindingFlags),
                                           vvl::FlagBitmask::VkDescriptorBindingFlagBits, AllVkDescriptorBindingFlagBits,
                                           structure->bindingCount, structure->pBindingFlags, false, kVUIDUndefined,
                                           "VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetVariableDescriptorCountAllocateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO: {  // Covers
                                                                                          // VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_descriptor_indexing)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                skip |=
                    LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                             "includes a pointer to a VkStructureType "
                             "(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO), but its parent extension "
                             "VK_EXT_descriptor_indexing has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDescriptorSetVariableDescriptorCountAllocateInfo);
                if (!IsExtEnabled(device_extensions.vk_ext_descriptor_indexing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_descriptor_indexing");
                }
                VkDescriptorSetVariableDescriptorCountAllocateInfo* structure =
                    (VkDescriptorSetVariableDescriptorCountAllocateInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::descriptorSetCount), pNext_loc.dot(Field::pDescriptorCounts),
                                      structure->descriptorSetCount, &structure->pDescriptorCounts, false, true, kVUIDUndefined,
                                      "VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter");
            }
        } break;

        // Validation code for VkDescriptorSetVariableDescriptorCountLayoutSupport structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT: {  // Covers
                                                                                           // VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_descriptor_indexing)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_descriptor_indexing))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT), but its parent extension "
                    "VK_EXT_descriptor_indexing has not been enabled.");
            }
        } break;

        // Validation code for VkSubpassDescriptionDepthStencilResolve structure members
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: {  // Covers
                                                                             // VUID-VkSubpassDescriptionDepthStencilResolve-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_depth_stencil_resolve)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_depth_stencil_resolve))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE), but its parent extension "
                                 "VK_KHR_depth_stencil_resolve has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSubpassDescriptionDepthStencilResolve);
                if (!IsExtEnabled(device_extensions.vk_khr_depth_stencil_resolve)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_depth_stencil_resolve");
                }
                VkSubpassDescriptionDepthStencilResolve* structure = (VkSubpassDescriptionDepthStencilResolve*)header;
                skip |=
                    ValidateStructType(pNext_loc.dot(Field::pDepthStencilResolveAttachment),
                                       structure->pDepthStencilResolveAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                                       "VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-parameter",
                                       "VUID-VkAttachmentReference2-sType-sType");

                if (structure->pDepthStencilResolveAttachment != nullptr) {
                    [[maybe_unused]] const Location pDepthStencilResolveAttachment_loc =
                        pNext_loc.dot(Field::pDepthStencilResolveAttachment);
                    skip |= ValidateRangedEnum(pDepthStencilResolveAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               structure->pDepthStencilResolveAttachment->layout,
                                               "VUID-VkAttachmentReference2-layout-parameter", VK_NULL_HANDLE);
                }
            }
        } break;

        // Validation code for VkImageStencilUsageCreateInfo structure members
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: {  // Covers VUID-VkImageStencilUsageCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_separate_stencil_usage)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_separate_stencil_usage))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_EXT_separate_stencil_usage has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageStencilUsageCreateInfo);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_separate_stencil_usage))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_separate_stencil_usage");
                }
                VkImageStencilUsageCreateInfo* structure = (VkImageStencilUsageCreateInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::stencilUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                      AllVkImageUsageFlagBits, structure->stencilUsage, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkImageStencilUsageCreateInfo-stencilUsage-parameter",
                                      "VUID-VkImageStencilUsageCreateInfo-stencilUsage-requiredbitmask");
            }
        } break;

        // Validation code for VkSamplerReductionModeCreateInfo structure members
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: {  // Covers VUID-VkSamplerReductionModeCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_sampler_filter_minmax)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_sampler_filter_minmax))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO), "
                                 "but its parent extension "
                                 "VK_EXT_sampler_filter_minmax has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerReductionModeCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_ext_sampler_filter_minmax)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_sampler_filter_minmax");
                }
                VkSamplerReductionModeCreateInfo* structure = (VkSamplerReductionModeCreateInfo*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::reductionMode), vvl::Enum::VkSamplerReductionMode,
                                           structure->reductionMode,
                                           "VUID-VkSamplerReductionModeCreateInfo-reductionMode-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkFramebufferAttachmentsCreateInfo structure members
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {  // Covers VUID-VkFramebufferAttachmentsCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_imageless_framebuffer)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_imageless_framebuffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkFramebufferAttachmentsCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_imageless_framebuffer");
                }
                VkFramebufferAttachmentsCreateInfo* structure = (VkFramebufferAttachmentsCreateInfo*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::attachmentImageInfoCount), pNext_loc.dot(Field::pAttachmentImageInfos),
                    structure->attachmentImageInfoCount, structure->pAttachmentImageInfos,
                    VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO, false, true,
                    "VUID-VkFramebufferAttachmentImageInfo-sType-sType",
                    "VUID-VkFramebufferAttachmentsCreateInfo-pAttachmentImageInfos-parameter", kVUIDUndefined);

                if (structure->pAttachmentImageInfos != nullptr) {
                    for (uint32_t attachmentImageInfoIndex = 0; attachmentImageInfoIndex < structure->attachmentImageInfoCount;
                         ++attachmentImageInfoIndex) {
                        [[maybe_unused]] const Location pAttachmentImageInfos_loc =
                            pNext_loc.dot(Field::pAttachmentImageInfos, attachmentImageInfoIndex);
                        skip |= ValidateFlags(pAttachmentImageInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                              AllVkImageCreateFlagBits,
                                              structure->pAttachmentImageInfos[attachmentImageInfoIndex].flags, kOptionalFlags,
                                              VK_NULL_HANDLE, "VUID-VkFramebufferAttachmentImageInfo-flags-parameter");

                        skip |=
                            ValidateFlags(pAttachmentImageInfos_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                          AllVkImageUsageFlagBits, structure->pAttachmentImageInfos[attachmentImageInfoIndex].usage,
                                          kRequiredFlags, VK_NULL_HANDLE, "VUID-VkFramebufferAttachmentImageInfo-usage-parameter",
                                          "VUID-VkFramebufferAttachmentImageInfo-usage-requiredbitmask");

                        skip |= ValidateRangedEnumArray(pAttachmentImageInfos_loc.dot(Field::viewFormatCount),
                                                        pAttachmentImageInfos_loc.dot(Field::pViewFormats), vvl::Enum::VkFormat,
                                                        structure->pAttachmentImageInfos[attachmentImageInfoIndex].viewFormatCount,
                                                        structure->pAttachmentImageInfos[attachmentImageInfoIndex].pViewFormats,
                                                        false, true, kVUIDUndefined,
                                                        "VUID-VkFramebufferAttachmentImageInfo-pViewFormats-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassAttachmentBeginInfo structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {  // Covers VUID-VkRenderPassAttachmentBeginInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_imageless_framebuffer)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO), "
                                 "but its parent extension "
                                 "VK_KHR_imageless_framebuffer has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassAttachmentBeginInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_imageless_framebuffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_imageless_framebuffer");
                }
                VkRenderPassAttachmentBeginInfo* structure = (VkRenderPassAttachmentBeginInfo*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::attachmentCount), pNext_loc.dot(Field::pAttachments),
                                      structure->attachmentCount, &structure->pAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassAttachmentBeginInfo-pAttachments-parameter");
            }
        } break;

        // Validation code for VkAttachmentReferenceStencilLayout structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: {  // Covers VUID-VkAttachmentReferenceStencilLayout-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_separate_depth_stencil_layouts)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT), "
                                 "but its parent extension "
                                 "VK_KHR_separate_depth_stencil_layouts has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAttachmentReferenceStencilLayout);
                if (!IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_separate_depth_stencil_layouts");
                }
                VkAttachmentReferenceStencilLayout* structure = (VkAttachmentReferenceStencilLayout*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::stencilLayout), vvl::Enum::VkImageLayout, structure->stencilLayout,
                                           "VUID-VkAttachmentReferenceStencilLayout-stencilLayout-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkAttachmentDescriptionStencilLayout structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: {  // Covers
                                                                         // VUID-VkAttachmentDescriptionStencilLayout-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_separate_depth_stencil_layouts)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT), but its parent extension "
                                 "VK_KHR_separate_depth_stencil_layouts has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAttachmentDescriptionStencilLayout);
                if (!IsExtEnabled(device_extensions.vk_khr_separate_depth_stencil_layouts)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_separate_depth_stencil_layouts");
                }
                VkAttachmentDescriptionStencilLayout* structure = (VkAttachmentDescriptionStencilLayout*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::stencilInitialLayout), vvl::Enum::VkImageLayout, structure->stencilInitialLayout,
                    "VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::stencilFinalLayout), vvl::Enum::VkImageLayout, structure->stencilFinalLayout,
                    "VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkSemaphoreTypeCreateInfo structure members
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: {  // Covers VUID-VkSemaphoreTypeCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_timeline_semaphore)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO), but its "
                                 "parent extension "
                                 "VK_KHR_timeline_semaphore has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSemaphoreTypeCreateInfo);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_timeline_semaphore");
                }
                VkSemaphoreTypeCreateInfo* structure = (VkSemaphoreTypeCreateInfo*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::semaphoreType), vvl::Enum::VkSemaphoreType, structure->semaphoreType,
                                       "VUID-VkSemaphoreTypeCreateInfo-semaphoreType-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkTimelineSemaphoreSubmitInfo structure members
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: {  // Covers VUID-VkTimelineSemaphoreSubmitInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_timeline_semaphore)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_timeline_semaphore has not been enabled.");
            }
        } break;

        // Validation code for VkBufferOpaqueCaptureAddressCreateInfo structure members
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: {  // Covers
                                                                             // VUID-VkBufferOpaqueCaptureAddressCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_buffer_device_address)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_buffer_device_address))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO), but its parent extension "
                                 "VK_KHR_buffer_device_address has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryOpaqueCaptureAddressAllocateInfo structure members
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: {  // Covers
                                                                               // VUID-VkMemoryOpaqueCaptureAddressAllocateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_buffer_device_address)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_buffer_device_address))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO), but its parent extension "
                                 "VK_KHR_buffer_device_address has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineCreationFeedbackCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: {  // Covers
                                                                          // VUID-VkPipelineCreationFeedbackCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_pipeline_creation_feedback)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_pipeline_creation_feedback))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO), but its parent extension "
                                 "VK_EXT_pipeline_creation_feedback has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCreationFeedbackCreateInfo);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_creation_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_pipeline_creation_feedback");
                }
                VkPipelineCreationFeedbackCreateInfo* structure = (VkPipelineCreationFeedbackCreateInfo*)header;
                skip |=
                    ValidateRequiredPointer(pNext_loc.dot(Field::pPipelineCreationFeedback), structure->pPipelineCreationFeedback,
                                            "VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineCreationFeedback-parameter");

                if (structure->pPipelineCreationFeedback != nullptr) {
                    [[maybe_unused]] const Location pPipelineCreationFeedback_loc = pNext_loc.dot(Field::pPipelineCreationFeedback);
                }

                skip |= ValidateArray(
                    pNext_loc.dot(Field::pipelineStageCreationFeedbackCount), pNext_loc.dot(Field::pPipelineStageCreationFeedbacks),
                    structure->pipelineStageCreationFeedbackCount, &structure->pPipelineStageCreationFeedbacks, false, true,
                    kVUIDUndefined, "VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineStageCreationFeedbacks-parameter");

                if (structure->pPipelineStageCreationFeedbacks != nullptr) {
                    for (uint32_t pipelineStageCreationFeedbackIndex = 0;
                         pipelineStageCreationFeedbackIndex < structure->pipelineStageCreationFeedbackCount;
                         ++pipelineStageCreationFeedbackIndex) {
                        [[maybe_unused]] const Location pPipelineStageCreationFeedbacks_loc =
                            pNext_loc.dot(Field::pPipelineStageCreationFeedbacks, pipelineStageCreationFeedbackIndex);
                    }
                }
            }
        } break;

        // Validation code for VkDevicePrivateDataCreateInfo structure members
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: {  // Covers VUID-VkDevicePrivateDataCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_private_data)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_private_data))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_EXT_private_data has not been enabled.");
            }
        } break;

        // Validation code for VkMemoryBarrier2 structure members
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: {  // Covers VUID-VkMemoryBarrier2-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_synchronization2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_synchronization2))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_MEMORY_BARRIER_2), but its parent extension "
                    "VK_KHR_synchronization2 has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMemoryBarrier2);
                if (!IsExtEnabled(device_extensions.vk_khr_synchronization2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_synchronization2");
                }
                VkMemoryBarrier2* structure = (VkMemoryBarrier2*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2, structure->srcStageMask, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2, structure->srcAccessMask, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2, structure->dstStageMask, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2, structure->dstAccessMask, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        } break;

        // Validation code for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO: {  // Covers
                                                                                            // VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_subgroup_size_control)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_subgroup_size_control))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType "
                    "(VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO), but its parent extension "
                    "VK_EXT_subgroup_size_control has not been enabled.");
            }
        } break;

        // Validation code for VkWriteDescriptorSetInlineUniformBlock structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: {  // Covers
                                                                             // VUID-VkWriteDescriptorSetInlineUniformBlock-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_inline_uniform_block)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK), but its parent extension "
                                 "VK_EXT_inline_uniform_block has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWriteDescriptorSetInlineUniformBlock);
                if (!IsExtEnabled(device_extensions.vk_ext_inline_uniform_block)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_inline_uniform_block");
                }
                VkWriteDescriptorSetInlineUniformBlock* structure = (VkWriteDescriptorSetInlineUniformBlock*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::dataSize), pNext_loc.dot(Field::pData), structure->dataSize,
                                  &structure->pData, true, true, "VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-arraylength",
                                  "VUID-VkWriteDescriptorSetInlineUniformBlock-pData-parameter");
            }
        } break;

        // Validation code for VkDescriptorPoolInlineUniformBlockCreateInfo structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: {  // Covers
                                                                                    // VUID-VkDescriptorPoolInlineUniformBlockCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_EXT_inline_uniform_block)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_inline_uniform_block))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO), but its parent extension "
                                 "VK_EXT_inline_uniform_block has not been enabled.");
            }
        } break;

        // Validation code for VkPipelineRenderingCreateInfo structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {  // Covers VUID-VkPipelineRenderingCreateInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_dynamic_rendering)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO), but "
                                 "its parent extension "
                                 "VK_KHR_dynamic_rendering has not been enabled.");
            }
        } break;

        // Validation code for VkCommandBufferInheritanceRenderingInfo structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {  // Covers
                                                                             // VUID-VkCommandBufferInheritanceRenderingInfo-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_dynamic_rendering)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType "
                                 "(VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO), but its parent extension "
                                 "VK_KHR_dynamic_rendering has not been enabled.");
            }
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkCommandBufferInheritanceRenderingInfo);
                if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_dynamic_rendering");
                }
                VkCommandBufferInheritanceRenderingInfo* structure = (VkCommandBufferInheritanceRenderingInfo*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderingFlagBits, AllVkRenderingFlagBits,
                                      structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkCommandBufferInheritanceRenderingInfo-flags-parameter");

                skip |= ValidateRangedEnumArray(
                    pNext_loc.dot(Field::colorAttachmentCount), pNext_loc.dot(Field::pColorAttachmentFormats), vvl::Enum::VkFormat,
                    structure->colorAttachmentCount, structure->pColorAttachmentFormats, false, true, kVUIDUndefined,
                    "VUID-VkCommandBufferInheritanceRenderingInfo-pColorAttachmentFormats-parameter");

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::depthAttachmentFormat), vvl::Enum::VkFormat, structure->depthAttachmentFormat,
                    "VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::stencilAttachmentFormat), vvl::Enum::VkFormat, structure->stencilAttachmentFormat,
                    "VUID-VkCommandBufferInheritanceRenderingInfo-stencilAttachmentFormat-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pNext_loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, structure->rasterizationSamples, kOptionalSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkCommandBufferInheritanceRenderingInfo-rasterizationSamples-parameter");
            }
        } break;

        // Validation code for VkFormatProperties3 structure members
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: {  // Covers VUID-VkFormatProperties3-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_format_feature_flags2)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_format_feature_flags2))) {
                skip |= LogError(
                    pnext_vuid, instance, loc.dot(Field::pNext),
                    "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3), but its parent extension "
                    "VK_KHR_format_feature_flags2 has not been enabled.");
            }
        } break;

        // No Validation code for VkImageSwapchainCreateInfoKHR structure members  -- Covers
        // VUID-VkImageSwapchainCreateInfoKHR-sType-sType

        // Validation code for VkBindImageMemorySwapchainInfoKHR structure members
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: {  // Covers VUID-VkBindImageMemorySwapchainInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindImageMemorySwapchainInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_swapchain) && !IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_swapchain or VK_KHR_device_group");
                }
                VkBindImageMemorySwapchainInfoKHR* structure = (VkBindImageMemorySwapchainInfoKHR*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::swapchain), structure->swapchain);
            }
        } break;

        // Validation code for VkDeviceGroupPresentInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: {  // Covers VUID-VkDeviceGroupPresentInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupPresentInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_swapchain) && !IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_swapchain or VK_KHR_device_group");
                }
                VkDeviceGroupPresentInfoKHR* structure = (VkDeviceGroupPresentInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pDeviceMasks),
                                      structure->swapchainCount, &structure->pDeviceMasks, false, true, kVUIDUndefined,
                                      "VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::mode), vvl::FlagBitmask::VkDeviceGroupPresentModeFlagBitsKHR,
                                      AllVkDeviceGroupPresentModeFlagBitsKHR, structure->mode, kRequiredSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkDeviceGroupPresentInfoKHR-mode-parameter",
                                      "VUID-VkDeviceGroupPresentInfoKHR-mode-parameter");
            }
        } break;

        // Validation code for VkDeviceGroupSwapchainCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: {  // Covers
                                                                          // VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceGroupSwapchainCreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_swapchain) && !IsExtEnabled(device_extensions.vk_khr_device_group)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_swapchain or VK_KHR_device_group");
                }
                VkDeviceGroupSwapchainCreateInfoKHR* structure = (VkDeviceGroupSwapchainCreateInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::modes), vvl::FlagBitmask::VkDeviceGroupPresentModeFlagBitsKHR,
                                      AllVkDeviceGroupPresentModeFlagBitsKHR, structure->modes, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter",
                                      "VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask");
            }
        } break;

        // Validation code for VkDisplayPresentInfoKHR structure members
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: {  // Covers VUID-VkDisplayPresentInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDisplayPresentInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_display_swapchain)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_display_swapchain");
                }
                VkDisplayPresentInfoKHR* structure = (VkDisplayPresentInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::persistent), structure->persistent);
            }
        } break;

        // No Validation code for VkQueueFamilyQueryResultStatusPropertiesKHR structure members  -- Covers
        // VUID-VkQueueFamilyQueryResultStatusPropertiesKHR-sType-sType

        // No Validation code for VkQueueFamilyVideoPropertiesKHR structure members  -- Covers
        // VUID-VkQueueFamilyVideoPropertiesKHR-sType-sType

        // Validation code for VkVideoProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoProfileInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoProfileInfoKHR);
                VkVideoProfileInfoKHR* structure = (VkVideoProfileInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                                      AllVkVideoCodecOperationFlagBitsKHR, structure->videoCodecOperation, kRequiredSingleBit,
                                      VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                                      "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::chromaSubsampling), vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                                  AllVkVideoChromaSubsamplingFlagBitsKHR, structure->chromaSubsampling, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

                skip |= ValidateFlags(pNext_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                      AllVkVideoComponentBitDepthFlagBitsKHR, structure->lumaBitDepth, kRequiredFlags,
                                      VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                                      "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

                skip |= ValidateFlags(pNext_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                      AllVkVideoComponentBitDepthFlagBitsKHR, structure->chromaBitDepth, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
            }
        } break;

        // Validation code for VkVideoProfileListInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: {  // Covers VUID-VkVideoProfileListInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoProfileListInfoKHR);
                VkVideoProfileListInfoKHR* structure = (VkVideoProfileListInfoKHR*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::profileCount), pNext_loc.dot(Field::pProfiles), structure->profileCount,
                    structure->pProfiles, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, false, true,
                    "VUID-VkVideoProfileInfoKHR-sType-sType", "VUID-VkVideoProfileListInfoKHR-pProfiles-parameter", kVUIDUndefined);

                if (structure->pProfiles != nullptr) {
                    for (uint32_t profileIndex = 0; profileIndex < structure->profileCount; ++profileIndex) {
                        [[maybe_unused]] const Location pProfiles_loc = pNext_loc.dot(Field::pProfiles, profileIndex);
                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                            AllVkVideoCodecOperationFlagBitsKHR, structure->pProfiles[profileIndex].videoCodecOperation,
                            kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                            "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::chromaSubsampling), vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                            AllVkVideoChromaSubsamplingFlagBitsKHR, structure->pProfiles[profileIndex].chromaSubsampling,
                            kRequiredFlags, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                            "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                            AllVkVideoComponentBitDepthFlagBitsKHR, structure->pProfiles[profileIndex].lumaBitDepth, kRequiredFlags,
                            VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                            "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

                        skip |= ValidateFlags(
                            pProfiles_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                            AllVkVideoComponentBitDepthFlagBitsKHR, structure->pProfiles[profileIndex].chromaBitDepth,
                            kOptionalFlags, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
                    }
                }
            }
        } break;

        // No Validation code for VkVideoDecodeCapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoDecodeCapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeUsageInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR: {  // Covers VUID-VkVideoDecodeUsageInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeUsageInfoKHR);
                VkVideoDecodeUsageInfoKHR* structure = (VkVideoDecodeUsageInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::videoUsageHints), vvl::FlagBitmask::VkVideoDecodeUsageFlagBitsKHR,
                                      AllVkVideoDecodeUsageFlagBitsKHR, structure->videoUsageHints, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkVideoDecodeUsageInfoKHR-videoUsageHints-parameter");
            }
        } break;

        // No Validation code for VkVideoEncodeH264CapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoEncodeH264CapabilitiesKHR-sType-sType

        // No Validation code for VkVideoEncodeH264QualityLevelPropertiesKHR structure members  -- Covers
        // VUID-VkVideoEncodeH264QualityLevelPropertiesKHR-sType-sType

        // Validation code for VkVideoEncodeH264SessionCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR: {  // Covers
                                                                             // VUID-VkVideoEncodeH264SessionCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264SessionCreateInfoKHR);
                VkVideoEncodeH264SessionCreateInfoKHR* structure = (VkVideoEncodeH264SessionCreateInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxLevelIdc), structure->useMaxLevelIdc);
            }
        } break;

        // No Validation code for VkVideoEncodeH264SessionParametersAddInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-sType-sType

        // Validation code for VkVideoEncodeH264SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoEncodeH264SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264SessionParametersCreateInfoKHR);
                VkVideoEncodeH264SessionParametersCreateInfoKHR* structure =
                    (VkVideoEncodeH264SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoEncodeH264SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr) {
                    [[maybe_unused]] const Location pParametersAddInfo_loc = pNext_loc.dot(Field::pParametersAddInfo);
                }
            }
        } break;

        // Validation code for VkVideoEncodeH264SessionParametersGetInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoEncodeH264SessionParametersGetInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264SessionParametersGetInfoKHR);
                VkVideoEncodeH264SessionParametersGetInfoKHR* structure = (VkVideoEncodeH264SessionParametersGetInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdSPS), structure->writeStdSPS);

                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdPPS), structure->writeStdPPS);
            }
        } break;

        // No Validation code for VkVideoEncodeH264SessionParametersFeedbackInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeH264SessionParametersFeedbackInfoKHR-sType-sType

        // Validation code for VkVideoEncodeH264PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoEncodeH264PictureInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR);
                VkVideoEncodeH264PictureInfoKHR* structure = (VkVideoEncodeH264PictureInfoKHR*)header;
                skip |= ValidateStructTypeArray(pNext_loc.dot(Field::naluSliceEntryCount), pNext_loc.dot(Field::pNaluSliceEntries),
                                                structure->naluSliceEntryCount, structure->pNaluSliceEntries,
                                                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR, true, true,
                                                "VUID-VkVideoEncodeH264NaluSliceInfoKHR-sType-sType",
                                                "VUID-VkVideoEncodeH264PictureInfoKHR-pNaluSliceEntries-parameter",
                                                "VUID-VkVideoEncodeH264PictureInfoKHR-naluSliceEntryCount-arraylength");

                if (structure->pNaluSliceEntries != nullptr) {
                    for (uint32_t naluSliceEntryIndex = 0; naluSliceEntryIndex < structure->naluSliceEntryCount;
                         ++naluSliceEntryIndex) {
                        [[maybe_unused]] const Location pNaluSliceEntries_loc =
                            pNext_loc.dot(Field::pNaluSliceEntries, naluSliceEntryIndex);
                        skip |= ValidateRequiredPointer(pNaluSliceEntries_loc.dot(Field::pStdSliceHeader),
                                                        structure->pNaluSliceEntries[naluSliceEntryIndex].pStdSliceHeader,
                                                        "VUID-VkVideoEncodeH264NaluSliceInfoKHR-pStdSliceHeader-parameter");
                    }
                }

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoEncodeH264PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateBool32(pNext_loc.dot(Field::generatePrefixNalu), structure->generatePrefixNalu);
            }
        } break;

        // Validation code for VkVideoEncodeH264DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoEncodeH264DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264DpbSlotInfoKHR);
                VkVideoEncodeH264DpbSlotInfoKHR* structure = (VkVideoEncodeH264DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoEncodeH264DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // No Validation code for VkVideoEncodeH264ProfileInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeH264ProfileInfoKHR-sType-sType

        // Validation code for VkVideoEncodeH264RateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR: {  // Covers
                                                                           // VUID-VkVideoEncodeH264RateControlInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264RateControlInfoKHR);
                VkVideoEncodeH264RateControlInfoKHR* structure = (VkVideoEncodeH264RateControlInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoEncodeH264RateControlFlagBitsKHR,
                                      AllVkVideoEncodeH264RateControlFlagBitsKHR, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkVideoEncodeH264RateControlInfoKHR-flags-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH264RateControlLayerInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR: {  // Covers
                                                                                 // VUID-VkVideoEncodeH264RateControlLayerInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264RateControlLayerInfoKHR);
                VkVideoEncodeH264RateControlLayerInfoKHR* structure = (VkVideoEncodeH264RateControlLayerInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMinQp), structure->useMinQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxQp), structure->useMaxQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxFrameSize), structure->useMaxFrameSize);
            }
        } break;

        // Validation code for VkVideoEncodeH264GopRemainingFrameInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeH264GopRemainingFrameInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH264GopRemainingFrameInfoKHR);
                VkVideoEncodeH264GopRemainingFrameInfoKHR* structure = (VkVideoEncodeH264GopRemainingFrameInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useGopRemainingFrames), structure->useGopRemainingFrames);
            }
        } break;

        // No Validation code for VkVideoEncodeH265CapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoEncodeH265CapabilitiesKHR-sType-sType

        // Validation code for VkVideoEncodeH265SessionCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR: {  // Covers
                                                                             // VUID-VkVideoEncodeH265SessionCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265SessionCreateInfoKHR);
                VkVideoEncodeH265SessionCreateInfoKHR* structure = (VkVideoEncodeH265SessionCreateInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxLevelIdc), structure->useMaxLevelIdc);
            }
        } break;

        // No Validation code for VkVideoEncodeH265QualityLevelPropertiesKHR structure members  -- Covers
        // VUID-VkVideoEncodeH265QualityLevelPropertiesKHR-sType-sType

        // No Validation code for VkVideoEncodeH265SessionParametersAddInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-sType-sType

        // Validation code for VkVideoEncodeH265SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoEncodeH265SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265SessionParametersCreateInfoKHR);
                VkVideoEncodeH265SessionParametersCreateInfoKHR* structure =
                    (VkVideoEncodeH265SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoEncodeH265SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr) {
                    [[maybe_unused]] const Location pParametersAddInfo_loc = pNext_loc.dot(Field::pParametersAddInfo);
                }
            }
        } break;

        // Validation code for VkVideoEncodeH265SessionParametersGetInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoEncodeH265SessionParametersGetInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265SessionParametersGetInfoKHR);
                VkVideoEncodeH265SessionParametersGetInfoKHR* structure = (VkVideoEncodeH265SessionParametersGetInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdVPS), structure->writeStdVPS);

                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdSPS), structure->writeStdSPS);

                skip |= ValidateBool32(pNext_loc.dot(Field::writeStdPPS), structure->writeStdPPS);
            }
        } break;

        // No Validation code for VkVideoEncodeH265SessionParametersFeedbackInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeH265SessionParametersFeedbackInfoKHR-sType-sType

        // Validation code for VkVideoEncodeH265PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoEncodeH265PictureInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265PictureInfoKHR);
                VkVideoEncodeH265PictureInfoKHR* structure = (VkVideoEncodeH265PictureInfoKHR*)header;
                skip |= ValidateStructTypeArray(pNext_loc.dot(Field::naluSliceSegmentEntryCount),
                                                pNext_loc.dot(Field::pNaluSliceSegmentEntries),
                                                structure->naluSliceSegmentEntryCount, structure->pNaluSliceSegmentEntries,
                                                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR, true, true,
                                                "VUID-VkVideoEncodeH265NaluSliceSegmentInfoKHR-sType-sType",
                                                "VUID-VkVideoEncodeH265PictureInfoKHR-pNaluSliceSegmentEntries-parameter",
                                                "VUID-VkVideoEncodeH265PictureInfoKHR-naluSliceSegmentEntryCount-arraylength");

                if (structure->pNaluSliceSegmentEntries != nullptr) {
                    for (uint32_t naluSliceSegmentEntryIndex = 0;
                         naluSliceSegmentEntryIndex < structure->naluSliceSegmentEntryCount; ++naluSliceSegmentEntryIndex) {
                        [[maybe_unused]] const Location pNaluSliceSegmentEntries_loc =
                            pNext_loc.dot(Field::pNaluSliceSegmentEntries, naluSliceSegmentEntryIndex);
                        skip |= ValidateRequiredPointer(
                            pNaluSliceSegmentEntries_loc.dot(Field::pStdSliceSegmentHeader),
                            structure->pNaluSliceSegmentEntries[naluSliceSegmentEntryIndex].pStdSliceSegmentHeader,
                            "VUID-VkVideoEncodeH265NaluSliceSegmentInfoKHR-pStdSliceSegmentHeader-parameter");
                    }
                }

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoEncodeH265PictureInfoKHR-pStdPictureInfo-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH265DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoEncodeH265DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265DpbSlotInfoKHR);
                VkVideoEncodeH265DpbSlotInfoKHR* structure = (VkVideoEncodeH265DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoEncodeH265DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // No Validation code for VkVideoEncodeH265ProfileInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeH265ProfileInfoKHR-sType-sType

        // Validation code for VkVideoEncodeH265RateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR: {  // Covers
                                                                           // VUID-VkVideoEncodeH265RateControlInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265RateControlInfoKHR);
                VkVideoEncodeH265RateControlInfoKHR* structure = (VkVideoEncodeH265RateControlInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoEncodeH265RateControlFlagBitsKHR,
                                      AllVkVideoEncodeH265RateControlFlagBitsKHR, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkVideoEncodeH265RateControlInfoKHR-flags-parameter");
            }
        } break;

        // Validation code for VkVideoEncodeH265RateControlLayerInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR: {  // Covers
                                                                                 // VUID-VkVideoEncodeH265RateControlLayerInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265RateControlLayerInfoKHR);
                VkVideoEncodeH265RateControlLayerInfoKHR* structure = (VkVideoEncodeH265RateControlLayerInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useMinQp), structure->useMinQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxQp), structure->useMaxQp);

                skip |= ValidateBool32(pNext_loc.dot(Field::useMaxFrameSize), structure->useMaxFrameSize);
            }
        } break;

        // Validation code for VkVideoEncodeH265GopRemainingFrameInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR: {  // Covers
                                                                                  // VUID-VkVideoEncodeH265GopRemainingFrameInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeH265GopRemainingFrameInfoKHR);
                VkVideoEncodeH265GopRemainingFrameInfoKHR* structure = (VkVideoEncodeH265GopRemainingFrameInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::useGopRemainingFrames), structure->useGopRemainingFrames);
            }
        } break;

        // Validation code for VkVideoDecodeH264ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH264ProfileInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264ProfileInfoKHR);
                VkVideoDecodeH264ProfileInfoKHR* structure = (VkVideoDecodeH264ProfileInfoKHR*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::pictureLayout), vvl::FlagBitmask::VkVideoDecodeH264PictureLayoutFlagBitsKHR,
                                  AllVkVideoDecodeH264PictureLayoutFlagBitsKHR, structure->pictureLayout, kOptionalSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkVideoDecodeH264ProfileInfoKHR-pictureLayout-parameter");
            }
        } break;

        // No Validation code for VkVideoDecodeH264CapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoDecodeH264CapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeH264SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264SessionParametersAddInfoKHR);
                VkVideoDecodeH264SessionParametersAddInfoKHR* structure = (VkVideoDecodeH264SessionParametersAddInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::stdSPSCount), pNext_loc.dot(Field::pStdSPSs), structure->stdSPSCount,
                                      &structure->pStdSPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdSPSs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::stdPPSCount), pNext_loc.dot(Field::pStdPPSs), structure->stdPPSCount,
                                      &structure->pStdPPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdPPSs-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoDecodeH264SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264SessionParametersCreateInfoKHR);
                VkVideoDecodeH264SessionParametersCreateInfoKHR* structure =
                    (VkVideoDecodeH264SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoDecodeH264SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr) {
                    [[maybe_unused]] const Location pParametersAddInfo_loc = pNext_loc.dot(Field::pParametersAddInfo);
                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdSPSCount), pParametersAddInfo_loc.dot(Field::pStdSPSs),
                                      structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdSPSs-parameter");

                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdPPSCount), pParametersAddInfo_loc.dot(Field::pStdPPSs),
                                      structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-pStdPPSs-parameter");
                }
            }
        } break;

        // Validation code for VkVideoDecodeH264PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH264PictureInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264PictureInfoKHR);
                VkVideoDecodeH264PictureInfoKHR* structure = (VkVideoDecodeH264PictureInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoDecodeH264PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::sliceCount), pNext_loc.dot(Field::pSliceOffsets), structure->sliceCount,
                                      &structure->pSliceOffsets, true, true,
                                      "VUID-VkVideoDecodeH264PictureInfoKHR-sliceCount-arraylength",
                                      "VUID-VkVideoDecodeH264PictureInfoKHR-pSliceOffsets-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH264DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoDecodeH264DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH264DpbSlotInfoKHR);
                VkVideoDecodeH264DpbSlotInfoKHR* structure = (VkVideoDecodeH264DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoDecodeH264DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkRenderingFragmentShadingRateAttachmentInfoKHR structure members
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {  // Covers
                                                                                       // VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_dynamic_rendering");
                }
                VkRenderingFragmentShadingRateAttachmentInfoKHR* structure =
                    (VkRenderingFragmentShadingRateAttachmentInfoKHR*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, structure->imageLayout,
                                           "VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageLayout-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkRenderingFragmentDensityMapAttachmentInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: {  // Covers
                                                                                      // VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderingFragmentDensityMapAttachmentInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_dynamic_rendering");
                }
                VkRenderingFragmentDensityMapAttachmentInfoEXT* structure = (VkRenderingFragmentDensityMapAttachmentInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::imageView), structure->imageView);

                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, structure->imageLayout,
                                       "VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageLayout-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkAttachmentSampleCountInfoAMD structure members
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: {  // Covers VUID-VkAttachmentSampleCountInfoAMD-sType-sType

            if ((is_physdev_api && !SupportedByPdev(physical_device, vvl::Extension::_VK_KHR_dynamic_rendering)) ||
                (!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))) {
                skip |= LogError(pnext_vuid, instance, loc.dot(Field::pNext),
                                 "includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD), "
                                 "but its parent extension "
                                 "VK_KHR_dynamic_rendering has not been enabled.");
            }
        } break;

        // Validation code for VkMultiviewPerViewAttributesInfoNVX structure members
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: {  // Covers
                                                                          // VUID-VkMultiviewPerViewAttributesInfoNVX-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMultiviewPerViewAttributesInfoNVX);
                if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_dynamic_rendering");
                }
                VkMultiviewPerViewAttributesInfoNVX* structure = (VkMultiviewPerViewAttributesInfoNVX*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::perViewAttributes), structure->perViewAttributes);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::perViewAttributesPositionXOnly), structure->perViewAttributesPositionXOnly);
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryWin32HandleInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: {  // Covers VUID-VkImportMemoryWin32HandleInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryWin32HandleInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_external_memory_win32)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_external_memory_win32");
                }
                VkImportMemoryWin32HandleInfoKHR* structure = (VkImportMemoryWin32HandleInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      VK_NULL_HANDLE, "VUID-VkImportMemoryWin32HandleInfoKHR-handleType-parameter");
            }
        } break;

        // No Validation code for VkExportMemoryWin32HandleInfoKHR structure members  -- Covers
        // VUID-VkExportMemoryWin32HandleInfoKHR-sType-sType
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryFdInfoKHR structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: {  // Covers VUID-VkImportMemoryFdInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryFdInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_external_memory_fd)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_external_memory_fd");
                }
                VkImportMemoryFdInfoKHR* structure = (VkImportMemoryFdInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      VK_NULL_HANDLE, "VUID-VkImportMemoryFdInfoKHR-handleType-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkWin32KeyedMutexAcquireReleaseInfoKHR structure members
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {  // Covers
                                                                              // VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWin32KeyedMutexAcquireReleaseInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_win32_keyed_mutex)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_win32_keyed_mutex");
                }
                VkWin32KeyedMutexAcquireReleaseInfoKHR* structure = (VkWin32KeyedMutexAcquireReleaseInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireSyncs),
                                      structure->acquireCount, &structure->pAcquireSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireKeys),
                                      structure->acquireCount, &structure->pAcquireKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireKeys-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireTimeouts),
                                      structure->acquireCount, &structure->pAcquireTimeouts, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireTimeouts-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseSyncs),
                                      structure->releaseCount, &structure->pReleaseSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseKeys),
                                      structure->releaseCount, &structure->pReleaseKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseKeys-parameter");
            }
        } break;

        // No Validation code for VkExportSemaphoreWin32HandleInfoKHR structure members  -- Covers
        // VUID-VkExportSemaphoreWin32HandleInfoKHR-sType-sType

        // No Validation code for VkD3D12FenceSubmitInfoKHR structure members  -- Covers VUID-VkD3D12FenceSubmitInfoKHR-sType-sType
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkPresentRegionsKHR structure members
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: {  // Covers VUID-VkPresentRegionsKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPresentRegionsKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_incremental_present)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_incremental_present");
                }
                VkPresentRegionsKHR* structure = (VkPresentRegionsKHR*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pRegions), structure->swapchainCount,
                                  &structure->pRegions, true, false, "VUID-VkPresentRegionsKHR-swapchainCount-arraylength",
                                  "VUID-VkPresentRegionsKHR-pRegions-parameter");

                if (structure->pRegions != nullptr) {
                    for (uint32_t swapchainIndex = 0; swapchainIndex < structure->swapchainCount; ++swapchainIndex) {
                        [[maybe_unused]] const Location pRegions_loc = pNext_loc.dot(Field::pRegions, swapchainIndex);
                        if (structure->pRegions[swapchainIndex].pRectangles != nullptr) {
                            for (uint32_t rectangleIndex = 0; rectangleIndex < structure->pRegions[swapchainIndex].rectangleCount;
                                 ++rectangleIndex) {
                                [[maybe_unused]] const Location pRectangles_loc =
                                    pRegions_loc.dot(Field::pRectangles, rectangleIndex);
                            }
                        }
                    }
                }
            }
        } break;

        // No Validation code for VkSharedPresentSurfaceCapabilitiesKHR structure members  -- Covers
        // VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkExportFenceWin32HandleInfoKHR structure members  -- Covers
        // VUID-VkExportFenceWin32HandleInfoKHR-sType-sType
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkQueryPoolPerformanceCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: {  // Covers
                                                                          // VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryPoolPerformanceCreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_performance_query)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_performance_query");
                }
                VkQueryPoolPerformanceCreateInfoKHR* structure = (VkQueryPoolPerformanceCreateInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::counterIndexCount), pNext_loc.dot(Field::pCounterIndices),
                                      structure->counterIndexCount, &structure->pCounterIndices, true, true,
                                      "VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength",
                                      "VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter");
            }
        } break;

        // No Validation code for VkPerformanceQuerySubmitInfoKHR structure members  -- Covers
        // VUID-VkPerformanceQuerySubmitInfoKHR-sType-sType

        // No Validation code for VkVideoDecodeH265ProfileInfoKHR structure members  -- Covers
        // VUID-VkVideoDecodeH265ProfileInfoKHR-sType-sType

        // No Validation code for VkVideoDecodeH265CapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoDecodeH265CapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeH265SessionParametersAddInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR: {  // Covers
                                                                                     // VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265SessionParametersAddInfoKHR);
                VkVideoDecodeH265SessionParametersAddInfoKHR* structure = (VkVideoDecodeH265SessionParametersAddInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::stdVPSCount), pNext_loc.dot(Field::pStdVPSs), structure->stdVPSCount,
                                      &structure->pStdVPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdVPSs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::stdSPSCount), pNext_loc.dot(Field::pStdSPSs), structure->stdSPSCount,
                                      &structure->pStdSPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdSPSs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::stdPPSCount), pNext_loc.dot(Field::pStdPPSs), structure->stdPPSCount,
                                      &structure->pStdPPSs, false, true, kVUIDUndefined,
                                      "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdPPSs-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH265SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                        // VUID-VkVideoDecodeH265SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265SessionParametersCreateInfoKHR);
                VkVideoDecodeH265SessionParametersCreateInfoKHR* structure =
                    (VkVideoDecodeH265SessionParametersCreateInfoKHR*)header;
                skip |= ValidateStructType(pNext_loc.dot(Field::pParametersAddInfo), structure->pParametersAddInfo,
                                           VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, false,
                                           "VUID-VkVideoDecodeH265SessionParametersCreateInfoKHR-pParametersAddInfo-parameter",
                                           "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-sType-sType");

                if (structure->pParametersAddInfo != nullptr) {
                    [[maybe_unused]] const Location pParametersAddInfo_loc = pNext_loc.dot(Field::pParametersAddInfo);
                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdVPSCount), pParametersAddInfo_loc.dot(Field::pStdVPSs),
                                      structure->pParametersAddInfo->stdVPSCount, &structure->pParametersAddInfo->pStdVPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdVPSs-parameter");

                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdSPSCount), pParametersAddInfo_loc.dot(Field::pStdSPSs),
                                      structure->pParametersAddInfo->stdSPSCount, &structure->pParametersAddInfo->pStdSPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdSPSs-parameter");

                    skip |=
                        ValidateArray(pParametersAddInfo_loc.dot(Field::stdPPSCount), pParametersAddInfo_loc.dot(Field::pStdPPSs),
                                      structure->pParametersAddInfo->stdPPSCount, &structure->pParametersAddInfo->pStdPPSs, false,
                                      true, kVUIDUndefined, "VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-pStdPPSs-parameter");
                }
            }
        } break;

        // Validation code for VkVideoDecodeH265PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoDecodeH265PictureInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265PictureInfoKHR);
                VkVideoDecodeH265PictureInfoKHR* structure = (VkVideoDecodeH265PictureInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoDecodeH265PictureInfoKHR-pStdPictureInfo-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::sliceSegmentCount), pNext_loc.dot(Field::pSliceSegmentOffsets),
                                      structure->sliceSegmentCount, &structure->pSliceSegmentOffsets, true, true,
                                      "VUID-VkVideoDecodeH265PictureInfoKHR-sliceSegmentCount-arraylength",
                                      "VUID-VkVideoDecodeH265PictureInfoKHR-pSliceSegmentOffsets-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeH265DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoDecodeH265DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeH265DpbSlotInfoKHR);
                VkVideoDecodeH265DpbSlotInfoKHR* structure = (VkVideoDecodeH265DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoDecodeH265DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // Validation code for VkDeviceQueueGlobalPriorityCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: {  // Covers
                                                                                // VUID-VkDeviceQueueGlobalPriorityCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceQueueGlobalPriorityCreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_global_priority) &&
                    !IsExtEnabled(device_extensions.vk_ext_global_priority)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_global_priority or VK_EXT_global_priority");
                }
                VkDeviceQueueGlobalPriorityCreateInfoKHR* structure = (VkDeviceQueueGlobalPriorityCreateInfoKHR*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::globalPriority), vvl::Enum::VkQueueGlobalPriorityKHR, structure->globalPriority,
                    "VUID-VkDeviceQueueGlobalPriorityCreateInfoKHR-globalPriority-parameter", VK_NULL_HANDLE);
            }
        } break;

        // No Validation code for VkQueueFamilyGlobalPriorityPropertiesKHR structure members  -- Covers
        // VUID-VkQueueFamilyGlobalPriorityPropertiesKHR-sType-sType

        // Validation code for VkFragmentShadingRateAttachmentInfoKHR structure members
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: {  // Covers
                                                                             // VUID-VkFragmentShadingRateAttachmentInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkFragmentShadingRateAttachmentInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_fragment_shading_rate)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_fragment_shading_rate");
                }
                VkFragmentShadingRateAttachmentInfoKHR* structure = (VkFragmentShadingRateAttachmentInfoKHR*)header;
                skip |=
                    ValidateStructType(pNext_loc.dot(Field::pFragmentShadingRateAttachment),
                                       structure->pFragmentShadingRateAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                                       "VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-parameter",
                                       "VUID-VkAttachmentReference2-sType-sType");

                if (structure->pFragmentShadingRateAttachment != nullptr) {
                    [[maybe_unused]] const Location pFragmentShadingRateAttachment_loc =
                        pNext_loc.dot(Field::pFragmentShadingRateAttachment);
                    skip |= ValidateRangedEnum(pFragmentShadingRateAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               structure->pFragmentShadingRateAttachment->layout,
                                               "VUID-VkAttachmentReference2-layout-parameter", VK_NULL_HANDLE);
                }
            }
        } break;

        // No Validation code for VkPipelineFragmentShadingRateStateCreateInfoKHR structure members  -- Covers
        // VUID-VkPipelineFragmentShadingRateStateCreateInfoKHR-sType-sType

        // No Validation code for VkRenderingAttachmentLocationInfoKHR structure members  -- Covers
        // VUID-VkRenderingAttachmentLocationInfoKHR-sType-sType

        // No Validation code for VkRenderingInputAttachmentIndexInfoKHR structure members  -- Covers
        // VUID-VkRenderingInputAttachmentIndexInfoKHR-sType-sType

        // No Validation code for VkSurfaceProtectedCapabilitiesKHR structure members  -- Covers
        // VUID-VkSurfaceProtectedCapabilitiesKHR-sType-sType

        // Validation code for VkPipelineLibraryCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {  // Covers VUID-VkPipelineLibraryCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineLibraryCreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_pipeline_library)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_pipeline_library");
                }
                VkPipelineLibraryCreateInfoKHR* structure = (VkPipelineLibraryCreateInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::libraryCount), pNext_loc.dot(Field::pLibraries), structure->libraryCount,
                                      &structure->pLibraries, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }
        } break;

        // Validation code for VkPresentIdKHR structure members
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR: {  // Covers VUID-VkPresentIdKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPresentIdKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_present_id)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_present_id");
                }
                VkPresentIdKHR* structure = (VkPresentIdKHR*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pPresentIds),
                                  structure->swapchainCount, &structure->pPresentIds, true, false,
                                  "VUID-VkPresentIdKHR-swapchainCount-arraylength", "VUID-VkPresentIdKHR-pPresentIds-parameter");
            }
        } break;

        // No Validation code for VkVideoEncodeCapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoEncodeCapabilitiesKHR-sType-sType

        // Validation code for VkQueryPoolVideoEncodeFeedbackCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR: {  // Covers
                                                                                    // VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryPoolVideoEncodeFeedbackCreateInfoKHR);
                VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* structure = (VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*)header;
                skip |=
                    ValidateFlags(pNext_loc.dot(Field::encodeFeedbackFlags), vvl::FlagBitmask::VkVideoEncodeFeedbackFlagBitsKHR,
                                  AllVkVideoEncodeFeedbackFlagBitsKHR, structure->encodeFeedbackFlags, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-encodeFeedbackFlags-parameter",
                                  "VUID-VkQueryPoolVideoEncodeFeedbackCreateInfoKHR-encodeFeedbackFlags-requiredbitmask");
            }
        } break;

        // Validation code for VkVideoEncodeUsageInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR: {  // Covers VUID-VkVideoEncodeUsageInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeUsageInfoKHR);
                VkVideoEncodeUsageInfoKHR* structure = (VkVideoEncodeUsageInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::videoUsageHints), vvl::FlagBitmask::VkVideoEncodeUsageFlagBitsKHR,
                                      AllVkVideoEncodeUsageFlagBitsKHR, structure->videoUsageHints, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkVideoEncodeUsageInfoKHR-videoUsageHints-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::videoContentHints), vvl::FlagBitmask::VkVideoEncodeContentFlagBitsKHR,
                                      AllVkVideoEncodeContentFlagBitsKHR, structure->videoContentHints, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkVideoEncodeUsageInfoKHR-videoContentHints-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::tuningMode), vvl::Enum::VkVideoEncodeTuningModeKHR,
                                           structure->tuningMode, "VUID-VkVideoEncodeUsageInfoKHR-tuningMode-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkVideoEncodeRateControlInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR: {  // Covers VUID-VkVideoEncodeRateControlInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoEncodeRateControlInfoKHR);
                VkVideoEncodeRateControlInfoKHR* structure = (VkVideoEncodeRateControlInfoKHR*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkVideoEncodeRateControlInfoKHR-flags-zerobitmask");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::rateControlMode), vvl::FlagBitmask::VkVideoEncodeRateControlModeFlagBitsKHR,
                                  AllVkVideoEncodeRateControlModeFlagBitsKHR, structure->rateControlMode, kOptionalSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkVideoEncodeRateControlInfoKHR-rateControlMode-parameter");

                skip |=
                    ValidateStructTypeArray(pNext_loc.dot(Field::layerCount), pNext_loc.dot(Field::pLayers), structure->layerCount,
                                            structure->pLayers, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR, false,
                                            true, "VUID-VkVideoEncodeRateControlLayerInfoKHR-sType-sType",
                                            "VUID-VkVideoEncodeRateControlInfoKHR-pLayers-parameter", kVUIDUndefined);

                if (structure->pLayers != nullptr) {
                    for (uint32_t layerIndex = 0; layerIndex < structure->layerCount; ++layerIndex) {
                        [[maybe_unused]] const Location pLayers_loc = pNext_loc.dot(Field::pLayers, layerIndex);
                    }
                }
            }
        } break;

        // No Validation code for VkVideoEncodeQualityLevelInfoKHR structure members  -- Covers
        // VUID-VkVideoEncodeQualityLevelInfoKHR-sType-sType

        // No Validation code for VkQueueFamilyCheckpointProperties2NV structure members  -- Covers
        // VUID-VkQueueFamilyCheckpointProperties2NV-sType-sType

        // Validation code for VkPipelineCreateFlags2CreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR: {  // Covers
                                                                           // VUID-VkPipelineCreateFlags2CreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCreateFlags2CreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance5)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance5");
                }
                VkPipelineCreateFlags2CreateInfoKHR* structure = (VkPipelineCreateFlags2CreateInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineCreateFlagBits2KHR,
                                      AllVkPipelineCreateFlagBits2KHR, structure->flags, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkPipelineCreateFlags2CreateInfoKHR-flags-parameter",
                                      "VUID-VkPipelineCreateFlags2CreateInfoKHR-flags-requiredbitmask");
            }
        } break;

        // Validation code for VkBufferUsageFlags2CreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR: {  // Covers VUID-VkBufferUsageFlags2CreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBufferUsageFlags2CreateInfoKHR);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_khr_maintenance5))) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance5");
                }
                VkBufferUsageFlags2CreateInfoKHR* structure = (VkBufferUsageFlags2CreateInfoKHR*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::usage), vvl::FlagBitmask::VkBufferUsageFlagBits2KHR,
                                      AllVkBufferUsageFlagBits2KHR, structure->usage, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkBufferUsageFlags2CreateInfoKHR-usage-parameter",
                                      "VUID-VkBufferUsageFlags2CreateInfoKHR-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkDevicePipelineBinaryInternalCacheControlKHR structure members
        case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR: {  // Covers
                                                                                     // VUID-VkDevicePipelineBinaryInternalCacheControlKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDevicePipelineBinaryInternalCacheControlKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_pipeline_binary");
                }
                VkDevicePipelineBinaryInternalCacheControlKHR* structure = (VkDevicePipelineBinaryInternalCacheControlKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::disableInternalCache), structure->disableInternalCache);
            }
        } break;

        // Validation code for VkPipelineBinaryInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR: {  // Covers VUID-VkPipelineBinaryInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineBinaryInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_pipeline_binary");
                }
                VkPipelineBinaryInfoKHR* structure = (VkPipelineBinaryInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::binaryCount), pNext_loc.dot(Field::pPipelineBinaries),
                                      structure->binaryCount, &structure->pPipelineBinaries, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineBinaryInfoKHR-pPipelineBinaries-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeAV1ProfileInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR: {  // Covers VUID-VkVideoDecodeAV1ProfileInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1ProfileInfoKHR);
                VkVideoDecodeAV1ProfileInfoKHR* structure = (VkVideoDecodeAV1ProfileInfoKHR*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::filmGrainSupport), structure->filmGrainSupport);
            }
        } break;

        // No Validation code for VkVideoDecodeAV1CapabilitiesKHR structure members  -- Covers
        // VUID-VkVideoDecodeAV1CapabilitiesKHR-sType-sType

        // Validation code for VkVideoDecodeAV1SessionParametersCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR: {  // Covers
                                                                                       // VUID-VkVideoDecodeAV1SessionParametersCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1SessionParametersCreateInfoKHR);
                VkVideoDecodeAV1SessionParametersCreateInfoKHR* structure = (VkVideoDecodeAV1SessionParametersCreateInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdSequenceHeader), structure->pStdSequenceHeader,
                                                "VUID-VkVideoDecodeAV1SessionParametersCreateInfoKHR-pStdSequenceHeader-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeAV1PictureInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR: {  // Covers VUID-VkVideoDecodeAV1PictureInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR);
                VkVideoDecodeAV1PictureInfoKHR* structure = (VkVideoDecodeAV1PictureInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdPictureInfo), structure->pStdPictureInfo,
                                                "VUID-VkVideoDecodeAV1PictureInfoKHR-pStdPictureInfo-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::tileCount), pNext_loc.dot(Field::pTileOffsets), structure->tileCount,
                                  &structure->pTileOffsets, true, true, "VUID-VkVideoDecodeAV1PictureInfoKHR-tileCount-arraylength",
                                  "VUID-VkVideoDecodeAV1PictureInfoKHR-pTileOffsets-parameter");

                skip |=
                    ValidateArray(pNext_loc.dot(Field::tileCount), pNext_loc.dot(Field::pTileSizes), structure->tileCount,
                                  &structure->pTileSizes, true, true, "VUID-VkVideoDecodeAV1PictureInfoKHR-tileCount-arraylength",
                                  "VUID-VkVideoDecodeAV1PictureInfoKHR-pTileSizes-parameter");
            }
        } break;

        // Validation code for VkVideoDecodeAV1DpbSlotInfoKHR structure members
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR: {  // Covers VUID-VkVideoDecodeAV1DpbSlotInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkVideoDecodeAV1DpbSlotInfoKHR);
                VkVideoDecodeAV1DpbSlotInfoKHR* structure = (VkVideoDecodeAV1DpbSlotInfoKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pStdReferenceInfo), structure->pStdReferenceInfo,
                                                "VUID-VkVideoDecodeAV1DpbSlotInfoKHR-pStdReferenceInfo-parameter");
            }
        } break;

        // No Validation code for VkVideoInlineQueryInfoKHR structure members  -- Covers VUID-VkVideoInlineQueryInfoKHR-sType-sType

        // Validation code for VkPipelineVertexInputDivisorStateCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR: {  // Covers
                                                                                       // VUID-VkPipelineVertexInputDivisorStateCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineVertexInputDivisorStateCreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_vertex_attribute_divisor) &&
                    !IsExtEnabled(device_extensions.vk_ext_vertex_attribute_divisor)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_vertex_attribute_divisor or "
                                     "VK_EXT_vertex_attribute_divisor");
                }
                VkPipelineVertexInputDivisorStateCreateInfoKHR* structure = (VkPipelineVertexInputDivisorStateCreateInfoKHR*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::vertexBindingDivisorCount), pNext_loc.dot(Field::pVertexBindingDivisors),
                                      structure->vertexBindingDivisorCount, &structure->pVertexBindingDivisors, true, true,
                                      "VUID-VkPipelineVertexInputDivisorStateCreateInfoKHR-vertexBindingDivisorCount-arraylength",
                                      "VUID-VkPipelineVertexInputDivisorStateCreateInfoKHR-pVertexBindingDivisors-parameter");

                if (structure->pVertexBindingDivisors != nullptr) {
                    for (uint32_t vertexBindingDivisorIndex = 0; vertexBindingDivisorIndex < structure->vertexBindingDivisorCount;
                         ++vertexBindingDivisorIndex) {
                        [[maybe_unused]] const Location pVertexBindingDivisors_loc =
                            pNext_loc.dot(Field::pVertexBindingDivisors, vertexBindingDivisorIndex);
                    }
                }
            }
        } break;

        // Validation code for VkPipelineRasterizationLineStateCreateInfoKHR structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR: {  // Covers
                                                                                     // VUID-VkPipelineRasterizationLineStateCreateInfoKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationLineStateCreateInfoKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_line_rasterization) &&
                    !IsExtEnabled(device_extensions.vk_ext_line_rasterization)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc,
                                 "extended struct requires the extensions VK_KHR_line_rasterization or VK_EXT_line_rasterization");
                }
                VkPipelineRasterizationLineStateCreateInfoKHR* structure = (VkPipelineRasterizationLineStateCreateInfoKHR*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::lineRasterizationMode), vvl::Enum::VkLineRasterizationModeKHR,
                                           structure->lineRasterizationMode,
                                           "VUID-VkPipelineRasterizationLineStateCreateInfoKHR-lineRasterizationMode-parameter",
                                           VK_NULL_HANDLE);

                skip |= ValidateBool32(pNext_loc.dot(Field::stippledLineEnable), structure->stippledLineEnable);
            }
        } break;

        // Validation code for VkBindMemoryStatusKHR structure members
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR: {  // Covers VUID-VkBindMemoryStatusKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBindMemoryStatusKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_maintenance6)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_KHR_maintenance6");
                }
                VkBindMemoryStatusKHR* structure = (VkBindMemoryStatusKHR*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pResult), structure->pResult,
                                                "VUID-VkBindMemoryStatusKHR-pResult-parameter");
            }
        } break;

        // No Validation code for VkPhysicalDeviceLayeredApiVulkanPropertiesKHR structure members  -- Covers
        // VUID-VkPhysicalDeviceLayeredApiVulkanPropertiesKHR-sType-sType

        // Validation code for VkDebugReportCallbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: {  // Covers
                                                                         // VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDebugReportCallbackCreateInfoEXT);
                VkDebugReportCallbackCreateInfoEXT* structure = (VkDebugReportCallbackCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkDebugReportFlagBitsEXT,
                                      AllVkDebugReportFlagBitsEXT, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pfnCallback),
                                                reinterpret_cast<const void*>(structure->pfnCallback),
                                                "VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter");
            }
        } break;

        // Validation code for VkPipelineRasterizationStateRasterizationOrderAMD structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: {  // Covers
                                                                                        // VUID-VkPipelineRasterizationStateRasterizationOrderAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationStateRasterizationOrderAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_rasterization_order)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_AMD_rasterization_order");
                }
                VkPipelineRasterizationStateRasterizationOrderAMD* structure =
                    (VkPipelineRasterizationStateRasterizationOrderAMD*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::rasterizationOrder), vvl::Enum::VkRasterizationOrderAMD, structure->rasterizationOrder,
                    "VUID-VkPipelineRasterizationStateRasterizationOrderAMD-rasterizationOrder-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkDedicatedAllocationImageCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: {  // Covers
                                                                             // VUID-VkDedicatedAllocationImageCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDedicatedAllocationImageCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_dedicated_allocation)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_dedicated_allocation");
                }
                VkDedicatedAllocationImageCreateInfoNV* structure = (VkDedicatedAllocationImageCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dedicatedAllocation), structure->dedicatedAllocation);
            }
        } break;

        // Validation code for VkDedicatedAllocationBufferCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: {  // Covers
                                                                              // VUID-VkDedicatedAllocationBufferCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDedicatedAllocationBufferCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_dedicated_allocation)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_dedicated_allocation");
                }
                VkDedicatedAllocationBufferCreateInfoNV* structure = (VkDedicatedAllocationBufferCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::dedicatedAllocation), structure->dedicatedAllocation);
            }
        } break;

        // No Validation code for VkDedicatedAllocationMemoryAllocateInfoNV structure members  -- Covers
        // VUID-VkDedicatedAllocationMemoryAllocateInfoNV-sType-sType

        // Validation code for VkPipelineRasterizationStateStreamCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: {  // Covers
                                                                                       // VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationStateStreamCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_transform_feedback");
                }
                VkPipelineRasterizationStateStreamCreateInfoEXT* structure =
                    (VkPipelineRasterizationStateStreamCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-flags-zerobitmask");
            }
        } break;

        // No Validation code for VkTextureLODGatherFormatPropertiesAMD structure members  -- Covers
        // VUID-VkTextureLODGatherFormatPropertiesAMD-sType-sType

        // Validation code for VkExternalMemoryImageCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: {  // Covers VUID-VkExternalMemoryImageCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryImageCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_external_memory)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_external_memory");
                }
                VkExternalMemoryImageCreateInfoNV* structure = (VkExternalMemoryImageCreateInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                      AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleTypes, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkExternalMemoryImageCreateInfoNV-handleTypes-parameter");
            }
        } break;

        // Validation code for VkExportMemoryAllocateInfoNV structure members
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: {  // Covers VUID-VkExportMemoryAllocateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMemoryAllocateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_external_memory)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_external_memory");
                }
                VkExportMemoryAllocateInfoNV* structure = (VkExportMemoryAllocateInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleTypes), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                      AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleTypes, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkExportMemoryAllocateInfoNV-handleTypes-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkImportMemoryWin32HandleInfoNV structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: {  // Covers VUID-VkImportMemoryWin32HandleInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryWin32HandleInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_external_memory_win32)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_external_memory_win32");
                }
                VkImportMemoryWin32HandleInfoNV* structure = (VkImportMemoryWin32HandleInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                                      AllVkExternalMemoryHandleTypeFlagBitsNV, structure->handleType, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImportMemoryWin32HandleInfoNV-handleType-parameter");
            }
        } break;

        // No Validation code for VkExportMemoryWin32HandleInfoNV structure members  -- Covers
        // VUID-VkExportMemoryWin32HandleInfoNV-sType-sType

        // Validation code for VkWin32KeyedMutexAcquireReleaseInfoNV structure members
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: {  // Covers
                                                                             // VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWin32KeyedMutexAcquireReleaseInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_win32_keyed_mutex)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_win32_keyed_mutex");
                }
                VkWin32KeyedMutexAcquireReleaseInfoNV* structure = (VkWin32KeyedMutexAcquireReleaseInfoNV*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireSyncs),
                                      structure->acquireCount, &structure->pAcquireSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireKeys),
                                      structure->acquireCount, &structure->pAcquireKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireKeys-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::acquireCount), pNext_loc.dot(Field::pAcquireTimeoutMilliseconds),
                                      structure->acquireCount, &structure->pAcquireTimeoutMilliseconds, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireTimeoutMilliseconds-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseSyncs),
                                      structure->releaseCount, &structure->pReleaseSyncs, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseSyncs-parameter");

                skip |= ValidateArray(pNext_loc.dot(Field::releaseCount), pNext_loc.dot(Field::pReleaseKeys),
                                      structure->releaseCount, &structure->pReleaseKeys, false, true, kVUIDUndefined,
                                      "VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseKeys-parameter");
            }
        } break;
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkValidationFlagsEXT structure members
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: {  // Covers VUID-VkValidationFlagsEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkValidationFlagsEXT);
                VkValidationFlagsEXT* structure = (VkValidationFlagsEXT*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::disabledValidationCheckCount),
                                                pNext_loc.dot(Field::pDisabledValidationChecks), vvl::Enum::VkValidationCheckEXT,
                                                structure->disabledValidationCheckCount, structure->pDisabledValidationChecks, true,
                                                true, "VUID-VkValidationFlagsEXT-disabledValidationCheckCount-arraylength",
                                                "VUID-VkValidationFlagsEXT-pDisabledValidationChecks-parameter");
            }
        } break;

        // Validation code for VkImageViewASTCDecodeModeEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: {  // Covers VUID-VkImageViewASTCDecodeModeEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageViewASTCDecodeModeEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_astc_decode_mode)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_astc_decode_mode");
                }
                VkImageViewASTCDecodeModeEXT* structure = (VkImageViewASTCDecodeModeEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::decodeMode), vvl::Enum::VkFormat, structure->decodeMode,
                                           "VUID-VkImageViewASTCDecodeModeEXT-decodeMode-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkPipelineRobustnessCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: {  // Covers VUID-VkPipelineRobustnessCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRobustnessCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_pipeline_robustness)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_pipeline_robustness");
                }
                VkPipelineRobustnessCreateInfoEXT* structure = (VkPipelineRobustnessCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::storageBuffers), vvl::Enum::VkPipelineRobustnessBufferBehaviorEXT,
                                           structure->storageBuffers,
                                           "VUID-VkPipelineRobustnessCreateInfoEXT-storageBuffers-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::uniformBuffers), vvl::Enum::VkPipelineRobustnessBufferBehaviorEXT,
                                           structure->uniformBuffers,
                                           "VUID-VkPipelineRobustnessCreateInfoEXT-uniformBuffers-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::vertexInputs), vvl::Enum::VkPipelineRobustnessBufferBehaviorEXT,
                                           structure->vertexInputs, "VUID-VkPipelineRobustnessCreateInfoEXT-vertexInputs-parameter",
                                           VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::images), vvl::Enum::VkPipelineRobustnessImageBehaviorEXT,
                                           structure->images, "VUID-VkPipelineRobustnessCreateInfoEXT-images-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkCommandBufferInheritanceConditionalRenderingInfoEXT structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT: {  // Covers
                                                                                             // VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkCommandBufferInheritanceConditionalRenderingInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_conditional_rendering)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_conditional_rendering");
                }
                VkCommandBufferInheritanceConditionalRenderingInfoEXT* structure =
                    (VkCommandBufferInheritanceConditionalRenderingInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::conditionalRenderingEnable), structure->conditionalRenderingEnable);
            }
        } break;

        // Validation code for VkPipelineViewportWScalingStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: {  // Covers
                                                                                    // VUID-VkPipelineViewportWScalingStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportWScalingStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_clip_space_w_scaling)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_clip_space_w_scaling");
                }
                VkPipelineViewportWScalingStateCreateInfoNV* structure = (VkPipelineViewportWScalingStateCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::viewportWScalingEnable), structure->viewportWScalingEnable);

                skip |= ValidateArray(pNext_loc.dot(Field::viewportCount), loc, structure->viewportCount,
                                      &structure->pViewportWScalings, true, false,
                                      "VUID-VkPipelineViewportWScalingStateCreateInfoNV-viewportCount-arraylength", kVUIDUndefined);
            }
        } break;

        // Validation code for VkSwapchainCounterCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: {  // Covers VUID-VkSwapchainCounterCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainCounterCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_display_control)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_display_control");
                }
                VkSwapchainCounterCreateInfoEXT* structure = (VkSwapchainCounterCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::surfaceCounters), vvl::FlagBitmask::VkSurfaceCounterFlagBitsEXT,
                                      AllVkSurfaceCounterFlagBitsEXT, structure->surfaceCounters, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter");
            }
        } break;

        // Validation code for VkPresentTimesInfoGOOGLE structure members
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: {  // Covers VUID-VkPresentTimesInfoGOOGLE-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPresentTimesInfoGOOGLE);
                if (!IsExtEnabled(device_extensions.vk_google_display_timing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_GOOGLE_display_timing");
                }
                VkPresentTimesInfoGOOGLE* structure = (VkPresentTimesInfoGOOGLE*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pTimes), structure->swapchainCount,
                                      &structure->pTimes, true, false, "VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength",
                                      "VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter");

                if (structure->pTimes != nullptr) {
                    for (uint32_t swapchainIndex = 0; swapchainIndex < structure->swapchainCount; ++swapchainIndex) {
                        [[maybe_unused]] const Location pTimes_loc = pNext_loc.dot(Field::pTimes, swapchainIndex);
                    }
                }
            }
        } break;

        // Validation code for VkPipelineViewportSwizzleStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: {  // Covers
                                                                                  // VUID-VkPipelineViewportSwizzleStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportSwizzleStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_viewport_swizzle)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_viewport_swizzle");
                }
                VkPipelineViewportSwizzleStateCreateInfoNV* structure = (VkPipelineViewportSwizzleStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateArray(pNext_loc.dot(Field::viewportCount), pNext_loc.dot(Field::pViewportSwizzles),
                                      structure->viewportCount, &structure->pViewportSwizzles, true, true,
                                      "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-arraylength",
                                      "VUID-VkPipelineViewportSwizzleStateCreateInfoNV-pViewportSwizzles-parameter");

                if (structure->pViewportSwizzles != nullptr) {
                    for (uint32_t viewportIndex = 0; viewportIndex < structure->viewportCount; ++viewportIndex) {
                        [[maybe_unused]] const Location pViewportSwizzles_loc =
                            pNext_loc.dot(Field::pViewportSwizzles, viewportIndex);
                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::x), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].x,
                                                   "VUID-VkViewportSwizzleNV-x-parameter", VK_NULL_HANDLE);

                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::y), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].y,
                                                   "VUID-VkViewportSwizzleNV-y-parameter", VK_NULL_HANDLE);

                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::z), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].z,
                                                   "VUID-VkViewportSwizzleNV-z-parameter", VK_NULL_HANDLE);

                        skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::w), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                                   structure->pViewportSwizzles[viewportIndex].w,
                                                   "VUID-VkViewportSwizzleNV-w-parameter", VK_NULL_HANDLE);
                    }
                }
            }
        } break;

        // Validation code for VkPipelineDiscardRectangleStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                    // VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineDiscardRectangleStateCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_discard_rectangles");
                }
                VkPipelineDiscardRectangleStateCreateInfoEXT* structure = (VkPipelineDiscardRectangleStateCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::discardRectangleMode), vvl::Enum::VkDiscardRectangleModeEXT,
                                           structure->discardRectangleMode,
                                           "VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleMode-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkPipelineRasterizationConservativeStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                             // VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPipelineRasterizationConservativeStateCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_conservative_rasterization)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_conservative_rasterization");
                }
                VkPipelineRasterizationConservativeStateCreateInfoEXT* structure =
                    (VkPipelineRasterizationConservativeStateCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::conservativeRasterizationMode), vvl::Enum::VkConservativeRasterizationModeEXT,
                    structure->conservativeRasterizationMode,
                    "VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-conservativeRasterizationMode-parameter",
                    VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkPipelineRasterizationDepthClipStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                           // VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineRasterizationDepthClipStateCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clip_enable)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_depth_clip_enable");
                }
                VkPipelineRasterizationDepthClipStateCreateInfoEXT* structure =
                    (VkPipelineRasterizationDepthClipStateCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateBool32(pNext_loc.dot(Field::depthClipEnable), structure->depthClipEnable);
            }
        } break;

        // Validation code for VkDebugUtilsObjectNameInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: {  // Covers VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDebugUtilsObjectNameInfoEXT);
                VkDebugUtilsObjectNameInfoEXT* structure = (VkDebugUtilsObjectNameInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::objectType), vvl::Enum::VkObjectType, structure->objectType,
                                           "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkDebugUtilsMessengerCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: {  // Covers
                                                                         // VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDebugUtilsMessengerCreateInfoEXT);
                VkDebugUtilsMessengerCreateInfoEXT* structure = (VkDebugUtilsMessengerCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask");

                skip |=
                    ValidateFlags(pNext_loc.dot(Field::messageSeverity), vvl::FlagBitmask::VkDebugUtilsMessageSeverityFlagBitsEXT,
                                  AllVkDebugUtilsMessageSeverityFlagBitsEXT, structure->messageSeverity, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter",
                                  "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask");

                skip |= ValidateFlags(pNext_loc.dot(Field::messageType), vvl::FlagBitmask::VkDebugUtilsMessageTypeFlagBitsEXT,
                                      AllVkDebugUtilsMessageTypeFlagBitsEXT, structure->messageType, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter",
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pfnUserCallback),
                                                reinterpret_cast<const void*>(structure->pfnUserCallback),
                                                "VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkAndroidHardwareBufferUsageANDROID structure members  -- Covers
        // VUID-VkAndroidHardwareBufferUsageANDROID-sType-sType

        // No Validation code for VkAndroidHardwareBufferFormatPropertiesANDROID structure members  -- Covers
        // VUID-VkAndroidHardwareBufferFormatPropertiesANDROID-sType-sType

        // Validation code for VkImportAndroidHardwareBufferInfoANDROID structure members
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: {  // Covers
                                                                               // VUID-VkImportAndroidHardwareBufferInfoANDROID-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportAndroidHardwareBufferInfoANDROID);
                if (!IsExtEnabled(device_extensions.vk_android_external_memory_android_hardware_buffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_ANDROID_external_memory_android_hardware_buffer");
                }
                VkImportAndroidHardwareBufferInfoANDROID* structure = (VkImportAndroidHardwareBufferInfoANDROID*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::buffer), structure->buffer,
                                                "VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-parameter");
            }
        } break;

        // No Validation code for VkExternalFormatANDROID structure members  -- Covers VUID-VkExternalFormatANDROID-sType-sType

        // No Validation code for VkAndroidHardwareBufferFormatProperties2ANDROID structure members  -- Covers
        // VUID-VkAndroidHardwareBufferFormatProperties2ANDROID-sType-sType
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // No Validation code for VkPipelineShaderStageNodeCreateInfoAMDX structure members  -- Covers
        // VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkSampleLocationsInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: {  // Covers VUID-VkSampleLocationsInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSampleLocationsInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_sample_locations)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_sample_locations");
                }
                VkSampleLocationsInfoEXT* structure = (VkSampleLocationsInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::sampleLocationsCount), pNext_loc.dot(Field::pSampleLocations),
                                      structure->sampleLocationsCount, &structure->pSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                if (structure->pSampleLocations != nullptr) {
                    for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < structure->sampleLocationsCount;
                         ++sampleLocationsIndex) {
                        [[maybe_unused]] const Location pSampleLocations_loc =
                            pNext_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassSampleLocationsBeginInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: {  // Covers
                                                                               // VUID-VkRenderPassSampleLocationsBeginInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassSampleLocationsBeginInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_sample_locations)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_sample_locations");
                }
                VkRenderPassSampleLocationsBeginInfoEXT* structure = (VkRenderPassSampleLocationsBeginInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::attachmentInitialSampleLocationsCount),
                                      pNext_loc.dot(Field::pAttachmentInitialSampleLocations),
                                      structure->attachmentInitialSampleLocationsCount,
                                      &structure->pAttachmentInitialSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassSampleLocationsBeginInfoEXT-pAttachmentInitialSampleLocations-parameter");

                if (structure->pAttachmentInitialSampleLocations != nullptr) {
                    for (uint32_t attachmentInitialSampleLocationsIndex = 0;
                         attachmentInitialSampleLocationsIndex < structure->attachmentInitialSampleLocationsCount;
                         ++attachmentInitialSampleLocationsIndex) {
                        [[maybe_unused]] const Location pAttachmentInitialSampleLocations_loc =
                            pNext_loc.dot(Field::pAttachmentInitialSampleLocations, attachmentInitialSampleLocationsIndex);
                        skip |=
                            ValidateStructType(pAttachmentInitialSampleLocations_loc.dot(Field::sampleLocationsInfo),
                                               &(structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                                     .sampleLocationsInfo),
                                               VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined,
                                               "VUID-VkSampleLocationsInfoEXT-sType-sType");

                        skip |=
                            ValidateArray(pAttachmentInitialSampleLocations_loc.dot(Field::sampleLocationsCount),
                                          pAttachmentInitialSampleLocations_loc.dot(Field::pSampleLocations),
                                          structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                              .sampleLocationsInfo.sampleLocationsCount,
                                          &structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                               .sampleLocationsInfo.pSampleLocations,
                                          false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                        if (structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                .sampleLocationsInfo.pSampleLocations != nullptr) {
                            for (uint32_t sampleLocationsIndex = 0;
                                 sampleLocationsIndex <
                                 structure->pAttachmentInitialSampleLocations[attachmentInitialSampleLocationsIndex]
                                     .sampleLocationsInfo.sampleLocationsCount;
                                 ++sampleLocationsIndex) {
                                [[maybe_unused]] const Location pSampleLocations_loc =
                                    pAttachmentInitialSampleLocations_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                            }
                        }
                    }
                }

                skip |= ValidateArray(pNext_loc.dot(Field::postSubpassSampleLocationsCount),
                                      pNext_loc.dot(Field::pPostSubpassSampleLocations), structure->postSubpassSampleLocationsCount,
                                      &structure->pPostSubpassSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkRenderPassSampleLocationsBeginInfoEXT-pPostSubpassSampleLocations-parameter");

                if (structure->pPostSubpassSampleLocations != nullptr) {
                    for (uint32_t postSubpassSampleLocationsIndex = 0;
                         postSubpassSampleLocationsIndex < structure->postSubpassSampleLocationsCount;
                         ++postSubpassSampleLocationsIndex) {
                        [[maybe_unused]] const Location pPostSubpassSampleLocations_loc =
                            pNext_loc.dot(Field::pPostSubpassSampleLocations, postSubpassSampleLocationsIndex);
                        skip |= ValidateStructType(
                            pPostSubpassSampleLocations_loc.dot(Field::sampleLocationsInfo),
                            &(structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex].sampleLocationsInfo),
                            VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined,
                            "VUID-VkSampleLocationsInfoEXT-sType-sType");

                        skip |=
                            ValidateArray(pPostSubpassSampleLocations_loc.dot(Field::sampleLocationsCount),
                                          pPostSubpassSampleLocations_loc.dot(Field::pSampleLocations),
                                          structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                              .sampleLocationsInfo.sampleLocationsCount,
                                          &structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                               .sampleLocationsInfo.pSampleLocations,
                                          false, true, kVUIDUndefined, "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                        if (structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                .sampleLocationsInfo.pSampleLocations != nullptr) {
                            for (uint32_t sampleLocationsIndex = 0;
                                 sampleLocationsIndex < structure->pPostSubpassSampleLocations[postSubpassSampleLocationsIndex]
                                                            .sampleLocationsInfo.sampleLocationsCount;
                                 ++sampleLocationsIndex) {
                                [[maybe_unused]] const Location pSampleLocations_loc =
                                    pPostSubpassSampleLocations_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkPipelineSampleLocationsStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                   // VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineSampleLocationsStateCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_sample_locations)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_sample_locations");
                }
                VkPipelineSampleLocationsStateCreateInfoEXT* structure = (VkPipelineSampleLocationsStateCreateInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::sampleLocationsEnable), structure->sampleLocationsEnable);

                skip |= ValidateStructType(pNext_loc.dot(Field::sampleLocationsInfo), &(structure->sampleLocationsInfo),
                                           VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, false, kVUIDUndefined,
                                           "VUID-VkSampleLocationsInfoEXT-sType-sType");

                skip |= ValidateArray(pNext_loc.dot(Field::sampleLocationsCount), pNext_loc.dot(Field::pSampleLocations),
                                      structure->sampleLocationsInfo.sampleLocationsCount,
                                      &structure->sampleLocationsInfo.pSampleLocations, false, true, kVUIDUndefined,
                                      "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

                if (structure->sampleLocationsInfo.pSampleLocations != nullptr) {
                    for (uint32_t sampleLocationsIndex = 0;
                         sampleLocationsIndex < structure->sampleLocationsInfo.sampleLocationsCount; ++sampleLocationsIndex) {
                        [[maybe_unused]] const Location pSampleLocations_loc =
                            pNext_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                    }
                }
            }
        } break;

        // Validation code for VkPipelineColorBlendAdvancedStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                       // VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineColorBlendAdvancedStateCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_blend_operation_advanced)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_blend_operation_advanced");
                }
                VkPipelineColorBlendAdvancedStateCreateInfoEXT* structure = (VkPipelineColorBlendAdvancedStateCreateInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::srcPremultiplied), structure->srcPremultiplied);

                skip |= ValidateBool32(pNext_loc.dot(Field::dstPremultiplied), structure->dstPremultiplied);

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::blendOverlap), vvl::Enum::VkBlendOverlapEXT, structure->blendOverlap,
                    "VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkPipelineCoverageToColorStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: {  // Covers
                                                                                   // VUID-VkPipelineCoverageToColorStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCoverageToColorStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_fragment_coverage_to_color)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_fragment_coverage_to_color");
                }
                VkPipelineCoverageToColorStateCreateInfoNV* structure = (VkPipelineCoverageToColorStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineCoverageToColorStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateBool32(pNext_loc.dot(Field::coverageToColorEnable), structure->coverageToColorEnable);
            }
        } break;

        // Validation code for VkPipelineCoverageModulationStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: {  // Covers
                                                                                     // VUID-VkPipelineCoverageModulationStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCoverageModulationStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_framebuffer_mixed_samples)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_framebuffer_mixed_samples");
                }
                VkPipelineCoverageModulationStateCreateInfoNV* structure = (VkPipelineCoverageModulationStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineCoverageModulationStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::coverageModulationMode), vvl::Enum::VkCoverageModulationModeNV,
                                           structure->coverageModulationMode,
                                           "VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationMode-parameter",
                                           VK_NULL_HANDLE);

                skip |=
                    ValidateBool32(pNext_loc.dot(Field::coverageModulationTableEnable), structure->coverageModulationTableEnable);
            }
        } break;

        // No Validation code for VkDrmFormatModifierPropertiesListEXT structure members  -- Covers
        // VUID-VkDrmFormatModifierPropertiesListEXT-sType-sType

        // Validation code for VkPhysicalDeviceImageDrmFormatModifierInfoEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: {  // Covers
                                                                                      // VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_image_drm_format_modifier))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_image_drm_format_modifier");
                }
                VkPhysicalDeviceImageDrmFormatModifierInfoEXT* structure = (VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode, structure->sharingMode,
                                       "VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-parameter", physicalDevice);
            }
        } break;

        // Validation code for VkImageDrmFormatModifierListCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: {  // Covers
                                                                                  // VUID-VkImageDrmFormatModifierListCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageDrmFormatModifierListCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_drm_format_modifier)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_image_drm_format_modifier");
                }
                VkImageDrmFormatModifierListCreateInfoEXT* structure = (VkImageDrmFormatModifierListCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::drmFormatModifierCount), pNext_loc.dot(Field::pDrmFormatModifiers),
                                      structure->drmFormatModifierCount, &structure->pDrmFormatModifiers, true, true,
                                      "VUID-VkImageDrmFormatModifierListCreateInfoEXT-drmFormatModifierCount-arraylength",
                                      "VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-parameter");
            }
        } break;

        // Validation code for VkImageDrmFormatModifierExplicitCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: {  // Covers
                                                                                      // VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImageDrmFormatModifierExplicitCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_image_drm_format_modifier)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_image_drm_format_modifier");
                }
                VkImageDrmFormatModifierExplicitCreateInfoEXT* structure = (VkImageDrmFormatModifierExplicitCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::drmFormatModifierPlaneCount), pNext_loc.dot(Field::pPlaneLayouts),
                                      structure->drmFormatModifierPlaneCount, &structure->pPlaneLayouts, true, true,
                                      "VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifierPlaneCount-arraylength",
                                      "VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-pPlaneLayouts-parameter");

                if (structure->pPlaneLayouts != nullptr) {
                    for (uint32_t drmFormatModifierPlaneIndex = 0;
                         drmFormatModifierPlaneIndex < structure->drmFormatModifierPlaneCount; ++drmFormatModifierPlaneIndex) {
                        [[maybe_unused]] const Location pPlaneLayouts_loc =
                            pNext_loc.dot(Field::pPlaneLayouts, drmFormatModifierPlaneIndex);
                    }
                }
            }
        } break;

        // No Validation code for VkDrmFormatModifierPropertiesList2EXT structure members  -- Covers
        // VUID-VkDrmFormatModifierPropertiesList2EXT-sType-sType

        // Validation code for VkShaderModuleValidationCacheCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: {  // Covers
                                                                                  // VUID-VkShaderModuleValidationCacheCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkShaderModuleValidationCacheCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_validation_cache)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_validation_cache");
                }
                VkShaderModuleValidationCacheCreateInfoEXT* structure = (VkShaderModuleValidationCacheCreateInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::validationCache), structure->validationCache);
            }
        } break;

        // Validation code for VkPipelineViewportShadingRateImageStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV: {  // Covers
                                                                                             // VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportShadingRateImageStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_shading_rate_image");
                }
                VkPipelineViewportShadingRateImageStateCreateInfoNV* structure =
                    (VkPipelineViewportShadingRateImageStateCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::shadingRateImageEnable), structure->shadingRateImageEnable);
            }
        } break;

        // Validation code for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV: {  // Covers
                                                                                              // VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_shading_rate_image");
                }
                VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* structure =
                    (VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::sampleOrderType), vvl::Enum::VkCoarseSampleOrderTypeNV, structure->sampleOrderType,
                    "VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-parameter", VK_NULL_HANDLE);

                skip |=
                    ValidateArray(pNext_loc.dot(Field::customSampleOrderCount), pNext_loc.dot(Field::pCustomSampleOrders),
                                  structure->customSampleOrderCount, &structure->pCustomSampleOrders, false, true, kVUIDUndefined,
                                  "VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-parameter");

                if (structure->pCustomSampleOrders != nullptr) {
                    for (uint32_t customSampleOrderIndex = 0; customSampleOrderIndex < structure->customSampleOrderCount;
                         ++customSampleOrderIndex) {
                        [[maybe_unused]] const Location pCustomSampleOrders_loc =
                            pNext_loc.dot(Field::pCustomSampleOrders, customSampleOrderIndex);
                        skip |= ValidateRangedEnum(pCustomSampleOrders_loc.dot(Field::shadingRate),
                                                   vvl::Enum::VkShadingRatePaletteEntryNV,
                                                   structure->pCustomSampleOrders[customSampleOrderIndex].shadingRate,
                                                   "VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter", VK_NULL_HANDLE);

                        skip |= ValidateArray(pCustomSampleOrders_loc.dot(Field::sampleLocationCount),
                                              pCustomSampleOrders_loc.dot(Field::pSampleLocations),
                                              structure->pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount,
                                              &structure->pCustomSampleOrders[customSampleOrderIndex].pSampleLocations, true, true,
                                              "VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength",
                                              "VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter");

                        if (structure->pCustomSampleOrders[customSampleOrderIndex].pSampleLocations != nullptr) {
                            for (uint32_t sampleLocationIndex = 0;
                                 sampleLocationIndex < structure->pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount;
                                 ++sampleLocationIndex) {
                                [[maybe_unused]] const Location pSampleLocations_loc =
                                    pCustomSampleOrders_loc.dot(Field::pSampleLocations, sampleLocationIndex);
                            }
                        }
                    }
                }
            }
        } break;

        // Validation code for VkWriteDescriptorSetAccelerationStructureNV structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: {  // Covers
                                                                                  // VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWriteDescriptorSetAccelerationStructureNV);
                if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_ray_tracing");
                }
                VkWriteDescriptorSetAccelerationStructureNV* structure = (VkWriteDescriptorSetAccelerationStructureNV*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::accelerationStructureCount), pNext_loc.dot(Field::pAccelerationStructures),
                                  structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false,
                                  "VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength",
                                  "VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter");
            }
        } break;

        // Validation code for VkPipelineRepresentativeFragmentTestStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV: {  // Covers
                                                                                              // VUID-VkPipelineRepresentativeFragmentTestStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPipelineRepresentativeFragmentTestStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_representative_fragment_test)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_representative_fragment_test");
                }
                VkPipelineRepresentativeFragmentTestStateCreateInfoNV* structure =
                    (VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::representativeFragmentTestEnable),
                                       structure->representativeFragmentTestEnable);
            }
        } break;

        // Validation code for VkPhysicalDeviceImageViewImageFormatInfoEXT structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: {  // Covers
                                                                                    // VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPhysicalDeviceImageViewImageFormatInfoEXT);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_filter_cubic))) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_filter_cubic");
                }
                VkPhysicalDeviceImageViewImageFormatInfoEXT* structure = (VkPhysicalDeviceImageViewImageFormatInfoEXT*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::imageViewType), vvl::Enum::VkImageViewType, structure->imageViewType,
                                       "VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-imageViewType-parameter", physicalDevice);
            }
        } break;

        // No Validation code for VkFilterCubicImageViewImageFormatPropertiesEXT structure members  -- Covers
        // VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-sType-sType

        // Validation code for VkImportMemoryHostPointerInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: {  // Covers VUID-VkImportMemoryHostPointerInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryHostPointerInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_external_memory_host)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_external_memory_host");
                }
                VkImportMemoryHostPointerInfoEXT* structure = (VkImportMemoryHostPointerInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kRequiredSingleBit,
                                      VK_NULL_HANDLE, "VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter",
                                      "VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pHostPointer), structure->pHostPointer,
                                                "VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-parameter");
            }
        } break;

        // Validation code for VkPipelineCompilerControlCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: {  // Covers
                                                                             // VUID-VkPipelineCompilerControlCreateInfoAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCompilerControlCreateInfoAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_pipeline_compiler_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_AMD_pipeline_compiler_control");
                }
                VkPipelineCompilerControlCreateInfoAMD* structure = (VkPipelineCompilerControlCreateInfoAMD*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::compilerControlFlags), structure->compilerControlFlags,
                                              "VUID-VkPipelineCompilerControlCreateInfoAMD-compilerControlFlags-zerobitmask");
            }
        } break;

        // Validation code for VkDeviceMemoryOverallocationCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: {  // Covers
                                                                                // VUID-VkDeviceMemoryOverallocationCreateInfoAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceMemoryOverallocationCreateInfoAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_memory_overallocation_behavior)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_AMD_memory_overallocation_behavior");
                }
                VkDeviceMemoryOverallocationCreateInfoAMD* structure = (VkDeviceMemoryOverallocationCreateInfoAMD*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::overallocationBehavior),
                                           vvl::Enum::VkMemoryOverallocationBehaviorAMD, structure->overallocationBehavior,
                                           "VUID-VkDeviceMemoryOverallocationCreateInfoAMD-overallocationBehavior-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;
#ifdef VK_USE_PLATFORM_GGP

        // No Validation code for VkPresentFrameTokenGGP structure members  -- Covers VUID-VkPresentFrameTokenGGP-sType-sType
#endif  // VK_USE_PLATFORM_GGP

        // No Validation code for VkPipelineViewportExclusiveScissorStateCreateInfoNV structure members  -- Covers
        // VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-sType-sType

        // No Validation code for VkQueueFamilyCheckpointPropertiesNV structure members  -- Covers
        // VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType

        // Validation code for VkQueryPoolPerformanceQueryCreateInfoINTEL structure members
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: {  // Covers
                                                                                  // VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryPoolPerformanceQueryCreateInfoINTEL);
                if (!IsExtEnabled(device_extensions.vk_intel_performance_query)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_INTEL_performance_query");
                }
                VkQueryPoolPerformanceQueryCreateInfoINTEL* structure = (VkQueryPoolPerformanceQueryCreateInfoINTEL*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::performanceCountersSampling),
                                           vvl::Enum::VkQueryPoolSamplingModeINTEL, structure->performanceCountersSampling,
                                           "VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-performanceCountersSampling-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // No Validation code for VkDisplayNativeHdrSurfaceCapabilitiesAMD structure members  -- Covers
        // VUID-VkDisplayNativeHdrSurfaceCapabilitiesAMD-sType-sType

        // Validation code for VkSwapchainDisplayNativeHdrCreateInfoAMD structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: {  // Covers
                                                                                // VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainDisplayNativeHdrCreateInfoAMD);
                if (!IsExtEnabled(device_extensions.vk_amd_display_native_hdr)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_AMD_display_native_hdr");
                }
                VkSwapchainDisplayNativeHdrCreateInfoAMD* structure = (VkSwapchainDisplayNativeHdrCreateInfoAMD*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::localDimmingEnable), structure->localDimmingEnable);
            }
        } break;

        // Validation code for VkRenderPassFragmentDensityMapCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: {  // Covers
                                                                                    // VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassFragmentDensityMapCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_fragment_density_map)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_fragment_density_map");
                }
                VkRenderPassFragmentDensityMapCreateInfoEXT* structure = (VkRenderPassFragmentDensityMapCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                           structure->fragmentDensityMapAttachment.layout,
                                           "VUID-VkAttachmentReference-layout-parameter", VK_NULL_HANDLE);
            }
        } break;

        // No Validation code for VkPhysicalDeviceMemoryBudgetPropertiesEXT structure members  -- Covers
        // VUID-VkPhysicalDeviceMemoryBudgetPropertiesEXT-sType-sType

        // No Validation code for VkMemoryPriorityAllocateInfoEXT structure members  -- Covers
        // VUID-VkMemoryPriorityAllocateInfoEXT-sType-sType

        // No Validation code for VkBufferDeviceAddressCreateInfoEXT structure members  -- Covers
        // VUID-VkBufferDeviceAddressCreateInfoEXT-sType-sType

        // Validation code for VkValidationFeaturesEXT structure members
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: {  // Covers VUID-VkValidationFeaturesEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkValidationFeaturesEXT);
                VkValidationFeaturesEXT* structure = (VkValidationFeaturesEXT*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::enabledValidationFeatureCount),
                                                pNext_loc.dot(Field::pEnabledValidationFeatures),
                                                vvl::Enum::VkValidationFeatureEnableEXT, structure->enabledValidationFeatureCount,
                                                structure->pEnabledValidationFeatures, false, true, kVUIDUndefined,
                                                "VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-parameter");

                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::disabledValidationFeatureCount),
                                                pNext_loc.dot(Field::pDisabledValidationFeatures),
                                                vvl::Enum::VkValidationFeatureDisableEXT, structure->disabledValidationFeatureCount,
                                                structure->pDisabledValidationFeatures, false, true, kVUIDUndefined,
                                                "VUID-VkValidationFeaturesEXT-pDisabledValidationFeatures-parameter");
            }
        } break;

        // Validation code for VkPipelineCoverageReductionStateCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: {  // Covers
                                                                                    // VUID-VkPipelineCoverageReductionStateCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineCoverageReductionStateCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_coverage_reduction_mode)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_coverage_reduction_mode");
                }
                VkPipelineCoverageReductionStateCreateInfoNV* structure = (VkPipelineCoverageReductionStateCreateInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkPipelineCoverageReductionStateCreateInfoNV-flags-zerobitmask");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::coverageReductionMode), vvl::Enum::VkCoverageReductionModeNV,
                                           structure->coverageReductionMode,
                                           "VUID-VkPipelineCoverageReductionStateCreateInfoNV-coverageReductionMode-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT: {  // Covers
                                                                                                 // VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPipelineRasterizationProvokingVertexStateCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_provoking_vertex)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_provoking_vertex");
                }
                VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* structure =
                    (VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::provokingVertexMode), vvl::Enum::VkProvokingVertexModeEXT, structure->provokingVertexMode,
                    "VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-provokingVertexMode-parameter", VK_NULL_HANDLE);
            }
        } break;
#ifdef VK_USE_PLATFORM_WIN32_KHR

        // Validation code for VkSurfaceFullScreenExclusiveInfoEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: {  // Covers
                                                                          // VUID-VkSurfaceFullScreenExclusiveInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSurfaceFullScreenExclusiveInfoEXT);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_full_screen_exclusive))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_full_screen_exclusive");
                }
                VkSurfaceFullScreenExclusiveInfoEXT* structure = (VkSurfaceFullScreenExclusiveInfoEXT*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::fullScreenExclusive), vvl::Enum::VkFullScreenExclusiveEXT, structure->fullScreenExclusive,
                    "VUID-VkSurfaceFullScreenExclusiveInfoEXT-fullScreenExclusive-parameter", VK_NULL_HANDLE);
            }
        } break;

        // No Validation code for VkSurfaceCapabilitiesFullScreenExclusiveEXT structure members  -- Covers
        // VUID-VkSurfaceCapabilitiesFullScreenExclusiveEXT-sType-sType

        // No Validation code for VkSurfaceFullScreenExclusiveWin32InfoEXT structure members  -- Covers
        // VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-sType-sType
#endif  // VK_USE_PLATFORM_WIN32_KHR

        // No Validation code for VkSubresourceHostMemcpySizeEXT structure members  -- Covers
        // VUID-VkSubresourceHostMemcpySizeEXT-sType-sType

        // No Validation code for VkHostImageCopyDevicePerformanceQueryEXT structure members  -- Covers
        // VUID-VkHostImageCopyDevicePerformanceQueryEXT-sType-sType

        // No Validation code for VkMemoryMapPlacedInfoEXT structure members  -- Covers VUID-VkMemoryMapPlacedInfoEXT-sType-sType

        // Validation code for VkSurfacePresentModeEXT structure members
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT: {  // Covers VUID-VkSurfacePresentModeEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSurfacePresentModeEXT);
                VkSurfacePresentModeEXT* structure = (VkSurfacePresentModeEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::presentMode), vvl::Enum::VkPresentModeKHR, structure->presentMode,
                                           "VUID-VkSurfacePresentModeEXT-presentMode-parameter", VK_NULL_HANDLE);
            }
        } break;

        // No Validation code for VkSurfacePresentScalingCapabilitiesEXT structure members  -- Covers
        // VUID-VkSurfacePresentScalingCapabilitiesEXT-sType-sType

        // No Validation code for VkSurfacePresentModeCompatibilityEXT structure members  -- Covers
        // VUID-VkSurfacePresentModeCompatibilityEXT-sType-sType

        // Validation code for VkSwapchainPresentFenceInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {  // Covers VUID-VkSwapchainPresentFenceInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentFenceInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_swapchain_maintenance1");
                }
                VkSwapchainPresentFenceInfoEXT* structure = (VkSwapchainPresentFenceInfoEXT*)header;
                skip |= ValidateHandleArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pFences),
                                            structure->swapchainCount, structure->pFences, true, true,
                                            "VUID-VkSwapchainPresentFenceInfoEXT-swapchainCount-arraylength");
            }
        } break;

        // Validation code for VkSwapchainPresentModesCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT: {  // Covers
                                                                           // VUID-VkSwapchainPresentModesCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentModesCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_swapchain_maintenance1");
                }
                VkSwapchainPresentModesCreateInfoEXT* structure = (VkSwapchainPresentModesCreateInfoEXT*)header;
                skip |=
                    ValidateRangedEnumArray(pNext_loc.dot(Field::presentModeCount), pNext_loc.dot(Field::pPresentModes),
                                            vvl::Enum::VkPresentModeKHR, structure->presentModeCount, structure->pPresentModes,
                                            true, true, "VUID-VkSwapchainPresentModesCreateInfoEXT-presentModeCount-arraylength",
                                            "VUID-VkSwapchainPresentModesCreateInfoEXT-pPresentModes-parameter");
            }
        } break;

        // Validation code for VkSwapchainPresentModeInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT: {  // Covers VUID-VkSwapchainPresentModeInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentModeInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_swapchain_maintenance1");
                }
                VkSwapchainPresentModeInfoEXT* structure = (VkSwapchainPresentModeInfoEXT*)header;
                skip |= ValidateRangedEnumArray(pNext_loc.dot(Field::swapchainCount), pNext_loc.dot(Field::pPresentModes),
                                                vvl::Enum::VkPresentModeKHR, structure->swapchainCount, structure->pPresentModes,
                                                true, true, "VUID-VkSwapchainPresentModeInfoEXT-swapchainCount-arraylength",
                                                "VUID-VkSwapchainPresentModeInfoEXT-pPresentModes-parameter");
            }
        } break;

        // Validation code for VkSwapchainPresentScalingCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT: {  // Covers
                                                                             // VUID-VkSwapchainPresentScalingCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentScalingCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_swapchain_maintenance1");
                }
                VkSwapchainPresentScalingCreateInfoEXT* structure = (VkSwapchainPresentScalingCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::scalingBehavior), vvl::FlagBitmask::VkPresentScalingFlagBitsEXT,
                                      AllVkPresentScalingFlagBitsEXT, structure->scalingBehavior, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkSwapchainPresentScalingCreateInfoEXT-scalingBehavior-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::presentGravityX), vvl::FlagBitmask::VkPresentGravityFlagBitsEXT,
                                      AllVkPresentGravityFlagBitsEXT, structure->presentGravityX, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkSwapchainPresentScalingCreateInfoEXT-presentGravityX-parameter");

                skip |= ValidateFlags(pNext_loc.dot(Field::presentGravityY), vvl::FlagBitmask::VkPresentGravityFlagBitsEXT,
                                      AllVkPresentGravityFlagBitsEXT, structure->presentGravityY, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkSwapchainPresentScalingCreateInfoEXT-presentGravityY-parameter");
            }
        } break;

        // Validation code for VkGraphicsPipelineShaderGroupsCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: {  // Covers
                                                                                  // VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGraphicsPipelineShaderGroupsCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_device_generated_commands");
                }
                VkGraphicsPipelineShaderGroupsCreateInfoNV* structure = (VkGraphicsPipelineShaderGroupsCreateInfoNV*)header;
                skip |=
                    ValidateStructTypeArray(pNext_loc.dot(Field::groupCount), pNext_loc.dot(Field::pGroups), structure->groupCount,
                                            structure->pGroups, VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV, false, true,
                                            "VUID-VkGraphicsShaderGroupCreateInfoNV-sType-sType",
                                            "VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-parameter", kVUIDUndefined);

                if (structure->pGroups != nullptr) {
                    for (uint32_t groupIndex = 0; groupIndex < structure->groupCount; ++groupIndex) {
                        [[maybe_unused]] const Location pGroups_loc = pNext_loc.dot(Field::pGroups, groupIndex);
                        skip |= ValidateStructTypeArray(pGroups_loc.dot(Field::stageCount), pGroups_loc.dot(Field::pStages),
                                                        structure->pGroups[groupIndex].stageCount,
                                                        structure->pGroups[groupIndex].pStages,
                                                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true,
                                                        "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                                        "VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-parameter",
                                                        "VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-arraylength");

                        if (structure->pGroups[groupIndex].pStages != nullptr) {
                            for (uint32_t stageIndex = 0; stageIndex < structure->pGroups[groupIndex].stageCount; ++stageIndex) {
                                [[maybe_unused]] const Location pStages_loc = pGroups_loc.dot(Field::pStages, stageIndex);
                                skip |= ValidateFlags(pStages_loc.dot(Field::flags),
                                                      vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                                      AllVkPipelineShaderStageCreateFlagBits,
                                                      structure->pGroups[groupIndex].pStages[stageIndex].flags, kOptionalFlags,
                                                      VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                                skip |= ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                                      AllVkShaderStageFlagBits,
                                                      structure->pGroups[groupIndex].pStages[stageIndex].stage, kRequiredSingleBit,
                                                      VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                                skip |= ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                                structure->pGroups[groupIndex].pStages[stageIndex].pName,
                                                                "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                                if (structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                                    [[maybe_unused]] const Location pSpecializationInfo_loc =
                                        pStages_loc.dot(Field::pSpecializationInfo);
                                    skip |= ValidateArray(
                                        pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                        pSpecializationInfo_loc.dot(Field::pMapEntries),
                                        structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                                        &structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries, false,
                                        true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                                    if (structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries !=
                                        nullptr) {
                                        for (uint32_t mapEntryIndex = 0;
                                             mapEntryIndex <
                                             structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                             ++mapEntryIndex) {
                                            [[maybe_unused]] const Location pMapEntries_loc =
                                                pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                        }
                                    }

                                    skip |= ValidateArray(
                                        pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                        structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                                        &structure->pGroups[groupIndex].pStages[stageIndex].pSpecializationInfo->pData, false, true,
                                        kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                                }
                            }
                        }
                    }
                }

                skip |= ValidateArray(pNext_loc.dot(Field::pipelineCount), pNext_loc.dot(Field::pPipelines),
                                      structure->pipelineCount, &structure->pPipelines, false, true, kVUIDUndefined,
                                      "VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-parameter");
            }
        } break;

        // Validation code for VkCommandBufferInheritanceViewportScissorInfoNV structure members
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: {  // Covers
                                                                                       // VUID-VkCommandBufferInheritanceViewportScissorInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkCommandBufferInheritanceViewportScissorInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_inherited_viewport_scissor)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_inherited_viewport_scissor");
                }
                VkCommandBufferInheritanceViewportScissorInfoNV* structure =
                    (VkCommandBufferInheritanceViewportScissorInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::viewportScissor2D), structure->viewportScissor2D);
            }
        } break;

        // No Validation code for VkRenderPassTransformBeginInfoQCOM structure members  -- Covers
        // VUID-VkRenderPassTransformBeginInfoQCOM-sType-sType

        // No Validation code for VkCommandBufferInheritanceRenderPassTransformInfoQCOM structure members  -- Covers
        // VUID-VkCommandBufferInheritanceRenderPassTransformInfoQCOM-sType-sType

        // Validation code for VkDepthBiasRepresentationInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT: {  // Covers VUID-VkDepthBiasRepresentationInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDepthBiasRepresentationInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_bias_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_depth_bias_control");
                }
                VkDepthBiasRepresentationInfoEXT* structure = (VkDepthBiasRepresentationInfoEXT*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::depthBiasRepresentation), vvl::Enum::VkDepthBiasRepresentationEXT,
                                       structure->depthBiasRepresentation,
                                       "VUID-VkDepthBiasRepresentationInfoEXT-depthBiasRepresentation-parameter", VK_NULL_HANDLE);

                skip |= ValidateBool32(pNext_loc.dot(Field::depthBiasExact), structure->depthBiasExact);
            }
        } break;

        // Validation code for VkDeviceDeviceMemoryReportCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: {  // Covers
                                                                               // VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceDeviceMemoryReportCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_memory_report)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_device_memory_report");
                }
                VkDeviceDeviceMemoryReportCreateInfoEXT* structure = (VkDeviceDeviceMemoryReportCreateInfoEXT*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-flags-zerobitmask");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pfnUserCallback),
                                                reinterpret_cast<const void*>(structure->pfnUserCallback),
                                                "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pfnUserCallback-parameter");

                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pUserData), structure->pUserData,
                                                "VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pUserData-parameter");
            }
        } break;

        // Validation code for VkSamplerCustomBorderColorCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: {  // Covers
                                                                               // VUID-VkSamplerCustomBorderColorCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerCustomBorderColorCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_custom_border_color)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_custom_border_color");
                }
                VkSamplerCustomBorderColorCreateInfoEXT* structure = (VkSamplerCustomBorderColorCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::format), vvl::Enum::VkFormat, structure->format,
                                           "VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-parameter", VK_NULL_HANDLE);
            }
        } break;

        // No Validation code for VkSurfaceCapabilitiesPresentBarrierNV structure members  -- Covers
        // VUID-VkSurfaceCapabilitiesPresentBarrierNV-sType-sType

        // Validation code for VkSwapchainPresentBarrierCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: {  // Covers
                                                                            // VUID-VkSwapchainPresentBarrierCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainPresentBarrierCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_present_barrier)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_present_barrier");
                }
                VkSwapchainPresentBarrierCreateInfoNV* structure = (VkSwapchainPresentBarrierCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::presentBarrierEnable), structure->presentBarrierEnable);
            }
        } break;

        // Validation code for VkDeviceDiagnosticsConfigCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: {  // Covers
                                                                            // VUID-VkDeviceDiagnosticsConfigCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceDiagnosticsConfigCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_device_diagnostics_config)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_device_diagnostics_config");
                }
                VkDeviceDiagnosticsConfigCreateInfoNV* structure = (VkDeviceDiagnosticsConfigCreateInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceDiagnosticsConfigFlagBitsNV,
                                      AllVkDeviceDiagnosticsConfigFlagBitsNV, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkDeviceDiagnosticsConfigCreateInfoNV-flags-parameter");
            }
        } break;

        // Validation code for VkQueryLowLatencySupportNV structure members
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: {  // Covers VUID-VkQueryLowLatencySupportNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkQueryLowLatencySupportNV);
                if (!IsExtEnabled(device_extensions.vk_nv_low_latency)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_low_latency");
                }
                VkQueryLowLatencySupportNV* structure = (VkQueryLowLatencySupportNV*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pQueriedLowLatencyData), structure->pQueriedLowLatencyData,
                                                "VUID-VkQueryLowLatencySupportNV-pQueriedLowLatencyData-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkExportMetalObjectCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: {  // Covers VUID-VkExportMetalObjectCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalObjectCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_metal_objects");
                }
                VkExportMetalObjectCreateInfoEXT* structure = (VkExportMetalObjectCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::exportObjectType), vvl::FlagBitmask::VkExportMetalObjectTypeFlagBitsEXT,
                                      AllVkExportMetalObjectTypeFlagBitsEXT, structure->exportObjectType, kOptionalSingleBit,
                                      VK_NULL_HANDLE, "VUID-VkExportMetalObjectCreateInfoEXT-exportObjectType-parameter");
            }
        } break;

        // No Validation code for VkExportMetalDeviceInfoEXT structure members  -- Covers
        // VUID-VkExportMetalDeviceInfoEXT-sType-sType

        // Validation code for VkExportMetalCommandQueueInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: {  // Covers VUID-VkExportMetalCommandQueueInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalCommandQueueInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_metal_objects");
                }
                VkExportMetalCommandQueueInfoEXT* structure = (VkExportMetalCommandQueueInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::queue), structure->queue);
            }
        } break;

        // Validation code for VkExportMetalBufferInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: {  // Covers VUID-VkExportMetalBufferInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalBufferInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_metal_objects");
                }
                VkExportMetalBufferInfoEXT* structure = (VkExportMetalBufferInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::memory), structure->memory);
            }
        } break;

        // No Validation code for VkImportMetalBufferInfoEXT structure members  -- Covers
        // VUID-VkImportMetalBufferInfoEXT-sType-sType

        // Validation code for VkExportMetalTextureInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: {  // Covers VUID-VkExportMetalTextureInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalTextureInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_metal_objects");
                }
                VkExportMetalTextureInfoEXT* structure = (VkExportMetalTextureInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::plane), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, structure->plane, kRequiredSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkExportMetalTextureInfoEXT-plane-parameter",
                                      "VUID-VkExportMetalTextureInfoEXT-plane-parameter");
            }
        } break;

        // Validation code for VkImportMetalTextureInfoEXT structure members
        case VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: {  // Covers VUID-VkImportMetalTextureInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMetalTextureInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_metal_objects");
                }
                VkImportMetalTextureInfoEXT* structure = (VkImportMetalTextureInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::plane), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, structure->plane, kRequiredSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkImportMetalTextureInfoEXT-plane-parameter",
                                      "VUID-VkImportMetalTextureInfoEXT-plane-parameter");
            }
        } break;

        // Validation code for VkExportMetalIOSurfaceInfoEXT structure members
        case VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: {  // Covers VUID-VkExportMetalIOSurfaceInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExportMetalIOSurfaceInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_metal_objects)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_metal_objects");
                }
                VkExportMetalIOSurfaceInfoEXT* structure = (VkExportMetalIOSurfaceInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::image), structure->image);
            }
        } break;

        // No Validation code for VkImportMetalIOSurfaceInfoEXT structure members  -- Covers
        // VUID-VkImportMetalIOSurfaceInfoEXT-sType-sType

        // No Validation code for VkExportMetalSharedEventInfoEXT structure members  -- Covers
        // VUID-VkExportMetalSharedEventInfoEXT-sType-sType

        // No Validation code for VkImportMetalSharedEventInfoEXT structure members  -- Covers
        // VUID-VkImportMetalSharedEventInfoEXT-sType-sType
#endif  // VK_USE_PLATFORM_METAL_EXT

        // Validation code for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure members
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT: {  // Covers
                                                                                               // VUID-VkDescriptorBufferBindingPushDescriptorBufferHandleEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkDescriptorBufferBindingPushDescriptorBufferHandleEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_descriptor_buffer");
                }
                VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* structure =
                    (VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::buffer), structure->buffer);
            }
        } break;

        // Validation code for VkOpaqueCaptureDescriptorDataCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: {  // Covers
                                                                                  // VUID-VkOpaqueCaptureDescriptorDataCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkOpaqueCaptureDescriptorDataCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_descriptor_buffer");
                }
                VkOpaqueCaptureDescriptorDataCreateInfoEXT* structure = (VkOpaqueCaptureDescriptorDataCreateInfoEXT*)header;
                skip |= ValidateRequiredPointer(
                    pNext_loc.dot(Field::opaqueCaptureDescriptorData), structure->opaqueCaptureDescriptorData,
                    "VUID-VkOpaqueCaptureDescriptorDataCreateInfoEXT-opaqueCaptureDescriptorData-parameter");
            }
        } break;

        // Validation code for VkGraphicsPipelineLibraryCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: {  // Covers
                                                                             // VUID-VkGraphicsPipelineLibraryCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGraphicsPipelineLibraryCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_graphics_pipeline_library)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_graphics_pipeline_library");
                }
                VkGraphicsPipelineLibraryCreateInfoEXT* structure = (VkGraphicsPipelineLibraryCreateInfoEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkGraphicsPipelineLibraryFlagBitsEXT,
                                      AllVkGraphicsPipelineLibraryFlagBitsEXT, structure->flags, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-parameter",
                                      "VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-requiredbitmask");
            }
        } break;

        // No Validation code for VkPipelineFragmentShadingRateEnumStateCreateInfoNV structure members  -- Covers
        // VUID-VkPipelineFragmentShadingRateEnumStateCreateInfoNV-sType-sType

        // No Validation code for VkAccelerationStructureGeometryMotionTrianglesDataNV structure members  -- Covers
        // VUID-VkAccelerationStructureGeometryMotionTrianglesDataNV-sType-sType

        // Validation code for VkAccelerationStructureMotionInfoNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: {  // Covers
                                                                         // VUID-VkAccelerationStructureMotionInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAccelerationStructureMotionInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing_motion_blur)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_ray_tracing_motion_blur");
                }
                VkAccelerationStructureMotionInfoNV* structure = (VkAccelerationStructureMotionInfoNV*)header;
                skip |= ValidateReservedFlags(pNext_loc.dot(Field::flags), structure->flags,
                                              "VUID-VkAccelerationStructureMotionInfoNV-flags-zerobitmask");
            }
        } break;

        // No Validation code for VkCopyCommandTransformInfoQCOM structure members  -- Covers
        // VUID-VkCopyCommandTransformInfoQCOM-sType-sType

        // No Validation code for VkImageCompressionControlEXT structure members  -- Covers
        // VUID-VkImageCompressionControlEXT-sType-sType

        // No Validation code for VkImageCompressionPropertiesEXT structure members  -- Covers
        // VUID-VkImageCompressionPropertiesEXT-sType-sType

        // Validation code for VkMutableDescriptorTypeCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: {  // Covers
                                                                           // VUID-VkMutableDescriptorTypeCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMutableDescriptorTypeCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_valve_mutable_descriptor_type) &&
                    !IsExtEnabled(device_extensions.vk_ext_mutable_descriptor_type)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_VALVE_mutable_descriptor_type or "
                                     "VK_EXT_mutable_descriptor_type");
                }
                VkMutableDescriptorTypeCreateInfoEXT* structure = (VkMutableDescriptorTypeCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::mutableDescriptorTypeListCount),
                                      pNext_loc.dot(Field::pMutableDescriptorTypeLists), structure->mutableDescriptorTypeListCount,
                                      &structure->pMutableDescriptorTypeLists, false, true, kVUIDUndefined,
                                      "VUID-VkMutableDescriptorTypeCreateInfoEXT-pMutableDescriptorTypeLists-parameter");

                if (structure->pMutableDescriptorTypeLists != nullptr) {
                    for (uint32_t mutableDescriptorTypeListIndex = 0;
                         mutableDescriptorTypeListIndex < structure->mutableDescriptorTypeListCount;
                         ++mutableDescriptorTypeListIndex) {
                        [[maybe_unused]] const Location pMutableDescriptorTypeLists_loc =
                            pNext_loc.dot(Field::pMutableDescriptorTypeLists, mutableDescriptorTypeListIndex);
                        skip |= ValidateRangedEnumArray(
                            pMutableDescriptorTypeLists_loc.dot(Field::descriptorTypeCount),
                            pMutableDescriptorTypeLists_loc.dot(Field::pDescriptorTypes), vvl::Enum::VkDescriptorType,
                            structure->pMutableDescriptorTypeLists[mutableDescriptorTypeListIndex].descriptorTypeCount,
                            structure->pMutableDescriptorTypeLists[mutableDescriptorTypeListIndex].pDescriptorTypes, false, true,
                            kVUIDUndefined, "VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkDeviceAddressBindingCallbackDataEXT structure members
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: {  // Covers
                                                                            // VUID-VkDeviceAddressBindingCallbackDataEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDeviceAddressBindingCallbackDataEXT);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_ext_device_address_binding_report))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_device_address_binding_report");
                }
                VkDeviceAddressBindingCallbackDataEXT* structure = (VkDeviceAddressBindingCallbackDataEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceAddressBindingFlagBitsEXT,
                                      AllVkDeviceAddressBindingFlagBitsEXT, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkDeviceAddressBindingCallbackDataEXT-flags-parameter");

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::bindingType), vvl::Enum::VkDeviceAddressBindingTypeEXT,
                                           structure->bindingType,
                                           "VUID-VkDeviceAddressBindingCallbackDataEXT-bindingType-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkPipelineViewportDepthClipControlCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: {  // Covers
                                                                                        // VUID-VkPipelineViewportDepthClipControlCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportDepthClipControlCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clip_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_depth_clip_control");
                }
                VkPipelineViewportDepthClipControlCreateInfoEXT* structure =
                    (VkPipelineViewportDepthClipControlCreateInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::negativeOneToOne), structure->negativeOneToOne);
            }
        } break;
#ifdef VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkImportMemoryZirconHandleInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: {  // Covers
                                                                            // VUID-VkImportMemoryZirconHandleInfoFUCHSIA-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryZirconHandleInfoFUCHSIA);
                if (!IsExtEnabled(device_extensions.vk_fuchsia_external_memory)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_FUCHSIA_external_memory");
                }
                VkImportMemoryZirconHandleInfoFUCHSIA* structure = (VkImportMemoryZirconHandleInfoFUCHSIA*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                                      AllVkExternalMemoryHandleTypeFlagBits, structure->handleType, kOptionalSingleBit,
                                      VK_NULL_HANDLE, "VUID-VkImportMemoryZirconHandleInfoFUCHSIA-handleType-parameter");
            }
        } break;

        // Validation code for VkImportMemoryBufferCollectionFUCHSIA structure members
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: {  // Covers
                                                                           // VUID-VkImportMemoryBufferCollectionFUCHSIA-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkImportMemoryBufferCollectionFUCHSIA);
                if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_FUCHSIA_buffer_collection");
                }
                VkImportMemoryBufferCollectionFUCHSIA* structure = (VkImportMemoryBufferCollectionFUCHSIA*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::collection), structure->collection);
            }
        } break;

        // Validation code for VkBufferCollectionImageCreateInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: {  // Covers
                                                                               // VUID-VkBufferCollectionImageCreateInfoFUCHSIA-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBufferCollectionImageCreateInfoFUCHSIA);
                if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_FUCHSIA_buffer_collection");
                }
                VkBufferCollectionImageCreateInfoFUCHSIA* structure = (VkBufferCollectionImageCreateInfoFUCHSIA*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::collection), structure->collection);
            }
        } break;

        // Validation code for VkBufferCollectionBufferCreateInfoFUCHSIA structure members
        case VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: {  // Covers
                                                                                // VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBufferCollectionBufferCreateInfoFUCHSIA);
                if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_FUCHSIA_buffer_collection");
                }
                VkBufferCollectionBufferCreateInfoFUCHSIA* structure = (VkBufferCollectionBufferCreateInfoFUCHSIA*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::collection), structure->collection);
            }
        } break;
#endif  // VK_USE_PLATFORM_FUCHSIA

        // Validation code for VkSubpassShadingPipelineCreateInfoHUAWEI structure members
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: {  // Covers
                                                                               // VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSubpassShadingPipelineCreateInfoHUAWEI);
                if (!IsExtEnabled(device_extensions.vk_huawei_subpass_shading)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_HUAWEI_subpass_shading");
                }
                VkSubpassShadingPipelineCreateInfoHUAWEI* structure = (VkSubpassShadingPipelineCreateInfoHUAWEI*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::renderPass), structure->renderPass);
            }
        } break;

        // Validation code for VkFrameBoundaryEXT structure members
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: {  // Covers VUID-VkFrameBoundaryEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkFrameBoundaryEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_frame_boundary)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_EXT_frame_boundary");
                }
                VkFrameBoundaryEXT* structure = (VkFrameBoundaryEXT*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::flags), vvl::FlagBitmask::VkFrameBoundaryFlagBitsEXT,
                                      AllVkFrameBoundaryFlagBitsEXT, structure->flags, kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkFrameBoundaryEXT-flags-parameter");
            }
        } break;

        // No Validation code for VkSubpassResolvePerformanceQueryEXT structure members  -- Covers
        // VUID-VkSubpassResolvePerformanceQueryEXT-sType-sType

        // Validation code for VkMultisampledRenderToSingleSampledInfoEXT structure members
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: {  // Covers
                                                                                  // VUID-VkMultisampledRenderToSingleSampledInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMultisampledRenderToSingleSampledInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_multisampled_render_to_single_sampled)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_multisampled_render_to_single_sampled");
                }
                VkMultisampledRenderToSingleSampledInfoEXT* structure = (VkMultisampledRenderToSingleSampledInfoEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::multisampledRenderToSingleSampledEnable),
                                       structure->multisampledRenderToSingleSampledEnable);

                skip |= ValidateFlags(pNext_loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, structure->rasterizationSamples, kRequiredSingleBit, VK_NULL_HANDLE,
                                      "VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter",
                                      "VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter");
            }
        } break;

        // Validation code for VkPipelineColorWriteCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: {  // Covers VUID-VkPipelineColorWriteCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineColorWriteCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_color_write_enable)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_color_write_enable");
                }
                VkPipelineColorWriteCreateInfoEXT* structure = (VkPipelineColorWriteCreateInfoEXT*)header;
                skip |= ValidateBool32Array(pNext_loc.dot(Field::attachmentCount), pNext_loc.dot(Field::pColorWriteEnables),
                                            structure->attachmentCount, structure->pColorWriteEnables, false, true, kVUIDUndefined,
                                            "VUID-VkPipelineColorWriteCreateInfoEXT-pColorWriteEnables-parameter");
            }
        } break;

        // No Validation code for VkImageViewMinLodCreateInfoEXT structure members  -- Covers
        // VUID-VkImageViewMinLodCreateInfoEXT-sType-sType

        // Validation code for VkAccelerationStructureTrianglesOpacityMicromapEXT structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: {  // Covers
                                                                                         // VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkAccelerationStructureTrianglesOpacityMicromapEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_opacity_micromap");
                }
                VkAccelerationStructureTrianglesOpacityMicromapEXT* structure =
                    (VkAccelerationStructureTrianglesOpacityMicromapEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexType), vvl::Enum::VkIndexType, structure->indexType,
                                           "VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-parameter",
                                           VK_NULL_HANDLE);

                if (structure->pUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location pUsageCounts_loc = pNext_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    }
                }

                if (structure->ppUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location ppUsageCounts_loc = pNext_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    }
                }
            }
        } break;
#ifdef VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkAccelerationStructureTrianglesDisplacementMicromapNV structure members
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV: {  // Covers
                                                                                             // VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkAccelerationStructureTrianglesDisplacementMicromapNV);
                if (!IsExtEnabled(device_extensions.vk_nv_displacement_micromap)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_NV_displacement_micromap");
                }
                VkAccelerationStructureTrianglesDisplacementMicromapNV* structure =
                    (VkAccelerationStructureTrianglesDisplacementMicromapNV*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::displacementBiasAndScaleFormat), vvl::Enum::VkFormat,
                    structure->displacementBiasAndScaleFormat,
                    "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementBiasAndScaleFormat-parameter",
                    VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::displacementVectorFormat), vvl::Enum::VkFormat, structure->displacementVectorFormat,
                    "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-displacementVectorFormat-parameter",
                    VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::indexType), vvl::Enum::VkIndexType, structure->indexType,
                                           "VUID-VkAccelerationStructureTrianglesDisplacementMicromapNV-indexType-parameter",
                                           VK_NULL_HANDLE);

                if (structure->pUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location pUsageCounts_loc = pNext_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    }
                }

                if (structure->ppUsageCounts != nullptr) {
                    for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < structure->usageCountsCount; ++usageIndexsIndex) {
                        [[maybe_unused]] const Location ppUsageCounts_loc = pNext_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    }
                }
            }
        } break;
#endif  // VK_ENABLE_BETA_EXTENSIONS

        // Validation code for VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI structure members
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI: {  // Covers
                                                                                              // VUID-VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc =
                    loc.pNext(Struct::VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI);
                if (!IsExtEnabled(device_extensions.vk_huawei_cluster_culling_shader)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_HUAWEI_cluster_culling_shader");
                }
                VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* structure =
                    (VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::clusterShadingRate), structure->clusterShadingRate);
            }
        } break;

        // Validation code for VkSamplerBorderColorComponentMappingCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT: {  // Covers
                                                                                          // VUID-VkSamplerBorderColorComponentMappingCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerBorderColorComponentMappingCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_border_color_swizzle)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_border_color_swizzle");
                }
                VkSamplerBorderColorComponentMappingCreateInfoEXT* structure =
                    (VkSamplerBorderColorComponentMappingCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::r), vvl::Enum::VkComponentSwizzle, structure->components.r,
                                           "VUID-VkComponentMapping-r-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::g), vvl::Enum::VkComponentSwizzle, structure->components.g,
                                           "VUID-VkComponentMapping-g-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::b), vvl::Enum::VkComponentSwizzle, structure->components.b,
                                           "VUID-VkComponentMapping-b-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pNext_loc.dot(Field::a), vvl::Enum::VkComponentSwizzle, structure->components.a,
                                           "VUID-VkComponentMapping-a-parameter", VK_NULL_HANDLE);

                skip |= ValidateBool32(pNext_loc.dot(Field::srgb), structure->srgb);
            }
        } break;

        // No Validation code for VkDeviceQueueShaderCoreControlCreateInfoARM structure members  -- Covers
        // VUID-VkDeviceQueueShaderCoreControlCreateInfoARM-sType-sType

        // No Validation code for VkImageViewSlicedCreateInfoEXT structure members  -- Covers
        // VUID-VkImageViewSlicedCreateInfoEXT-sType-sType

        // Validation code for VkRenderPassStripeBeginInfoARM structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM: {  // Covers VUID-VkRenderPassStripeBeginInfoARM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassStripeBeginInfoARM);
                if (!IsExtEnabled(device_extensions.vk_arm_render_pass_striped)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_ARM_render_pass_striped");
                }
                VkRenderPassStripeBeginInfoARM* structure = (VkRenderPassStripeBeginInfoARM*)header;
                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::stripeInfoCount), pNext_loc.dot(Field::pStripeInfos), structure->stripeInfoCount,
                    structure->pStripeInfos, VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM, true, true,
                    "VUID-VkRenderPassStripeInfoARM-sType-sType", "VUID-VkRenderPassStripeBeginInfoARM-pStripeInfos-parameter",
                    "VUID-VkRenderPassStripeBeginInfoARM-stripeInfoCount-arraylength");

                if (structure->pStripeInfos != nullptr) {
                    for (uint32_t stripeInfoIndex = 0; stripeInfoIndex < structure->stripeInfoCount; ++stripeInfoIndex) {
                        [[maybe_unused]] const Location pStripeInfos_loc = pNext_loc.dot(Field::pStripeInfos, stripeInfoIndex);
                    }
                }
            }
        } break;

        // Validation code for VkRenderPassStripeSubmitInfoARM structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM: {  // Covers VUID-VkRenderPassStripeSubmitInfoARM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassStripeSubmitInfoARM);
                if (!IsExtEnabled(device_extensions.vk_arm_render_pass_striped)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_ARM_render_pass_striped");
                }
                VkRenderPassStripeSubmitInfoARM* structure = (VkRenderPassStripeSubmitInfoARM*)header;
                skip |= ValidateStructTypeArray(pNext_loc.dot(Field::stripeSemaphoreInfoCount),
                                                pNext_loc.dot(Field::pStripeSemaphoreInfos), structure->stripeSemaphoreInfoCount,
                                                structure->pStripeSemaphoreInfos, VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, true,
                                                true, "VUID-VkSemaphoreSubmitInfo-sType-sType",
                                                "VUID-VkRenderPassStripeSubmitInfoARM-pStripeSemaphoreInfos-parameter",
                                                "VUID-VkRenderPassStripeSubmitInfoARM-stripeSemaphoreInfoCount-arraylength");

                if (structure->pStripeSemaphoreInfos != nullptr) {
                    for (uint32_t stripeSemaphoreInfoIndex = 0; stripeSemaphoreInfoIndex < structure->stripeSemaphoreInfoCount;
                         ++stripeSemaphoreInfoIndex) {
                        [[maybe_unused]] const Location pStripeSemaphoreInfos_loc =
                            pNext_loc.dot(Field::pStripeSemaphoreInfos, stripeSemaphoreInfoIndex);
                        skip |= ValidateRequiredHandle(pStripeSemaphoreInfos_loc.dot(Field::semaphore),
                                                       structure->pStripeSemaphoreInfos[stripeSemaphoreInfoIndex].semaphore);

                        skip |= ValidateFlags(pStripeSemaphoreInfos_loc.dot(Field::stageMask),
                                              vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                              structure->pStripeSemaphoreInfos[stripeSemaphoreInfoIndex].stageMask, kOptionalFlags,
                                              VK_NULL_HANDLE, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                    }
                }
            }
        } break;

        // Validation code for VkSubpassFragmentDensityMapOffsetEndInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: {  // Covers
                                                                                     // VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSubpassFragmentDensityMapOffsetEndInfoQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_fragment_density_map_offset)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_QCOM_fragment_density_map_offset");
                }
                VkSubpassFragmentDensityMapOffsetEndInfoQCOM* structure = (VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::fragmentDensityOffsetCount),
                                      pNext_loc.dot(Field::pFragmentDensityOffsets), structure->fragmentDensityOffsetCount,
                                      &structure->pFragmentDensityOffsets, false, true, kVUIDUndefined,
                                      "VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pFragmentDensityOffsets-parameter");

                if (structure->pFragmentDensityOffsets != nullptr) {
                    for (uint32_t fragmentDensityOffsetIndex = 0;
                         fragmentDensityOffsetIndex < structure->fragmentDensityOffsetCount; ++fragmentDensityOffsetIndex) {
                        [[maybe_unused]] const Location pFragmentDensityOffsets_loc =
                            pNext_loc.dot(Field::pFragmentDensityOffsets, fragmentDensityOffsetIndex);
                    }
                }
            }
        } break;

        // No Validation code for VkComputePipelineIndirectBufferInfoNV structure members  -- Covers
        // VUID-VkComputePipelineIndirectBufferInfoNV-sType-sType

        // No Validation code for VkImageViewSampleWeightCreateInfoQCOM structure members  -- Covers
        // VUID-VkImageViewSampleWeightCreateInfoQCOM-sType-sType

        // Validation code for VkExternalMemoryAcquireUnmodifiedEXT structure members
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT: {  // Covers
                                                                          // VUID-VkExternalMemoryAcquireUnmodifiedEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkExternalMemoryAcquireUnmodifiedEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_external_memory_acquire_unmodified)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_external_memory_acquire_unmodified");
                }
                VkExternalMemoryAcquireUnmodifiedEXT* structure = (VkExternalMemoryAcquireUnmodifiedEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::acquireUnmodifiedMemory), structure->acquireUnmodifiedMemory);
            }
        } break;

        // Validation code for VkRenderPassCreationControlEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: {  // Covers VUID-VkRenderPassCreationControlEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassCreationControlEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_subpass_merge_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_subpass_merge_feedback");
                }
                VkRenderPassCreationControlEXT* structure = (VkRenderPassCreationControlEXT*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::disallowMerging), structure->disallowMerging);
            }
        } break;

        // Validation code for VkRenderPassCreationFeedbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: {  // Covers
                                                                                 // VUID-VkRenderPassCreationFeedbackCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassCreationFeedbackCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_subpass_merge_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_subpass_merge_feedback");
                }
                VkRenderPassCreationFeedbackCreateInfoEXT* structure = (VkRenderPassCreationFeedbackCreateInfoEXT*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pRenderPassFeedback), structure->pRenderPassFeedback,
                                                "VUID-VkRenderPassCreationFeedbackCreateInfoEXT-pRenderPassFeedback-parameter");

                if (structure->pRenderPassFeedback != nullptr) {
                    [[maybe_unused]] const Location pRenderPassFeedback_loc = pNext_loc.dot(Field::pRenderPassFeedback);
                }
            }
        } break;

        // Validation code for VkRenderPassSubpassFeedbackCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: {  // Covers
                                                                                // VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkRenderPassSubpassFeedbackCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_subpass_merge_feedback)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_subpass_merge_feedback");
                }
                VkRenderPassSubpassFeedbackCreateInfoEXT* structure = (VkRenderPassSubpassFeedbackCreateInfoEXT*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pSubpassFeedback), structure->pSubpassFeedback,
                                                "VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-pSubpassFeedback-parameter");

                if (structure->pSubpassFeedback != nullptr) {
                    [[maybe_unused]] const Location pSubpassFeedback_loc = pNext_loc.dot(Field::pSubpassFeedback);
                }
            }
        } break;

        // Validation code for VkDirectDriverLoadingListLUNARG structure members
        case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG: {  // Covers VUID-VkDirectDriverLoadingListLUNARG-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkDirectDriverLoadingListLUNARG);
                VkDirectDriverLoadingListLUNARG* structure = (VkDirectDriverLoadingListLUNARG*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::mode), vvl::Enum::VkDirectDriverLoadingModeLUNARG, structure->mode,
                                           "VUID-VkDirectDriverLoadingListLUNARG-mode-parameter", VK_NULL_HANDLE);

                skip |= ValidateStructTypeArray(
                    pNext_loc.dot(Field::driverCount), pNext_loc.dot(Field::pDrivers), structure->driverCount, structure->pDrivers,
                    VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG, true, true,
                    "VUID-VkDirectDriverLoadingInfoLUNARG-sType-sType", "VUID-VkDirectDriverLoadingListLUNARG-pDrivers-parameter",
                    "VUID-VkDirectDriverLoadingListLUNARG-driverCount-arraylength");

                if (structure->pDrivers != nullptr) {
                    for (uint32_t driverIndex = 0; driverIndex < structure->driverCount; ++driverIndex) {
                        [[maybe_unused]] const Location pDrivers_loc = pNext_loc.dot(Field::pDrivers, driverIndex);
                        skip |= ValidateReservedFlags(pDrivers_loc.dot(Field::flags), structure->pDrivers[driverIndex].flags,
                                                      "VUID-VkDirectDriverLoadingInfoLUNARG-flags-zerobitmask");
                    }
                }
            }
        } break;

        // Validation code for VkPipelineShaderStageModuleIdentifierCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT: {  // Covers
                                                                                           // VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineShaderStageModuleIdentifierCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_shader_module_identifier)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_shader_module_identifier");
                }
                VkPipelineShaderStageModuleIdentifierCreateInfoEXT* structure =
                    (VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)header;
                skip |= ValidateArray(pNext_loc.dot(Field::identifierSize), pNext_loc.dot(Field::pIdentifier),
                                      structure->identifierSize, &structure->pIdentifier, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pIdentifier-parameter");
            }
        } break;

        // Validation code for VkOpticalFlowImageFormatInfoNV structure members
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: {  // Covers VUID-VkOpticalFlowImageFormatInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkOpticalFlowImageFormatInfoNV);
                if ((!is_physdev_api && !IsExtEnabled(device_extensions.vk_nv_optical_flow))) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_optical_flow");
                }
                VkOpticalFlowImageFormatInfoNV* structure = (VkOpticalFlowImageFormatInfoNV*)header;
                skip |= ValidateFlags(pNext_loc.dot(Field::usage), vvl::FlagBitmask::VkOpticalFlowUsageFlagBitsNV,
                                      AllVkOpticalFlowUsageFlagBitsNV, structure->usage, kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter",
                                      "VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask");
            }
        } break;

        // Validation code for VkOpticalFlowSessionCreatePrivateDataInfoNV structure members
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: {  // Covers
                                                                                    // VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkOpticalFlowSessionCreatePrivateDataInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_optical_flow)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_optical_flow");
                }
                VkOpticalFlowSessionCreatePrivateDataInfoNV* structure = (VkOpticalFlowSessionCreatePrivateDataInfoNV*)header;
                skip |= ValidateRequiredPointer(pNext_loc.dot(Field::pPrivateData), structure->pPrivateData,
                                                "VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-pPrivateData-parameter");
            }
        } break;
#ifdef VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkAndroidHardwareBufferFormatResolvePropertiesANDROID structure members  -- Covers
        // VUID-VkAndroidHardwareBufferFormatResolvePropertiesANDROID-sType-sType
#endif  // VK_USE_PLATFORM_ANDROID_KHR

        // No Validation code for VkAmigoProfilingSubmitInfoSEC structure members  -- Covers
        // VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType

        // No Validation code for VkLatencySubmissionPresentIdNV structure members  -- Covers
        // VUID-VkLatencySubmissionPresentIdNV-sType-sType

        // Validation code for VkSwapchainLatencyCreateInfoNV structure members
        case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV: {  // Covers VUID-VkSwapchainLatencyCreateInfoNV-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSwapchainLatencyCreateInfoNV);
                if (!IsExtEnabled(device_extensions.vk_nv_low_latency2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_NV_low_latency2");
                }
                VkSwapchainLatencyCreateInfoNV* structure = (VkSwapchainLatencyCreateInfoNV*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::latencyModeEnable), structure->latencyModeEnable);
            }
        } break;

        // No Validation code for VkLatencySurfaceCapabilitiesNV structure members  -- Covers
        // VUID-VkLatencySurfaceCapabilitiesNV-sType-sType

        // Validation code for VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM structure members
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM: {  // Covers
                                                                                               // VUID-VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_multiview_per_view_render_areas)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_QCOM_multiview_per_view_render_areas");
                }
                VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* structure =
                    (VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::perViewRenderAreaCount), pNext_loc.dot(Field::pPerViewRenderAreas),
                                  structure->perViewRenderAreaCount, &structure->pPerViewRenderAreas, false, true, kVUIDUndefined,
                                  "VUID-VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM-pPerViewRenderAreas-parameter");

                if (structure->pPerViewRenderAreas != nullptr) {
                    for (uint32_t perViewRenderAreaIndex = 0; perViewRenderAreaIndex < structure->perViewRenderAreaCount;
                         ++perViewRenderAreaIndex) {
                        [[maybe_unused]] const Location pPerViewRenderAreas_loc =
                            pNext_loc.dot(Field::pPerViewRenderAreas, perViewRenderAreaIndex);
                    }
                }
            }
        } break;

        // Validation code for VkSamplerBlockMatchWindowCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM: {  // Covers
                                                                               // VUID-VkSamplerBlockMatchWindowCreateInfoQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerBlockMatchWindowCreateInfoQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_image_processing2)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_QCOM_image_processing2");
                }
                VkSamplerBlockMatchWindowCreateInfoQCOM* structure = (VkSamplerBlockMatchWindowCreateInfoQCOM*)header;
                skip |=
                    ValidateRangedEnum(pNext_loc.dot(Field::windowCompareMode), vvl::Enum::VkBlockMatchWindowCompareModeQCOM,
                                       structure->windowCompareMode,
                                       "VUID-VkSamplerBlockMatchWindowCreateInfoQCOM-windowCompareMode-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkSamplerCubicWeightsCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM: {  // Covers
                                                                          // VUID-VkSamplerCubicWeightsCreateInfoQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerCubicWeightsCreateInfoQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_filter_cubic_weights)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_QCOM_filter_cubic_weights");
                }
                VkSamplerCubicWeightsCreateInfoQCOM* structure = (VkSamplerCubicWeightsCreateInfoQCOM*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::cubicWeights), vvl::Enum::VkCubicFilterWeightsQCOM,
                                           structure->cubicWeights,
                                           "VUID-VkSamplerCubicWeightsCreateInfoQCOM-cubicWeights-parameter", VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkBlitImageCubicWeightsInfoQCOM structure members
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM: {  // Covers VUID-VkBlitImageCubicWeightsInfoQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkBlitImageCubicWeightsInfoQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_filter_cubic_weights)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_QCOM_filter_cubic_weights");
                }
                VkBlitImageCubicWeightsInfoQCOM* structure = (VkBlitImageCubicWeightsInfoQCOM*)header;
                skip |= ValidateRangedEnum(pNext_loc.dot(Field::cubicWeights), vvl::Enum::VkCubicFilterWeightsQCOM,
                                           structure->cubicWeights, "VUID-VkBlitImageCubicWeightsInfoQCOM-cubicWeights-parameter",
                                           VK_NULL_HANDLE);
            }
        } break;

        // Validation code for VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM structure members
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM: {  // Covers
                                                                                           // VUID-VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM);
                if (!IsExtEnabled(device_extensions.vk_qcom_ycbcr_degamma)) {
                    skip |=
                        LogError(pnext_vuid, instance, pNext_loc, "extended struct requires the extensions VK_QCOM_ycbcr_degamma");
                }
                VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* structure =
                    (VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)header;
                skip |= ValidateBool32(pNext_loc.dot(Field::enableYDegamma), structure->enableYDegamma);

                skip |= ValidateBool32(pNext_loc.dot(Field::enableCbCrDegamma), structure->enableCbCrDegamma);
            }
        } break;
#ifdef VK_USE_PLATFORM_SCREEN_QNX

        // No Validation code for VkScreenBufferFormatPropertiesQNX structure members  -- Covers
        // VUID-VkScreenBufferFormatPropertiesQNX-sType-sType

        // No Validation code for VkImportScreenBufferInfoQNX structure members  -- Covers
        // VUID-VkImportScreenBufferInfoQNX-sType-sType

        // No Validation code for VkExternalFormatQNX structure members  -- Covers VUID-VkExternalFormatQNX-sType-sType
#endif  // VK_USE_PLATFORM_SCREEN_QNX

        // Validation code for VkGeneratedCommandsPipelineInfoEXT structure members
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT: {  // Covers
                                                                        // VUID-VkGeneratedCommandsPipelineInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGeneratedCommandsPipelineInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_device_generated_commands");
                }
                VkGeneratedCommandsPipelineInfoEXT* structure = (VkGeneratedCommandsPipelineInfoEXT*)header;
                skip |= ValidateRequiredHandle(pNext_loc.dot(Field::pipeline), structure->pipeline);
            }
        } break;

        // Validation code for VkGeneratedCommandsShaderInfoEXT structure members
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT: {  // Covers VUID-VkGeneratedCommandsShaderInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkGeneratedCommandsShaderInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_device_generated_commands");
                }
                VkGeneratedCommandsShaderInfoEXT* structure = (VkGeneratedCommandsShaderInfoEXT*)header;
                skip |= ValidateHandleArray(pNext_loc.dot(Field::shaderCount), pNext_loc.dot(Field::pShaders),
                                            structure->shaderCount, structure->pShaders, true, true,
                                            "VUID-VkGeneratedCommandsShaderInfoEXT-shaderCount-arraylength");
            }
        } break;

        // No Validation code for VkImageAlignmentControlCreateInfoMESA structure members  -- Covers
        // VUID-VkImageAlignmentControlCreateInfoMESA-sType-sType

        // Validation code for VkPipelineViewportDepthClampControlCreateInfoEXT structure members
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT: {  // Covers
                                                                                         // VUID-VkPipelineViewportDepthClampControlCreateInfoEXT-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkPipelineViewportDepthClampControlCreateInfoEXT);
                if (!IsExtEnabled(device_extensions.vk_ext_depth_clamp_control)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_EXT_depth_clamp_control");
                }
                VkPipelineViewportDepthClampControlCreateInfoEXT* structure =
                    (VkPipelineViewportDepthClampControlCreateInfoEXT*)header;
                skip |= ValidateRangedEnum(
                    pNext_loc.dot(Field::depthClampMode), vvl::Enum::VkDepthClampModeEXT, structure->depthClampMode,
                    "VUID-VkPipelineViewportDepthClampControlCreateInfoEXT-depthClampMode-parameter", VK_NULL_HANDLE);

                if (structure->pDepthClampRange != nullptr) {
                    [[maybe_unused]] const Location pDepthClampRange_loc = pNext_loc.dot(Field::pDepthClampRange);
                }
            }
        } break;

        // Validation code for VkWriteDescriptorSetAccelerationStructureKHR structure members
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: {  // Covers
                                                                                   // VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType
            if (is_const_param) {
                [[maybe_unused]] const Location pNext_loc = loc.pNext(Struct::VkWriteDescriptorSetAccelerationStructureKHR);
                if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure)) {
                    skip |= LogError(pnext_vuid, instance, pNext_loc,
                                     "extended struct requires the extensions VK_KHR_acceleration_structure");
                }
                VkWriteDescriptorSetAccelerationStructureKHR* structure = (VkWriteDescriptorSetAccelerationStructureKHR*)header;
                skip |=
                    ValidateArray(pNext_loc.dot(Field::accelerationStructureCount), pNext_loc.dot(Field::pAccelerationStructures),
                                  structure->accelerationStructureCount, &structure->pAccelerationStructures, true, false,
                                  "VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength",
                                  "VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter");
            }
        } break;

        default:
            skip = false;
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateInstance(const VkInstanceCreateInfo* pCreateInfo,
                                                        const VkAllocationCallbacks* pAllocator, VkInstance* pInstance,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, true,
                               "VUID-vkCreateInstance-pCreateInfo-parameter", "VUID-VkInstanceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkInstanceCreateInfo = {VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
                                                                     VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
                                                                     VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkInstanceCreateInfo.size(),
                                    allowed_structs_VkInstanceCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkInstanceCreateInfo-pNext-pNext", "VUID-VkInstanceCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkInstanceCreateFlagBits,
                              AllVkInstanceCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkInstanceCreateInfo-flags-parameter");

        skip |= ValidateStructType(pCreateInfo_loc.dot(Field::pApplicationInfo), pCreateInfo->pApplicationInfo,
                                   VK_STRUCTURE_TYPE_APPLICATION_INFO, false,
                                   "VUID-VkInstanceCreateInfo-pApplicationInfo-parameter", "VUID-VkApplicationInfo-sType-sType");

        if (pCreateInfo->pApplicationInfo != nullptr) {
            [[maybe_unused]] const Location pApplicationInfo_loc = pCreateInfo_loc.dot(Field::pApplicationInfo);
            skip |= ValidateStructPnext(pApplicationInfo_loc, pCreateInfo->pApplicationInfo->pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkApplicationInfo-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);
        }

        skip |= ValidateStringArray(pCreateInfo_loc.dot(Field::enabledLayerCount), pCreateInfo_loc.dot(Field::ppEnabledLayerNames),
                                    pCreateInfo->enabledLayerCount, pCreateInfo->ppEnabledLayerNames, false, true, kVUIDUndefined,
                                    "VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter");

        skip |= ValidateStringArray(pCreateInfo_loc.dot(Field::enabledExtensionCount),
                                    pCreateInfo_loc.dot(Field::ppEnabledExtensionNames), pCreateInfo->enabledExtensionCount,
                                    pCreateInfo->ppEnabledExtensionNames, false, true, kVUIDUndefined,
                                    "VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pInstance), pInstance, "VUID-vkCreateInstance-pInstance-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateInstance(pCreateInfo, pAllocator, pInstance, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDevices(VkInstance instance, uint32_t* pPhysicalDeviceCount,
                                                                  VkPhysicalDevice* pPhysicalDevices,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidatePointerArray(loc.dot(Field::pPhysicalDeviceCount), loc.dot(Field::pPhysicalDevices), pPhysicalDeviceCount,
                                 &pPhysicalDevices, true, false, false,
                                 "VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter", kVUIDUndefined,
                                 "VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice,
                                                                   VkPhysicalDeviceFeatures* pFeatures,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc.dot(Field::pFeatures), pFeatures, "VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                           VkFormatProperties* pFormatProperties,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                               "VUID-vkGetPhysicalDeviceFormatProperties-format-parameter", physicalDevice);
    skip |= ValidateRequiredPointer(loc.dot(Field::pFormatProperties), pFormatProperties,
                                    "VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter");
    if (pFormatProperties != nullptr) {
        [[maybe_unused]] const Location pFormatProperties_loc = loc.dot(Field::pFormatProperties);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                                VkImageType type, VkImageTiling tiling,
                                                                                VkImageUsageFlags usage, VkImageCreateFlags flags,
                                                                                VkImageFormatProperties* pImageFormatProperties,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                               "VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter", physicalDevice);
    skip |= ValidateRangedEnum(loc.dot(Field::type), vvl::Enum::VkImageType, type,
                               "VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter", physicalDevice);
    skip |= ValidateRangedEnum(loc.dot(Field::tiling), vvl::Enum::VkImageTiling, tiling,
                               "VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter", physicalDevice);
    skip |= ValidateFlags(loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits, usage,
                          kRequiredFlags, physicalDevice, "VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter",
                          "VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask");
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits, flags,
                          kOptionalFlags, physicalDevice, "VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::pImageFormatProperties), pImageFormatProperties,
                                    "VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter");
    if (pImageFormatProperties != nullptr) {
        [[maybe_unused]] const Location pImageFormatProperties_loc = loc.dot(Field::pImageFormatProperties);
        // No xml-driven validation
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags,
                                                                             pImageFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice,
                                                                     VkPhysicalDeviceProperties* pProperties,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc.dot(Field::pProperties), pProperties,
                                    "VUID-vkGetPhysicalDeviceProperties-pProperties-parameter");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice,
                                                                                uint32_t* pQueueFamilyPropertyCount,
                                                                                VkQueueFamilyProperties* pQueueFamilyProperties,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidatePointerArray(loc.dot(Field::pQueueFamilyPropertyCount), loc.dot(Field::pQueueFamilyProperties),
                                 pQueueFamilyPropertyCount, &pQueueFamilyProperties, true, false, false,
                                 "VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter",
                                 kVUIDUndefined, "VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter");
    if (pQueueFamilyProperties != nullptr) {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount;
             ++pQueueFamilyPropertyIndex) {
            [[maybe_unused]] const Location pQueueFamilyProperties_loc =
                loc.dot(Field::pQueueFamilyProperties, pQueueFamilyPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice,
                                                                           VkPhysicalDeviceMemoryProperties* pMemoryProperties,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc.dot(Field::pMemoryProperties), pMemoryProperties,
                                    "VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter");
    if (pMemoryProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryProperties_loc = loc.dot(Field::pMemoryProperties);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator, VkDevice* pDevice,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, true,
                               "VUID-vkCreateDevice-pCreateInfo-parameter", "VUID-VkDeviceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDeviceCreateInfo = {
            VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
            VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
            VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
            VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDeviceCreateInfo.size(),
                                    allowed_structs_VkDeviceCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceCreateInfo-pNext-pNext", "VUID-VkDeviceCreateInfo-sType-unique", physicalDevice,
                                    true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkDeviceCreateInfo-flags-zerobitmask");

        skip |= ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::queueCreateInfoCount), pCreateInfo_loc.dot(Field::pQueueCreateInfos),
            pCreateInfo->queueCreateInfoCount, pCreateInfo->pQueueCreateInfos, VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, true,
            true, "VUID-VkDeviceQueueCreateInfo-sType-sType", "VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter",
            "VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength");

        if (pCreateInfo->pQueueCreateInfos != nullptr) {
            for (uint32_t queueCreateInfoIndex = 0; queueCreateInfoIndex < pCreateInfo->queueCreateInfoCount;
                 ++queueCreateInfoIndex) {
                [[maybe_unused]] const Location pQueueCreateInfos_loc =
                    pCreateInfo_loc.dot(Field::pQueueCreateInfos, queueCreateInfoIndex);
                constexpr std::array allowed_structs_VkDeviceQueueCreateInfo = {
                    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR,
                    VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM};

                skip |= ValidateStructPnext(pQueueCreateInfos_loc, pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pNext,
                                            allowed_structs_VkDeviceQueueCreateInfo.size(),
                                            allowed_structs_VkDeviceQueueCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkDeviceQueueCreateInfo-pNext-pNext", "VUID-VkDeviceQueueCreateInfo-sType-unique",
                                            physicalDevice, true);

                skip |= ValidateFlags(pQueueCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceQueueCreateFlagBits,
                                      AllVkDeviceQueueCreateFlagBits, pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkDeviceQueueCreateInfo-flags-parameter");

                skip |=
                    ValidateArray(pQueueCreateInfos_loc.dot(Field::queueCount), pQueueCreateInfos_loc.dot(Field::pQueuePriorities),
                                  pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].queueCount,
                                  &pCreateInfo->pQueueCreateInfos[queueCreateInfoIndex].pQueuePriorities, true, true,
                                  "VUID-VkDeviceQueueCreateInfo-queueCount-arraylength",
                                  "VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter");
            }
        }

        skip |= ValidateStringArray(pCreateInfo_loc.dot(Field::enabledLayerCount), pCreateInfo_loc.dot(Field::ppEnabledLayerNames),
                                    pCreateInfo->enabledLayerCount, pCreateInfo->ppEnabledLayerNames, false, true, kVUIDUndefined,
                                    "VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter");

        skip |= ValidateStringArray(pCreateInfo_loc.dot(Field::enabledExtensionCount),
                                    pCreateInfo_loc.dot(Field::ppEnabledExtensionNames), pCreateInfo->enabledExtensionCount,
                                    pCreateInfo->ppEnabledExtensionNames, false, true, kVUIDUndefined,
                                    "VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter");

        if (pCreateInfo->pEnabledFeatures != nullptr) {
            [[maybe_unused]] const Location pEnabledFeatures_loc = pCreateInfo_loc.dot(Field::pEnabledFeatures);
            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::robustBufferAccess),
                                   pCreateInfo->pEnabledFeatures->robustBufferAccess);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::fullDrawIndexUint32),
                                   pCreateInfo->pEnabledFeatures->fullDrawIndexUint32);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::imageCubeArray), pCreateInfo->pEnabledFeatures->imageCubeArray);

            skip |=
                ValidateBool32(pEnabledFeatures_loc.dot(Field::independentBlend), pCreateInfo->pEnabledFeatures->independentBlend);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::geometryShader), pCreateInfo->pEnabledFeatures->geometryShader);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::tessellationShader),
                                   pCreateInfo->pEnabledFeatures->tessellationShader);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sampleRateShading),
                                   pCreateInfo->pEnabledFeatures->sampleRateShading);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::dualSrcBlend), pCreateInfo->pEnabledFeatures->dualSrcBlend);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::logicOp), pCreateInfo->pEnabledFeatures->logicOp);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::multiDrawIndirect),
                                   pCreateInfo->pEnabledFeatures->multiDrawIndirect);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::drawIndirectFirstInstance),
                                   pCreateInfo->pEnabledFeatures->drawIndirectFirstInstance);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::depthClamp), pCreateInfo->pEnabledFeatures->depthClamp);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::depthBiasClamp), pCreateInfo->pEnabledFeatures->depthBiasClamp);

            skip |=
                ValidateBool32(pEnabledFeatures_loc.dot(Field::fillModeNonSolid), pCreateInfo->pEnabledFeatures->fillModeNonSolid);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::depthBounds), pCreateInfo->pEnabledFeatures->depthBounds);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::wideLines), pCreateInfo->pEnabledFeatures->wideLines);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::largePoints), pCreateInfo->pEnabledFeatures->largePoints);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::alphaToOne), pCreateInfo->pEnabledFeatures->alphaToOne);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::multiViewport), pCreateInfo->pEnabledFeatures->multiViewport);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::samplerAnisotropy),
                                   pCreateInfo->pEnabledFeatures->samplerAnisotropy);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::textureCompressionETC2),
                                   pCreateInfo->pEnabledFeatures->textureCompressionETC2);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::textureCompressionASTC_LDR),
                                   pCreateInfo->pEnabledFeatures->textureCompressionASTC_LDR);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::textureCompressionBC),
                                   pCreateInfo->pEnabledFeatures->textureCompressionBC);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::occlusionQueryPrecise),
                                   pCreateInfo->pEnabledFeatures->occlusionQueryPrecise);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::pipelineStatisticsQuery),
                                   pCreateInfo->pEnabledFeatures->pipelineStatisticsQuery);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::vertexPipelineStoresAndAtomics),
                                   pCreateInfo->pEnabledFeatures->vertexPipelineStoresAndAtomics);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::fragmentStoresAndAtomics),
                                   pCreateInfo->pEnabledFeatures->fragmentStoresAndAtomics);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderTessellationAndGeometryPointSize),
                                   pCreateInfo->pEnabledFeatures->shaderTessellationAndGeometryPointSize);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderImageGatherExtended),
                                   pCreateInfo->pEnabledFeatures->shaderImageGatherExtended);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderStorageImageExtendedFormats),
                                   pCreateInfo->pEnabledFeatures->shaderStorageImageExtendedFormats);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderStorageImageMultisample),
                                   pCreateInfo->pEnabledFeatures->shaderStorageImageMultisample);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderStorageImageReadWithoutFormat),
                                   pCreateInfo->pEnabledFeatures->shaderStorageImageReadWithoutFormat);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderStorageImageWriteWithoutFormat),
                                   pCreateInfo->pEnabledFeatures->shaderStorageImageWriteWithoutFormat);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderUniformBufferArrayDynamicIndexing),
                                   pCreateInfo->pEnabledFeatures->shaderUniformBufferArrayDynamicIndexing);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderSampledImageArrayDynamicIndexing),
                                   pCreateInfo->pEnabledFeatures->shaderSampledImageArrayDynamicIndexing);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderStorageBufferArrayDynamicIndexing),
                                   pCreateInfo->pEnabledFeatures->shaderStorageBufferArrayDynamicIndexing);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderStorageImageArrayDynamicIndexing),
                                   pCreateInfo->pEnabledFeatures->shaderStorageImageArrayDynamicIndexing);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderClipDistance),
                                   pCreateInfo->pEnabledFeatures->shaderClipDistance);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderCullDistance),
                                   pCreateInfo->pEnabledFeatures->shaderCullDistance);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderFloat64), pCreateInfo->pEnabledFeatures->shaderFloat64);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderInt64), pCreateInfo->pEnabledFeatures->shaderInt64);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderInt16), pCreateInfo->pEnabledFeatures->shaderInt16);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderResourceResidency),
                                   pCreateInfo->pEnabledFeatures->shaderResourceResidency);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::shaderResourceMinLod),
                                   pCreateInfo->pEnabledFeatures->shaderResourceMinLod);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseBinding), pCreateInfo->pEnabledFeatures->sparseBinding);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidencyBuffer),
                                   pCreateInfo->pEnabledFeatures->sparseResidencyBuffer);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidencyImage2D),
                                   pCreateInfo->pEnabledFeatures->sparseResidencyImage2D);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidencyImage3D),
                                   pCreateInfo->pEnabledFeatures->sparseResidencyImage3D);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidency2Samples),
                                   pCreateInfo->pEnabledFeatures->sparseResidency2Samples);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidency4Samples),
                                   pCreateInfo->pEnabledFeatures->sparseResidency4Samples);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidency8Samples),
                                   pCreateInfo->pEnabledFeatures->sparseResidency8Samples);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidency16Samples),
                                   pCreateInfo->pEnabledFeatures->sparseResidency16Samples);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::sparseResidencyAliased),
                                   pCreateInfo->pEnabledFeatures->sparseResidencyAliased);

            skip |= ValidateBool32(pEnabledFeatures_loc.dot(Field::variableMultisampleRate),
                                   pCreateInfo->pEnabledFeatures->variableMultisampleRate);

            skip |=
                ValidateBool32(pEnabledFeatures_loc.dot(Field::inheritedQueries), pCreateInfo->pEnabledFeatures->inheritedQueries);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pDevice), pDevice, "VUID-vkCreateDevice-pDevice-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex,
                                                        VkQueue* pQueue, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc.dot(Field::pQueue), pQueue, "VUID-vkGetDeviceQueue-pQueue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                                     VkFence fence, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc.dot(Field::submitCount), loc.dot(Field::pSubmits), submitCount, pSubmits,
                                    VK_STRUCTURE_TYPE_SUBMIT_INFO, false, true, "VUID-VkSubmitInfo-sType-sType",
                                    "VUID-vkQueueSubmit-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr) {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex) {
            [[maybe_unused]] const Location pSubmits_loc = loc.dot(Field::pSubmits, submitIndex);
            constexpr std::array allowed_structs_VkSubmitInfo = {VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC,
                                                                 VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
                                                                 VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                                                                 VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
                                                                 VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
                                                                 VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
                                                                 VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV};

            skip |= ValidateStructPnext(pSubmits_loc, pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo.size(),
                                        allowed_structs_VkSubmitInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkSubmitInfo-pNext-pNext", "VUID-VkSubmitInfo-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateArray(pSubmits_loc.dot(Field::waitSemaphoreCount), pSubmits_loc.dot(Field::pWaitSemaphores),
                                  pSubmits[submitIndex].waitSemaphoreCount, &pSubmits[submitIndex].pWaitSemaphores, false, true,
                                  kVUIDUndefined, "VUID-VkSubmitInfo-pWaitSemaphores-parameter");

            skip |= ValidateFlagsArray(pSubmits_loc.dot(Field::waitSemaphoreCount), pSubmits_loc.dot(Field::pWaitDstStageMask),
                                       vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                                       pSubmits[submitIndex].waitSemaphoreCount, pSubmits[submitIndex].pWaitDstStageMask, false,
                                       kVUIDUndefined, "VUID-VkSubmitInfo-pWaitDstStageMask-parameter");

            skip |= ValidateArray(pSubmits_loc.dot(Field::commandBufferCount), pSubmits_loc.dot(Field::pCommandBuffers),
                                  pSubmits[submitIndex].commandBufferCount, &pSubmits[submitIndex].pCommandBuffers, false, true,
                                  kVUIDUndefined, "VUID-VkSubmitInfo-pCommandBuffers-parameter");

            skip |= ValidateArray(pSubmits_loc.dot(Field::signalSemaphoreCount), pSubmits_loc.dot(Field::pSignalSemaphores),
                                  pSubmits[submitIndex].signalSemaphoreCount, &pSubmits[submitIndex].pSignalSemaphores, false, true,
                                  kVUIDUndefined, "VUID-VkSubmitInfo-pSignalSemaphores-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateQueueWaitIdle(VkQueue queue, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateDeviceWaitIdle(VkDevice device, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateAllocateMemory(VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo,
                                                        const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pAllocateInfo), pAllocateInfo, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, true,
                               "VUID-vkAllocateMemory-pAllocateInfo-parameter", "VUID-VkMemoryAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr) {
        [[maybe_unused]] const Location pAllocateInfo_loc = loc.dot(Field::pAllocateInfo);
        constexpr std::array allowed_structs_VkMemoryAllocateInfo = {VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
                                                                     VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA,
                                                                     VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT,
                                                                     VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX,
                                                                     VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
                                                                     VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
                                                                     VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
                                                                     VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT};

        skip |= ValidateStructPnext(pAllocateInfo_loc, pAllocateInfo->pNext, allowed_structs_VkMemoryAllocateInfo.size(),
                                    allowed_structs_VkMemoryAllocateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryAllocateInfo-pNext-pNext", "VUID-VkMemoryAllocateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pMemory), pMemory, "VUID-vkAllocateMemory-pMemory-parameter");
    if (!skip) skip |= manual_PreCallValidateAllocateMemory(device, pAllocateInfo, pAllocator, pMemory, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator,
                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
                                                   VkMemoryMapFlags flags, void** ppData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryMapFlagBits, AllVkMemoryMapFlagBits, flags,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkMapMemory-flags-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::ppData), ppData, "VUID-vkMapMemory-ppData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateUnmapMemory(VkDevice device, VkDeviceMemory memory, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    return skip;
}

bool StatelessValidation::PreCallValidateFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                                 const VkMappedMemoryRange* pMemoryRanges,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::memoryRangeCount), loc.dot(Field::pMemoryRanges), memoryRangeCount, pMemoryRanges,
        VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, "VUID-VkMappedMemoryRange-sType-sType",
        "VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter", "VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength");
    if (pMemoryRanges != nullptr) {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex) {
            [[maybe_unused]] const Location pMemoryRanges_loc = loc.dot(Field::pMemoryRanges, memoryRangeIndex);
            skip |= ValidateStructPnext(pMemoryRanges_loc, pMemoryRanges[memoryRangeIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkMappedMemoryRange-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pMemoryRanges_loc.dot(Field::memory), pMemoryRanges[memoryRangeIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                                      const VkMappedMemoryRange* pMemoryRanges,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructTypeArray(loc.dot(Field::memoryRangeCount), loc.dot(Field::pMemoryRanges), memoryRangeCount, pMemoryRanges,
                                VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, true, true, "VUID-VkMappedMemoryRange-sType-sType",
                                "VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter",
                                "VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength");
    if (pMemoryRanges != nullptr) {
        for (uint32_t memoryRangeIndex = 0; memoryRangeIndex < memoryRangeCount; ++memoryRangeIndex) {
            [[maybe_unused]] const Location pMemoryRanges_loc = loc.dot(Field::pMemoryRanges, memoryRangeIndex);
            skip |= ValidateStructPnext(pMemoryRanges_loc, pMemoryRanges[memoryRangeIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkMappedMemoryRange-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pMemoryRanges_loc.dot(Field::memory), pMemoryRanges[memoryRangeIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory,
                                                                   VkDeviceSize* pCommittedMemoryInBytes,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    skip |= ValidateRequiredPointer(loc.dot(Field::pCommittedMemoryInBytes), pCommittedMemoryInBytes,
                                    "VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
                                                          VkDeviceSize memoryOffset, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    return skip;
}

bool StatelessValidation::PreCallValidateBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory,
                                                         VkDeviceSize memoryOffset, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer,
                                                                     VkMemoryRequirements* pMemoryRequirements,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= ValidateRequiredPointer(loc.dot(Field::pMemoryRequirements), pMemoryRequirements,
                                    "VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageMemoryRequirements(VkDevice device, VkImage image,
                                                                    VkMemoryRequirements* pMemoryRequirements,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateRequiredPointer(loc.dot(Field::pMemoryRequirements), pMemoryRequirements,
                                    "VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSparseMemoryRequirements(
    VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements* pSparseMemoryRequirements, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidatePointerArray(loc.dot(Field::pSparseMemoryRequirementCount), loc.dot(Field::pSparseMemoryRequirements),
                                 pSparseMemoryRequirementCount, &pSparseMemoryRequirements, true, false, false,
                                 "VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter", kVUIDUndefined,
                                 "VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter");
    if (pSparseMemoryRequirements != nullptr) {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount;
             ++pSparseMemoryRequirementIndex) {
            [[maybe_unused]] const Location pSparseMemoryRequirements_loc =
                loc.dot(Field::pSparseMemoryRequirements, pSparseMemoryRequirementIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage,
    VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                               "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter", physicalDevice);
    skip |= ValidateRangedEnum(loc.dot(Field::type), vvl::Enum::VkImageType, type,
                               "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter", physicalDevice);
    skip |=
        ValidateFlags(loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits, samples,
                      kRequiredSingleBit, physicalDevice, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter",
                      "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter");
    skip |= ValidateFlags(loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits, usage,
                          kRequiredFlags, physicalDevice, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter",
                          "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask");
    skip |= ValidateRangedEnum(loc.dot(Field::tiling), vvl::Enum::VkImageTiling, tiling,
                               "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter", physicalDevice);
    skip |= ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties, true,
                                 false, false, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter",
                                 kVUIDUndefined, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                                         VkFence fence, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfo), bindInfoCount, pBindInfo,
                                    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO, false, true, "VUID-VkBindSparseInfo-sType-sType",
                                    "VUID-vkQueueBindSparse-pBindInfo-parameter", kVUIDUndefined);
    if (pBindInfo != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfo_loc = loc.dot(Field::pBindInfo, bindInfoIndex);
            constexpr std::array allowed_structs_VkBindSparseInfo = {VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
                                                                     VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                                                                     VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO};

            skip |= ValidateStructPnext(pBindInfo_loc, pBindInfo[bindInfoIndex].pNext, allowed_structs_VkBindSparseInfo.size(),
                                        allowed_structs_VkBindSparseInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkBindSparseInfo-pNext-pNext", "VUID-VkBindSparseInfo-sType-unique", VK_NULL_HANDLE,
                                        true);

            skip |= ValidateArray(pBindInfo_loc.dot(Field::waitSemaphoreCount), pBindInfo_loc.dot(Field::pWaitSemaphores),
                                  pBindInfo[bindInfoIndex].waitSemaphoreCount, &pBindInfo[bindInfoIndex].pWaitSemaphores, false,
                                  true, kVUIDUndefined, "VUID-VkBindSparseInfo-pWaitSemaphores-parameter");

            skip |= ValidateArray(pBindInfo_loc.dot(Field::bufferBindCount), pBindInfo_loc.dot(Field::pBufferBinds),
                                  pBindInfo[bindInfoIndex].bufferBindCount, &pBindInfo[bindInfoIndex].pBufferBinds, false, true,
                                  kVUIDUndefined, "VUID-VkBindSparseInfo-pBufferBinds-parameter");

            if (pBindInfo[bindInfoIndex].pBufferBinds != nullptr) {
                for (uint32_t bufferBindIndex = 0; bufferBindIndex < pBindInfo[bindInfoIndex].bufferBindCount; ++bufferBindIndex) {
                    [[maybe_unused]] const Location pBufferBinds_loc = pBindInfo_loc.dot(Field::pBufferBinds, bufferBindIndex);
                    skip |= ValidateRequiredHandle(pBufferBinds_loc.dot(Field::buffer),
                                                   pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].buffer);

                    skip |= ValidateArray(pBufferBinds_loc.dot(Field::bindCount), pBufferBinds_loc.dot(Field::pBinds),
                                          pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount,
                                          &pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds, true, true,
                                          "VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength",
                                          "VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds != nullptr) {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].bindCount;
                             ++bindIndex) {
                            [[maybe_unused]] const Location pBinds_loc = pBufferBinds_loc.dot(Field::pBinds, bindIndex);
                            skip |= ValidateFlags(pBinds_loc.dot(Field::flags), vvl::FlagBitmask::VkSparseMemoryBindFlagBits,
                                                  AllVkSparseMemoryBindFlagBits,
                                                  pBindInfo[bindInfoIndex].pBufferBinds[bufferBindIndex].pBinds[bindIndex].flags,
                                                  kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSparseMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= ValidateArray(pBindInfo_loc.dot(Field::imageOpaqueBindCount), pBindInfo_loc.dot(Field::pImageOpaqueBinds),
                                  pBindInfo[bindInfoIndex].imageOpaqueBindCount, &pBindInfo[bindInfoIndex].pImageOpaqueBinds, false,
                                  true, kVUIDUndefined, "VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter");

            if (pBindInfo[bindInfoIndex].pImageOpaqueBinds != nullptr) {
                for (uint32_t imageOpaqueBindIndex = 0; imageOpaqueBindIndex < pBindInfo[bindInfoIndex].imageOpaqueBindCount;
                     ++imageOpaqueBindIndex) {
                    [[maybe_unused]] const Location pImageOpaqueBinds_loc =
                        pBindInfo_loc.dot(Field::pImageOpaqueBinds, imageOpaqueBindIndex);
                    skip |= ValidateRequiredHandle(pImageOpaqueBinds_loc.dot(Field::image),
                                                   pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].image);

                    skip |= ValidateArray(pImageOpaqueBinds_loc.dot(Field::bindCount), pImageOpaqueBinds_loc.dot(Field::pBinds),
                                          pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount,
                                          &pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds, true, true,
                                          "VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength",
                                          "VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds != nullptr) {
                        for (uint32_t bindIndex = 0;
                             bindIndex < pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].bindCount; ++bindIndex) {
                            [[maybe_unused]] const Location pBinds_loc = pImageOpaqueBinds_loc.dot(Field::pBinds, bindIndex);
                            skip |= ValidateFlags(
                                pBinds_loc.dot(Field::flags), vvl::FlagBitmask::VkSparseMemoryBindFlagBits,
                                AllVkSparseMemoryBindFlagBits,
                                pBindInfo[bindInfoIndex].pImageOpaqueBinds[imageOpaqueBindIndex].pBinds[bindIndex].flags,
                                kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSparseMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= ValidateArray(pBindInfo_loc.dot(Field::imageBindCount), pBindInfo_loc.dot(Field::pImageBinds),
                                  pBindInfo[bindInfoIndex].imageBindCount, &pBindInfo[bindInfoIndex].pImageBinds, false, true,
                                  kVUIDUndefined, "VUID-VkBindSparseInfo-pImageBinds-parameter");

            if (pBindInfo[bindInfoIndex].pImageBinds != nullptr) {
                for (uint32_t imageBindIndex = 0; imageBindIndex < pBindInfo[bindInfoIndex].imageBindCount; ++imageBindIndex) {
                    [[maybe_unused]] const Location pImageBinds_loc = pBindInfo_loc.dot(Field::pImageBinds, imageBindIndex);
                    skip |= ValidateRequiredHandle(pImageBinds_loc.dot(Field::image),
                                                   pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].image);

                    skip |= ValidateArray(pImageBinds_loc.dot(Field::bindCount), pImageBinds_loc.dot(Field::pBinds),
                                          pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount,
                                          &pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds, true, true,
                                          "VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength",
                                          "VUID-VkSparseImageMemoryBindInfo-pBinds-parameter");

                    if (pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds != nullptr) {
                        for (uint32_t bindIndex = 0; bindIndex < pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].bindCount;
                             ++bindIndex) {
                            [[maybe_unused]] const Location pBinds_loc = pImageBinds_loc.dot(Field::pBinds, bindIndex);
                            skip |= ValidateFlags(
                                pBinds_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                AllVkImageAspectFlagBits,
                                pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].subresource.aspectMask,
                                kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresource-aspectMask-parameter",
                                "VUID-VkImageSubresource-aspectMask-requiredbitmask");

                            // No xml-driven validation

                            // No xml-driven validation

                            skip |= ValidateFlags(pBinds_loc.dot(Field::flags), vvl::FlagBitmask::VkSparseMemoryBindFlagBits,
                                                  AllVkSparseMemoryBindFlagBits,
                                                  pBindInfo[bindInfoIndex].pImageBinds[imageBindIndex].pBinds[bindIndex].flags,
                                                  kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSparseImageMemoryBind-flags-parameter");
                        }
                    }
                }
            }

            skip |= ValidateArray(pBindInfo_loc.dot(Field::signalSemaphoreCount), pBindInfo_loc.dot(Field::pSignalSemaphores),
                                  pBindInfo[bindInfoIndex].signalSemaphoreCount, &pBindInfo[bindInfoIndex].pSignalSemaphores, false,
                                  true, kVUIDUndefined, "VUID-VkBindSparseInfo-pSignalSemaphores-parameter");
        }
    }
    if (!skip) skip |= manual_PreCallValidateQueueBindSparse(queue, bindInfoCount, pBindInfo, fence, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateFence(VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator, VkFence* pFence,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, true,
                               "VUID-vkCreateFence-pCreateInfo-parameter", "VUID-VkFenceCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkFenceCreateInfo = {VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
                                                                  VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkFenceCreateInfo.size(),
                                allowed_structs_VkFenceCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkFenceCreateInfo-pNext-pNext", "VUID-VkFenceCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFenceCreateFlagBits, AllVkFenceCreateFlagBits,
                              pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkFenceCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFence), pFence, "VUID-vkCreateFence-pFence-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateHandleArray(loc.dot(Field::fenceCount), loc.dot(Field::pFences), fenceCount, pFences, true, true,
                                "VUID-vkResetFences-fenceCount-arraylength");
    return skip;
}

bool StatelessValidation::PreCallValidateGetFenceStatus(VkDevice device, VkFence fence, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::fence), fence);
    return skip;
}

bool StatelessValidation::PreCallValidateWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences,
                                                       VkBool32 waitAll, uint64_t timeout, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateHandleArray(loc.dot(Field::fenceCount), loc.dot(Field::pFences), fenceCount, pFences, true, true,
                                "VUID-vkWaitForFences-fenceCount-arraylength");
    skip |= ValidateBool32(loc.dot(Field::waitAll), waitAll);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo,
                                                         const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, true,
                               "VUID-vkCreateSemaphore-pCreateInfo-parameter", "VUID-VkSemaphoreCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSemaphoreCreateInfo = {
            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
            VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT,
            VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV,           VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSemaphoreCreateInfo.size(),
                                    allowed_structs_VkSemaphoreCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSemaphoreCreateInfo-pNext-pNext", "VUID-VkSemaphoreCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkSemaphoreCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSemaphore), pSemaphore, "VUID-vkCreateSemaphore-pSemaphore-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySemaphore(VkDevice device, VkSemaphore semaphore,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateEvent(VkDevice device, const VkEventCreateInfo* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator, VkEvent* pEvent,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_EVENT_CREATE_INFO, true,
                               "VUID-vkCreateEvent-pCreateInfo-parameter", "VUID-VkEventCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkEventCreateInfo = {VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                                                                  VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkEventCreateInfo.size(),
                                allowed_structs_VkEventCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkEventCreateInfo-pNext-pNext", "VUID-VkEventCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkEventCreateFlagBits, AllVkEventCreateFlagBits,
                              pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkEventCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pEvent), pEvent, "VUID-vkCreateEvent-pEvent-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateEvent(device, pCreateInfo, pAllocator, pEvent, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetEventStatus(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    return skip;
}

bool StatelessValidation::PreCallValidateSetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    return skip;
}

bool StatelessValidation::PreCallValidateResetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo,
                                                         const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, true,
                               "VUID-vkCreateQueryPool-pCreateInfo-parameter", "VUID-VkQueryPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkQueryPoolCreateInfo = {
            VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkQueryPoolCreateInfo.size(),
                                    allowed_structs_VkQueryPoolCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkQueryPoolCreateInfo-pNext-pNext", "VUID-VkQueryPoolCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkQueryPoolCreateInfo-flags-zerobitmask");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::queryType), vvl::Enum::VkQueryType, pCreateInfo->queryType,
                                   "VUID-VkQueryPoolCreateInfo-queryType-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pQueryPool), pQueryPool, "VUID-vkCreateQueryPool-pQueryPool-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyQueryPool(VkDevice device, VkQueryPool queryPool,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                                             uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride,
                                                             VkQueryResultFlags flags, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkGetQueryPoolResults-dataSize-arraylength", "VUID-vkGetQueryPoolResults-pData-parameter");
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryResultFlagBits, AllVkQueryResultFlagBits, flags,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkGetQueryPoolResults-flags-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags,
                                                          error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateBuffer(VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                                                      const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, true,
                               "VUID-vkCreateBuffer-pCreateInfo-parameter", "VUID-VkBufferCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkBufferCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                                                                   VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR,
                                                                   VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
                                                                   VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(),
                                    allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique", VK_NULL_HANDLE,
                                    true);

        skip |=
            ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits, AllVkBufferCreateFlagBits,
                          pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode, pCreateInfo->sharingMode,
                                   "VUID-VkBufferCreateInfo-sharingMode-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pBuffer), pBuffer, "VUID-vkCreateBuffer-pBuffer-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateBuffer(device, pCreateInfo, pAllocator, pBuffer, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateBufferView(VkDevice device, const VkBufferViewCreateInfo* pCreateInfo,
                                                          const VkAllocationCallbacks* pAllocator, VkBufferView* pView,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, true,
                               "VUID-vkCreateBufferView-pCreateInfo-parameter", "VUID-VkBufferViewCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkBufferViewCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR,
                                                                       VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkBufferViewCreateInfo.size(),
                                    allowed_structs_VkBufferViewCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferViewCreateInfo-pNext-pNext", "VUID-VkBufferViewCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkBufferViewCreateInfo-flags-zerobitmask");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::buffer), pCreateInfo->buffer);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                   "VUID-VkBufferViewCreateInfo-format-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pView), pView, "VUID-vkCreateBufferView-pView-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateBufferView(device, pCreateInfo, pAllocator, pView, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyBufferView(VkDevice device, VkBufferView bufferView,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateImage(VkDevice device, const VkImageCreateInfo* pCreateInfo,
                                                     const VkAllocationCallbacks* pAllocator, VkImage* pImage,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
                               "VUID-vkCreateImage-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkImageCreateInfo = {
            VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
            VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
            VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
            VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits,
                              pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType, pCreateInfo->imageType,
                                   "VUID-VkImageCreateInfo-imageType-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                   "VUID-VkImageCreateInfo-format-parameter", VK_NULL_HANDLE);

        // No xml-driven validation

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                              AllVkSampleCountFlagBits, pCreateInfo->samples, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pCreateInfo->tiling,
                                   "VUID-VkImageCreateInfo-tiling-parameter", VK_NULL_HANDLE);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits,
                              pCreateInfo->usage, kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageCreateInfo-usage-parameter",
                              "VUID-VkImageCreateInfo-usage-requiredbitmask");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode, pCreateInfo->sharingMode,
                                   "VUID-VkImageCreateInfo-sharingMode-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout, pCreateInfo->initialLayout,
                                   "VUID-VkImageCreateInfo-initialLayout-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pImage), pImage, "VUID-vkCreateImage-pImage-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateImage(device, pCreateInfo, pAllocator, pImage, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSubresourceLayout(VkDevice device, VkImage image,
                                                                   const VkImageSubresource* pSubresource,
                                                                   VkSubresourceLayout* pLayout,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateRequiredPointer(loc.dot(Field::pSubresource), pSubresource,
                                    "VUID-vkGetImageSubresourceLayout-pSubresource-parameter");
    if (pSubresource != nullptr) {
        [[maybe_unused]] const Location pSubresource_loc = loc.dot(Field::pSubresource);
        skip |= ValidateFlags(pSubresource_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                              AllVkImageAspectFlagBits, pSubresource->aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pLayout), pLayout, "VUID-vkGetImageSubresourceLayout-pLayout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateImageView(VkDevice device, const VkImageViewCreateInfo* pCreateInfo,
                                                         const VkAllocationCallbacks* pAllocator, VkImageView* pView,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, true,
                               "VUID-vkCreateImageView-pCreateInfo-parameter", "VUID-VkImageViewCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkImageViewCreateInfo = {
            VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkImageViewCreateInfo.size(),
                                    allowed_structs_VkImageViewCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageViewCreateInfo-pNext-pNext", "VUID-VkImageViewCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageViewCreateFlagBits,
                              AllVkImageViewCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkImageViewCreateInfo-flags-parameter");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::image), pCreateInfo->image);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::viewType), vvl::Enum::VkImageViewType, pCreateInfo->viewType,
                                   "VUID-VkImageViewCreateInfo-viewType-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                   "VUID-VkImageViewCreateInfo-format-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::r), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.r,
                                   "VUID-VkComponentMapping-r-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::g), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.g,
                                   "VUID-VkComponentMapping-g-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::b), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.b,
                                   "VUID-VkComponentMapping-b-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::a), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.a,
                                   "VUID-VkComponentMapping-a-parameter", VK_NULL_HANDLE);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                              AllVkImageAspectFlagBits, pCreateInfo->subresourceRange.aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkImageSubresourceRange-aspectMask-parameter",
                              "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pView), pView, "VUID-vkCreateImageView-pView-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateImageView(device, pCreateInfo, pAllocator, pView, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyImageView(VkDevice device, VkImageView imageView,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true,
                               "VUID-vkCreateShaderModule-pCreateInfo-parameter", "VUID-VkShaderModuleCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::codeSize), pCreateInfo_loc.dot(Field::pCode), pCreateInfo->codeSize / 4,
                              &pCreateInfo->pCode, true, true, "VUID-VkShaderModuleCreateInfo-codeSize-01085",
                              "VUID-VkShaderModuleCreateInfo-pCode-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pShaderModule), pShaderModule, "VUID-vkCreateShaderModule-pShaderModule-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyShaderModule(VkDevice device, VkShaderModule shaderModule,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             VkPipelineCache* pPipelineCache, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, true,
                               "VUID-vkCreatePipelineCache-pCreateInfo-parameter", "VUID-VkPipelineCacheCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineCacheCreateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineCacheCreateFlagBits,
                              AllVkPipelineCacheCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkPipelineCacheCreateInfo-flags-parameter");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::initialDataSize), pCreateInfo_loc.dot(Field::pInitialData),
                              pCreateInfo->initialDataSize, &pCreateInfo->pInitialData, false, true, kVUIDUndefined,
                              "VUID-VkPipelineCacheCreateInfo-pInitialData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pPipelineCache), pPipelineCache,
                                    "VUID-vkCreatePipelineCache-pPipelineCache-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache,
                                                              const VkAllocationCallbacks* pAllocator,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize,
                                                              void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::pipelineCache), pipelineCache);
    skip |= ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                 "VUID-vkGetPipelineCacheData-pDataSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetPipelineCacheData-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount,
                                                             const VkPipelineCache* pSrcCaches,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::dstCache), dstCache);
    skip |= ValidateHandleArray(loc.dot(Field::srcCacheCount), loc.dot(Field::pSrcCaches), srcCacheCount, pSrcCaches, true, true,
                                "VUID-vkMergePipelineCaches-srcCacheCount-arraylength");
    if (!skip) skip |= manual_PreCallValidateMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache,
                                                                 uint32_t createInfoCount,
                                                                 const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                                                 const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
        VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, true, true, "VUID-VkGraphicsPipelineCreateInfo-sType-sType",
        "VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter", "VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkGraphicsPipelineCreateInfo = {
                VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR,
                VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                        allowed_structs_VkGraphicsPipelineCreateInfo.size(),
                                        allowed_structs_VkGraphicsPipelineCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkGraphicsPipelineCreateInfo-pNext-pNext",
                                        "VUID-VkGraphicsPipelineCreateInfo-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructType(pCreateInfos_loc.dot(Field::pDynamicState), pCreateInfos[createInfoIndex].pDynamicState,
                                       VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false,
                                       "VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter",
                                       "VUID-VkPipelineDynamicStateCreateInfo-sType-sType");

            if (pCreateInfos[createInfoIndex].pDynamicState != nullptr) {
                [[maybe_unused]] const Location pDynamicState_loc = pCreateInfos_loc.dot(Field::pDynamicState);
                skip |= ValidateStructPnext(pDynamicState_loc, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |=
                    ValidateReservedFlags(pDynamicState_loc.dot(Field::flags), pCreateInfos[createInfoIndex].pDynamicState->flags,
                                          "VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask");

                skip |= ValidateRangedEnumArray(pDynamicState_loc.dot(Field::dynamicStateCount),
                                                pDynamicState_loc.dot(Field::pDynamicStates), vvl::Enum::VkDynamicState,
                                                pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount,
                                                pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, false, true,
                                                kVUIDUndefined, "VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true, true,
                          "VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength",
                          "VUID-vkCreateGraphicsPipelines-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                              pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache,
                                                                uint32_t createInfoCount,
                                                                const VkComputePipelineCreateInfo* pCreateInfos,
                                                                const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
        VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, true, true, "VUID-VkComputePipelineCreateInfo-sType-sType",
        "VUID-vkCreateComputePipelines-pCreateInfos-parameter", "VUID-vkCreateComputePipelines-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkComputePipelineCreateInfo = {
                VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
                VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                        allowed_structs_VkComputePipelineCreateInfo.size(),
                                        allowed_structs_VkComputePipelineCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkComputePipelineCreateInfo-pNext-pNext",
                                        "VUID-VkComputePipelineCreateInfo-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructType(pCreateInfos_loc.dot(Field::stage), &(pCreateInfos[createInfoIndex].stage),
                                       VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, kVUIDUndefined,
                                       "VUID-VkPipelineShaderStageCreateInfo-sType-sType");

            constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].stage.pNext,
                                        allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                        allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                        "VUID-VkPipelineShaderStageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                  AllVkPipelineShaderStageCreateFlagBits, pCreateInfos[createInfoIndex].stage.flags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                  AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage.stage, kRequiredSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                  "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

            skip |= ValidateRequiredPointer(pCreateInfos_loc.dot(Field::pName), pCreateInfos[createInfoIndex].stage.pName,
                                            "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

            if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo != nullptr) {
                [[maybe_unused]] const Location pSpecializationInfo_loc = pCreateInfos_loc.dot(Field::pSpecializationInfo);
                skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                      pSpecializationInfo_loc.dot(Field::pMapEntries),
                                      pCreateInfos[createInfoIndex].stage.pSpecializationInfo->mapEntryCount,
                                      &pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pMapEntries, false, true,
                                      kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                if (pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pMapEntries != nullptr) {
                    for (uint32_t mapEntryIndex = 0;
                         mapEntryIndex < pCreateInfos[createInfoIndex].stage.pSpecializationInfo->mapEntryCount; ++mapEntryIndex) {
                        [[maybe_unused]] const Location pMapEntries_loc =
                            pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                        // No xml-driven validation
                    }
                }

                skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                      pCreateInfos[createInfoIndex].stage.pSpecializationInfo->dataSize,
                                      &pCreateInfos[createInfoIndex].stage.pSpecializationInfo->pData, false, true, kVUIDUndefined,
                                      "VUID-VkSpecializationInfo-pData-parameter");
            }

            skip |= ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true, true,
                          "VUID-vkCreateComputePipelines-createInfoCount-arraylength",
                          "VUID-vkCreateComputePipelines-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                             pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipeline(VkDevice device, VkPipeline pipeline,
                                                         const VkAllocationCallbacks* pAllocator,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator,
                                                              VkPipelineLayout* pPipelineLayout,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, true,
                               "VUID-vkCreatePipelineLayout-pCreateInfo-parameter", "VUID-VkPipelineLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined,
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineLayoutCreateFlagBits,
                              AllVkPipelineLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkPipelineLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::pushConstantRangeCount), pCreateInfo_loc.dot(Field::pPushConstantRanges),
                              pCreateInfo->pushConstantRangeCount, &pCreateInfo->pPushConstantRanges, false, true, kVUIDUndefined,
                              "VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter");

        if (pCreateInfo->pPushConstantRanges != nullptr) {
            for (uint32_t pushConstantRangeIndex = 0; pushConstantRangeIndex < pCreateInfo->pushConstantRangeCount;
                 ++pushConstantRangeIndex) {
                [[maybe_unused]] const Location pPushConstantRanges_loc =
                    pCreateInfo_loc.dot(Field::pPushConstantRanges, pushConstantRangeIndex);
                skip |= ValidateFlags(pPushConstantRanges_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfo->pPushConstantRanges[pushConstantRangeIndex].stageFlags,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkPushConstantRange-stageFlags-parameter",
                                      "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pPipelineLayout), pPipelineLayout,
                                    "VUID-vkCreatePipelineLayout-pPipelineLayout-parameter");
    if (!skip) skip |= manual_PreCallValidateCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout,
                                                               const VkAllocationCallbacks* pAllocator,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSampler(VkDevice device, const VkSamplerCreateInfo* pCreateInfo,
                                                       const VkAllocationCallbacks* pAllocator, VkSampler* pSampler,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, true,
                               "VUID-vkCreateSampler-pCreateInfo-parameter", "VUID-VkSamplerCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSamplerCreateInfo = {
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM,
            VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM,
            VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSamplerCreateInfo.size(),
                                    allowed_structs_VkSamplerCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSamplerCreateInfo-pNext-pNext", "VUID-VkSamplerCreateInfo-sType-unique", VK_NULL_HANDLE,
                                    true);

        skip |=
            ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSamplerCreateFlagBits, AllVkSamplerCreateFlagBits,
                          pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSamplerCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::magFilter), vvl::Enum::VkFilter, pCreateInfo->magFilter,
                                   "VUID-VkSamplerCreateInfo-magFilter-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::minFilter), vvl::Enum::VkFilter, pCreateInfo->minFilter,
                                   "VUID-VkSamplerCreateInfo-minFilter-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::mipmapMode), vvl::Enum::VkSamplerMipmapMode, pCreateInfo->mipmapMode,
                                   "VUID-VkSamplerCreateInfo-mipmapMode-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::addressModeU), vvl::Enum::VkSamplerAddressMode,
                                   pCreateInfo->addressModeU, "VUID-VkSamplerCreateInfo-addressModeU-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::addressModeV), vvl::Enum::VkSamplerAddressMode,
                                   pCreateInfo->addressModeV, "VUID-VkSamplerCreateInfo-addressModeV-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::addressModeW), vvl::Enum::VkSamplerAddressMode,
                                   pCreateInfo->addressModeW, "VUID-VkSamplerCreateInfo-addressModeW-parameter", VK_NULL_HANDLE);

        skip |= ValidateBool32(pCreateInfo_loc.dot(Field::anisotropyEnable), pCreateInfo->anisotropyEnable);

        skip |= ValidateBool32(pCreateInfo_loc.dot(Field::compareEnable), pCreateInfo->compareEnable);

        skip |= ValidateBool32(pCreateInfo_loc.dot(Field::unnormalizedCoordinates), pCreateInfo->unnormalizedCoordinates);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSampler), pSampler, "VUID-vkCreateSampler-pSampler-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSampler(device, pCreateInfo, pAllocator, pSampler, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorSetLayout(VkDevice device,
                                                                   const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                                   const VkAllocationCallbacks* pAllocator,
                                                                   VkDescriptorSetLayout* pSetLayout,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true,
                               "VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter",
                               "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(),
                                    allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext",
                                    "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDescriptorSetLayoutCreateFlagBits,
                              AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::bindingCount), pCreateInfo_loc.dot(Field::pBindings),
                              pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined,
                              "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr) {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex) {
                [[maybe_unused]] const Location pBindings_loc = pCreateInfo_loc.dot(Field::pBindings, bindingIndex);
                skip |= ValidateRangedEnum(pBindings_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                           pCreateInfo->pBindings[bindingIndex].descriptorType,
                                           "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter", VK_NULL_HANDLE);
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pSetLayout), pSetLayout, "VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
                                                                    const VkAllocationCallbacks* pAllocator,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator,
                                                              VkDescriptorPool* pDescriptorPool,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, true,
                               "VUID-vkCreateDescriptorPool-pCreateInfo-parameter", "VUID-VkDescriptorPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDescriptorPoolCreateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDescriptorPoolCreateInfo.size(),
                                    allowed_structs_VkDescriptorPoolCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorPoolCreateInfo-pNext-pNext", "VUID-VkDescriptorPoolCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDescriptorPoolCreateFlagBits,
                              AllVkDescriptorPoolCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDescriptorPoolCreateInfo-flags-parameter");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::poolSizeCount), pCreateInfo_loc.dot(Field::pPoolSizes),
                              pCreateInfo->poolSizeCount, &pCreateInfo->pPoolSizes, false, true, kVUIDUndefined,
                              "VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter");

        if (pCreateInfo->pPoolSizes != nullptr) {
            for (uint32_t poolSizeIndex = 0; poolSizeIndex < pCreateInfo->poolSizeCount; ++poolSizeIndex) {
                [[maybe_unused]] const Location pPoolSizes_loc = pCreateInfo_loc.dot(Field::pPoolSizes, poolSizeIndex);
                skip |= ValidateRangedEnum(pPoolSizes_loc.dot(Field::type), vvl::Enum::VkDescriptorType,
                                           pCreateInfo->pPoolSizes[poolSizeIndex].type, "VUID-VkDescriptorPoolSize-type-parameter",
                                           VK_NULL_HANDLE);
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pDescriptorPool), pDescriptorPool,
                                    "VUID-vkCreateDescriptorPool-pDescriptorPool-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                                               const VkAllocationCallbacks* pAllocator,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                                             VkDescriptorPoolResetFlags flags, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::descriptorPool), descriptorPool);
    skip |= ValidateReservedFlags(loc.dot(Field::flags), flags, "VUID-vkResetDescriptorPool-flags-zerobitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                                                VkDescriptorSet* pDescriptorSets,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructType(loc.dot(Field::pAllocateInfo), pAllocateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, true,
                           "VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter", "VUID-VkDescriptorSetAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr) {
        [[maybe_unused]] const Location pAllocateInfo_loc = loc.dot(Field::pAllocateInfo);
        constexpr std::array allowed_structs_VkDescriptorSetAllocateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO};

        skip |= ValidateStructPnext(pAllocateInfo_loc, pAllocateInfo->pNext, allowed_structs_VkDescriptorSetAllocateInfo.size(),
                                    allowed_structs_VkDescriptorSetAllocateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorSetAllocateInfo-pNext-pNext", "VUID-VkDescriptorSetAllocateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pAllocateInfo_loc.dot(Field::descriptorPool), pAllocateInfo->descriptorPool);

        skip |= ValidateHandleArray(pAllocateInfo_loc.dot(Field::descriptorSetCount), pAllocateInfo_loc.dot(Field::pSetLayouts),
                                    pAllocateInfo->descriptorSetCount, pAllocateInfo->pSetLayouts, true, true,
                                    "VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength");
    }
    if (pAllocateInfo != nullptr) {
        skip |= ValidateArray(loc.dot(Field::pAllocateInfo).dot(Field::descriptorSetCount), loc.dot(Field::pDescriptorSets),
                              pAllocateInfo->descriptorSetCount, &pDescriptorSets, true, true,
                              "VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength",
                              "VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool,
                                                            uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::descriptorPool), descriptorPool);
    skip |= ValidateArray(loc.dot(Field::descriptorSetCount), loc, descriptorSetCount, &pDescriptorSets, true, false,
                          "VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength", kVUIDUndefined);
    if (!skip)
        skip |= manual_PreCallValidateFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount,
                                                              const VkWriteDescriptorSet* pDescriptorWrites,
                                                              uint32_t descriptorCopyCount,
                                                              const VkCopyDescriptorSet* pDescriptorCopies,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc.dot(Field::descriptorWriteCount), loc.dot(Field::pDescriptorWrites), descriptorWriteCount,
                                    pDescriptorWrites, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, false, true,
                                    "VUID-VkWriteDescriptorSet-sType-sType",
                                    "VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter", kVUIDUndefined);
    if (pDescriptorWrites != nullptr) {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex) {
            [[maybe_unused]] const Location pDescriptorWrites_loc = loc.dot(Field::pDescriptorWrites, descriptorWriteIndex);
            constexpr std::array allowed_structs_VkWriteDescriptorSet = {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK};

            skip |= ValidateStructPnext(pDescriptorWrites_loc, pDescriptorWrites[descriptorWriteIndex].pNext,
                                        allowed_structs_VkWriteDescriptorSet.size(), allowed_structs_VkWriteDescriptorSet.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext",
                                        "VUID-VkWriteDescriptorSet-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pDescriptorWrites_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                       pDescriptorWrites[descriptorWriteIndex].descriptorType,
                                       "VUID-VkWriteDescriptorSet-descriptorType-parameter", VK_NULL_HANDLE);

            skip |= ValidateArray(pDescriptorWrites_loc.dot(Field::descriptorCount), loc,
                                  pDescriptorWrites[descriptorWriteIndex].descriptorCount,
                                  &pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false,
                                  "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
        }
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::descriptorCopyCount), loc.dot(Field::pDescriptorCopies), descriptorCopyCount,
                                    pDescriptorCopies, VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, false, true,
                                    "VUID-VkCopyDescriptorSet-sType-sType",
                                    "VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter", kVUIDUndefined);
    if (pDescriptorCopies != nullptr) {
        for (uint32_t descriptorCopyIndex = 0; descriptorCopyIndex < descriptorCopyCount; ++descriptorCopyIndex) {
            [[maybe_unused]] const Location pDescriptorCopies_loc = loc.dot(Field::pDescriptorCopies, descriptorCopyIndex);
            skip |= ValidateStructPnext(pDescriptorCopies_loc, pDescriptorCopies[descriptorCopyIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkCopyDescriptorSet-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pDescriptorCopies_loc.dot(Field::srcSet), pDescriptorCopies[descriptorCopyIndex].srcSet);

            skip |= ValidateRequiredHandle(pDescriptorCopies_loc.dot(Field::dstSet), pDescriptorCopies[descriptorCopyIndex].dstSet);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount,
                                                           pDescriptorCopies, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, true,
                               "VUID-vkCreateFramebuffer-pCreateInfo-parameter", "VUID-VkFramebufferCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkFramebufferCreateInfo = {VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkFramebufferCreateInfo.size(),
                                    allowed_structs_VkFramebufferCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkFramebufferCreateInfo-pNext-pNext", "VUID-VkFramebufferCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFramebufferCreateFlagBits,
                              AllVkFramebufferCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkFramebufferCreateInfo-flags-parameter");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::renderPass), pCreateInfo->renderPass);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFramebuffer), pFramebuffer, "VUID-vkCreateFramebuffer-pFramebuffer-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo* pCreateInfo,
                                                          const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, true,
                               "VUID-vkCreateRenderPass-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkRenderPassCreateInfo = {
            VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO, VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo.size(),
                                    allowed_structs_VkRenderPassCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderPassCreateInfo-pNext-pNext", "VUID-VkRenderPassCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderPassCreateFlagBits,
                              AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkRenderPassCreateInfo-flags-parameter");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::attachmentCount), pCreateInfo_loc.dot(Field::pAttachments),
                              pCreateInfo->attachmentCount, &pCreateInfo->pAttachments, false, true, kVUIDUndefined,
                              "VUID-VkRenderPassCreateInfo-pAttachments-parameter");

        if (pCreateInfo->pAttachments != nullptr) {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex) {
                [[maybe_unused]] const Location pAttachments_loc = pCreateInfo_loc.dot(Field::pAttachments, attachmentIndex);
                skip |= ValidateFlags(pAttachments_loc.dot(Field::flags), vvl::FlagBitmask::VkAttachmentDescriptionFlagBits,
                                      AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkAttachmentDescription-flags-parameter");

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::format), vvl::Enum::VkFormat,
                                           pCreateInfo->pAttachments[attachmentIndex].format,
                                           "VUID-VkAttachmentDescription-format-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pAttachments_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples,
                                      kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkAttachmentDescription-samples-parameter",
                                      "VUID-VkAttachmentDescription-samples-parameter");

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                           pCreateInfo->pAttachments[attachmentIndex].loadOp,
                                           "VUID-VkAttachmentDescription-loadOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                           pCreateInfo->pAttachments[attachmentIndex].storeOp,
                                           "VUID-VkAttachmentDescription-storeOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::stencilLoadOp), vvl::Enum::VkAttachmentLoadOp,
                                           pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp,
                                           "VUID-VkAttachmentDescription-stencilLoadOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::stencilStoreOp), vvl::Enum::VkAttachmentStoreOp,
                                           pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp,
                                           "VUID-VkAttachmentDescription-stencilStoreOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                           pCreateInfo->pAttachments[attachmentIndex].initialLayout,
                                           "VUID-VkAttachmentDescription-initialLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::finalLayout), vvl::Enum::VkImageLayout,
                                           pCreateInfo->pAttachments[attachmentIndex].finalLayout,
                                           "VUID-VkAttachmentDescription-finalLayout-parameter", VK_NULL_HANDLE);
            }
        }

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::subpassCount), pCreateInfo_loc.dot(Field::pSubpasses),
                              pCreateInfo->subpassCount, &pCreateInfo->pSubpasses, true, true,
                              "VUID-VkRenderPassCreateInfo-subpassCount-arraylength",
                              "VUID-VkRenderPassCreateInfo-pSubpasses-parameter");

        if (pCreateInfo->pSubpasses != nullptr) {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex) {
                [[maybe_unused]] const Location pSubpasses_loc = pCreateInfo_loc.dot(Field::pSubpasses, subpassIndex);
                skip |= ValidateFlags(pSubpasses_loc.dot(Field::flags), vvl::FlagBitmask::VkSubpassDescriptionFlagBits,
                                      AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkSubpassDescription-flags-parameter");

                skip |= ValidateRangedEnum(pSubpasses_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint,
                                           "VUID-VkSubpassDescription-pipelineBindPoint-parameter", VK_NULL_HANDLE);

                skip |= ValidateArray(pSubpasses_loc.dot(Field::inputAttachmentCount), pSubpasses_loc.dot(Field::pInputAttachments),
                                      pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount,
                                      &pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkSubpassDescription-pInputAttachments-parameter");

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr) {
                    for (uint32_t inputAttachmentIndex = 0;
                         inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount;
                         ++inputAttachmentIndex) {
                        [[maybe_unused]] const Location pInputAttachments_loc =
                            pSubpasses_loc.dot(Field::pInputAttachments, inputAttachmentIndex);
                        skip |=
                            ValidateRangedEnum(pInputAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout,
                                               "VUID-VkAttachmentReference-layout-parameter", VK_NULL_HANDLE);
                    }
                }

                skip |= ValidateArray(pSubpasses_loc.dot(Field::colorAttachmentCount), pSubpasses_loc.dot(Field::pColorAttachments),
                                      pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount,
                                      &pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkSubpassDescription-pColorAttachments-parameter");

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pColorAttachments_loc =
                            pSubpasses_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                        skip |=
                            ValidateRangedEnum(pColorAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout,
                                               "VUID-VkAttachmentReference-layout-parameter", VK_NULL_HANDLE);
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pResolveAttachments_loc =
                            pSubpasses_loc.dot(Field::pResolveAttachments, colorAttachmentIndex);
                        skip |= ValidateRangedEnum(
                            pResolveAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout,
                            "VUID-VkAttachmentReference-layout-parameter", VK_NULL_HANDLE);
                    }
                }

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr) {
                    [[maybe_unused]] const Location pDepthStencilAttachment_loc =
                        pSubpasses_loc.dot(Field::pDepthStencilAttachment);
                    skip |= ValidateRangedEnum(pDepthStencilAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout,
                                               "VUID-VkAttachmentReference-layout-parameter", VK_NULL_HANDLE);
                }

                skip |= ValidateArray(pSubpasses_loc.dot(Field::preserveAttachmentCount),
                                      pSubpasses_loc.dot(Field::pPreserveAttachments),
                                      pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount,
                                      &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkSubpassDescription-pPreserveAttachments-parameter");
            }
        }

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::dependencyCount), pCreateInfo_loc.dot(Field::pDependencies),
                              pCreateInfo->dependencyCount, &pCreateInfo->pDependencies, false, true, kVUIDUndefined,
                              "VUID-VkRenderPassCreateInfo-pDependencies-parameter");

        if (pCreateInfo->pDependencies != nullptr) {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex) {
                [[maybe_unused]] const Location pDependencies_loc = pCreateInfo_loc.dot(Field::pDependencies, dependencyIndex);
                skip |= ValidateFlags(pDependencies_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                      AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency-srcStageMask-parameter");

                skip |= ValidateFlags(pDependencies_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                      AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency-dstStageMask-parameter");

                skip |= ValidateFlags(pDependencies_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                      AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency-srcAccessMask-parameter");

                skip |= ValidateFlags(pDependencies_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                      AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency-dstAccessMask-parameter");

                skip |= ValidateFlags(pDependencies_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                      AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency-dependencyFlags-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pRenderPass), pRenderPass, "VUID-vkCreateRenderPass-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyRenderPass(VkDevice device, VkRenderPass renderPass,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass,
                                                                  VkExtent2D* pGranularity, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::renderPass), renderPass);
    skip |= ValidateRequiredPointer(loc.dot(Field::pGranularity), pGranularity,
                                    "VUID-vkGetRenderAreaGranularity-pGranularity-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, true,
                               "VUID-vkCreateCommandPool-pCreateInfo-parameter", "VUID-VkCommandPoolCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCommandPoolCreateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkCommandPoolCreateFlagBits,
                              AllVkCommandPoolCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkCommandPoolCreateInfo-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pCommandPool), pCommandPool, "VUID-vkCreateCommandPool-pCommandPool-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCommandPool(VkDevice device, VkCommandPool commandPool,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkCommandPoolResetFlagBits, AllVkCommandPoolResetFlagBits, flags,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkResetCommandPool-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo,
                                                                VkCommandBuffer* pCommandBuffers,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructType(loc.dot(Field::pAllocateInfo), pAllocateInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, true,
                           "VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter", "VUID-VkCommandBufferAllocateInfo-sType-sType");
    if (pAllocateInfo != nullptr) {
        [[maybe_unused]] const Location pAllocateInfo_loc = loc.dot(Field::pAllocateInfo);
        skip |= ValidateStructPnext(pAllocateInfo_loc, pAllocateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCommandBufferAllocateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pAllocateInfo_loc.dot(Field::commandPool), pAllocateInfo->commandPool);

        skip |= ValidateRangedEnum(pAllocateInfo_loc.dot(Field::level), vvl::Enum::VkCommandBufferLevel, pAllocateInfo->level,
                                   "VUID-VkCommandBufferAllocateInfo-level-parameter", VK_NULL_HANDLE);
    }
    if (pAllocateInfo != nullptr) {
        skip |= ValidateArray(loc.dot(Field::pAllocateInfo).dot(Field::commandBufferCount), loc.dot(Field::pCommandBuffers),
                              pAllocateInfo->commandBufferCount, &pCommandBuffers, true, true,
                              "VUID-vkAllocateCommandBuffers-pAllocateInfo::commandBufferCount-arraylength",
                              "VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount,
                                                            const VkCommandBuffer* pCommandBuffers,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);
    skip |= ValidateArray(loc.dot(Field::commandBufferCount), loc, commandBufferCount, &pCommandBuffers, true, false,
                          "VUID-vkFreeCommandBuffers-commandBufferCount-arraylength", kVUIDUndefined);
    if (!skip)
        skip |= manual_PreCallValidateFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateBeginCommandBuffer(VkCommandBuffer commandBuffer,
                                                            const VkCommandBufferBeginInfo* pBeginInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pBeginInfo), pBeginInfo, VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, true,
                               "VUID-vkBeginCommandBuffer-pBeginInfo-parameter", "VUID-VkCommandBufferBeginInfo-sType-sType");
    if (pBeginInfo != nullptr) {
        [[maybe_unused]] const Location pBeginInfo_loc = loc.dot(Field::pBeginInfo);
        constexpr std::array allowed_structs_VkCommandBufferBeginInfo = {VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO};

        skip |= ValidateStructPnext(pBeginInfo_loc, pBeginInfo->pNext, allowed_structs_VkCommandBufferBeginInfo.size(),
                                    allowed_structs_VkCommandBufferBeginInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkCommandBufferBeginInfo-pNext-pNext", "VUID-VkCommandBufferBeginInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pBeginInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkCommandBufferUsageFlagBits,
                              AllVkCommandBufferUsageFlagBits, pBeginInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkCommandBufferBeginInfo-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateBeginCommandBuffer(commandBuffer, pBeginInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateEndCommandBuffer(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkCommandBufferResetFlagBits, AllVkCommandBufferResetFlagBits,
                          flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkResetCommandBuffer-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                         VkPipeline pipeline, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdBindPipeline-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                        uint32_t viewportCount, const VkViewport* pViewports,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewports), viewportCount, &pViewports, true, true,
                          "VUID-vkCmdSetViewport-viewportCount-arraylength", "VUID-vkCmdSetViewport-pViewports-parameter");
    if (pViewports != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewports_loc = loc.dot(Field::pViewports, viewportIndex);
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount,
                                                       const VkRect2D* pScissors, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateArray(loc.dot(Field::scissorCount), loc.dot(Field::pScissors), scissorCount, &pScissors, true, true,
                          "VUID-vkCmdSetScissor-scissorCount-arraylength", "VUID-vkCmdSetScissor-pScissors-parameter");
    if (pScissors != nullptr) {
        for (uint32_t scissorIndex = 0; scissorIndex < scissorCount; ++scissorIndex) {
            [[maybe_unused]] const Location pScissors_loc = loc.dot(Field::pScissors, scissorIndex);
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdSetLineWidth(commandBuffer, lineWidth, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor,
                                                         float depthBiasClamp, float depthBiasSlopeFactor,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4],
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds,
                                                           float maxDepthBounds, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                                  uint32_t compareMask, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits, faceMask,
                          kRequiredFlags, VK_NULL_HANDLE, "VUID-vkCmdSetStencilCompareMask-faceMask-parameter",
                          "VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                                uint32_t writeMask, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits, faceMask,
                          kRequiredFlags, VK_NULL_HANDLE, "VUID-vkCmdSetStencilWriteMask-faceMask-parameter",
                          "VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                                uint32_t reference, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits, faceMask,
                          kRequiredFlags, VK_NULL_HANDLE, "VUID-vkCmdSetStencilReference-faceMask-parameter",
                          "VUID-vkCmdSetStencilReference-faceMask-requiredbitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                               VkPipelineLayout layout, uint32_t firstSet,
                                                               uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets,
                                                               uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= ValidateArray(loc.dot(Field::descriptorSetCount), loc.dot(Field::pDescriptorSets), descriptorSetCount, &pDescriptorSets,
                          true, false, "VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength",
                          "VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter");
    skip |= ValidateArray(loc.dot(Field::dynamicOffsetCount), loc.dot(Field::pDynamicOffsets), dynamicOffsetCount, &pDynamicOffsets,
                          false, true, kVUIDUndefined, "VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                            VkIndexType indexType, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::indexType), vvl::Enum::VkIndexType, indexType,
                               "VUID-vkCmdBindIndexBuffer-indexType-parameter", VK_NULL_HANDLE);
    if (!skip) skip |= manual_PreCallValidateCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                                              uint32_t bindingCount, const VkBuffer* pBuffers,
                                                              const VkDeviceSize* pOffsets, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateArray(loc.dot(Field::bindingCount), loc.dot(Field::pBuffers), bindingCount, &pBuffers, true, false,
                          "VUID-vkCmdBindVertexBuffers-bindingCount-arraylength", "VUID-vkCmdBindVertexBuffers-pBuffers-parameter");
    skip |= ValidateArray(loc.dot(Field::bindingCount), loc.dot(Field::pOffsets), bindingCount, &pOffsets, true, true,
                          "VUID-vkCmdBindVertexBuffers-bindingCount-arraylength", "VUID-vkCmdBindVertexBuffers-pOffsets-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
                                                 uint32_t firstVertex, uint32_t firstInstance, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount,
                                                        uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                         uint32_t drawCount, uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                                uint32_t drawCount, uint32_t stride,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                                                     uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer,
                                                       uint32_t regionCount, const VkBufferCopy* pRegions,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::srcBuffer), srcBuffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                          "VUID-vkCmdCopyBuffer-regionCount-arraylength", "VUID-vkCmdCopyBuffer-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                                      VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                                                      const VkImageCopy* pRegions, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                               "VUID-vkCmdCopyImage-srcImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                               "VUID-vkCmdCopyImage-dstImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                          "VUID-vkCmdCopyImage-regionCount-arraylength", "VUID-vkCmdCopyImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                                      VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                                                      const VkImageBlit* pRegions, VkFilter filter,
                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                               "VUID-vkCmdBlitImage-srcImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                               "VUID-vkCmdBlitImage-dstImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                          "VUID-vkCmdBlitImage-regionCount-arraylength", "VUID-vkCmdBlitImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
        }
    }
    skip |= ValidateRangedEnum(loc.dot(Field::filter), vvl::Enum::VkFilter, filter, "VUID-vkCmdBlitImage-filter-parameter",
                               VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
                                                              VkImageLayout dstImageLayout, uint32_t regionCount,
                                                              const VkBufferImageCopy* pRegions,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::srcBuffer), srcBuffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                               "VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                          "VUID-vkCmdCopyBufferToImage-regionCount-arraylength", "VUID-vkCmdCopyBufferToImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage,
                                                              VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                                              uint32_t regionCount, const VkBufferImageCopy* pRegions,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                               "VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                          "VUID-vkCmdCopyImageToBuffer-regionCount-arraylength", "VUID-vkCmdCopyImageToBuffer-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                                         VkDeviceSize dataSize, const void* pData,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkCmdUpdateBuffer-dataSize-arraylength", "VUID-vkCmdUpdateBuffer-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                                       VkDeviceSize size, uint32_t data, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    if (!skip) skip |= manual_PreCallValidateCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
                                                            const VkClearColorValue* pColor, uint32_t rangeCount,
                                                            const VkImageSubresourceRange* pRanges,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                               "VUID-vkCmdClearColorImage-imageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::rangeCount), loc.dot(Field::pRanges), rangeCount, &pRanges, true, true,
                          "VUID-vkCmdClearColorImage-rangeCount-arraylength", "VUID-vkCmdClearColorImage-pRanges-parameter");
    if (pRanges != nullptr) {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex) {
            [[maybe_unused]] const Location pRanges_loc = loc.dot(Field::pRanges, rangeIndex);
            skip |= ValidateFlags(pRanges_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                  "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image,
                                                                   VkImageLayout imageLayout,
                                                                   const VkClearDepthStencilValue* pDepthStencil,
                                                                   uint32_t rangeCount, const VkImageSubresourceRange* pRanges,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                               "VUID-vkCmdClearDepthStencilImage-imageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredPointer(loc.dot(Field::pDepthStencil), pDepthStencil,
                                    "VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter");
    if (pDepthStencil != nullptr) {
        [[maybe_unused]] const Location pDepthStencil_loc = loc.dot(Field::pDepthStencil);
        // No xml-driven validation
    }
    skip |= ValidateArray(loc.dot(Field::rangeCount), loc.dot(Field::pRanges), rangeCount, &pRanges, true, true,
                          "VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength",
                          "VUID-vkCmdClearDepthStencilImage-pRanges-parameter");
    if (pRanges != nullptr) {
        for (uint32_t rangeIndex = 0; rangeIndex < rangeCount; ++rangeIndex) {
            [[maybe_unused]] const Location pRanges_loc = loc.dot(Field::pRanges, rangeIndex);
            skip |= ValidateFlags(pRanges_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRanges[rangeIndex].aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                  "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                                             const VkClearAttachment* pAttachments, uint32_t rectCount,
                                                             const VkClearRect* pRects, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateArray(loc.dot(Field::attachmentCount), loc.dot(Field::pAttachments), attachmentCount, &pAttachments, true, true,
                          "VUID-vkCmdClearAttachments-attachmentCount-arraylength",
                          "VUID-vkCmdClearAttachments-pAttachments-parameter");
    if (pAttachments != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pAttachments_loc = loc.dot(Field::pAttachments, attachmentIndex);
            skip |=
                ValidateFlags(pAttachments_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                              AllVkImageAspectFlagBits, pAttachments[attachmentIndex].aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkClearAttachment-aspectMask-parameter", "VUID-VkClearAttachment-aspectMask-requiredbitmask");
        }
    }
    skip |= ValidateArray(loc.dot(Field::rectCount), loc.dot(Field::pRects), rectCount, &pRects, true, true,
                          "VUID-vkCmdClearAttachments-rectCount-arraylength", "VUID-vkCmdClearAttachments-pRects-parameter");
    if (pRects != nullptr) {
        for (uint32_t rectIndex = 0; rectIndex < rectCount; ++rectIndex) {
            [[maybe_unused]] const Location pRects_loc = loc.dot(Field::pRects, rectIndex);
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip)
        skip |=
            manual_PreCallValidateCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                                         VkImageLayout srcImageLayout, VkImage dstImage,
                                                         VkImageLayout dstImageLayout, uint32_t regionCount,
                                                         const VkImageResolve* pRegions, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::srcImage), srcImage);
    skip |= ValidateRangedEnum(loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout, srcImageLayout,
                               "VUID-vkCmdResolveImage-srcImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                               "VUID-vkCmdResolveImage-dstImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::regionCount), loc.dot(Field::pRegions), regionCount, &pRegions, true, true,
                          "VUID-vkCmdResolveImage-regionCount-arraylength", "VUID-vkCmdResolveImage-pRegions-parameter");
    if (pRegions != nullptr) {
        for (uint32_t regionIndex = 0; regionIndex < regionCount; ++regionIndex) {
            [[maybe_unused]] const Location pRegions_loc = loc.dot(Field::pRegions, regionIndex);
            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].srcSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pRegions[regionIndex].dstSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

            // No xml-driven validation

            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= ValidateFlags(loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          stageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdSetEvent-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= ValidateFlags(loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          stageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdResetEvent-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWaitEvents(
    VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateHandleArray(loc.dot(Field::eventCount), loc.dot(Field::pEvents), eventCount, pEvents, true, true,
                                "VUID-vkCmdWaitEvents-eventCount-arraylength");
    skip |= ValidateFlags(loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          srcStageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdWaitEvents-srcStageMask-parameter");
    skip |= ValidateFlags(loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          dstStageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdWaitEvents-dstStageMask-parameter");
    skip |=
        ValidateStructTypeArray(loc.dot(Field::memoryBarrierCount), loc.dot(Field::pMemoryBarriers), memoryBarrierCount,
                                pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true, "VUID-VkMemoryBarrier-sType-sType",
                                "VUID-vkCmdWaitEvents-pMemoryBarriers-parameter", kVUIDUndefined);
    if (pMemoryBarriers != nullptr) {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex) {
            [[maybe_unused]] const Location pMemoryBarriers_loc = loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
            skip |= ValidateStructPnext(pMemoryBarriers_loc, pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkMemoryBarrier-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                  AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkMemoryBarrier-srcAccessMask-parameter");

            skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                  AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkMemoryBarrier-dstAccessMask-parameter");
        }
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::bufferMemoryBarrierCount), loc.dot(Field::pBufferMemoryBarriers),
                                    bufferMemoryBarrierCount, pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false,
                                    true, "VUID-VkBufferMemoryBarrier-sType-sType",
                                    "VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter", kVUIDUndefined);
    if (pBufferMemoryBarriers != nullptr) {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount;
             ++bufferMemoryBarrierIndex) {
            [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkBufferMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

            skip |= ValidateStructPnext(pBufferMemoryBarriers_loc, pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                                        allowed_structs_VkBufferMemoryBarrier.size(), allowed_structs_VkBufferMemoryBarrier.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier-pNext-pNext",
                                        "VUID-VkBufferMemoryBarrier-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                           pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::imageMemoryBarrierCount), loc.dot(Field::pImageMemoryBarriers),
                                    imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, false,
                                    true, "VUID-VkImageMemoryBarrier-sType-sType",
                                    "VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter", kVUIDUndefined);
    if (pImageMemoryBarriers != nullptr) {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex) {
            [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkImageMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                                                                         VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

            skip |= ValidateStructPnext(pImageMemoryBarriers_loc, pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                                        allowed_structs_VkImageMemoryBarrier.size(), allowed_structs_VkImageMemoryBarrier.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier-pNext-pNext",
                                        "VUID-VkImageMemoryBarrier-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                       pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                       "VUID-VkImageMemoryBarrier-oldLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                       pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                       "VUID-VkImageMemoryBarrier-newLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                           pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= ValidateFlags(
                pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPipelineBarrier(
    VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount,
    const VkImageMemoryBarrier* pImageMemoryBarriers, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          srcStageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdPipelineBarrier-srcStageMask-parameter");
    skip |= ValidateFlags(loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          dstStageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdPipelineBarrier-dstStageMask-parameter");
    skip |= ValidateFlags(loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits, AllVkDependencyFlagBits,
                          dependencyFlags, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdPipelineBarrier-dependencyFlags-parameter");
    skip |=
        ValidateStructTypeArray(loc.dot(Field::memoryBarrierCount), loc.dot(Field::pMemoryBarriers), memoryBarrierCount,
                                pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER, false, true, "VUID-VkMemoryBarrier-sType-sType",
                                "VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter", kVUIDUndefined);
    if (pMemoryBarriers != nullptr) {
        for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < memoryBarrierCount; ++memoryBarrierIndex) {
            [[maybe_unused]] const Location pMemoryBarriers_loc = loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
            skip |= ValidateStructPnext(pMemoryBarriers_loc, pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkMemoryBarrier-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                  AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].srcAccessMask, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkMemoryBarrier-srcAccessMask-parameter");

            skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                  AllVkAccessFlagBits, pMemoryBarriers[memoryBarrierIndex].dstAccessMask, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkMemoryBarrier-dstAccessMask-parameter");
        }
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::bufferMemoryBarrierCount), loc.dot(Field::pBufferMemoryBarriers),
                                    bufferMemoryBarrierCount, pBufferMemoryBarriers, VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, false,
                                    true, "VUID-VkBufferMemoryBarrier-sType-sType",
                                    "VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter", kVUIDUndefined);
    if (pBufferMemoryBarriers != nullptr) {
        for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < bufferMemoryBarrierCount;
             ++bufferMemoryBarrierIndex) {
            [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkBufferMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

            skip |= ValidateStructPnext(pBufferMemoryBarriers_loc, pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                                        allowed_structs_VkBufferMemoryBarrier.size(), allowed_structs_VkBufferMemoryBarrier.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier-pNext-pNext",
                                        "VUID-VkBufferMemoryBarrier-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                           pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
        }
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::imageMemoryBarrierCount), loc.dot(Field::pImageMemoryBarriers),
                                    imageMemoryBarrierCount, pImageMemoryBarriers, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, false,
                                    true, "VUID-VkImageMemoryBarrier-sType-sType",
                                    "VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter", kVUIDUndefined);
    if (pImageMemoryBarriers != nullptr) {
        for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < imageMemoryBarrierCount; ++imageMemoryBarrierIndex) {
            [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
            constexpr std::array allowed_structs_VkImageMemoryBarrier = {VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
                                                                         VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

            skip |= ValidateStructPnext(pImageMemoryBarriers_loc, pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                                        allowed_structs_VkImageMemoryBarrier.size(), allowed_structs_VkImageMemoryBarrier.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier-pNext-pNext",
                                        "VUID-VkImageMemoryBarrier-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                       pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                       "VUID-VkImageMemoryBarrier-oldLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                       pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                       "VUID-VkImageMemoryBarrier-newLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                           pImageMemoryBarriers[imageMemoryBarrierIndex].image);

            skip |= ValidateFlags(
                pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                "VUID-VkImageSubresourceRange-aspectMask-parameter", "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                                       VkQueryControlFlags flags, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryControlFlagBits, AllVkQueryControlFlagBits, flags,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdBeginQuery-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                                           uint32_t firstQuery, uint32_t queryCount,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
                                                           VkQueryPool queryPool, uint32_t query,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::pipelineStage), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                          pipelineStage, kRequiredSingleBit, VK_NULL_HANDLE, "VUID-vkCmdWriteTimestamp-pipelineStage-parameter",
                          "VUID-vkCmdWriteTimestamp-pipelineStage-parameter");
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                                                 uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer,
                                                                 VkDeviceSize dstOffset, VkDeviceSize stride,
                                                                 VkQueryResultFlags flags, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryResultFlagBits, AllVkQueryResultFlagBits, flags,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdCopyQueryPoolResults-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                                          VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
                                                          const void* pValues, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= ValidateFlags(loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits, stageFlags,
                          kRequiredFlags, VK_NULL_HANDLE, "VUID-vkCmdPushConstants-stageFlags-parameter",
                          "VUID-vkCmdPushConstants-stageFlags-requiredbitmask");
    skip |= ValidateArray(loc.dot(Field::size), loc.dot(Field::pValues), size, &pValues, true, true,
                          "VUID-vkCmdPushConstants-size-arraylength", "VUID-vkCmdPushConstants-pValues-parameter");
    if (!skip) skip |= manual_PreCallValidateCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderPass(VkCommandBuffer commandBuffer,
                                                            const VkRenderPassBeginInfo* pRenderPassBegin,
                                                            VkSubpassContents contents, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pRenderPassBegin), pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, true,
                               "VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter", "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr) {
        [[maybe_unused]] const Location pRenderPassBegin_loc = loc.dot(Field::pRenderPassBegin);
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM};

        skip |= ValidateStructPnext(pRenderPassBegin_loc, pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(),
                                    allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::renderPass), pRenderPassBegin->renderPass);

        skip |= ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::framebuffer), pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |= ValidateRangedEnum(loc.dot(Field::contents), vvl::Enum::VkSubpassContents, contents,
                               "VUID-vkCmdBeginRenderPass-contents-parameter", VK_NULL_HANDLE);
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::contents), vvl::Enum::VkSubpassContents, contents,
                               "VUID-vkCmdNextSubpass-contents-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderPass(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                                            const VkCommandBuffer* pCommandBuffers,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateHandleArray(loc.dot(Field::commandBufferCount), loc.dot(Field::pCommandBuffers), commandBufferCount,
                                pCommandBuffers, true, true, "VUID-vkCmdExecuteCommands-commandBufferCount-arraylength");
    return skip;
}

bool StatelessValidation::PreCallValidateBindBufferMemory2(VkDevice device, uint32_t bindInfoCount,
                                                           const VkBindBufferMemoryInfo* pBindInfos,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfos), bindInfoCount, pBindInfos,
                                    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO, true, true,
                                    "VUID-VkBindBufferMemoryInfo-sType-sType", "VUID-vkBindBufferMemory2-pBindInfos-parameter",
                                    "VUID-vkBindBufferMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfos_loc = loc.dot(Field::pBindInfos, bindInfoIndex);
            constexpr std::array allowed_structs_VkBindBufferMemoryInfo = {VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
                                                                           VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR};

            skip |= ValidateStructPnext(
                pBindInfos_loc, pBindInfos[bindInfoIndex].pNext, allowed_structs_VkBindBufferMemoryInfo.size(),
                allowed_structs_VkBindBufferMemoryInfo.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkBindBufferMemoryInfo-pNext-pNext", "VUID-VkBindBufferMemoryInfo-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pBindInfos_loc.dot(Field::buffer), pBindInfos[bindInfoIndex].buffer);

            skip |= ValidateRequiredHandle(pBindInfos_loc.dot(Field::memory), pBindInfos[bindInfoIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindImageMemory2(VkDevice device, uint32_t bindInfoCount,
                                                          const VkBindImageMemoryInfo* pBindInfos,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfos), bindInfoCount, pBindInfos,
                                    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO, true, true, "VUID-VkBindImageMemoryInfo-sType-sType",
                                    "VUID-vkBindImageMemory2-pBindInfos-parameter",
                                    "VUID-vkBindImageMemory2-bindInfoCount-arraylength");
    if (pBindInfos != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfos_loc = loc.dot(Field::pBindInfos, bindInfoIndex);
            constexpr std::array allowed_structs_VkBindImageMemoryInfo = {
                VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
                VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR};

            skip |= ValidateStructPnext(pBindInfos_loc, pBindInfos[bindInfoIndex].pNext,
                                        allowed_structs_VkBindImageMemoryInfo.size(), allowed_structs_VkBindImageMemoryInfo.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkBindImageMemoryInfo-pNext-pNext",
                                        "VUID-VkBindImageMemoryInfo-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pBindInfos_loc.dot(Field::image), pBindInfos[bindInfoIndex].image);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex,
                                                                          uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
                                                                          VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc.dot(Field::pPeerMemoryFeatures), pPeerMemoryFeatures,
                                    "VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                                                         uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
                                                         uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDeviceGroups(
    VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkEnumeratePhysicalDeviceGroups &&
        CheckPromotedApiAgainstVulkanVersion(instance, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructTypeArray(loc.dot(Field::pPhysicalDeviceGroupCount), loc.dot(Field::pPhysicalDeviceGroupProperties),
                                    pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties,
                                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, true, false, false,
                                    "VUID-VkPhysicalDeviceGroupProperties-sType-sType",
                                    "VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter",
                                    "VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupCount-parameter", kVUIDUndefined);
    if (pPhysicalDeviceGroupProperties != nullptr) {
        for (uint32_t pPhysicalDeviceGroupIndex = 0; pPhysicalDeviceGroupIndex < *pPhysicalDeviceGroupCount;
             ++pPhysicalDeviceGroupIndex) {
            [[maybe_unused]] const Location pPhysicalDeviceGroupProperties_loc =
                loc.dot(Field::pPhysicalDeviceGroupProperties, pPhysicalDeviceGroupIndex);
            skip |= ValidateStructPnext(pPhysicalDeviceGroupProperties_loc,
                                        pPhysicalDeviceGroupProperties[pPhysicalDeviceGroupIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceGroupProperties-pNext-pNext",
                                        kVUIDUndefined, VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo,
                                                                     VkMemoryRequirements2* pMemoryRequirements,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, true,
                           "VUID-vkGetImageMemoryRequirements2-pInfo-parameter", "VUID-VkImageMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        constexpr std::array allowed_structs_VkImageMemoryRequirementsInfo2 = {
            VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO};

        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, allowed_structs_VkImageMemoryRequirementsInfo2.size(),
                                    allowed_structs_VkImageMemoryRequirementsInfo2.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageMemoryRequirementsInfo2-pNext-pNext",
                                    "VUID-VkImageMemoryRequirementsInfo2-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo,
                                                                      VkMemoryRequirements2* pMemoryRequirements,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2, true,
                               "VUID-vkGetBufferMemoryRequirements2-pInfo-parameter",
                               "VUID-VkBufferMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSparseMemoryRequirements2(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2, true,
                               "VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter",
                               "VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);
    }
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pSparseMemoryRequirementCount), loc.dot(Field::pSparseMemoryRequirements), pSparseMemoryRequirementCount,
        pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false,
        "VUID-VkSparseImageMemoryRequirements2-sType-sType",
        "VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirements-parameter",
        "VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirementCount-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr) {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount;
             ++pSparseMemoryRequirementIndex) {
            [[maybe_unused]] const Location pSparseMemoryRequirements_loc =
                loc.dot(Field::pSparseMemoryRequirements, pSparseMemoryRequirementIndex);
            skip |=
                ValidateStructPnext(pSparseMemoryRequirements_loc, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext,
                                    0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
                                                                    VkPhysicalDeviceFeatures2* pFeatures,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceFeatures2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |=
        ValidateStructType(loc.dot(Field::pFeatures), pFeatures, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, true,
                           "VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter", "VUID-VkPhysicalDeviceFeatures2-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice,
                                                                      VkPhysicalDeviceProperties2* pProperties,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, true,
                               "VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter",
                               "VUID-VkPhysicalDeviceProperties2-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        constexpr std::array allowed_structs_VkPhysicalDeviceProperties2 = {
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES};

        skip |= ValidateStructPnext(pProperties_loc, pProperties->pNext, allowed_structs_VkPhysicalDeviceProperties2.size(),
                                    allowed_structs_VkPhysicalDeviceProperties2.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceProperties2-pNext-pNext", "VUID-VkPhysicalDeviceProperties2-sType-unique",
                                    physicalDevice, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetPhysicalDeviceProperties2(physicalDevice, pProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                            VkFormatProperties2* pFormatProperties,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceFormatProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                               "VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter", physicalDevice);
    skip |= ValidateStructType(loc.dot(Field::pFormatProperties), pFormatProperties, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, true,
                               "VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter",
                               "VUID-VkFormatProperties2-sType-sType");
    if (pFormatProperties != nullptr) {
        [[maybe_unused]] const Location pFormatProperties_loc = loc.dot(Field::pFormatProperties);
        constexpr std::array allowed_structs_VkFormatProperties2 = {
            VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT, VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT};

        skip |= ValidateStructPnext(pFormatProperties_loc, pFormatProperties->pNext, allowed_structs_VkFormatProperties2.size(),
                                    allowed_structs_VkFormatProperties2.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkFormatProperties2-pNext-pNext", "VUID-VkFormatProperties2-sType-unique", physicalDevice,
                                    false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceImageFormatProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructType(loc.dot(Field::pImageFormatInfo), pImageFormatInfo,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2, true,
                               "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter",
                               "VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType");
    if (pImageFormatInfo != nullptr) {
        [[maybe_unused]] const Location pImageFormatInfo_loc = loc.dot(Field::pImageFormatInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceImageFormatInfo2 = {
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= ValidateStructPnext(pImageFormatInfo_loc, pImageFormatInfo->pNext,
                                    allowed_structs_VkPhysicalDeviceImageFormatInfo2.size(),
                                    allowed_structs_VkPhysicalDeviceImageFormatInfo2.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext",
                                    "VUID-VkPhysicalDeviceImageFormatInfo2-sType-unique", physicalDevice, true);

        skip |= ValidateRangedEnum(pImageFormatInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pImageFormatInfo->format,
                                   "VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter", physicalDevice);

        skip |= ValidateRangedEnum(pImageFormatInfo_loc.dot(Field::type), vvl::Enum::VkImageType, pImageFormatInfo->type,
                                   "VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter", physicalDevice);

        skip |= ValidateRangedEnum(pImageFormatInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pImageFormatInfo->tiling,
                                   "VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter", physicalDevice);

        skip |= ValidateFlags(pImageFormatInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                              AllVkImageUsageFlagBits, pImageFormatInfo->usage, kRequiredFlags, physicalDevice,
                              "VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter",
                              "VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask");

        skip |= ValidateFlags(pImageFormatInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                              AllVkImageCreateFlagBits, pImageFormatInfo->flags, kOptionalFlags, physicalDevice,
                              "VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pImageFormatProperties), pImageFormatProperties,
                               VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, true,
                               "VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter",
                               "VUID-VkImageFormatProperties2-sType-sType");
    if (pImageFormatProperties != nullptr) {
        [[maybe_unused]] const Location pImageFormatProperties_loc = loc.dot(Field::pImageFormatProperties);
        constexpr std::array allowed_structs_VkImageFormatProperties2 = {
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
            VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT,
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD};

        skip |= ValidateStructPnext(
            pImageFormatProperties_loc, pImageFormatProperties->pNext, allowed_structs_VkImageFormatProperties2.size(),
            allowed_structs_VkImageFormatProperties2.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkImageFormatProperties2-pNext-pNext", "VUID-VkImageFormatProperties2-sType-unique", physicalDevice, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo,
                                                                              pImageFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice,
                                                                                 uint32_t* pQueueFamilyPropertyCount,
                                                                                 VkQueueFamilyProperties2* pQueueFamilyProperties,
                                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceQueueFamilyProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructTypeArray(loc.dot(Field::pQueueFamilyPropertyCount), loc.dot(Field::pQueueFamilyProperties),
                                    pQueueFamilyPropertyCount, pQueueFamilyProperties, VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
                                    true, false, false, "VUID-VkQueueFamilyProperties2-sType-sType",
                                    "VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter",
                                    "VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyPropertyCount-parameter",
                                    kVUIDUndefined);
    if (pQueueFamilyProperties != nullptr) {
        for (uint32_t pQueueFamilyPropertyIndex = 0; pQueueFamilyPropertyIndex < *pQueueFamilyPropertyCount;
             ++pQueueFamilyPropertyIndex) {
            [[maybe_unused]] const Location pQueueFamilyProperties_loc =
                loc.dot(Field::pQueueFamilyProperties, pQueueFamilyPropertyIndex);
            constexpr std::array allowed_structs_VkQueueFamilyProperties2 = {
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR,
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
                VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR};

            skip |= ValidateStructPnext(pQueueFamilyProperties_loc, pQueueFamilyProperties[pQueueFamilyPropertyIndex].pNext,
                                        allowed_structs_VkQueueFamilyProperties2.size(),
                                        allowed_structs_VkQueueFamilyProperties2.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkQueueFamilyProperties2-pNext-pNext", "VUID-VkQueueFamilyProperties2-sType-unique",
                                        physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice,
                                                                            VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceMemoryProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructType(loc.dot(Field::pMemoryProperties), pMemoryProperties,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, true,
                               "VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter",
                               "VUID-VkPhysicalDeviceMemoryProperties2-sType-sType");
    if (pMemoryProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryProperties_loc = loc.dot(Field::pMemoryProperties);
        constexpr std::array allowed_structs_VkPhysicalDeviceMemoryProperties2 = {
            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT};

        skip |= ValidateStructPnext(pMemoryProperties_loc, pMemoryProperties->pNext,
                                    allowed_structs_VkPhysicalDeviceMemoryProperties2.size(),
                                    allowed_structs_VkPhysicalDeviceMemoryProperties2.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext",
                                    "VUID-VkPhysicalDeviceMemoryProperties2-sType-unique", physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceSparseImageFormatProperties2 &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |=
        ValidateStructType(loc.dot(Field::pFormatInfo), pFormatInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
                           true, "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter",
                           "VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType");
    if (pFormatInfo != nullptr) {
        [[maybe_unused]] const Location pFormatInfo_loc = loc.dot(Field::pFormatInfo);
        skip |=
            ValidateStructPnext(pFormatInfo_loc, pFormatInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext", kVUIDUndefined, physicalDevice, true);

        skip |= ValidateRangedEnum(pFormatInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pFormatInfo->format,
                                   "VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter", physicalDevice);

        skip |= ValidateRangedEnum(pFormatInfo_loc.dot(Field::type), vvl::Enum::VkImageType, pFormatInfo->type,
                                   "VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter", physicalDevice);

        skip |= ValidateFlags(pFormatInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                              AllVkSampleCountFlagBits, pFormatInfo->samples, kRequiredSingleBit, physicalDevice,
                              "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter",
                              "VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter");

        skip |= ValidateFlags(pFormatInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits,
                              pFormatInfo->usage, kRequiredFlags, physicalDevice,
                              "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter",
                              "VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask");

        skip |= ValidateRangedEnum(pFormatInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pFormatInfo->tiling,
                                   "VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter", physicalDevice);
    }
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, true, false, false, "VUID-VkSparseImageFormatProperties2-sType-sType",
        "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pProperties-parameter",
        "VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSparseImageFormatProperties2-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);
    skip |= ValidateReservedFlags(loc.dot(Field::flags), flags, "VUID-vkTrimCommandPool-flags-zerobitmask");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pQueueInfo), pQueueInfo, VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2, true,
                               "VUID-vkGetDeviceQueue2-pQueueInfo-parameter", "VUID-VkDeviceQueueInfo2-sType-sType");
    if (pQueueInfo != nullptr) {
        [[maybe_unused]] const Location pQueueInfo_loc = loc.dot(Field::pQueueInfo);
        skip |= ValidateStructPnext(pQueueInfo_loc, pQueueInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceQueueInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pQueueInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDeviceQueueCreateFlagBits,
                              AllVkDeviceQueueCreateFlagBits, pQueueInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDeviceQueueInfo2-flags-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pQueue), pQueue, "VUID-vkGetDeviceQueue2-pQueue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSamplerYcbcrConversion(VkDevice device,
                                                                      const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                                                      const VkAllocationCallbacks* pAllocator,
                                                                      VkSamplerYcbcrConversion* pYcbcrConversion,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
                               true, "VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter",
                               "VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSamplerYcbcrConversionCreateInfo = {
            VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
            VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSamplerYcbcrConversionCreateInfo.size(),
                                    allowed_structs_VkSamplerYcbcrConversionCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext",
                                    "VUID-VkSamplerYcbcrConversionCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pCreateInfo->format,
                                   "VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::ycbcrModel), vvl::Enum::VkSamplerYcbcrModelConversion,
                                   pCreateInfo->ycbcrModel, "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::ycbcrRange), vvl::Enum::VkSamplerYcbcrRange, pCreateInfo->ycbcrRange,
                                   "VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::r), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.r,
                                   "VUID-VkComponentMapping-r-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::g), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.g,
                                   "VUID-VkComponentMapping-g-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::b), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.b,
                                   "VUID-VkComponentMapping-b-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::a), vvl::Enum::VkComponentSwizzle, pCreateInfo->components.a,
                                   "VUID-VkComponentMapping-a-parameter", VK_NULL_HANDLE);

        skip |=
            ValidateRangedEnum(pCreateInfo_loc.dot(Field::xChromaOffset), vvl::Enum::VkChromaLocation, pCreateInfo->xChromaOffset,
                               "VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter", VK_NULL_HANDLE);

        skip |=
            ValidateRangedEnum(pCreateInfo_loc.dot(Field::yChromaOffset), vvl::Enum::VkChromaLocation, pCreateInfo->yChromaOffset,
                               "VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::chromaFilter), vvl::Enum::VkFilter, pCreateInfo->chromaFilter,
                                   "VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter", VK_NULL_HANDLE);

        skip |= ValidateBool32(pCreateInfo_loc.dot(Field::forceExplicitReconstruction), pCreateInfo->forceExplicitReconstruction);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pYcbcrConversion), pYcbcrConversion,
                                    "VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorUpdateTemplate(VkDevice device,
                                                                        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
                               true, "VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter",
                               "VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::descriptorUpdateEntryCount),
                              pCreateInfo_loc.dot(Field::pDescriptorUpdateEntries), pCreateInfo->descriptorUpdateEntryCount,
                              &pCreateInfo->pDescriptorUpdateEntries, true, true,
                              "VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength",
                              "VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter");

        if (pCreateInfo->pDescriptorUpdateEntries != nullptr) {
            for (uint32_t descriptorUpdateEntryIndex = 0; descriptorUpdateEntryIndex < pCreateInfo->descriptorUpdateEntryCount;
                 ++descriptorUpdateEntryIndex) {
                [[maybe_unused]] const Location pDescriptorUpdateEntries_loc =
                    pCreateInfo_loc.dot(Field::pDescriptorUpdateEntries, descriptorUpdateEntryIndex);
                skip |= ValidateRangedEnum(pDescriptorUpdateEntries_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                           pCreateInfo->pDescriptorUpdateEntries[descriptorUpdateEntryIndex].descriptorType,
                                           "VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter", VK_NULL_HANDLE);
            }
        }

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::templateType), vvl::Enum::VkDescriptorUpdateTemplateType,
                                   pCreateInfo->templateType, "VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter",
                                   VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pDescriptorUpdateTemplate), pDescriptorUpdateTemplate,
                                    "VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorUpdateTemplate(VkDevice device,
                                                                         VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                                         const VkAllocationCallbacks* pAllocator,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet,
                                                                         VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                                         const void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::descriptorSet), descriptorSet);
    skip |= ValidateRequiredHandle(loc.dot(Field::descriptorUpdateTemplate), descriptorUpdateTemplate);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceExternalBufferProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructType(loc.dot(Field::pExternalBufferInfo), pExternalBufferInfo,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO, true,
                               "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter",
                               "VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType");
    if (pExternalBufferInfo != nullptr) {
        [[maybe_unused]] const Location pExternalBufferInfo_loc = loc.dot(Field::pExternalBufferInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalBufferInfo = {
            VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR};

        skip |= ValidateStructPnext(pExternalBufferInfo_loc, pExternalBufferInfo->pNext,
                                    allowed_structs_VkPhysicalDeviceExternalBufferInfo.size(),
                                    allowed_structs_VkPhysicalDeviceExternalBufferInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext",
                                    "VUID-VkPhysicalDeviceExternalBufferInfo-sType-unique", physicalDevice, true);

        skip |= ValidateFlags(pExternalBufferInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                              AllVkBufferCreateFlagBits, pExternalBufferInfo->flags, kOptionalFlags, physicalDevice,
                              "VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter");

        skip |= ValidateFlags(pExternalBufferInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                              AllVkExternalMemoryHandleTypeFlagBits, pExternalBufferInfo->handleType, kRequiredSingleBit,
                              physicalDevice, "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter",
                              "VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pExternalBufferProperties), pExternalBufferProperties,
                               VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, true,
                               "VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter",
                               "VUID-VkExternalBufferProperties-sType-sType");
    if (pExternalBufferProperties != nullptr) {
        [[maybe_unused]] const Location pExternalBufferProperties_loc = loc.dot(Field::pExternalBufferProperties);
        skip |= ValidateStructPnext(pExternalBufferProperties_loc, pExternalBufferProperties->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkExternalBufferProperties-pNext-pNext", kVUIDUndefined,
                                    physicalDevice, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo,
                                                                                pExternalBufferProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceExternalFenceProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructType(loc.dot(Field::pExternalFenceInfo), pExternalFenceInfo,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, true,
                               "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter",
                               "VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType");
    if (pExternalFenceInfo != nullptr) {
        [[maybe_unused]] const Location pExternalFenceInfo_loc = loc.dot(Field::pExternalFenceInfo);
        skip |= ValidateStructPnext(pExternalFenceInfo_loc, pExternalFenceInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext", kVUIDUndefined, physicalDevice, true);

        skip |= ValidateFlags(pExternalFenceInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                              AllVkExternalFenceHandleTypeFlagBits, pExternalFenceInfo->handleType, kRequiredSingleBit,
                              physicalDevice, "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter",
                              "VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pExternalFenceProperties), pExternalFenceProperties,
                               VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, true,
                               "VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter",
                               "VUID-VkExternalFenceProperties-sType-sType");
    if (pExternalFenceProperties != nullptr) {
        [[maybe_unused]] const Location pExternalFenceProperties_loc = loc.dot(Field::pExternalFenceProperties);
        skip |= ValidateStructPnext(pExternalFenceProperties_loc, pExternalFenceProperties->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkExternalFenceProperties-pNext-pNext", kVUIDUndefined,
                                    physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceExternalSemaphoreProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_1))
        return true;
    skip |= ValidateStructType(loc.dot(Field::pExternalSemaphoreInfo), pExternalSemaphoreInfo,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, true,
                               "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter",
                               "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType");
    if (pExternalSemaphoreInfo != nullptr) {
        [[maybe_unused]] const Location pExternalSemaphoreInfo_loc = loc.dot(Field::pExternalSemaphoreInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo = {VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO};

        skip |= ValidateStructPnext(pExternalSemaphoreInfo_loc, pExternalSemaphoreInfo->pNext,
                                    allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.size(),
                                    allowed_structs_VkPhysicalDeviceExternalSemaphoreInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext",
                                    "VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-unique", physicalDevice, true);

        skip |= ValidateFlags(pExternalSemaphoreInfo_loc.dot(Field::handleType),
                              vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits, AllVkExternalSemaphoreHandleTypeFlagBits,
                              pExternalSemaphoreInfo->handleType, kRequiredSingleBit, physicalDevice,
                              "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter",
                              "VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pExternalSemaphoreProperties), pExternalSemaphoreProperties,
                               VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, true,
                               "VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter",
                               "VUID-VkExternalSemaphoreProperties-sType-sType");
    if (pExternalSemaphoreProperties != nullptr) {
        [[maybe_unused]] const Location pExternalSemaphoreProperties_loc = loc.dot(Field::pExternalSemaphoreProperties);
        skip |= ValidateStructPnext(pExternalSemaphoreProperties_loc, pExternalSemaphoreProperties->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkExternalSemaphoreProperties-pNext-pNext", kVUIDUndefined,
                                    physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutSupport(VkDevice device,
                                                                       const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                                       VkDescriptorSetLayoutSupport* pSupport,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, true,
                               "VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter",
                               "VUID-VkDescriptorSetLayoutCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkDescriptorSetLayoutCreateInfo = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkDescriptorSetLayoutCreateInfo.size(),
                                    allowed_structs_VkDescriptorSetLayoutCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext",
                                    "VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDescriptorSetLayoutCreateFlagBits,
                              AllVkDescriptorSetLayoutCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::bindingCount), pCreateInfo_loc.dot(Field::pBindings),
                              pCreateInfo->bindingCount, &pCreateInfo->pBindings, false, true, kVUIDUndefined,
                              "VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter");

        if (pCreateInfo->pBindings != nullptr) {
            for (uint32_t bindingIndex = 0; bindingIndex < pCreateInfo->bindingCount; ++bindingIndex) {
                [[maybe_unused]] const Location pBindings_loc = pCreateInfo_loc.dot(Field::pBindings, bindingIndex);
                skip |= ValidateRangedEnum(pBindings_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                           pCreateInfo->pBindings[bindingIndex].descriptorType,
                                           "VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter", VK_NULL_HANDLE);
            }
        }
    }
    skip |= ValidateStructType(loc.dot(Field::pSupport), pSupport, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, true,
                               "VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter",
                               "VUID-VkDescriptorSetLayoutSupport-sType-sType");
    if (pSupport != nullptr) {
        [[maybe_unused]] const Location pSupport_loc = loc.dot(Field::pSupport);
        constexpr std::array allowed_structs_VkDescriptorSetLayoutSupport = {
            VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT};

        skip |= ValidateStructPnext(pSupport_loc, pSupport->pNext, allowed_structs_VkDescriptorSetLayoutSupport.size(),
                                    allowed_structs_VkDescriptorSetLayoutSupport.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorSetLayoutSupport-pNext-pNext",
                                    "VUID-VkDescriptorSetLayoutSupport-sType-unique", VK_NULL_HANDLE, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                              VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                              uint32_t maxDrawCount, uint32_t stride,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                     VkDeviceSize offset, VkBuffer countBuffer,
                                                                     VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                     uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, true,
                               "VUID-vkCreateRenderPass2-pCreateInfo-parameter", "VUID-VkRenderPassCreateInfo2-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkRenderPassCreateInfo2 = {
            VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkRenderPassCreateInfo2.size(),
                                    allowed_structs_VkRenderPassCreateInfo2.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderPassCreateInfo2-pNext-pNext", "VUID-VkRenderPassCreateInfo2-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderPassCreateFlagBits,
                              AllVkRenderPassCreateFlagBits, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkRenderPassCreateInfo2-flags-parameter");

        skip |= ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::attachmentCount), pCreateInfo_loc.dot(Field::pAttachments), pCreateInfo->attachmentCount,
            pCreateInfo->pAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, false, true,
            "VUID-VkAttachmentDescription2-sType-sType", "VUID-VkRenderPassCreateInfo2-pAttachments-parameter", kVUIDUndefined);

        if (pCreateInfo->pAttachments != nullptr) {
            for (uint32_t attachmentIndex = 0; attachmentIndex < pCreateInfo->attachmentCount; ++attachmentIndex) {
                [[maybe_unused]] const Location pAttachments_loc = pCreateInfo_loc.dot(Field::pAttachments, attachmentIndex);
                constexpr std::array allowed_structs_VkAttachmentDescription2 = {
                    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT, VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID};

                skip |= ValidateStructPnext(pAttachments_loc, pCreateInfo->pAttachments[attachmentIndex].pNext,
                                            allowed_structs_VkAttachmentDescription2.size(),
                                            allowed_structs_VkAttachmentDescription2.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkAttachmentDescription2-pNext-pNext",
                                            "VUID-VkAttachmentDescription2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pAttachments_loc.dot(Field::flags), vvl::FlagBitmask::VkAttachmentDescriptionFlagBits,
                                      AllVkAttachmentDescriptionFlagBits, pCreateInfo->pAttachments[attachmentIndex].flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkAttachmentDescription2-flags-parameter");

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::format), vvl::Enum::VkFormat,
                                           pCreateInfo->pAttachments[attachmentIndex].format,
                                           "VUID-VkAttachmentDescription2-format-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pAttachments_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                      AllVkSampleCountFlagBits, pCreateInfo->pAttachments[attachmentIndex].samples,
                                      kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkAttachmentDescription2-samples-parameter",
                                      "VUID-VkAttachmentDescription2-samples-parameter");

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                           pCreateInfo->pAttachments[attachmentIndex].loadOp,
                                           "VUID-VkAttachmentDescription2-loadOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                           pCreateInfo->pAttachments[attachmentIndex].storeOp,
                                           "VUID-VkAttachmentDescription2-storeOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::stencilLoadOp), vvl::Enum::VkAttachmentLoadOp,
                                           pCreateInfo->pAttachments[attachmentIndex].stencilLoadOp,
                                           "VUID-VkAttachmentDescription2-stencilLoadOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::stencilStoreOp), vvl::Enum::VkAttachmentStoreOp,
                                           pCreateInfo->pAttachments[attachmentIndex].stencilStoreOp,
                                           "VUID-VkAttachmentDescription2-stencilStoreOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                           pCreateInfo->pAttachments[attachmentIndex].initialLayout,
                                           "VUID-VkAttachmentDescription2-initialLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::finalLayout), vvl::Enum::VkImageLayout,
                                           pCreateInfo->pAttachments[attachmentIndex].finalLayout,
                                           "VUID-VkAttachmentDescription2-finalLayout-parameter", VK_NULL_HANDLE);
            }
        }

        skip |= ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::subpassCount), pCreateInfo_loc.dot(Field::pSubpasses), pCreateInfo->subpassCount,
            pCreateInfo->pSubpasses, VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, true, true, "VUID-VkSubpassDescription2-sType-sType",
            "VUID-VkRenderPassCreateInfo2-pSubpasses-parameter", "VUID-VkRenderPassCreateInfo2-subpassCount-arraylength");

        if (pCreateInfo->pSubpasses != nullptr) {
            for (uint32_t subpassIndex = 0; subpassIndex < pCreateInfo->subpassCount; ++subpassIndex) {
                [[maybe_unused]] const Location pSubpasses_loc = pCreateInfo_loc.dot(Field::pSubpasses, subpassIndex);
                constexpr std::array allowed_structs_VkSubpassDescription2 = {
                    VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
                    VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
                    VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
                    VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE};

                skip |= ValidateStructPnext(
                    pSubpasses_loc, pCreateInfo->pSubpasses[subpassIndex].pNext, allowed_structs_VkSubpassDescription2.size(),
                    allowed_structs_VkSubpassDescription2.data(), GeneratedVulkanHeaderVersion,
                    "VUID-VkSubpassDescription2-pNext-pNext", "VUID-VkSubpassDescription2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pSubpasses_loc.dot(Field::flags), vvl::FlagBitmask::VkSubpassDescriptionFlagBits,
                                      AllVkSubpassDescriptionFlagBits, pCreateInfo->pSubpasses[subpassIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkSubpassDescription2-flags-parameter");

                skip |= ValidateRangedEnum(pSubpasses_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                           pCreateInfo->pSubpasses[subpassIndex].pipelineBindPoint,
                                           "VUID-VkSubpassDescription2-pipelineBindPoint-parameter", VK_NULL_HANDLE);

                skip |= ValidateStructTypeArray(
                    pSubpasses_loc.dot(Field::inputAttachmentCount), pSubpasses_loc.dot(Field::pInputAttachments),
                    pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount,
                    pCreateInfo->pSubpasses[subpassIndex].pInputAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true,
                    "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pInputAttachments-parameter",
                    kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pInputAttachments != nullptr) {
                    for (uint32_t inputAttachmentIndex = 0;
                         inputAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].inputAttachmentCount;
                         ++inputAttachmentIndex) {
                        [[maybe_unused]] const Location pInputAttachments_loc =
                            pSubpasses_loc.dot(Field::pInputAttachments, inputAttachmentIndex);
                        constexpr std::array allowed_structs_VkAttachmentReference2 = {
                            VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                        skip |= ValidateStructPnext(
                            pInputAttachments_loc,
                            pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].pNext,
                            allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                            GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                            "VUID-VkAttachmentReference2-sType-unique", VK_NULL_HANDLE, true);

                        skip |=
                            ValidateRangedEnum(pInputAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               pCreateInfo->pSubpasses[subpassIndex].pInputAttachments[inputAttachmentIndex].layout,
                                               "VUID-VkAttachmentReference2-layout-parameter", VK_NULL_HANDLE);
                    }
                }

                skip |= ValidateStructTypeArray(
                    pSubpasses_loc.dot(Field::colorAttachmentCount), pSubpasses_loc.dot(Field::pColorAttachments),
                    pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount,
                    pCreateInfo->pSubpasses[subpassIndex].pColorAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false, true,
                    "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pColorAttachments-parameter",
                    kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pColorAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pColorAttachments_loc =
                            pSubpasses_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                        constexpr std::array allowed_structs_VkAttachmentReference2 = {
                            VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                        skip |= ValidateStructPnext(
                            pColorAttachments_loc,
                            pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].pNext,
                            allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                            GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                            "VUID-VkAttachmentReference2-sType-unique", VK_NULL_HANDLE, true);

                        skip |=
                            ValidateRangedEnum(pColorAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               pCreateInfo->pSubpasses[subpassIndex].pColorAttachments[colorAttachmentIndex].layout,
                                               "VUID-VkAttachmentReference2-layout-parameter", VK_NULL_HANDLE);
                    }
                }

                skip |= ValidateStructTypeArray(
                    pSubpasses_loc.dot(Field::colorAttachmentCount), pSubpasses_loc.dot(Field::pResolveAttachments),
                    pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount,
                    pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                    false, "VUID-VkAttachmentReference2-sType-sType", "VUID-VkSubpassDescription2-pResolveAttachments-parameter",
                    kVUIDUndefined);

                if (pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments != nullptr) {
                    for (uint32_t colorAttachmentIndex = 0;
                         colorAttachmentIndex < pCreateInfo->pSubpasses[subpassIndex].colorAttachmentCount;
                         ++colorAttachmentIndex) {
                        [[maybe_unused]] const Location pResolveAttachments_loc =
                            pSubpasses_loc.dot(Field::pResolveAttachments, colorAttachmentIndex);
                        constexpr std::array allowed_structs_VkAttachmentReference2 = {
                            VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                        skip |= ValidateStructPnext(
                            pResolveAttachments_loc,
                            pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].pNext,
                            allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                            GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                            "VUID-VkAttachmentReference2-sType-unique", VK_NULL_HANDLE, true);

                        skip |= ValidateRangedEnum(
                            pResolveAttachments_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                            pCreateInfo->pSubpasses[subpassIndex].pResolveAttachments[colorAttachmentIndex].layout,
                            "VUID-VkAttachmentReference2-layout-parameter", VK_NULL_HANDLE);
                    }
                }

                skip |= ValidateStructType(
                    pSubpasses_loc.dot(Field::pDepthStencilAttachment),
                    pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment, VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, false,
                    "VUID-VkSubpassDescription2-pDepthStencilAttachment-parameter", "VUID-VkAttachmentReference2-sType-sType");

                if (pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment != nullptr) {
                    [[maybe_unused]] const Location pDepthStencilAttachment_loc =
                        pSubpasses_loc.dot(Field::pDepthStencilAttachment);
                    constexpr std::array allowed_structs_VkAttachmentReference2 = {
                        VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT};

                    skip |= ValidateStructPnext(
                        pDepthStencilAttachment_loc, pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->pNext,
                        allowed_structs_VkAttachmentReference2.size(), allowed_structs_VkAttachmentReference2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkAttachmentReference2-pNext-pNext",
                        "VUID-VkAttachmentReference2-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(pDepthStencilAttachment_loc.dot(Field::layout), vvl::Enum::VkImageLayout,
                                               pCreateInfo->pSubpasses[subpassIndex].pDepthStencilAttachment->layout,
                                               "VUID-VkAttachmentReference2-layout-parameter", VK_NULL_HANDLE);
                }

                skip |= ValidateArray(pSubpasses_loc.dot(Field::preserveAttachmentCount),
                                      pSubpasses_loc.dot(Field::pPreserveAttachments),
                                      pCreateInfo->pSubpasses[subpassIndex].preserveAttachmentCount,
                                      &pCreateInfo->pSubpasses[subpassIndex].pPreserveAttachments, false, true, kVUIDUndefined,
                                      "VUID-VkSubpassDescription2-pPreserveAttachments-parameter");
            }
        }

        skip |= ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::dependencyCount), pCreateInfo_loc.dot(Field::pDependencies), pCreateInfo->dependencyCount,
            pCreateInfo->pDependencies, VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, false, true,
            "VUID-VkSubpassDependency2-sType-sType", "VUID-VkRenderPassCreateInfo2-pDependencies-parameter", kVUIDUndefined);

        if (pCreateInfo->pDependencies != nullptr) {
            for (uint32_t dependencyIndex = 0; dependencyIndex < pCreateInfo->dependencyCount; ++dependencyIndex) {
                [[maybe_unused]] const Location pDependencies_loc = pCreateInfo_loc.dot(Field::pDependencies, dependencyIndex);
                constexpr std::array allowed_structs_VkSubpassDependency2 = {VK_STRUCTURE_TYPE_MEMORY_BARRIER_2};

                skip |=
                    ValidateStructPnext(pDependencies_loc, pCreateInfo->pDependencies[dependencyIndex].pNext,
                                        allowed_structs_VkSubpassDependency2.size(), allowed_structs_VkSubpassDependency2.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkSubpassDependency2-pNext-pNext",
                                        "VUID-VkSubpassDependency2-sType-unique", VK_NULL_HANDLE, true);

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |= ValidateFlags(pDependencies_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                          AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency2-srcStageMask-parameter");
                }

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |= ValidateFlags(pDependencies_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits,
                                          AllVkPipelineStageFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency2-dstStageMask-parameter");
                }

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |= ValidateFlags(pDependencies_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                          AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].srcAccessMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency2-srcAccessMask-parameter");
                }

                if (!vku::FindStructInPNextChain<VkMemoryBarrier2>(pCreateInfo->pDependencies[dependencyIndex].pNext)) {
                    skip |= ValidateFlags(pDependencies_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits,
                                          AllVkAccessFlagBits, pCreateInfo->pDependencies[dependencyIndex].dstAccessMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency2-dstAccessMask-parameter");
                }

                skip |= ValidateFlags(pDependencies_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                      AllVkDependencyFlagBits, pCreateInfo->pDependencies[dependencyIndex].dependencyFlags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubpassDependency2-dependencyFlags-parameter");
            }
        }

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::correlatedViewMaskCount), pCreateInfo_loc.dot(Field::pCorrelatedViewMasks),
                              pCreateInfo->correlatedViewMaskCount, &pCreateInfo->pCorrelatedViewMasks, false, true, kVUIDUndefined,
                              "VUID-VkRenderPassCreateInfo2-pCorrelatedViewMasks-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pRenderPass), pRenderPass, "VUID-vkCreateRenderPass2-pRenderPass-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderPass2(VkCommandBuffer commandBuffer,
                                                             const VkRenderPassBeginInfo* pRenderPassBegin,
                                                             const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pRenderPassBegin), pRenderPassBegin, VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, true,
                               "VUID-vkCmdBeginRenderPass2-pRenderPassBegin-parameter", "VUID-VkRenderPassBeginInfo-sType-sType");
    if (pRenderPassBegin != nullptr) {
        [[maybe_unused]] const Location pRenderPassBegin_loc = loc.dot(Field::pRenderPassBegin);
        constexpr std::array allowed_structs_VkRenderPassBeginInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM};

        skip |= ValidateStructPnext(pRenderPassBegin_loc, pRenderPassBegin->pNext, allowed_structs_VkRenderPassBeginInfo.size(),
                                    allowed_structs_VkRenderPassBeginInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderPassBeginInfo-pNext-pNext", "VUID-VkRenderPassBeginInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::renderPass), pRenderPassBegin->renderPass);

        skip |= ValidateRequiredHandle(pRenderPassBegin_loc.dot(Field::framebuffer), pRenderPassBegin->framebuffer);

        // No xml-driven validation

        // No xml-driven validation
    }
    skip |= ValidateStructType(loc.dot(Field::pSubpassBeginInfo), pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true,
                               "VUID-vkCmdBeginRenderPass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassBeginInfo_loc = loc.dot(Field::pSubpassBeginInfo);
        skip |= ValidateStructPnext(pSubpassBeginInfo_loc, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pSubpassBeginInfo_loc.dot(Field::contents), vvl::Enum::VkSubpassContents,
                                   pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                         const VkSubpassEndInfo* pSubpassEndInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pSubpassBeginInfo), pSubpassBeginInfo, VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, true,
                               "VUID-vkCmdNextSubpass2-pSubpassBeginInfo-parameter", "VUID-VkSubpassBeginInfo-sType-sType");
    if (pSubpassBeginInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassBeginInfo_loc = loc.dot(Field::pSubpassBeginInfo);
        skip |= ValidateStructPnext(pSubpassBeginInfo_loc, pSubpassBeginInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSubpassBeginInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pSubpassBeginInfo_loc.dot(Field::contents), vvl::Enum::VkSubpassContents,
                                   pSubpassBeginInfo->contents, "VUID-VkSubpassBeginInfo-contents-parameter", VK_NULL_HANDLE);
    }
    skip |= ValidateStructType(loc.dot(Field::pSubpassEndInfo), pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true,
                               "VUID-vkCmdNextSubpass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassEndInfo_loc = loc.dot(Field::pSubpassEndInfo);
        constexpr std::array allowed_structs_VkSubpassEndInfo = {
            VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM};

        skip |=
            ValidateStructPnext(pSubpassEndInfo_loc, pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(),
                                allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pSubpassEndInfo), pSubpassEndInfo, VK_STRUCTURE_TYPE_SUBPASS_END_INFO, true,
                               "VUID-vkCmdEndRenderPass2-pSubpassEndInfo-parameter", "VUID-VkSubpassEndInfo-sType-sType");
    if (pSubpassEndInfo != nullptr) {
        [[maybe_unused]] const Location pSubpassEndInfo_loc = loc.dot(Field::pSubpassEndInfo);
        constexpr std::array allowed_structs_VkSubpassEndInfo = {
            VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM};

        skip |=
            ValidateStructPnext(pSubpassEndInfo_loc, pSubpassEndInfo->pNext, allowed_structs_VkSubpassEndInfo.size(),
                                allowed_structs_VkSubpassEndInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkSubpassEndInfo-pNext-pNext", "VUID-VkSubpassEndInfo-sType-unique", VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                                        uint32_t queryCount, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t* pValue,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::semaphore), semaphore);
    skip |= ValidateRequiredPointer(loc.dot(Field::pValue), pValue, "VUID-vkGetSemaphoreCounterValue-pValue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pWaitInfo), pWaitInfo, VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, true,
                               "VUID-vkWaitSemaphores-pWaitInfo-parameter", "VUID-VkSemaphoreWaitInfo-sType-sType");
    if (pWaitInfo != nullptr) {
        [[maybe_unused]] const Location pWaitInfo_loc = loc.dot(Field::pWaitInfo);
        skip |= ValidateStructPnext(pWaitInfo_loc, pWaitInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSemaphoreWaitInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateFlags(pWaitInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSemaphoreWaitFlagBits, AllVkSemaphoreWaitFlagBits,
                          pWaitInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSemaphoreWaitInfo-flags-parameter");

        skip |= ValidateHandleArray(pWaitInfo_loc.dot(Field::semaphoreCount), pWaitInfo_loc.dot(Field::pSemaphores),
                                    pWaitInfo->semaphoreCount, pWaitInfo->pSemaphores, true, true,
                                    "VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength");

        skip |= ValidateArray(pWaitInfo_loc.dot(Field::semaphoreCount), pWaitInfo_loc.dot(Field::pValues),
                              pWaitInfo->semaphoreCount, &pWaitInfo->pValues, true, true,
                              "VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength", "VUID-VkSemaphoreWaitInfo-pValues-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pSignalInfo), pSignalInfo, VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, true,
                               "VUID-vkSignalSemaphore-pSignalInfo-parameter", "VUID-VkSemaphoreSignalInfo-sType-sType");
    if (pSignalInfo != nullptr) {
        [[maybe_unused]] const Location pSignalInfo_loc = loc.dot(Field::pSignalInfo);
        skip |= ValidateStructPnext(pSignalInfo_loc, pSignalInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSemaphoreSignalInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pSignalInfo_loc.dot(Field::semaphore), pSignalInfo->semaphore);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true,
                               "VUID-vkGetBufferDeviceAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, true,
                           "VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter", "VUID-VkBufferDeviceAddressInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferDeviceAddressInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMemoryOpaqueCaptureAddress(VkDevice device,
                                                                             const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO, true,
                               "VUID-vkGetDeviceMemoryOpaqueCaptureAddress-pInfo-parameter",
                               "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |=
            ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::memory), pInfo->memory);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                                                         VkPhysicalDeviceToolProperties* pToolProperties,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (loc.function == vvl::Func::vkGetPhysicalDeviceToolProperties &&
        CheckPromotedApiAgainstVulkanVersion(physicalDevice, loc, VK_API_VERSION_1_3))
        return true;
    skip |= ValidateStructTypeArray(loc.dot(Field::pToolCount), loc.dot(Field::pToolProperties), pToolCount, pToolProperties,
                                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, true, false, false,
                                    "VUID-VkPhysicalDeviceToolProperties-sType-sType",
                                    "VUID-vkGetPhysicalDeviceToolProperties-pToolProperties-parameter",
                                    "VUID-vkGetPhysicalDeviceToolProperties-pToolCount-parameter", kVUIDUndefined);
    if (pToolProperties != nullptr) {
        for (uint32_t pToolIndex = 0; pToolIndex < *pToolCount; ++pToolIndex) {
            [[maybe_unused]] const Location pToolProperties_loc = loc.dot(Field::pToolProperties, pToolIndex);
            skip |= ValidateStructPnext(pToolProperties_loc, pToolProperties[pToolIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceToolProperties-pNext-pNext",
                                        kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                                               const VkAllocationCallbacks* pAllocator,
                                                               VkPrivateDataSlot* pPrivateDataSlot,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO, true,
                           "VUID-vkCreatePrivateDataSlot-pCreateInfo-parameter", "VUID-VkPrivateDataSlotCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPrivateDataSlotCreateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkPrivateDataSlotCreateInfo-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pPrivateDataSlot), pPrivateDataSlot,
                                    "VUID-vkCreatePrivateDataSlot-pPrivateDataSlot-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                                                const VkAllocationCallbacks* pAllocator,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                                        VkPrivateDataSlot privateDataSlot, uint64_t data,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkObjectType, objectType,
                               "VUID-vkSetPrivateData-objectType-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::privateDataSlot), privateDataSlot);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                                        VkPrivateDataSlot privateDataSlot, uint64_t* pData,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkObjectType, objectType,
                               "VUID-vkGetPrivateData-objectType-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::privateDataSlot), privateDataSlot);
    skip |= ValidateRequiredPointer(loc.dot(Field::pData), pData, "VUID-vkGetPrivateData-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                                      const VkDependencyInfo* pDependencyInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= ValidateStructType(loc.dot(Field::pDependencyInfo), pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true,
                               "VUID-vkCmdSetEvent2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr) {
        [[maybe_unused]] const Location pDependencyInfo_loc = loc.dot(Field::pDependencyInfo);
        skip |= ValidateStructPnext(pDependencyInfo_loc, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pDependencyInfo_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                              AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::memoryBarrierCount), pDependencyInfo_loc.dot(Field::pMemoryBarriers),
            pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true,
            "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr) {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex) {
                [[maybe_unused]] const Location pMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
                skip |=
                    ValidateStructPnext(pMemoryBarriers_loc, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |=
                    ValidateFlags(pMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                  AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask,
                                  kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |=
                    ValidateFlags(pMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                  AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask,
                                  kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::bufferMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers),
            pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers,
            VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr) {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount;
                 ++bufferMemoryBarrierIndex) {
                [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

                skip |= ValidateStructPnext(
                    pBufferMemoryBarriers_loc, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                    allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext",
                    "VUID-VkBufferMemoryBarrier2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcStageMask),
                                      vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstStageMask),
                                      vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                               pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::imageMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pImageMemoryBarriers),
            pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers,
            VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr) {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount;
                 ++imageMemoryBarrierIndex) {
                [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

                skip |= ValidateStructPnext(
                    pImageMemoryBarriers_loc, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                    allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext",
                    "VUID-VkImageMemoryBarrier2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                           pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                           "VUID-VkImageMemoryBarrier2-oldLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                           pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                           "VUID-VkImageMemoryBarrier2-newLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                               pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                      "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                                        VkPipelineStageFlags2 stageMask, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::event), event);
    skip |= ValidateFlags(loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                          stageMask, kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdResetEvent2-stageMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents,
                                                        const VkDependencyInfo* pDependencyInfos,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateHandleArray(loc.dot(Field::eventCount), loc.dot(Field::pEvents), eventCount, pEvents, true, true,
                                "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    skip |=
        ValidateStructTypeArray(loc.dot(Field::eventCount), loc.dot(Field::pDependencyInfos), eventCount, pDependencyInfos,
                                VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true, true, "VUID-VkDependencyInfo-sType-sType",
                                "VUID-vkCmdWaitEvents2-pDependencyInfos-parameter", "VUID-vkCmdWaitEvents2-eventCount-arraylength");
    if (pDependencyInfos != nullptr) {
        for (uint32_t eventIndex = 0; eventIndex < eventCount; ++eventIndex) {
            [[maybe_unused]] const Location pDependencyInfos_loc = loc.dot(Field::pDependencyInfos, eventIndex);
            skip |= ValidateStructPnext(pDependencyInfos_loc, pDependencyInfos[eventIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pDependencyInfos_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                                  AllVkDependencyFlagBits, pDependencyInfos[eventIndex].dependencyFlags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkDependencyInfo-dependencyFlags-parameter");

            skip |= ValidateStructTypeArray(
                pDependencyInfos_loc.dot(Field::memoryBarrierCount), pDependencyInfos_loc.dot(Field::pMemoryBarriers),
                pDependencyInfos[eventIndex].memoryBarrierCount, pDependencyInfos[eventIndex].pMemoryBarriers,
                VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true, "VUID-VkMemoryBarrier2-sType-sType",
                "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pMemoryBarriers != nullptr) {
                for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfos[eventIndex].memoryBarrierCount;
                     ++memoryBarrierIndex) {
                    [[maybe_unused]] const Location pMemoryBarriers_loc =
                        pDependencyInfos_loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
                    skip |= ValidateStructPnext(pMemoryBarriers_loc,
                                                pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                          AllVkPipelineStageFlagBits2,
                                          pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2,
                                          pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].srcAccessMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                          AllVkPipelineStageFlagBits2,
                                          pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2,
                                          pDependencyInfos[eventIndex].pMemoryBarriers[memoryBarrierIndex].dstAccessMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
                }
            }

            skip |= ValidateStructTypeArray(
                pDependencyInfos_loc.dot(Field::bufferMemoryBarrierCount), pDependencyInfos_loc.dot(Field::pBufferMemoryBarriers),
                pDependencyInfos[eventIndex].bufferMemoryBarrierCount, pDependencyInfos[eventIndex].pBufferMemoryBarriers,
                VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType",
                "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pBufferMemoryBarriers != nullptr) {
                for (uint32_t bufferMemoryBarrierIndex = 0;
                     bufferMemoryBarrierIndex < pDependencyInfos[eventIndex].bufferMemoryBarrierCount; ++bufferMemoryBarrierIndex) {
                    [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                        pDependencyInfos_loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
                    constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = {
                        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

                    skip |= ValidateStructPnext(pBufferMemoryBarriers_loc,
                                                pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                                                allowed_structs_VkBufferMemoryBarrier2.size(),
                                                allowed_structs_VkBufferMemoryBarrier2.data(), GeneratedVulkanHeaderVersion,
                                                "VUID-VkBufferMemoryBarrier2-pNext-pNext",
                                                "VUID-VkBufferMemoryBarrier2-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcStageMask),
                                          vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                          pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                    skip |=
                        ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstStageMask),
                                          vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                          pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                    skip |=
                        ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                    skip |=
                        ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                               pDependencyInfos[eventIndex].pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
                }
            }

            skip |= ValidateStructTypeArray(
                pDependencyInfos_loc.dot(Field::imageMemoryBarrierCount), pDependencyInfos_loc.dot(Field::pImageMemoryBarriers),
                pDependencyInfos[eventIndex].imageMemoryBarrierCount, pDependencyInfos[eventIndex].pImageMemoryBarriers,
                VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType",
                "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

            if (pDependencyInfos[eventIndex].pImageMemoryBarriers != nullptr) {
                for (uint32_t imageMemoryBarrierIndex = 0;
                     imageMemoryBarrierIndex < pDependencyInfos[eventIndex].imageMemoryBarrierCount; ++imageMemoryBarrierIndex) {
                    [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                        pDependencyInfos_loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
                    constexpr std::array allowed_structs_VkImageMemoryBarrier2 = {
                        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

                    skip |= ValidateStructPnext(
                        pImageMemoryBarriers_loc, pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                        allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext",
                        "VUID-VkImageMemoryBarrier2-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcStageMask),
                                          vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                          pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                    skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2,
                                          pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                    skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstStageMask),
                                          vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                          pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                    skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                          AllVkAccessFlagBits2,
                                          pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                    skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                               pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                               "VUID-VkImageMemoryBarrier2-oldLayout-parameter", VK_NULL_HANDLE);

                    skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                               pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                               "VUID-VkImageMemoryBarrier2-newLayout-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                               pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                    skip |= ValidateFlags(
                        pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                        AllVkImageAspectFlagBits,
                        pDependencyInfos[eventIndex].pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask,
                        kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceRange-aspectMask-parameter",
                        "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo* pDependencyInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pDependencyInfo), pDependencyInfo, VK_STRUCTURE_TYPE_DEPENDENCY_INFO, true,
                               "VUID-vkCmdPipelineBarrier2-pDependencyInfo-parameter", "VUID-VkDependencyInfo-sType-sType");
    if (pDependencyInfo != nullptr) {
        [[maybe_unused]] const Location pDependencyInfo_loc = loc.dot(Field::pDependencyInfo);
        skip |= ValidateStructPnext(pDependencyInfo_loc, pDependencyInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDependencyInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pDependencyInfo_loc.dot(Field::dependencyFlags), vvl::FlagBitmask::VkDependencyFlagBits,
                              AllVkDependencyFlagBits, pDependencyInfo->dependencyFlags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDependencyInfo-dependencyFlags-parameter");

        skip |= ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::memoryBarrierCount), pDependencyInfo_loc.dot(Field::pMemoryBarriers),
            pDependencyInfo->memoryBarrierCount, pDependencyInfo->pMemoryBarriers, VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, false, true,
            "VUID-VkMemoryBarrier2-sType-sType", "VUID-VkDependencyInfo-pMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pMemoryBarriers != nullptr) {
            for (uint32_t memoryBarrierIndex = 0; memoryBarrierIndex < pDependencyInfo->memoryBarrierCount; ++memoryBarrierIndex) {
                [[maybe_unused]] const Location pMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pMemoryBarriers, memoryBarrierIndex);
                skip |=
                    ValidateStructPnext(pMemoryBarriers_loc, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |=
                    ValidateFlags(pMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                  AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcStageMask,
                                  kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].srcAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-srcAccessMask-parameter");

                skip |=
                    ValidateFlags(pMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                  AllVkPipelineStageFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstStageMask,
                                  kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2, pDependencyInfo->pMemoryBarriers[memoryBarrierIndex].dstAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryBarrier2-dstAccessMask-parameter");
            }
        }

        skip |= ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::bufferMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers),
            pDependencyInfo->bufferMemoryBarrierCount, pDependencyInfo->pBufferMemoryBarriers,
            VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, false, true, "VUID-VkBufferMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pBufferMemoryBarriers != nullptr) {
            for (uint32_t bufferMemoryBarrierIndex = 0; bufferMemoryBarrierIndex < pDependencyInfo->bufferMemoryBarrierCount;
                 ++bufferMemoryBarrierIndex) {
                [[maybe_unused]] const Location pBufferMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pBufferMemoryBarriers, bufferMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkBufferMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT};

                skip |= ValidateStructPnext(
                    pBufferMemoryBarriers_loc, pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].pNext,
                    allowed_structs_VkBufferMemoryBarrier2.size(), allowed_structs_VkBufferMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkBufferMemoryBarrier2-pNext-pNext",
                    "VUID-VkBufferMemoryBarrier2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcStageMask),
                                      vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].srcAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstStageMask),
                                      vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pBufferMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].dstAccessMask,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRequiredHandle(pBufferMemoryBarriers_loc.dot(Field::buffer),
                                               pDependencyInfo->pBufferMemoryBarriers[bufferMemoryBarrierIndex].buffer);
            }
        }

        skip |= ValidateStructTypeArray(
            pDependencyInfo_loc.dot(Field::imageMemoryBarrierCount), pDependencyInfo_loc.dot(Field::pImageMemoryBarriers),
            pDependencyInfo->imageMemoryBarrierCount, pDependencyInfo->pImageMemoryBarriers,
            VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, false, true, "VUID-VkImageMemoryBarrier2-sType-sType",
            "VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", kVUIDUndefined);

        if (pDependencyInfo->pImageMemoryBarriers != nullptr) {
            for (uint32_t imageMemoryBarrierIndex = 0; imageMemoryBarrierIndex < pDependencyInfo->imageMemoryBarrierCount;
                 ++imageMemoryBarrierIndex) {
                [[maybe_unused]] const Location pImageMemoryBarriers_loc =
                    pDependencyInfo_loc.dot(Field::pImageMemoryBarriers, imageMemoryBarrierIndex);
                constexpr std::array allowed_structs_VkImageMemoryBarrier2 = {
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT};

                skip |= ValidateStructPnext(
                    pImageMemoryBarriers_loc, pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].pNext,
                    allowed_structs_VkImageMemoryBarrier2.size(), allowed_structs_VkImageMemoryBarrier2.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkImageMemoryBarrier2-pNext-pNext",
                    "VUID-VkImageMemoryBarrier2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-srcStageMask-parameter");

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::srcAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].srcAccessMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-srcAccessMask-parameter");

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstStageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                      AllVkPipelineStageFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstStageMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-dstStageMask-parameter");

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::dstAccessMask), vvl::FlagBitmask::VkAccessFlagBits2,
                                      AllVkAccessFlagBits2,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].dstAccessMask, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageMemoryBarrier2-dstAccessMask-parameter");

                skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                           pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].oldLayout,
                                           "VUID-VkImageMemoryBarrier2-oldLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pImageMemoryBarriers_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                           pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].newLayout,
                                           "VUID-VkImageMemoryBarrier2-newLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRequiredHandle(pImageMemoryBarriers_loc.dot(Field::image),
                                               pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].image);

                skip |= ValidateFlags(pImageMemoryBarriers_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits,
                                      pDependencyInfo->pImageMemoryBarriers[imageMemoryBarrierIndex].subresourceRange.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                      "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                                            VkQueryPool queryPool, uint32_t query,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::stage), vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2, stage,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdWriteTimestamp2-stage-parameter");
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                                                      VkFence fence, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(loc.dot(Field::submitCount), loc.dot(Field::pSubmits), submitCount, pSubmits,
                                    VK_STRUCTURE_TYPE_SUBMIT_INFO_2, false, true, "VUID-VkSubmitInfo2-sType-sType",
                                    "VUID-vkQueueSubmit2-pSubmits-parameter", kVUIDUndefined);
    if (pSubmits != nullptr) {
        for (uint32_t submitIndex = 0; submitIndex < submitCount; ++submitIndex) {
            [[maybe_unused]] const Location pSubmits_loc = loc.dot(Field::pSubmits, submitIndex);
            constexpr std::array allowed_structs_VkSubmitInfo2 = {
                VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT, VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
                VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
                VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV};

            skip |= ValidateStructPnext(pSubmits_loc, pSubmits[submitIndex].pNext, allowed_structs_VkSubmitInfo2.size(),
                                        allowed_structs_VkSubmitInfo2.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkSubmitInfo2-pNext-pNext", "VUID-VkSubmitInfo2-sType-unique", VK_NULL_HANDLE, true);

            skip |=
                ValidateFlags(pSubmits_loc.dot(Field::flags), vvl::FlagBitmask::VkSubmitFlagBits, AllVkSubmitFlagBits,
                              pSubmits[submitIndex].flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSubmitInfo2-flags-parameter");

            skip |= ValidateStructTypeArray(
                pSubmits_loc.dot(Field::waitSemaphoreInfoCount), pSubmits_loc.dot(Field::pWaitSemaphoreInfos),
                pSubmits[submitIndex].waitSemaphoreInfoCount, pSubmits[submitIndex].pWaitSemaphoreInfos,
                VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType",
                "VUID-VkSubmitInfo2-pWaitSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pWaitSemaphoreInfos != nullptr) {
                for (uint32_t waitSemaphoreInfoIndex = 0; waitSemaphoreInfoIndex < pSubmits[submitIndex].waitSemaphoreInfoCount;
                     ++waitSemaphoreInfoIndex) {
                    [[maybe_unused]] const Location pWaitSemaphoreInfos_loc =
                        pSubmits_loc.dot(Field::pWaitSemaphoreInfos, waitSemaphoreInfoIndex);
                    skip |= ValidateStructPnext(pWaitSemaphoreInfos_loc,
                                                pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRequiredHandle(pWaitSemaphoreInfos_loc.dot(Field::semaphore),
                                                   pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].semaphore);

                    skip |= ValidateFlags(pWaitSemaphoreInfos_loc.dot(Field::stageMask), vvl::FlagBitmask::VkPipelineStageFlagBits2,
                                          AllVkPipelineStageFlagBits2,
                                          pSubmits[submitIndex].pWaitSemaphoreInfos[waitSemaphoreInfoIndex].stageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }

            skip |= ValidateStructTypeArray(
                pSubmits_loc.dot(Field::commandBufferInfoCount), pSubmits_loc.dot(Field::pCommandBufferInfos),
                pSubmits[submitIndex].commandBufferInfoCount, pSubmits[submitIndex].pCommandBufferInfos,
                VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO, false, true, "VUID-VkCommandBufferSubmitInfo-sType-sType",
                "VUID-VkSubmitInfo2-pCommandBufferInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pCommandBufferInfos != nullptr) {
                for (uint32_t commandBufferInfoIndex = 0; commandBufferInfoIndex < pSubmits[submitIndex].commandBufferInfoCount;
                     ++commandBufferInfoIndex) {
                    [[maybe_unused]] const Location pCommandBufferInfos_loc =
                        pSubmits_loc.dot(Field::pCommandBufferInfos, commandBufferInfoIndex);
                    constexpr std::array allowed_structs_VkCommandBufferSubmitInfo = {
                        VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM};

                    skip |= ValidateStructPnext(
                        pCommandBufferInfos_loc, pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].pNext,
                        allowed_structs_VkCommandBufferSubmitInfo.size(), allowed_structs_VkCommandBufferSubmitInfo.data(),
                        GeneratedVulkanHeaderVersion, "VUID-VkCommandBufferSubmitInfo-pNext-pNext",
                        "VUID-VkCommandBufferSubmitInfo-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateRequiredHandle(pCommandBufferInfos_loc.dot(Field::commandBuffer),
                                                   pSubmits[submitIndex].pCommandBufferInfos[commandBufferInfoIndex].commandBuffer);
                }
            }

            skip |= ValidateStructTypeArray(
                pSubmits_loc.dot(Field::signalSemaphoreInfoCount), pSubmits_loc.dot(Field::pSignalSemaphoreInfos),
                pSubmits[submitIndex].signalSemaphoreInfoCount, pSubmits[submitIndex].pSignalSemaphoreInfos,
                VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, false, true, "VUID-VkSemaphoreSubmitInfo-sType-sType",
                "VUID-VkSubmitInfo2-pSignalSemaphoreInfos-parameter", kVUIDUndefined);

            if (pSubmits[submitIndex].pSignalSemaphoreInfos != nullptr) {
                for (uint32_t signalSemaphoreInfoIndex = 0;
                     signalSemaphoreInfoIndex < pSubmits[submitIndex].signalSemaphoreInfoCount; ++signalSemaphoreInfoIndex) {
                    [[maybe_unused]] const Location pSignalSemaphoreInfos_loc =
                        pSubmits_loc.dot(Field::pSignalSemaphoreInfos, signalSemaphoreInfoIndex);
                    skip |= ValidateStructPnext(pSignalSemaphoreInfos_loc,
                                                pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].pNext, 0,
                                                nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSemaphoreSubmitInfo-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRequiredHandle(pSignalSemaphoreInfos_loc.dot(Field::semaphore),
                                                   pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].semaphore);

                    skip |= ValidateFlags(pSignalSemaphoreInfos_loc.dot(Field::stageMask),
                                          vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2,
                                          pSubmits[submitIndex].pSignalSemaphoreInfos[signalSemaphoreInfoIndex].stageMask,
                                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkSemaphoreSubmitInfo-stageMask-parameter");
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCopyBufferInfo), pCopyBufferInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2, true,
                               "VUID-vkCmdCopyBuffer2-pCopyBufferInfo-parameter", "VUID-VkCopyBufferInfo2-sType-sType");
    if (pCopyBufferInfo != nullptr) {
        [[maybe_unused]] const Location pCopyBufferInfo_loc = loc.dot(Field::pCopyBufferInfo);
        skip |= ValidateStructPnext(pCopyBufferInfo_loc, pCopyBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyBufferInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pCopyBufferInfo_loc.dot(Field::srcBuffer), pCopyBufferInfo->srcBuffer);

        skip |= ValidateRequiredHandle(pCopyBufferInfo_loc.dot(Field::dstBuffer), pCopyBufferInfo->dstBuffer);

        skip |= ValidateStructTypeArray(pCopyBufferInfo_loc.dot(Field::regionCount), pCopyBufferInfo_loc.dot(Field::pRegions),
                                        pCopyBufferInfo->regionCount, pCopyBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_COPY_2,
                                        true, true, "VUID-VkBufferCopy2-sType-sType", "VUID-VkCopyBufferInfo2-pRegions-parameter",
                                        "VUID-VkCopyBufferInfo2-regionCount-arraylength");

        if (pCopyBufferInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyBufferInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= ValidateStructPnext(pRegions_loc, pCopyBufferInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkBufferCopy2-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyBuffer2(commandBuffer, pCopyBufferInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pCopyImageInfo), pCopyImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2, true,
                               "VUID-vkCmdCopyImage2-pCopyImageInfo-parameter", "VUID-VkCopyImageInfo2-sType-sType");
    if (pCopyImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageInfo_loc = loc.dot(Field::pCopyImageInfo);
        skip |= ValidateStructPnext(pCopyImageInfo_loc, pCopyImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyImageInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pCopyImageInfo_loc.dot(Field::srcImage), pCopyImageInfo->srcImage);

        skip |=
            ValidateRangedEnum(pCopyImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                               pCopyImageInfo->srcImageLayout, "VUID-VkCopyImageInfo2-srcImageLayout-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pCopyImageInfo_loc.dot(Field::dstImage), pCopyImageInfo->dstImage);

        skip |=
            ValidateRangedEnum(pCopyImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                               pCopyImageInfo->dstImageLayout, "VUID-VkCopyImageInfo2-dstImageLayout-parameter", VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(pCopyImageInfo_loc.dot(Field::regionCount), pCopyImageInfo_loc.dot(Field::pRegions),
                                        pCopyImageInfo->regionCount, pCopyImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true,
                                        true, "VUID-VkImageCopy2-sType-sType", "VUID-VkCopyImageInfo2-pRegions-parameter",
                                        "VUID-VkCopyImageInfo2-regionCount-arraylength");

        if (pCopyImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= ValidateStructPnext(pRegions_loc, pCopyImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pCopyImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
                                                               const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(
        loc.dot(Field::pCopyBufferToImageInfo), pCopyBufferToImageInfo, VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2, true,
        "VUID-vkCmdCopyBufferToImage2-pCopyBufferToImageInfo-parameter", "VUID-VkCopyBufferToImageInfo2-sType-sType");
    if (pCopyBufferToImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyBufferToImageInfo_loc = loc.dot(Field::pCopyBufferToImageInfo);
        skip |=
            ValidateStructPnext(pCopyBufferToImageInfo_loc, pCopyBufferToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkCopyBufferToImageInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pCopyBufferToImageInfo_loc.dot(Field::srcBuffer), pCopyBufferToImageInfo->srcBuffer);

        skip |= ValidateRequiredHandle(pCopyBufferToImageInfo_loc.dot(Field::dstImage), pCopyBufferToImageInfo->dstImage);

        skip |= ValidateRangedEnum(pCopyBufferToImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                   pCopyBufferToImageInfo->dstImageLayout, "VUID-VkCopyBufferToImageInfo2-dstImageLayout-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(pCopyBufferToImageInfo_loc.dot(Field::regionCount),
                                        pCopyBufferToImageInfo_loc.dot(Field::pRegions), pCopyBufferToImageInfo->regionCount,
                                        pCopyBufferToImageInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true, true,
                                        "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyBufferToImageInfo2-pRegions-parameter",
                                        "VUID-VkCopyBufferToImageInfo2-regionCount-arraylength");

        if (pCopyBufferToImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyBufferToImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyBufferToImageInfo_loc.dot(Field::pRegions, regionIndex);
                constexpr std::array allowed_structs_VkBufferImageCopy2 = {VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM};

                skip |= ValidateStructPnext(pRegions_loc, pCopyBufferToImageInfo->pRegions[regionIndex].pNext,
                                            allowed_structs_VkBufferImageCopy2.size(), allowed_structs_VkBufferImageCopy2.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext",
                                            "VUID-VkBufferImageCopy2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits,
                                      pCopyBufferToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
                                                               const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(
        loc.dot(Field::pCopyImageToBufferInfo), pCopyImageToBufferInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2, true,
        "VUID-vkCmdCopyImageToBuffer2-pCopyImageToBufferInfo-parameter", "VUID-VkCopyImageToBufferInfo2-sType-sType");
    if (pCopyImageToBufferInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageToBufferInfo_loc = loc.dot(Field::pCopyImageToBufferInfo);
        skip |=
            ValidateStructPnext(pCopyImageToBufferInfo_loc, pCopyImageToBufferInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkCopyImageToBufferInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pCopyImageToBufferInfo_loc.dot(Field::srcImage), pCopyImageToBufferInfo->srcImage);

        skip |= ValidateRangedEnum(pCopyImageToBufferInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                   pCopyImageToBufferInfo->srcImageLayout, "VUID-VkCopyImageToBufferInfo2-srcImageLayout-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pCopyImageToBufferInfo_loc.dot(Field::dstBuffer), pCopyImageToBufferInfo->dstBuffer);

        skip |= ValidateStructTypeArray(pCopyImageToBufferInfo_loc.dot(Field::regionCount),
                                        pCopyImageToBufferInfo_loc.dot(Field::pRegions), pCopyImageToBufferInfo->regionCount,
                                        pCopyImageToBufferInfo->pRegions, VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, true, true,
                                        "VUID-VkBufferImageCopy2-sType-sType", "VUID-VkCopyImageToBufferInfo2-pRegions-parameter",
                                        "VUID-VkCopyImageToBufferInfo2-regionCount-arraylength");

        if (pCopyImageToBufferInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToBufferInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageToBufferInfo_loc.dot(Field::pRegions, regionIndex);
                constexpr std::array allowed_structs_VkBufferImageCopy2 = {VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM};

                skip |= ValidateStructPnext(pRegions_loc, pCopyImageToBufferInfo->pRegions[regionIndex].pNext,
                                            allowed_structs_VkBufferImageCopy2.size(), allowed_structs_VkBufferImageCopy2.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkBufferImageCopy2-pNext-pNext",
                                            "VUID-VkBufferImageCopy2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits,
                                      pCopyImageToBufferInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pBlitImageInfo), pBlitImageInfo, VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2, true,
                               "VUID-vkCmdBlitImage2-pBlitImageInfo-parameter", "VUID-VkBlitImageInfo2-sType-sType");
    if (pBlitImageInfo != nullptr) {
        [[maybe_unused]] const Location pBlitImageInfo_loc = loc.dot(Field::pBlitImageInfo);
        constexpr std::array allowed_structs_VkBlitImageInfo2 = {VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM};

        skip |=
            ValidateStructPnext(pBlitImageInfo_loc, pBlitImageInfo->pNext, allowed_structs_VkBlitImageInfo2.size(),
                                allowed_structs_VkBlitImageInfo2.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkBlitImageInfo2-pNext-pNext", "VUID-VkBlitImageInfo2-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pBlitImageInfo_loc.dot(Field::srcImage), pBlitImageInfo->srcImage);

        skip |=
            ValidateRangedEnum(pBlitImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                               pBlitImageInfo->srcImageLayout, "VUID-VkBlitImageInfo2-srcImageLayout-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pBlitImageInfo_loc.dot(Field::dstImage), pBlitImageInfo->dstImage);

        skip |=
            ValidateRangedEnum(pBlitImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                               pBlitImageInfo->dstImageLayout, "VUID-VkBlitImageInfo2-dstImageLayout-parameter", VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(pBlitImageInfo_loc.dot(Field::regionCount), pBlitImageInfo_loc.dot(Field::pRegions),
                                        pBlitImageInfo->regionCount, pBlitImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_BLIT_2, true,
                                        true, "VUID-VkImageBlit2-sType-sType", "VUID-VkBlitImageInfo2-pRegions-parameter",
                                        "VUID-VkBlitImageInfo2-regionCount-arraylength");

        if (pBlitImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pBlitImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pBlitImageInfo_loc.dot(Field::pRegions, regionIndex);
                constexpr std::array allowed_structs_VkImageBlit2 = {VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM};

                skip |= ValidateStructPnext(pRegions_loc, pBlitImageInfo->pRegions[regionIndex].pNext,
                                            allowed_structs_VkImageBlit2.size(), allowed_structs_VkImageBlit2.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageBlit2-pNext-pNext",
                                            "VUID-VkImageBlit2-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pBlitImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
            }
        }

        skip |= ValidateRangedEnum(pBlitImageInfo_loc.dot(Field::filter), vvl::Enum::VkFilter, pBlitImageInfo->filter,
                                   "VUID-VkBlitImageInfo2-filter-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResolveImage2(VkCommandBuffer commandBuffer,
                                                          const VkResolveImageInfo2* pResolveImageInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pResolveImageInfo), pResolveImageInfo, VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2, true,
                               "VUID-vkCmdResolveImage2-pResolveImageInfo-parameter", "VUID-VkResolveImageInfo2-sType-sType");
    if (pResolveImageInfo != nullptr) {
        [[maybe_unused]] const Location pResolveImageInfo_loc = loc.dot(Field::pResolveImageInfo);
        skip |= ValidateStructPnext(pResolveImageInfo_loc, pResolveImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkResolveImageInfo2-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pResolveImageInfo_loc.dot(Field::srcImage), pResolveImageInfo->srcImage);

        skip |= ValidateRangedEnum(pResolveImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                   pResolveImageInfo->srcImageLayout, "VUID-VkResolveImageInfo2-srcImageLayout-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pResolveImageInfo_loc.dot(Field::dstImage), pResolveImageInfo->dstImage);

        skip |= ValidateRangedEnum(pResolveImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                   pResolveImageInfo->dstImageLayout, "VUID-VkResolveImageInfo2-dstImageLayout-parameter",
                                   VK_NULL_HANDLE);

        skip |=
            ValidateStructTypeArray(pResolveImageInfo_loc.dot(Field::regionCount), pResolveImageInfo_loc.dot(Field::pRegions),
                                    pResolveImageInfo->regionCount, pResolveImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2,
                                    true, true, "VUID-VkImageResolve2-sType-sType", "VUID-VkResolveImageInfo2-pRegions-parameter",
                                    "VUID-VkResolveImageInfo2-regionCount-arraylength");

        if (pResolveImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pResolveImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pResolveImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= ValidateStructPnext(pRegions_loc, pResolveImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageResolve2-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pResolveImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits, pResolveImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                      kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pRenderingInfo), pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true,
                               "VUID-vkCmdBeginRendering-pRenderingInfo-parameter", "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr) {
        [[maybe_unused]] const Location pRenderingInfo_loc = loc.dot(Field::pRenderingInfo);
        constexpr std::array allowed_structs_VkRenderingInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR};

        skip |= ValidateStructPnext(pRenderingInfo_loc, pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(),
                                    allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pRenderingInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderingFlagBits, AllVkRenderingFlagBits,
                              pRenderingInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateStructTypeArray(pRenderingInfo_loc.dot(Field::colorAttachmentCount),
                                        pRenderingInfo_loc.dot(Field::pColorAttachments), pRenderingInfo->colorAttachmentCount,
                                        pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, true,
                                        "VUID-VkRenderingAttachmentInfo-sType-sType",
                                        "VUID-VkRenderingInfo-pColorAttachments-parameter", kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr) {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount;
                 ++colorAttachmentIndex) {
                [[maybe_unused]] const Location pColorAttachments_loc =
                    pRenderingInfo_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                skip |= ValidateStructPnext(pColorAttachments_loc, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout,
                                           "VUID-VkRenderingAttachmentInfo-imageLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pColorAttachments_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                      AllVkResolveModeFlagBits, pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode,
                                      kOptionalSingleBit, VK_NULL_HANDLE, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout,
                                           "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp,
                                           "VUID-VkRenderingAttachmentInfo-loadOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp,
                                           "VUID-VkRenderingAttachmentInfo-storeOp-parameter", VK_NULL_HANDLE);

                // No xml-driven validation
            }
        }

        skip |= ValidateStructType(pRenderingInfo_loc.dot(Field::pDepthAttachment), pRenderingInfo->pDepthAttachment,
                                   VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                                   "VUID-VkRenderingInfo-pDepthAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr) {
            [[maybe_unused]] const Location pDepthAttachment_loc = pRenderingInfo_loc.dot(Field::pDepthAttachment);
            skip |= ValidateStructPnext(pDepthAttachment_loc, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pDepthAttachment->imageLayout,
                                       "VUID-VkRenderingAttachmentInfo-imageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pDepthAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                  AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode, kOptionalSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pDepthAttachment->resolveImageLayout,
                                       "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                       pRenderingInfo->pDepthAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter",
                                       VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                       pRenderingInfo->pDepthAttachment->storeOp,
                                       "VUID-VkRenderingAttachmentInfo-storeOp-parameter", VK_NULL_HANDLE);

            // No xml-driven validation
        }

        skip |=
            ValidateStructType(pRenderingInfo_loc.dot(Field::pStencilAttachment), pRenderingInfo->pStencilAttachment,
                               VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                               "VUID-VkRenderingInfo-pStencilAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr) {
            [[maybe_unused]] const Location pStencilAttachment_loc = pRenderingInfo_loc.dot(Field::pStencilAttachment);
            skip |= ValidateStructPnext(pStencilAttachment_loc, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pStencilAttachment->imageLayout,
                                       "VUID-VkRenderingAttachmentInfo-imageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pStencilAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                  AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode, kOptionalSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pStencilAttachment->resolveImageLayout,
                                       "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                       pRenderingInfo->pStencilAttachment->loadOp,
                                       "VUID-VkRenderingAttachmentInfo-loadOp-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                       pRenderingInfo->pStencilAttachment->storeOp,
                                       "VUID-VkRenderingAttachmentInfo-storeOp-parameter", VK_NULL_HANDLE);

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginRendering(commandBuffer, pRenderingInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRendering(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::cullMode), vvl::FlagBitmask::VkCullModeFlagBits, AllVkCullModeFlagBits, cullMode,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdSetCullMode-cullMode-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::frontFace), vvl::Enum::VkFrontFace, frontFace,
                               "VUID-vkCmdSetFrontFace-frontFace-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer,
                                                                 VkPrimitiveTopology primitiveTopology,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::primitiveTopology), vvl::Enum::VkPrimitiveTopology, primitiveTopology,
                               "VUID-vkCmdSetPrimitiveTopology-primitiveTopology-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                                                 const VkViewport* pViewports, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewports), viewportCount, &pViewports, true, true,
                          "VUID-vkCmdSetViewportWithCount-viewportCount-arraylength",
                          "VUID-vkCmdSetViewportWithCount-pViewports-parameter");
    if (pViewports != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewports_loc = loc.dot(Field::pViewports, viewportIndex);
            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                                                const VkRect2D* pScissors, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateArray(loc.dot(Field::scissorCount), loc.dot(Field::pScissors), scissorCount, &pScissors, true, true,
                          "VUID-vkCmdSetScissorWithCount-scissorCount-arraylength",
                          "VUID-vkCmdSetScissorWithCount-pScissors-parameter");
    if (pScissors != nullptr) {
        for (uint32_t scissorIndex = 0; scissorIndex < scissorCount; ++scissorIndex) {
            [[maybe_unused]] const Location pScissors_loc = loc.dot(Field::pScissors, scissorIndex);
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                                               uint32_t bindingCount, const VkBuffer* pBuffers,
                                                               const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                                               const VkDeviceSize* pStrides, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    // No xml-driven validation
    if (!skip)
        skip |= manual_PreCallValidateCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes,
                                                            pStrides, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::depthTestEnable), depthTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::depthWriteEnable), depthWriteEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRangedEnum(loc.dot(Field::depthCompareOp), vvl::Enum::VkCompareOp, depthCompareOp,
                               "VUID-vkCmdSetDepthCompareOp-depthCompareOp-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::depthBoundsTestEnable), depthBoundsTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::stencilTestEnable), stencilTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                         VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
                                                         VkCompareOp compareOp, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits, faceMask,
                          kRequiredFlags, VK_NULL_HANDLE, "VUID-vkCmdSetStencilOp-faceMask-parameter",
                          "VUID-vkCmdSetStencilOp-faceMask-requiredbitmask");
    skip |= ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, failOp, "VUID-vkCmdSetStencilOp-failOp-parameter",
                               VK_NULL_HANDLE);
    skip |= ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, passOp, "VUID-vkCmdSetStencilOp-passOp-parameter",
                               VK_NULL_HANDLE);
    skip |= ValidateRangedEnum(loc.dot(Field::depthFailOp), vvl::Enum::VkStencilOp, depthFailOp,
                               "VUID-vkCmdSetStencilOp-depthFailOp-parameter", VK_NULL_HANDLE);
    skip |= ValidateRangedEnum(loc.dot(Field::compareOp), vvl::Enum::VkCompareOp, compareOp,
                               "VUID-vkCmdSetStencilOp-compareOp-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer,
                                                                       VkBool32 rasterizerDiscardEnable,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::rasterizerDiscardEnable), rasterizerDiscardEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::depthBiasEnable), depthBiasEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer,
                                                                      VkBool32 primitiveRestartEnable,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateBool32(loc.dot(Field::primitiveRestartEnable), primitiveRestartEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceBufferMemoryRequirements(VkDevice device,
                                                                           const VkDeviceBufferMemoryRequirements* pInfo,
                                                                           VkMemoryRequirements2* pMemoryRequirements,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS, true,
                               "VUID-vkGetDeviceBufferMemoryRequirements-pInfo-parameter",
                               "VUID-VkDeviceBufferMemoryRequirements-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceBufferMemoryRequirements-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateStructType(pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
                                   true, "VUID-VkDeviceBufferMemoryRequirements-pCreateInfo-parameter",
                                   "VUID-VkBufferCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkBufferCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |= ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkBufferCreateInfo.size(),
                                        allowed_structs_VkBufferCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkBufferCreateInfo-pNext-pNext", "VUID-VkBufferCreateInfo-sType-unique",
                                        VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                                  AllVkBufferCreateFlagBits, pInfo->pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                                  "VUID-VkBufferCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                       pInfo->pCreateInfo->sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter",
                                       VK_NULL_HANDLE);
        }
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetDeviceBufferMemoryRequirements-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageMemoryRequirements(VkDevice device,
                                                                          const VkDeviceImageMemoryRequirements* pInfo,
                                                                          VkMemoryRequirements2* pMemoryRequirements,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true,
                               "VUID-vkGetDeviceImageMemoryRequirements-pInfo-parameter",
                               "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateStructType(pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
                               "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkImageCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |= ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                        allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", VK_NULL_HANDLE,
                                        true);

            skip |=
                ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits,
                              pInfo->pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType, pInfo->pCreateInfo->imageType,
                                       "VUID-VkImageCreateInfo-imageType-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pInfo->pCreateInfo->format,
                                       "VUID-VkImageCreateInfo-format-parameter", VK_NULL_HANDLE);

            // No xml-driven validation

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                  AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, VK_NULL_HANDLE,
                                  "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pInfo->pCreateInfo->tiling,
                                       "VUID-VkImageCreateInfo-tiling-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                  AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |=
                ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                   pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                       pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter",
                                       VK_NULL_HANDLE);
        }

        skip |= ValidateFlags(pInfo_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                              pInfo->planeAspect, kOptionalSingleBit, VK_NULL_HANDLE,
                              "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetDeviceImageMemoryRequirements-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageSparseMemoryRequirements(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, true,
                               "VUID-vkGetDeviceImageSparseMemoryRequirements-pInfo-parameter",
                               "VUID-VkDeviceImageMemoryRequirements-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceImageMemoryRequirements-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateStructType(pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
                               "VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkImageCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |= ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                        allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", VK_NULL_HANDLE,
                                        true);

            skip |=
                ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits,
                              pInfo->pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType, pInfo->pCreateInfo->imageType,
                                       "VUID-VkImageCreateInfo-imageType-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pInfo->pCreateInfo->format,
                                       "VUID-VkImageCreateInfo-format-parameter", VK_NULL_HANDLE);

            // No xml-driven validation

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                  AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, VK_NULL_HANDLE,
                                  "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pInfo->pCreateInfo->tiling,
                                       "VUID-VkImageCreateInfo-tiling-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                  AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |=
                ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                   pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                       pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter",
                                       VK_NULL_HANDLE);
        }

        skip |= ValidateFlags(pInfo_loc.dot(Field::planeAspect), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits,
                              pInfo->planeAspect, kOptionalSingleBit, VK_NULL_HANDLE,
                              "VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter");
    }
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pSparseMemoryRequirementCount), loc.dot(Field::pSparseMemoryRequirements), pSparseMemoryRequirementCount,
        pSparseMemoryRequirements, VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, true, false, false,
        "VUID-VkSparseImageMemoryRequirements2-sType-sType",
        "VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter",
        "VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter", kVUIDUndefined);
    if (pSparseMemoryRequirements != nullptr) {
        for (uint32_t pSparseMemoryRequirementIndex = 0; pSparseMemoryRequirementIndex < *pSparseMemoryRequirementCount;
             ++pSparseMemoryRequirementIndex) {
            [[maybe_unused]] const Location pSparseMemoryRequirements_loc =
                loc.dot(Field::pSparseMemoryRequirements, pSparseMemoryRequirementIndex);
            skip |=
                ValidateStructPnext(pSparseMemoryRequirements_loc, pSparseMemoryRequirements[pSparseMemoryRequirementIndex].pNext,
                                    0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSparseImageMemoryRequirements2-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, false);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                                             pSparseMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
                                                           const VkAllocationCallbacks* pAllocator,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice,
                                                                            uint32_t queueFamilyIndex, VkSurfaceKHR surface,
                                                                            VkBool32* pSupported,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= ValidateRequiredPointer(loc.dot(Field::pSupported), pSupported,
                                    "VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice,
                                                                                 VkSurfaceKHR surface,
                                                                                 VkSurfaceCapabilitiesKHR* pSurfaceCapabilities,
                                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurfaceCapabilities), pSurfaceCapabilities,
                                    "VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter");
    if (pSurfaceCapabilities != nullptr) {
        [[maybe_unused]] const Location pSurfaceCapabilities_loc = loc.dot(Field::pSurfaceCapabilities);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                            uint32_t* pSurfaceFormatCount,
                                                                            VkSurfaceFormatKHR* pSurfaceFormats,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |= ValidatePointerArray(loc.dot(Field::pSurfaceFormatCount), loc.dot(Field::pSurfaceFormats), pSurfaceFormatCount,
                                 &pSurfaceFormats, true, false, false,
                                 "VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormatCount-parameter", kVUIDUndefined,
                                 "VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter");
    if (pSurfaceFormats != nullptr) {
        for (uint32_t pSurfaceFormatIndex = 0; pSurfaceFormatIndex < *pSurfaceFormatCount; ++pSurfaceFormatIndex) {
            [[maybe_unused]] const Location pSurfaceFormats_loc = loc.dot(Field::pSurfaceFormats, pSurfaceFormatIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount,
                                                                         pSurfaceFormats, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice,
                                                                                 VkSurfaceKHR surface, uint32_t* pPresentModeCount,
                                                                                 VkPresentModeKHR* pPresentModes,
                                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_surface});
    skip |=
        ValidatePointerArray(loc.dot(Field::pPresentModeCount), loc.dot(Field::pPresentModes), pPresentModeCount, &pPresentModes,
                             true, false, false, "VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModeCount-parameter",
                             kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount,
                                                                              pPresentModes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true,
                               "VUID-vkCreateSwapchainKHR-pCreateInfo-parameter", "VUID-VkSwapchainCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkSwapchainCreateInfoKHR = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
            VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
            VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkSwapchainCreateInfoKHR.size(),
                                    allowed_structs_VkSwapchainCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSwapchainCreateInfoKHR-pNext-pNext", "VUID-VkSwapchainCreateInfoKHR-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSwapchainCreateFlagBitsKHR,
                              AllVkSwapchainCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkSwapchainCreateInfoKHR-flags-parameter");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::surface), pCreateInfo->surface);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageFormat), vvl::Enum::VkFormat, pCreateInfo->imageFormat,
                                   "VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageColorSpace), vvl::Enum::VkColorSpaceKHR,
                                   pCreateInfo->imageColorSpace, "VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter",
                                   VK_NULL_HANDLE);

        // No xml-driven validation

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::imageUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                              AllVkImageUsageFlagBits, pCreateInfo->imageUsage, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter",
                              "VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageSharingMode), vvl::Enum::VkSharingMode,
                                   pCreateInfo->imageSharingMode, "VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::preTransform), vvl::FlagBitmask::VkSurfaceTransformFlagBitsKHR,
                              AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->preTransform, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter",
                              "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::compositeAlpha), vvl::FlagBitmask::VkCompositeAlphaFlagBitsKHR,
                              AllVkCompositeAlphaFlagBitsKHR, pCreateInfo->compositeAlpha, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter",
                              "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::presentMode), vvl::Enum::VkPresentModeKHR, pCreateInfo->presentMode,
                                   "VUID-VkSwapchainCreateInfoKHR-presentMode-parameter", VK_NULL_HANDLE);

        skip |= ValidateBool32(pCreateInfo_loc.dot(Field::clipped), pCreateInfo->clipped);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSwapchain), pSwapchain, "VUID-vkCreateSwapchainKHR-pSwapchain-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain,
                                                               uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |=
        ValidatePointerArray(loc.dot(Field::pSwapchainImageCount), loc.dot(Field::pSwapchainImages), pSwapchainImageCount,
                             &pSwapchainImages, true, false, false, "VUID-vkGetSwapchainImagesKHR-pSwapchainImageCount-parameter",
                             kVUIDUndefined, "VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout,
                                                             VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidateRequiredPointer(loc.dot(Field::pImageIndex), pImageIndex, "VUID-vkAcquireNextImageKHR-pImageIndex-parameter");
    if (!skip)
        skip |= manual_PreCallValidateAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR* pPresentInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});
    skip |= ValidateStructType(loc.dot(Field::pPresentInfo), pPresentInfo, VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, true,
                               "VUID-vkQueuePresentKHR-pPresentInfo-parameter", "VUID-VkPresentInfoKHR-sType-sType");
    if (pPresentInfo != nullptr) {
        [[maybe_unused]] const Location pPresentInfo_loc = loc.dot(Field::pPresentInfo);
        constexpr std::array allowed_structs_VkPresentInfoKHR = {VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
                                                                 VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT,
                                                                 VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
                                                                 VK_STRUCTURE_TYPE_PRESENT_ID_KHR,
                                                                 VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
                                                                 VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
                                                                 VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT,
                                                                 VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT};

        skip |=
            ValidateStructPnext(pPresentInfo_loc, pPresentInfo->pNext, allowed_structs_VkPresentInfoKHR.size(),
                                allowed_structs_VkPresentInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPresentInfoKHR-pNext-pNext", "VUID-VkPresentInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateArray(pPresentInfo_loc.dot(Field::waitSemaphoreCount), pPresentInfo_loc.dot(Field::pWaitSemaphores),
                              pPresentInfo->waitSemaphoreCount, &pPresentInfo->pWaitSemaphores, false, true, kVUIDUndefined,
                              "VUID-VkPresentInfoKHR-pWaitSemaphores-parameter");

        skip |= ValidateHandleArray(pPresentInfo_loc.dot(Field::swapchainCount), pPresentInfo_loc.dot(Field::pSwapchains),
                                    pPresentInfo->swapchainCount, pPresentInfo->pSwapchains, true, true,
                                    "VUID-VkPresentInfoKHR-swapchainCount-arraylength");

        skip |= ValidateArray(pPresentInfo_loc.dot(Field::swapchainCount), pPresentInfo_loc.dot(Field::pImageIndices),
                              pPresentInfo->swapchainCount, &pPresentInfo->pImageIndices, true, true,
                              "VUID-VkPresentInfoKHR-swapchainCount-arraylength", "VUID-VkPresentInfoKHR-pImageIndices-parameter");

        skip |= ValidateArray(pPresentInfo_loc.dot(Field::swapchainCount), pPresentInfo_loc.dot(Field::pResults),
                              pPresentInfo->swapchainCount, &pPresentInfo->pResults, true, false,
                              "VUID-VkPresentInfoKHR-swapchainCount-arraylength", "VUID-VkPresentInfoKHR-pResults-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateQueuePresentKHR(queue, pPresentInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});
    skip |= ValidateStructType(loc.dot(Field::pDeviceGroupPresentCapabilities), pDeviceGroupPresentCapabilities,
                               VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR, true,
                               "VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter",
                               "VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType");
    if (pDeviceGroupPresentCapabilities != nullptr) {
        [[maybe_unused]] const Location pDeviceGroupPresentCapabilities_loc = loc.dot(Field::pDeviceGroupPresentCapabilities);
        skip |= ValidateStructPnext(pDeviceGroupPresentCapabilities_loc, pDeviceGroupPresentCapabilities->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface,
                                                                              VkDeviceGroupPresentModeFlagsKHR* pModes,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});
    skip |= ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= ValidateRequiredPointer(loc.dot(Field::pModes), pModes, "VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice,
                                                                               VkSurfaceKHR surface, uint32_t* pRectCount,
                                                                               VkRect2D* pRects,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |= ValidatePointerArray(loc.dot(Field::pRectCount), loc.dot(Field::pRects), pRectCount, &pRects, true, false, false,
                                 "VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRectCount-parameter", kVUIDUndefined,
                                 "VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo,
                                                              uint32_t* pImageIndex, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});
    skip |= ValidateStructType(loc.dot(Field::pAcquireInfo), pAcquireInfo, VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR, true,
                               "VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter", "VUID-VkAcquireNextImageInfoKHR-sType-sType");
    if (pAcquireInfo != nullptr) {
        [[maybe_unused]] const Location pAcquireInfo_loc = loc.dot(Field::pAcquireInfo);
        skip |= ValidateStructPnext(pAcquireInfo_loc, pAcquireInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAcquireNextImageInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pAcquireInfo_loc.dot(Field::swapchain), pAcquireInfo->swapchain);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pImageIndex), pImageIndex, "VUID-vkAcquireNextImage2KHR-pImageIndex-parameter");
    if (!skip) skip |= manual_PreCallValidateAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice,
                                                                               uint32_t* pPropertyCount,
                                                                               VkDisplayPropertiesKHR* pProperties,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties, true,
                                 false, false, "VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pPropertyCount-parameter",
                                 kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice,
                                                                                    uint32_t* pPropertyCount,
                                                                                    VkDisplayPlanePropertiesKHR* pProperties,
                                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties, true,
                                 false, false, "VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pPropertyCount-parameter",
                                 kVUIDUndefined, "VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex,
                                                                             uint32_t* pDisplayCount, VkDisplayKHR* pDisplays,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidatePointerArray(loc.dot(Field::pDisplayCount), loc.dot(Field::pDisplays), pDisplayCount, &pDisplays, true, false,
                                 false, "VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplayCount-parameter", kVUIDUndefined,
                                 "VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                                     uint32_t* pPropertyCount,
                                                                     VkDisplayModePropertiesKHR* pProperties,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= ValidatePointerArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, &pProperties, true,
                                 false, false, "VUID-vkGetDisplayModePropertiesKHR-pPropertyCount-parameter", kVUIDUndefined,
                                 "VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter");
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                              const VkDisplayModeCreateInfoKHR* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR, true,
                               "VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter", "VUID-VkDisplayModeCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayModeCreateInfoKHR-pNext-pNext", kVUIDUndefined, physicalDevice, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask");

        // No xml-driven validation
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pMode), pMode, "VUID-vkCreateDisplayModeKHR-pMode-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode,
                                                                        uint32_t planeIndex,
                                                                        VkDisplayPlaneCapabilitiesKHR* pCapabilities,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidateRequiredHandle(loc.dot(Field::mode), mode);
    skip |= ValidateRequiredPointer(loc.dot(Field::pCapabilities), pCapabilities,
                                    "VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter");
    if (pCapabilities != nullptr) {
        [[maybe_unused]] const Location pCapabilities_loc = loc.dot(Field::pCapabilities);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDisplayPlaneSurfaceKHR(VkInstance instance,
                                                                      const VkDisplaySurfaceCreateInfoKHR* pCreateInfo,
                                                                      const VkAllocationCallbacks* pAllocator,
                                                                      VkSurfaceKHR* pSurface, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_display)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR, true,
                               "VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter",
                               "VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::displayMode), pCreateInfo->displayMode);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::transform), vvl::FlagBitmask::VkSurfaceTransformFlagBitsKHR,
                              AllVkSurfaceTransformFlagBitsKHR, pCreateInfo->transform, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter",
                              "VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::alphaMode), vvl::FlagBitmask::VkDisplayPlaneAlphaFlagBitsKHR,
                              AllVkDisplayPlaneAlphaFlagBitsKHR, pCreateInfo->alphaMode, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter",
                              "VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter");

        // No xml-driven validation
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount,
                                                                   const VkSwapchainCreateInfoKHR* pCreateInfos,
                                                                   const VkAllocationCallbacks* pAllocator,
                                                                   VkSwapchainKHR* pSwapchains,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_display_swapchain))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_display_swapchain});
    skip |= ValidateStructTypeArray(
        loc.dot(Field::swapchainCount), loc.dot(Field::pCreateInfos), swapchainCount, pCreateInfos,
        VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, true, true, "VUID-VkSwapchainCreateInfoKHR-sType-sType",
        "VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter", "VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, swapchainIndex);
            constexpr std::array allowed_structs_VkSwapchainCreateInfoKHR = {
                VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
                VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
                VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT};

            skip |= ValidateStructPnext(
                pCreateInfos_loc, pCreateInfos[swapchainIndex].pNext, allowed_structs_VkSwapchainCreateInfoKHR.size(),
                allowed_structs_VkSwapchainCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                "VUID-VkSwapchainCreateInfoKHR-pNext-pNext", "VUID-VkSwapchainCreateInfoKHR-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkSwapchainCreateFlagBitsKHR,
                                  AllVkSwapchainCreateFlagBitsKHR, pCreateInfos[swapchainIndex].flags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkSwapchainCreateInfoKHR-flags-parameter");

            skip |= ValidateRequiredHandle(pCreateInfos_loc.dot(Field::surface), pCreateInfos[swapchainIndex].surface);

            skip |= ValidateRangedEnum(pCreateInfos_loc.dot(Field::imageFormat), vvl::Enum::VkFormat,
                                       pCreateInfos[swapchainIndex].imageFormat,
                                       "VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfos_loc.dot(Field::imageColorSpace), vvl::Enum::VkColorSpaceKHR,
                                       pCreateInfos[swapchainIndex].imageColorSpace,
                                       "VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter", VK_NULL_HANDLE);

            // No xml-driven validation

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::imageUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                  AllVkImageUsageFlagBits, pCreateInfos[swapchainIndex].imageUsage, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter",
                                  "VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask");

            skip |= ValidateRangedEnum(pCreateInfos_loc.dot(Field::imageSharingMode), vvl::Enum::VkSharingMode,
                                       pCreateInfos[swapchainIndex].imageSharingMode,
                                       "VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::preTransform), vvl::FlagBitmask::VkSurfaceTransformFlagBitsKHR,
                                  AllVkSurfaceTransformFlagBitsKHR, pCreateInfos[swapchainIndex].preTransform, kRequiredSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter",
                                  "VUID-VkSwapchainCreateInfoKHR-preTransform-parameter");

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::compositeAlpha), vvl::FlagBitmask::VkCompositeAlphaFlagBitsKHR,
                                  AllVkCompositeAlphaFlagBitsKHR, pCreateInfos[swapchainIndex].compositeAlpha, kRequiredSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter",
                                  "VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter");

            skip |= ValidateRangedEnum(pCreateInfos_loc.dot(Field::presentMode), vvl::Enum::VkPresentModeKHR,
                                       pCreateInfos[swapchainIndex].presentMode,
                                       "VUID-VkSwapchainCreateInfoKHR-presentMode-parameter", VK_NULL_HANDLE);

            skip |= ValidateBool32(pCreateInfos_loc.dot(Field::clipped), pCreateInfos[swapchainIndex].clipped);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::swapchainCount), loc.dot(Field::pSwapchains), swapchainCount, &pSwapchains, true, true,
                          "VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength",
                          "VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains,
                                                                error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_XLIB_KHR
bool StatelessValidation::PreCallValidateCreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_xlib_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xlib_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, true,
                               "VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter", "VUID-VkXlibSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateXlibSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                                     uint32_t queueFamilyIndex, Display* dpy,
                                                                                     VisualID visualID,
                                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_xlib_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xlib_surface});
    skip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, "VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
bool StatelessValidation::PreCallValidateCreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo,
                                                             const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_xcb_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xcb_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, true,
                               "VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter", "VUID-VkXcbSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateXcbSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                                    uint32_t queueFamilyIndex,
                                                                                    xcb_connection_t* connection,
                                                                                    xcb_visualid_t visual_id,
                                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_xcb_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xcb_surface});
    skip |= ValidateRequiredPointer(loc.dot(Field::connection), connection,
                                    "VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
bool StatelessValidation::PreCallValidateCreateWaylandSurfaceKHR(VkInstance instance,
                                                                 const VkWaylandSurfaceCreateInfoKHR* pCreateInfo,
                                                                 const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_wayland_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_wayland_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR, true,
                               "VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter",
                               "VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                                        uint32_t queueFamilyIndex,
                                                                                        struct wl_display* display,
                                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_wayland_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_wayland_surface});
    skip |= ValidateRequiredPointer(loc.dot(Field::display), display,
                                    "VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool StatelessValidation::PreCallValidateCreateAndroidSurfaceKHR(VkInstance instance,
                                                                 const VkAndroidSurfaceCreateInfoKHR* pCreateInfo,
                                                                 const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_android_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_android_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR, true,
                               "VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter",
                               "VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateCreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo,
                                                               const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_win32_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_win32_surface});
    skip |=
        ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR, true,
                           "VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter", "VUID-VkWin32SurfaceCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateWin32SurfaceKHR-pSurface-parameter");
    if (!skip) skip |= manual_PreCallValidateCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                                      uint32_t queueFamilyIndex,
                                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_win32_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_win32_surface});
    // No xml-driven validation
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateGetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice,
                                                                               const VkVideoProfileInfoKHR* pVideoProfile,
                                                                               VkVideoCapabilitiesKHR* pCapabilities,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pVideoProfile), pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true,
                               "VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-parameter",
                               "VUID-VkVideoProfileInfoKHR-sType-sType");
    if (pVideoProfile != nullptr) {
        [[maybe_unused]] const Location pVideoProfile_loc = loc.dot(Field::pVideoProfile);
        constexpr std::array allowed_structs_VkVideoProfileInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR};

        skip |= ValidateStructPnext(pVideoProfile_loc, pVideoProfile->pNext, allowed_structs_VkVideoProfileInfoKHR.size(),
                                    allowed_structs_VkVideoProfileInfoKHR.data(), GeneratedVulkanHeaderVersion, kVUIDUndefined,
                                    kVUIDUndefined, physicalDevice, true);

        skip |= ValidateFlags(pVideoProfile_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                              AllVkVideoCodecOperationFlagBitsKHR, pVideoProfile->videoCodecOperation, kRequiredSingleBit,
                              VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                              "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

        skip |=
            ValidateFlags(pVideoProfile_loc.dot(Field::chromaSubsampling), vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR,
                          AllVkVideoChromaSubsamplingFlagBitsKHR, pVideoProfile->chromaSubsampling, kRequiredFlags, VK_NULL_HANDLE,
                          "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                          "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

        skip |= ValidateFlags(pVideoProfile_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                              AllVkVideoComponentBitDepthFlagBitsKHR, pVideoProfile->lumaBitDepth, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                              "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

        skip |= ValidateFlags(pVideoProfile_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                              AllVkVideoComponentBitDepthFlagBitsKHR, pVideoProfile->chromaBitDepth, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pCapabilities), pCapabilities, VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR, true,
                               "VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pCapabilities-parameter",
                               "VUID-VkVideoCapabilitiesKHR-sType-sType");
    if (pCapabilities != nullptr) {
        [[maybe_unused]] const Location pCapabilities_loc = loc.dot(Field::pCapabilities);
        constexpr std::array allowed_structs_VkVideoCapabilitiesKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,      VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR};

        skip |= ValidateStructPnext(pCapabilities_loc, pCapabilities->pNext, allowed_structs_VkVideoCapabilitiesKHR.size(),
                                    allowed_structs_VkVideoCapabilitiesKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoCapabilitiesKHR-pNext-pNext", "VUID-VkVideoCapabilitiesKHR-sType-unique",
                                    physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceVideoFormatPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo,
    uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pVideoFormatInfo), pVideoFormatInfo,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR, true,
                               "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatInfo-parameter",
                               "VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-sType");
    if (pVideoFormatInfo != nullptr) {
        [[maybe_unused]] const Location pVideoFormatInfo_loc = loc.dot(Field::pVideoFormatInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR = {VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= ValidateStructPnext(pVideoFormatInfo_loc, pVideoFormatInfo->pNext,
                                    allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR.size(),
                                    allowed_structs_VkPhysicalDeviceVideoFormatInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceVideoFormatInfoKHR-pNext-pNext",
                                    "VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-unique", physicalDevice, true);

        skip |= ValidateFlags(pVideoFormatInfo_loc.dot(Field::imageUsage), vvl::FlagBitmask::VkImageUsageFlagBits,
                              AllVkImageUsageFlagBits, pVideoFormatInfo->imageUsage, kRequiredFlags, physicalDevice,
                              "VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-parameter",
                              "VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-requiredbitmask");
    }
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pVideoFormatPropertyCount), loc.dot(Field::pVideoFormatProperties), pVideoFormatPropertyCount,
        pVideoFormatProperties, VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR, true, false, false,
        "VUID-VkVideoFormatPropertiesKHR-sType-sType",
        "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatProperties-parameter",
        "VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatPropertyCount-parameter", kVUIDUndefined);
    if (pVideoFormatProperties != nullptr) {
        for (uint32_t pVideoFormatPropertyIndex = 0; pVideoFormatPropertyIndex < *pVideoFormatPropertyCount;
             ++pVideoFormatPropertyIndex) {
            [[maybe_unused]] const Location pVideoFormatProperties_loc =
                loc.dot(Field::pVideoFormatProperties, pVideoFormatPropertyIndex);
            skip |= ValidateStructPnext(pVideoFormatProperties_loc, pVideoFormatProperties[pVideoFormatPropertyIndex].pNext, 0,
                                        nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoFormatPropertiesKHR-pNext-pNext",
                                        kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR* pCreateInfo,
                                                               const VkAllocationCallbacks* pAllocator,
                                                               VkVideoSessionKHR* pVideoSession,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |=
        ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR, true,
                           "VUID-vkCreateVideoSessionKHR-pCreateInfo-parameter", "VUID-VkVideoSessionCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkVideoSessionCreateInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkVideoSessionCreateInfoKHR.size(),
                                    allowed_structs_VkVideoSessionCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoSessionCreateInfoKHR-pNext-pNext", "VUID-VkVideoSessionCreateInfoKHR-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoSessionCreateFlagBitsKHR,
                              AllVkVideoSessionCreateFlagBitsKHR, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkVideoSessionCreateInfoKHR-flags-parameter");

        skip |= ValidateStructType(
            pCreateInfo_loc.dot(Field::pVideoProfile), pCreateInfo->pVideoProfile, VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true,
            "VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-parameter", "VUID-VkVideoProfileInfoKHR-sType-sType");

        if (pCreateInfo->pVideoProfile != nullptr) {
            [[maybe_unused]] const Location pVideoProfile_loc = pCreateInfo_loc.dot(Field::pVideoProfile);
            constexpr std::array allowed_structs_VkVideoProfileInfoKHR = {
                VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR};

            skip |= ValidateStructPnext(pVideoProfile_loc, pCreateInfo->pVideoProfile->pNext,
                                        allowed_structs_VkVideoProfileInfoKHR.size(), allowed_structs_VkVideoProfileInfoKHR.data(),
                                        GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |=
                ValidateFlags(pVideoProfile_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                              AllVkVideoCodecOperationFlagBitsKHR, pCreateInfo->pVideoProfile->videoCodecOperation,
                              kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                              "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

            skip |= ValidateFlags(pVideoProfile_loc.dot(Field::chromaSubsampling),
                                  vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR, AllVkVideoChromaSubsamplingFlagBitsKHR,
                                  pCreateInfo->pVideoProfile->chromaSubsampling, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

            skip |= ValidateFlags(pVideoProfile_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                  AllVkVideoComponentBitDepthFlagBitsKHR, pCreateInfo->pVideoProfile->lumaBitDepth, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                                  "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

            skip |=
                ValidateFlags(pVideoProfile_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                              AllVkVideoComponentBitDepthFlagBitsKHR, pCreateInfo->pVideoProfile->chromaBitDepth, kOptionalFlags,
                              VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
        }

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::pictureFormat), vvl::Enum::VkFormat, pCreateInfo->pictureFormat,
                                   "VUID-VkVideoSessionCreateInfoKHR-pictureFormat-parameter", VK_NULL_HANDLE);

        // No xml-driven validation

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::referencePictureFormat), vvl::Enum::VkFormat,
                                   pCreateInfo->referencePictureFormat,
                                   "VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pStdHeaderVersion), pCreateInfo->pStdHeaderVersion,
                                        "VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-parameter");

        if (pCreateInfo->pStdHeaderVersion != nullptr) {
            [[maybe_unused]] const Location pStdHeaderVersion_loc = pCreateInfo_loc.dot(Field::pStdHeaderVersion);
            // No xml-driven validation
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pVideoSession), pVideoSession,
                                    "VUID-vkCreateVideoSessionKHR-pVideoSession-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                                                const VkAllocationCallbacks* pAllocator,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetVideoSessionMemoryRequirementsKHR(
    VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount,
    VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateRequiredHandle(loc.dot(Field::videoSession), videoSession);
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pMemoryRequirementsCount), loc.dot(Field::pMemoryRequirements), pMemoryRequirementsCount,
        pMemoryRequirements, VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR, true, false, false,
        "VUID-VkVideoSessionMemoryRequirementsKHR-sType-sType",
        "VUID-vkGetVideoSessionMemoryRequirementsKHR-pMemoryRequirements-parameter",
        "VUID-vkGetVideoSessionMemoryRequirementsKHR-pMemoryRequirementsCount-parameter", kVUIDUndefined);
    if (pMemoryRequirements != nullptr) {
        for (uint32_t pMemoryRequirementsIndex = 0; pMemoryRequirementsIndex < *pMemoryRequirementsCount;
             ++pMemoryRequirementsIndex) {
            [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements, pMemoryRequirementsIndex);
            skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements[pMemoryRequirementsIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkVideoSessionMemoryRequirementsKHR-pNext-pNext",
                                        kVUIDUndefined, VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                                                   uint32_t bindSessionMemoryInfoCount,
                                                                   const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateRequiredHandle(loc.dot(Field::videoSession), videoSession);
    skip |= ValidateStructTypeArray(
        loc.dot(Field::bindSessionMemoryInfoCount), loc.dot(Field::pBindSessionMemoryInfos), bindSessionMemoryInfoCount,
        pBindSessionMemoryInfos, VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR, true, true,
        "VUID-VkBindVideoSessionMemoryInfoKHR-sType-sType", "VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-parameter",
        "VUID-vkBindVideoSessionMemoryKHR-bindSessionMemoryInfoCount-arraylength");
    if (pBindSessionMemoryInfos != nullptr) {
        for (uint32_t bindSessionMemoryInfoIndex = 0; bindSessionMemoryInfoIndex < bindSessionMemoryInfoCount;
             ++bindSessionMemoryInfoIndex) {
            [[maybe_unused]] const Location pBindSessionMemoryInfos_loc =
                loc.dot(Field::pBindSessionMemoryInfos, bindSessionMemoryInfoIndex);
            skip |= ValidateStructPnext(pBindSessionMemoryInfos_loc, pBindSessionMemoryInfos[bindSessionMemoryInfoIndex].pNext, 0,
                                        nullptr, GeneratedVulkanHeaderVersion, "VUID-VkBindVideoSessionMemoryInfoKHR-pNext-pNext",
                                        kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pBindSessionMemoryInfos_loc.dot(Field::memory),
                                           pBindSessionMemoryInfos[bindSessionMemoryInfoIndex].memory);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateVideoSessionParametersKHR(VkDevice device,
                                                                         const VkVideoSessionParametersCreateInfoKHR* pCreateInfo,
                                                                         const VkAllocationCallbacks* pAllocator,
                                                                         VkVideoSessionParametersKHR* pVideoSessionParameters,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
                               true, "VUID-vkCreateVideoSessionParametersKHR-pCreateInfo-parameter",
                               "VUID-VkVideoSessionParametersCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkVideoSessionParametersCreateInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkVideoSessionParametersCreateInfoKHR.size(),
                                allowed_structs_VkVideoSessionParametersCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkVideoSessionParametersCreateInfoKHR-pNext-pNext",
                                "VUID-VkVideoSessionParametersCreateInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkVideoSessionParametersCreateInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::videoSession), pCreateInfo->videoSession);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pVideoSessionParameters), pVideoSessionParameters,
                                    "VUID-vkCreateVideoSessionParametersKHR-pVideoSessionParameters-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateVideoSessionParametersKHR(VkDevice device,
                                                                         VkVideoSessionParametersKHR videoSessionParameters,
                                                                         const VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateRequiredHandle(loc.dot(Field::videoSessionParameters), videoSessionParameters);
    skip |= ValidateStructType(loc.dot(Field::pUpdateInfo), pUpdateInfo, VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
                               true, "VUID-vkUpdateVideoSessionParametersKHR-pUpdateInfo-parameter",
                               "VUID-VkVideoSessionParametersUpdateInfoKHR-sType-sType");
    if (pUpdateInfo != nullptr) {
        [[maybe_unused]] const Location pUpdateInfo_loc = loc.dot(Field::pUpdateInfo);
        constexpr std::array allowed_structs_VkVideoSessionParametersUpdateInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR};

        skip |=
            ValidateStructPnext(pUpdateInfo_loc, pUpdateInfo->pNext, allowed_structs_VkVideoSessionParametersUpdateInfoKHR.size(),
                                allowed_structs_VkVideoSessionParametersUpdateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkVideoSessionParametersUpdateInfoKHR-pNext-pNext",
                                "VUID-VkVideoSessionParametersUpdateInfoKHR-sType-unique", VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyVideoSessionParametersKHR(VkDevice device,
                                                                          VkVideoSessionParametersKHR videoSessionParameters,
                                                                          const VkAllocationCallbacks* pAllocator,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer,
                                                                const VkVideoBeginCodingInfoKHR* pBeginInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateStructType(loc.dot(Field::pBeginInfo), pBeginInfo, VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR, true,
                               "VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-parameter", "VUID-VkVideoBeginCodingInfoKHR-sType-sType");
    if (pBeginInfo != nullptr) {
        [[maybe_unused]] const Location pBeginInfo_loc = loc.dot(Field::pBeginInfo);
        constexpr std::array allowed_structs_VkVideoBeginCodingInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR};

        skip |= ValidateStructPnext(pBeginInfo_loc, pBeginInfo->pNext, allowed_structs_VkVideoBeginCodingInfoKHR.size(),
                                    allowed_structs_VkVideoBeginCodingInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoBeginCodingInfoKHR-pNext-pNext", "VUID-VkVideoBeginCodingInfoKHR-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pBeginInfo_loc.dot(Field::flags), pBeginInfo->flags,
                                      "VUID-VkVideoBeginCodingInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(pBeginInfo_loc.dot(Field::videoSession), pBeginInfo->videoSession);

        skip |= ValidateStructTypeArray(pBeginInfo_loc.dot(Field::referenceSlotCount), pBeginInfo_loc.dot(Field::pReferenceSlots),
                                        pBeginInfo->referenceSlotCount, pBeginInfo->pReferenceSlots,
                                        VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, true,
                                        "VUID-VkVideoReferenceSlotInfoKHR-sType-sType",
                                        "VUID-VkVideoBeginCodingInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pBeginInfo->pReferenceSlots != nullptr) {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pBeginInfo->referenceSlotCount; ++referenceSlotIndex) {
                [[maybe_unused]] const Location pReferenceSlots_loc =
                    pBeginInfo_loc.dot(Field::pReferenceSlots, referenceSlotIndex);
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

                skip |= ValidateStructPnext(pReferenceSlots_loc, pBeginInfo->pReferenceSlots[referenceSlotIndex].pNext,
                                            allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                            allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                            "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateStructType(pReferenceSlots_loc.dot(Field::pPictureResource),
                                           pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource,
                                           VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                                           "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter",
                                           "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr) {
                    [[maybe_unused]] const Location pPictureResource_loc = pReferenceSlots_loc.dot(Field::pPictureResource);
                    skip |= ValidateStructPnext(pPictureResource_loc,
                                                pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |=
                        ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                               pBeginInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndVideoCodingKHR(VkCommandBuffer commandBuffer,
                                                              const VkVideoEndCodingInfoKHR* pEndCodingInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateStructType(loc.dot(Field::pEndCodingInfo), pEndCodingInfo, VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR, true,
                               "VUID-vkCmdEndVideoCodingKHR-pEndCodingInfo-parameter", "VUID-VkVideoEndCodingInfoKHR-sType-sType");
    if (pEndCodingInfo != nullptr) {
        [[maybe_unused]] const Location pEndCodingInfo_loc = loc.dot(Field::pEndCodingInfo);
        skip |= ValidateStructPnext(pEndCodingInfo_loc, pEndCodingInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoEndCodingInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pEndCodingInfo_loc.dot(Field::flags), pEndCodingInfo->flags,
                                      "VUID-VkVideoEndCodingInfoKHR-flags-zerobitmask");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdControlVideoCodingKHR(VkCommandBuffer commandBuffer,
                                                                  const VkVideoCodingControlInfoKHR* pCodingControlInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_queue});
    skip |= ValidateStructType(
        loc.dot(Field::pCodingControlInfo), pCodingControlInfo, VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR, true,
        "VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-parameter", "VUID-VkVideoCodingControlInfoKHR-sType-sType");
    if (pCodingControlInfo != nullptr) {
        [[maybe_unused]] const Location pCodingControlInfo_loc = loc.dot(Field::pCodingControlInfo);
        constexpr std::array allowed_structs_VkVideoCodingControlInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR};

        skip |= ValidateStructPnext(
            pCodingControlInfo_loc, pCodingControlInfo->pNext, allowed_structs_VkVideoCodingControlInfoKHR.size(),
            allowed_structs_VkVideoCodingControlInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkVideoCodingControlInfoKHR-pNext-pNext", "VUID-VkVideoCodingControlInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCodingControlInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkVideoCodingControlFlagBitsKHR,
                              AllVkVideoCodingControlFlagBitsKHR, pCodingControlInfo->flags, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkVideoCodingControlInfoKHR-flags-parameter",
                              "VUID-VkVideoCodingControlInfoKHR-flags-requiredbitmask");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR* pDecodeInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_decode_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_decode_queue});
    skip |= ValidateStructType(loc.dot(Field::pDecodeInfo), pDecodeInfo, VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR, true,
                               "VUID-vkCmdDecodeVideoKHR-pDecodeInfo-parameter", "VUID-VkVideoDecodeInfoKHR-sType-sType");
    if (pDecodeInfo != nullptr) {
        [[maybe_unused]] const Location pDecodeInfo_loc = loc.dot(Field::pDecodeInfo);
        constexpr std::array allowed_structs_VkVideoDecodeInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR};

        skip |= ValidateStructPnext(pDecodeInfo_loc, pDecodeInfo->pNext, allowed_structs_VkVideoDecodeInfoKHR.size(),
                                    allowed_structs_VkVideoDecodeInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoDecodeInfoKHR-pNext-pNext", "VUID-VkVideoDecodeInfoKHR-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pDecodeInfo_loc.dot(Field::flags), pDecodeInfo->flags,
                                      "VUID-VkVideoDecodeInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(pDecodeInfo_loc.dot(Field::srcBuffer), pDecodeInfo->srcBuffer);

        skip |= ValidateStructType(pDecodeInfo_loc.dot(Field::dstPictureResource), &(pDecodeInfo->dstPictureResource),
                                   VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, kVUIDUndefined,
                                   "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

        skip |=
            ValidateStructPnext(pDecodeInfo_loc, pDecodeInfo->dstPictureResource.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        // No xml-driven validation

        // No xml-driven validation

        skip |=
            ValidateRequiredHandle(pDecodeInfo_loc.dot(Field::imageViewBinding), pDecodeInfo->dstPictureResource.imageViewBinding);

        skip |= ValidateStructType(pDecodeInfo_loc.dot(Field::pSetupReferenceSlot), pDecodeInfo->pSetupReferenceSlot,
                                   VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false,
                                   "VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-parameter",
                                   "VUID-VkVideoReferenceSlotInfoKHR-sType-sType");

        if (pDecodeInfo->pSetupReferenceSlot != nullptr) {
            [[maybe_unused]] const Location pSetupReferenceSlot_loc = pDecodeInfo_loc.dot(Field::pSetupReferenceSlot);
            constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

            skip |= ValidateStructPnext(pSetupReferenceSlot_loc, pDecodeInfo->pSetupReferenceSlot->pNext,
                                        allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                        allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                        "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructType(
                pSetupReferenceSlot_loc.dot(Field::pPictureResource), pDecodeInfo->pSetupReferenceSlot->pPictureResource,
                VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

            if (pDecodeInfo->pSetupReferenceSlot->pPictureResource != nullptr) {
                [[maybe_unused]] const Location pPictureResource_loc = pSetupReferenceSlot_loc.dot(Field::pPictureResource);
                skip |= ValidateStructPnext(pPictureResource_loc, pDecodeInfo->pSetupReferenceSlot->pPictureResource->pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                // No xml-driven validation

                // No xml-driven validation

                skip |= ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                               pDecodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding);
            }
        }

        skip |= ValidateStructTypeArray(pDecodeInfo_loc.dot(Field::referenceSlotCount), pDecodeInfo_loc.dot(Field::pReferenceSlots),
                                        pDecodeInfo->referenceSlotCount, pDecodeInfo->pReferenceSlots,
                                        VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, true,
                                        "VUID-VkVideoReferenceSlotInfoKHR-sType-sType",
                                        "VUID-VkVideoDecodeInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pDecodeInfo->pReferenceSlots != nullptr) {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pDecodeInfo->referenceSlotCount; ++referenceSlotIndex) {
                [[maybe_unused]] const Location pReferenceSlots_loc =
                    pDecodeInfo_loc.dot(Field::pReferenceSlots, referenceSlotIndex);
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

                skip |= ValidateStructPnext(pReferenceSlots_loc, pDecodeInfo->pReferenceSlots[referenceSlotIndex].pNext,
                                            allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                            allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                            "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateStructType(pReferenceSlots_loc.dot(Field::pPictureResource),
                                           pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource,
                                           VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                                           "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter",
                                           "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr) {
                    [[maybe_unused]] const Location pPictureResource_loc = pReferenceSlots_loc.dot(Field::pPictureResource);
                    skip |= ValidateStructPnext(
                        pPictureResource_loc, pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined,
                        VK_NULL_HANDLE, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |=
                        ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                               pDecodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo* pRenderingInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering});
    skip |= PreCallValidateCmdBeginRendering(commandBuffer, pRenderingInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderingKHR(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering});
    skip |= PreCallValidateCmdEndRendering(commandBuffer, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice,
                                                                       VkPhysicalDeviceFeatures2* pFeatures,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceFeatures2(physicalDevice, pFeatures, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                         VkPhysicalDeviceProperties2* pProperties,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceProperties2(physicalDevice, pProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                               VkFormatProperties2* pFormatProperties,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
    VkImageFormatProperties2* pImageFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |=
        PreCallValidateGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount,
                                                                   pQueueFamilyProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                               VkPhysicalDeviceMemoryProperties2* pMemoryProperties,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount,
    VkSparseImageFormatProperties2* pProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_physical_device_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_physical_device_properties2});
    skip |= PreCallValidateGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties,
                                                                         error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex,
                                                                             uint32_t localDeviceIndex, uint32_t remoteDeviceIndex,
                                                                             VkPeerMemoryFeatureFlags* pPeerMemoryFeatures,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_device_group))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group});
    skip |= PreCallValidateGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex,
                                                            pPeerMemoryFeatures, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_device_group))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group});
    skip |= PreCallValidateCmdSetDeviceMask(commandBuffer, deviceMask, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                                                            uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
                                                            uint32_t groupCountZ, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_device_group))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group});
    skip |= PreCallValidateCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ,
                                           error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool,
                                                            VkCommandPoolTrimFlags flags, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance1))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance1});
    skip |= PreCallValidateTrimCommandPool(device, commandPool, flags, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_device_group_creation))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_device_group_creation});
    skip |= PreCallValidateEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties,
                                                         error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo,
    VkExternalBufferProperties* pExternalBufferProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_external_memory_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_capabilities});
    skip |= PreCallValidateGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties,
                                                                     error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetMemoryWin32HandleKHR(VkDevice device,
                                                                 const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo,
                                                                 HANDLE* pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_win32});
    skip |= ValidateStructType(
        loc.dot(Field::pGetWin32HandleInfo), pGetWin32HandleInfo, VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR, true,
        "VUID-vkGetMemoryWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkMemoryGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetWin32HandleInfo_loc = loc.dot(Field::pGetWin32HandleInfo);
        skip |= ValidateStructPnext(pGetWin32HandleInfo_loc, pGetWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryGetWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetWin32HandleInfo_loc.dot(Field::memory), pGetWin32HandleInfo->memory);

        skip |= ValidateFlags(pGetWin32HandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                              AllVkExternalMemoryHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit,
                              VK_NULL_HANDLE, "VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter",
                              "VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryWin32HandlePropertiesKHR(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_win32});
    skip |= ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                          AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter",
                          "VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter");
    skip |= ValidateStructType(loc.dot(Field::pMemoryWin32HandleProperties), pMemoryWin32HandleProperties,
                               VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR, true,
                               "VUID-vkGetMemoryWin32HandlePropertiesKHR-pMemoryWin32HandleProperties-parameter",
                               "VUID-VkMemoryWin32HandlePropertiesKHR-sType-sType");
    if (pMemoryWin32HandleProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryWin32HandleProperties_loc = loc.dot(Field::pMemoryWin32HandleProperties);
        skip |= ValidateStructPnext(pMemoryWin32HandleProperties_loc, pMemoryWin32HandleProperties->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryWin32HandlePropertiesKHR-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties,
                                                                        error_obj);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_fd});
    skip |= ValidateStructType(loc.dot(Field::pGetFdInfo), pGetFdInfo, VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, true,
                               "VUID-vkGetMemoryFdKHR-pGetFdInfo-parameter", "VUID-VkMemoryGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr) {
        [[maybe_unused]] const Location pGetFdInfo_loc = loc.dot(Field::pGetFdInfo);
        skip |= ValidateStructPnext(pGetFdInfo_loc, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryGetFdInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetFdInfo_loc.dot(Field::memory), pGetFdInfo->memory);

        skip |= ValidateFlags(pGetFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                              AllVkExternalMemoryHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkMemoryGetFdInfoKHR-handleType-parameter", "VUID-VkMemoryGetFdInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFd), pFd, "VUID-vkGetMemoryFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetMemoryFdKHR(device, pGetFdInfo, pFd, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType,
                                                                  int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_memory_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_memory_fd});
    skip |= ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                          AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter",
                          "VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter");
    skip |= ValidateStructType(loc.dot(Field::pMemoryFdProperties), pMemoryFdProperties, VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
                               true, "VUID-vkGetMemoryFdPropertiesKHR-pMemoryFdProperties-parameter",
                               "VUID-VkMemoryFdPropertiesKHR-sType-sType");
    if (pMemoryFdProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryFdProperties_loc = loc.dot(Field::pMemoryFdProperties);
        skip |= ValidateStructPnext(pMemoryFdProperties_loc, pMemoryFdProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryFdPropertiesKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties* pExternalSemaphoreProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_external_semaphore_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_capabilities});
    skip |= PreCallValidateGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo,
                                                                        pExternalSemaphoreProperties, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateImportSemaphoreWin32HandleKHR(
    VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_win32});
    skip |= ValidateStructType(loc.dot(Field::pImportSemaphoreWin32HandleInfo), pImportSemaphoreWin32HandleInfo,
                               VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR, true,
                               "VUID-vkImportSemaphoreWin32HandleKHR-pImportSemaphoreWin32HandleInfo-parameter",
                               "VUID-VkImportSemaphoreWin32HandleInfoKHR-sType-sType");
    if (pImportSemaphoreWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pImportSemaphoreWin32HandleInfo_loc = loc.dot(Field::pImportSemaphoreWin32HandleInfo);
        skip |= ValidateStructPnext(pImportSemaphoreWin32HandleInfo_loc, pImportSemaphoreWin32HandleInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreWin32HandleInfoKHR-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pImportSemaphoreWin32HandleInfo_loc.dot(Field::semaphore),
                                       pImportSemaphoreWin32HandleInfo->semaphore);

        skip |= ValidateFlags(pImportSemaphoreWin32HandleInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSemaphoreImportFlagBits,
                              AllVkSemaphoreImportFlagBits, pImportSemaphoreWin32HandleInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreWin32HandleKHR(VkDevice device,
                                                                    const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo,
                                                                    HANDLE* pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_win32});
    skip |= ValidateStructType(
        loc.dot(Field::pGetWin32HandleInfo), pGetWin32HandleInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR, true,
        "VUID-vkGetSemaphoreWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkSemaphoreGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetWin32HandleInfo_loc = loc.dot(Field::pGetWin32HandleInfo);
        skip |= ValidateStructPnext(pGetWin32HandleInfo_loc, pGetWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSemaphoreGetWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetWin32HandleInfo_loc.dot(Field::semaphore), pGetWin32HandleInfo->semaphore);

        skip |=
            ValidateFlags(pGetWin32HandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                          AllVkExternalSemaphoreHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit,
                          VK_NULL_HANDLE, "VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter",
                          "VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, error_obj);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateImportSemaphoreFdKHR(VkDevice device,
                                                              const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_fd});
    skip |= ValidateStructType(
        loc.dot(Field::pImportSemaphoreFdInfo), pImportSemaphoreFdInfo, VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR, true,
        "VUID-vkImportSemaphoreFdKHR-pImportSemaphoreFdInfo-parameter", "VUID-VkImportSemaphoreFdInfoKHR-sType-sType");
    if (pImportSemaphoreFdInfo != nullptr) {
        [[maybe_unused]] const Location pImportSemaphoreFdInfo_loc = loc.dot(Field::pImportSemaphoreFdInfo);
        skip |=
            ValidateStructPnext(pImportSemaphoreFdInfo_loc, pImportSemaphoreFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkImportSemaphoreFdInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pImportSemaphoreFdInfo_loc.dot(Field::semaphore), pImportSemaphoreFdInfo->semaphore);

        skip |= ValidateFlags(pImportSemaphoreFdInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSemaphoreImportFlagBits,
                              AllVkSemaphoreImportFlagBits, pImportSemaphoreFdInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkImportSemaphoreFdInfoKHR-flags-parameter");

        skip |= ValidateFlags(
            pImportSemaphoreFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
            AllVkExternalSemaphoreHandleTypeFlagBits, pImportSemaphoreFdInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
            "VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter", "VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_semaphore_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_semaphore_fd});
    skip |= ValidateStructType(loc.dot(Field::pGetFdInfo), pGetFdInfo, VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, true,
                               "VUID-vkGetSemaphoreFdKHR-pGetFdInfo-parameter", "VUID-VkSemaphoreGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr) {
        [[maybe_unused]] const Location pGetFdInfo_loc = loc.dot(Field::pGetFdInfo);
        skip |= ValidateStructPnext(pGetFdInfo_loc, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSemaphoreGetFdInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetFdInfo_loc.dot(Field::semaphore), pGetFdInfo->semaphore);

        skip |=
            ValidateFlags(pGetFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                          AllVkExternalSemaphoreHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter", "VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFd), pFd, "VUID-vkGetSemaphoreFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetSemaphoreFdKHR(device, pGetFdInfo, pFd, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer,
                                                                 VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                                                 uint32_t set, uint32_t descriptorWriteCount,
                                                                 const VkWriteDescriptorSet* pDescriptorWrites,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_push_descriptor))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_push_descriptor});
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= ValidateStructTypeArray(loc.dot(Field::descriptorWriteCount), loc.dot(Field::pDescriptorWrites), descriptorWriteCount,
                                    pDescriptorWrites, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, true, true,
                                    "VUID-VkWriteDescriptorSet-sType-sType",
                                    "VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter",
                                    "VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength");
    if (pDescriptorWrites != nullptr) {
        for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < descriptorWriteCount; ++descriptorWriteIndex) {
            [[maybe_unused]] const Location pDescriptorWrites_loc = loc.dot(Field::pDescriptorWrites, descriptorWriteIndex);
            constexpr std::array allowed_structs_VkWriteDescriptorSet = {
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
                VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK};

            skip |= ValidateStructPnext(pDescriptorWrites_loc, pDescriptorWrites[descriptorWriteIndex].pNext,
                                        allowed_structs_VkWriteDescriptorSet.size(), allowed_structs_VkWriteDescriptorSet.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext",
                                        "VUID-VkWriteDescriptorSet-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pDescriptorWrites_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                       pDescriptorWrites[descriptorWriteIndex].descriptorType,
                                       "VUID-VkWriteDescriptorSet-descriptorType-parameter", VK_NULL_HANDLE);

            skip |= ValidateArray(pDescriptorWrites_loc.dot(Field::descriptorCount), loc,
                                  pDescriptorWrites[descriptorWriteIndex].descriptorCount,
                                  &pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false,
                                  "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount,
                                                              pDescriptorWrites, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer,
                                                                             VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                                             VkPipelineLayout layout, uint32_t set,
                                                                             const void* pData,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_khr_push_descriptor) ||
          IsExtEnabled(device_extensions.vk_khr_descriptor_update_template)))
        skip |= OutputExtensionError(loc,
                                     {vvl::Extension::_VK_KHR_push_descriptor, vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= ValidateRequiredHandle(loc.dot(Field::descriptorUpdateTemplate), descriptorUpdateTemplate);
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDescriptorUpdateTemplateKHR(VkDevice device,
                                                                           const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
                                                                           const VkAllocationCallbacks* pAllocator,
                                                                           VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_descriptor_update_template))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDescriptorUpdateTemplateKHR(VkDevice device,
                                                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                                            const VkAllocationCallbacks* pAllocator,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_descriptor_update_template))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet,
                                                                            VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                                            const void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_descriptor_update_template))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_descriptor_update_template});
    skip |= PreCallValidateUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer,
                                                                const VkRenderPassBeginInfo* pRenderPassBegin,
                                                                const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdNextSubpass2KHR(VkCommandBuffer commandBuffer,
                                                            const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                            const VkSubpassEndInfo* pSubpassEndInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer,
                                                              const VkSubpassEndInfo* pSubpassEndInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_create_renderpass2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_create_renderpass2});
    skip |= PreCallValidateCmdEndRenderPass2(commandBuffer, pSubpassEndInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_shared_presentable_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_shared_presentable_image});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo,
    VkExternalFenceProperties* pExternalFenceProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_external_fence_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_capabilities});
    skip |= PreCallValidateGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties,
                                                                    error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateImportFenceWin32HandleKHR(
    VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_win32});
    skip |= ValidateStructType(loc.dot(Field::pImportFenceWin32HandleInfo), pImportFenceWin32HandleInfo,
                               VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR, true,
                               "VUID-vkImportFenceWin32HandleKHR-pImportFenceWin32HandleInfo-parameter",
                               "VUID-VkImportFenceWin32HandleInfoKHR-sType-sType");
    if (pImportFenceWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pImportFenceWin32HandleInfo_loc = loc.dot(Field::pImportFenceWin32HandleInfo);
        skip |= ValidateStructPnext(pImportFenceWin32HandleInfo_loc, pImportFenceWin32HandleInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkImportFenceWin32HandleInfoKHR-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pImportFenceWin32HandleInfo_loc.dot(Field::fence), pImportFenceWin32HandleInfo->fence);

        skip |= ValidateFlags(pImportFenceWin32HandleInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFenceImportFlagBits,
                              AllVkFenceImportFlagBits, pImportFenceWin32HandleInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkImportFenceWin32HandleInfoKHR-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetFenceWin32HandleKHR(VkDevice device,
                                                                const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo,
                                                                HANDLE* pHandle, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_win32});
    skip |= ValidateStructType(
        loc.dot(Field::pGetWin32HandleInfo), pGetWin32HandleInfo, VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR, true,
        "VUID-vkGetFenceWin32HandleKHR-pGetWin32HandleInfo-parameter", "VUID-VkFenceGetWin32HandleInfoKHR-sType-sType");
    if (pGetWin32HandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetWin32HandleInfo_loc = loc.dot(Field::pGetWin32HandleInfo);
        skip |= ValidateStructPnext(pGetWin32HandleInfo_loc, pGetWin32HandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkFenceGetWin32HandleInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetWin32HandleInfo_loc.dot(Field::fence), pGetWin32HandleInfo->fence);

        skip |= ValidateFlags(pGetWin32HandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                              AllVkExternalFenceHandleTypeFlagBits, pGetWin32HandleInfo->handleType, kRequiredSingleBit,
                              VK_NULL_HANDLE, "VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter",
                              "VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetFenceWin32HandleKHR-pHandle-parameter");
    if (!skip) skip |= manual_PreCallValidateGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle, error_obj);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_fd});
    skip |=
        ValidateStructType(loc.dot(Field::pImportFenceFdInfo), pImportFenceFdInfo, VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR, true,
                           "VUID-vkImportFenceFdKHR-pImportFenceFdInfo-parameter", "VUID-VkImportFenceFdInfoKHR-sType-sType");
    if (pImportFenceFdInfo != nullptr) {
        [[maybe_unused]] const Location pImportFenceFdInfo_loc = loc.dot(Field::pImportFenceFdInfo);
        skip |= ValidateStructPnext(pImportFenceFdInfo_loc, pImportFenceFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImportFenceFdInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pImportFenceFdInfo_loc.dot(Field::fence), pImportFenceFdInfo->fence);

        skip |= ValidateFlags(pImportFenceFdInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkFenceImportFlagBits,
                              AllVkFenceImportFlagBits, pImportFenceFdInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkImportFenceFdInfoKHR-flags-parameter");

        skip |=
            ValidateFlags(pImportFenceFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                          AllVkExternalFenceHandleTypeFlagBits, pImportFenceFdInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-VkImportFenceFdInfoKHR-handleType-parameter", "VUID-VkImportFenceFdInfoKHR-handleType-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateImportFenceFdKHR(device, pImportFenceFdInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_external_fence_fd))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_external_fence_fd});
    skip |= ValidateStructType(loc.dot(Field::pGetFdInfo), pGetFdInfo, VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, true,
                               "VUID-vkGetFenceFdKHR-pGetFdInfo-parameter", "VUID-VkFenceGetFdInfoKHR-sType-sType");
    if (pGetFdInfo != nullptr) {
        [[maybe_unused]] const Location pGetFdInfo_loc = loc.dot(Field::pGetFdInfo);
        skip |= ValidateStructPnext(pGetFdInfo_loc, pGetFdInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkFenceGetFdInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetFdInfo_loc.dot(Field::fence), pGetFdInfo->fence);

        skip |= ValidateFlags(pGetFdInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalFenceHandleTypeFlagBits,
                              AllVkExternalFenceHandleTypeFlagBits, pGetFdInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkFenceGetFdInfoKHR-handleType-parameter", "VUID-VkFenceGetFdInfoKHR-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFd), pFd, "VUID-vkGetFenceFdKHR-pFd-parameter");
    if (!skip) skip |= manual_PreCallValidateGetFenceFdKHR(device, pGetFdInfo, pFd, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters,
    VkPerformanceCounterDescriptionKHR* pCounterDescriptions, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pCounterCount), loc.dot(Field::pCounters), pCounterCount, pCounters,
        VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR, true, false, false, "VUID-VkPerformanceCounterKHR-sType-sType",
        "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounters-parameter",
        "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterCount-parameter", kVUIDUndefined);
    if (pCounters != nullptr) {
        for (uint32_t pIndexerIndex = 0; pIndexerIndex < *pCounterCount; ++pIndexerIndex) {
            [[maybe_unused]] const Location pCounters_loc = loc.dot(Field::pCounters, pIndexerIndex);
            skip |= ValidateStructPnext(pCounters_loc, pCounters[pIndexerIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPerformanceCounterKHR-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pCounterCount), loc.dot(Field::pCounterDescriptions), pCounterCount, pCounterDescriptions,
        VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR, true, false, false,
        "VUID-VkPerformanceCounterDescriptionKHR-sType-sType",
        "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterDescriptions-parameter",
        "VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterCount-parameter", kVUIDUndefined);
    if (pCounterDescriptions != nullptr) {
        for (uint32_t pIndexerIndex = 0; pIndexerIndex < *pCounterCount; ++pIndexerIndex) {
            [[maybe_unused]] const Location pCounterDescriptions_loc = loc.dot(Field::pCounterDescriptions, pIndexerIndex);
            skip |= ValidateStructPnext(pCounterDescriptions_loc, pCounterDescriptions[pIndexerIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkPerformanceCounterDescriptionKHR-pNext-pNext",
                                        kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pPerformanceQueryCreateInfo), pPerformanceQueryCreateInfo,
                               VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, true,
                               "VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pPerformanceQueryCreateInfo-parameter",
                               "VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType");
    if (pPerformanceQueryCreateInfo != nullptr) {
        [[maybe_unused]] const Location pPerformanceQueryCreateInfo_loc = loc.dot(Field::pPerformanceQueryCreateInfo);
        skip |= ValidateStructPnext(pPerformanceQueryCreateInfo_loc, pPerformanceQueryCreateInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, physicalDevice, true);

        skip |= ValidateArray(pPerformanceQueryCreateInfo_loc.dot(Field::counterIndexCount),
                              pPerformanceQueryCreateInfo_loc.dot(Field::pCounterIndices),
                              pPerformanceQueryCreateInfo->counterIndexCount, &pPerformanceQueryCreateInfo->pCounterIndices, true,
                              true, "VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength",
                              "VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pNumPasses), pNumPasses,
                                    "VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pNumPasses-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR* pInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_performance_query});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR, true,
                               "VUID-vkAcquireProfilingLockKHR-pInfo-parameter", "VUID-VkAcquireProfilingLockInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAcquireProfilingLockInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pInfo_loc.dot(Field::flags), pInfo->flags,
                                      "VUID-VkAcquireProfilingLockInfoKHR-flags-zerobitmask");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseProfilingLockKHR(VkDevice device, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_performance_query});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceCapabilities2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
    VkSurfaceCapabilities2KHR* pSurfaceCapabilities, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_surface_capabilities2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_surface_capabilities2});
    skip |= ValidateStructType(loc.dot(Field::pSurfaceInfo), pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
                               true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter",
                               "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr) {
        [[maybe_unused]] const Location pSurfaceInfo_loc = loc.dot(Field::pSurfaceInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = {
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT};

        skip |= ValidateStructPnext(pSurfaceInfo_loc, pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(),
                                    allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext",
                                    "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", physicalDevice, true);
    }
    skip |=
        ValidateStructType(loc.dot(Field::pSurfaceCapabilities), pSurfaceCapabilities, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
                           true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter",
                           "VUID-VkSurfaceCapabilities2KHR-sType-sType");
    if (pSurfaceCapabilities != nullptr) {
        [[maybe_unused]] const Location pSurfaceCapabilities_loc = loc.dot(Field::pSurfaceCapabilities);
        constexpr std::array allowed_structs_VkSurfaceCapabilities2KHR = {
            VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV,
            VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
            VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV,
            VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT,
            VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT,
            VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR};

        skip |= ValidateStructPnext(
            pSurfaceCapabilities_loc, pSurfaceCapabilities->pNext, allowed_structs_VkSurfaceCapabilities2KHR.size(),
            allowed_structs_VkSurfaceCapabilities2KHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkSurfaceCapabilities2KHR-pNext-pNext", "VUID-VkSurfaceCapabilities2KHR-sType-unique", physicalDevice, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities,
                                                                               error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice,
                                                                             const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo,
                                                                             uint32_t* pSurfaceFormatCount,
                                                                             VkSurfaceFormat2KHR* pSurfaceFormats,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_surface_capabilities2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_surface_capabilities2});
    skip |= ValidateStructType(loc.dot(Field::pSurfaceInfo), pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
                               true, "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter",
                               "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr) {
        [[maybe_unused]] const Location pSurfaceInfo_loc = loc.dot(Field::pSurfaceInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = {
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT};

        skip |= ValidateStructPnext(pSurfaceInfo_loc, pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(),
                                    allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext",
                                    "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", physicalDevice, true);
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::pSurfaceFormatCount), loc.dot(Field::pSurfaceFormats), pSurfaceFormatCount,
                                    pSurfaceFormats, VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, true, false, false,
                                    "VUID-VkSurfaceFormat2KHR-sType-sType",
                                    "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormats-parameter",
                                    "VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormatCount-parameter", kVUIDUndefined);
    if (pSurfaceFormats != nullptr) {
        for (uint32_t pSurfaceFormatIndex = 0; pSurfaceFormatIndex < *pSurfaceFormatCount; ++pSurfaceFormatIndex) {
            [[maybe_unused]] const Location pSurfaceFormats_loc = loc.dot(Field::pSurfaceFormats, pSurfaceFormatIndex);
            constexpr std::array allowed_structs_VkSurfaceFormat2KHR = {VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT};

            skip |= ValidateStructPnext(pSurfaceFormats_loc, pSurfaceFormats[pSurfaceFormatIndex].pNext,
                                        allowed_structs_VkSurfaceFormat2KHR.size(), allowed_structs_VkSurfaceFormat2KHR.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkSurfaceFormat2KHR-pNext-pNext",
                                        "VUID-VkSurfaceFormat2KHR-sType-unique", physicalDevice, false);
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount,
                                                                          pSurfaceFormats, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                                uint32_t* pPropertyCount,
                                                                                VkDisplayProperties2KHR* pProperties,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= ValidateStructTypeArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
                                    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR, true, false, false,
                                    "VUID-VkDisplayProperties2KHR-sType-sType",
                                    "VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pProperties-parameter",
                                    "VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayProperties2KHR-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                                     uint32_t* pPropertyCount,
                                                                                     VkDisplayPlaneProperties2KHR* pProperties,
                                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= ValidateStructTypeArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
                                    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR, true, false, false,
                                    "VUID-VkDisplayPlaneProperties2KHR-sType-sType",
                                    "VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pProperties-parameter",
                                    "VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayPlaneProperties2KHR-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                                      uint32_t* pPropertyCount,
                                                                      VkDisplayModeProperties2KHR* pProperties,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |= ValidateStructTypeArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
                                    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR, true, false, false,
                                    "VUID-VkDisplayModeProperties2KHR-sType-sType",
                                    "VUID-vkGetDisplayModeProperties2KHR-pProperties-parameter",
                                    "VUID-vkGetDisplayModeProperties2KHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayModeProperties2KHR-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice,
                                                                         const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo,
                                                                         VkDisplayPlaneCapabilities2KHR* pCapabilities,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_khr_get_display_properties2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_display_properties2});
    skip |= ValidateStructType(loc.dot(Field::pDisplayPlaneInfo), pDisplayPlaneInfo, VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
                               true, "VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter",
                               "VUID-VkDisplayPlaneInfo2KHR-sType-sType");
    if (pDisplayPlaneInfo != nullptr) {
        [[maybe_unused]] const Location pDisplayPlaneInfo_loc = loc.dot(Field::pDisplayPlaneInfo);
        skip |= ValidateStructPnext(pDisplayPlaneInfo_loc, pDisplayPlaneInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayPlaneInfo2KHR-pNext-pNext", kVUIDUndefined, physicalDevice, true);

        skip |= ValidateRequiredHandle(pDisplayPlaneInfo_loc.dot(Field::mode), pDisplayPlaneInfo->mode);
    }
    skip |= ValidateStructType(loc.dot(Field::pCapabilities), pCapabilities, VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
                               true, "VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter",
                               "VUID-VkDisplayPlaneCapabilities2KHR-sType-sType");
    if (pCapabilities != nullptr) {
        [[maybe_unused]] const Location pCapabilities_loc = loc.dot(Field::pCapabilities);
        skip |= ValidateStructPnext(pCapabilities_loc, pCapabilities->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext", kVUIDUndefined, physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageMemoryRequirements2KHR(VkDevice device,
                                                                        const VkImageMemoryRequirementsInfo2* pInfo,
                                                                        VkMemoryRequirements2* pMemoryRequirements,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_get_memory_requirements2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_memory_requirements2});
    skip |= PreCallValidateGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferMemoryRequirements2KHR(VkDevice device,
                                                                         const VkBufferMemoryRequirementsInfo2* pInfo,
                                                                         VkMemoryRequirements2* pMemoryRequirements,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_get_memory_requirements2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_memory_requirements2});
    skip |= PreCallValidateGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSparseMemoryRequirements2KHR(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_get_memory_requirements2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_get_memory_requirements2});
    skip |= PreCallValidateGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount,
                                                             pSparseMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateSamplerYcbcrConversionKHR(VkDevice device,
                                                                         const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
                                                                         const VkAllocationCallbacks* pAllocator,
                                                                         VkSamplerYcbcrConversion* pYcbcrConversion,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_sampler_ycbcr_conversion});
    skip |= PreCallValidateCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                                                          const VkAllocationCallbacks* pAllocator,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_sampler_ycbcr_conversion))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_sampler_ycbcr_conversion});
    skip |= PreCallValidateDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                                              const VkBindBufferMemoryInfo* pBindInfos,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_bind_memory2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_bind_memory2});
    skip |= PreCallValidateBindBufferMemory2(device, bindInfoCount, pBindInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                                             const VkBindImageMemoryInfo* pBindInfos,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_bind_memory2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_bind_memory2});
    skip |= PreCallValidateBindImageMemory2(device, bindInfoCount, pBindInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutSupportKHR(VkDevice device,
                                                                          const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                                                          VkDescriptorSetLayoutSupport* pSupport,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance3))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance3});
    skip |= PreCallValidateGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                 VkDeviceSize offset, VkBuffer countBuffer,
                                                                 VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                 uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride,
                                                error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                        VkDeviceSize offset, VkBuffer countBuffer,
                                                                        VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                        uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                                       stride, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t* pValue,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_timeline_semaphore});
    skip |= PreCallValidateGetSemaphoreCounterValue(device, semaphore, pValue, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_timeline_semaphore});
    skip |= PreCallValidateWaitSemaphores(device, pWaitInfo, timeout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo* pSignalInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_timeline_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_timeline_semaphore});
    skip |= PreCallValidateSignalSemaphore(device, pSignalInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceFragmentShadingRatesKHR(
    VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount,
    VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pFragmentShadingRateCount), loc.dot(Field::pFragmentShadingRates), pFragmentShadingRateCount,
        pFragmentShadingRates, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR, true, false, false,
        "VUID-VkPhysicalDeviceFragmentShadingRateKHR-sType-sType",
        "VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-pFragmentShadingRates-parameter",
        "VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-pFragmentShadingRateCount-parameter", kVUIDUndefined);
    if (pFragmentShadingRates != nullptr) {
        for (uint32_t pFragmentShadingRateIndex = 0; pFragmentShadingRateIndex < *pFragmentShadingRateCount;
             ++pFragmentShadingRateIndex) {
            [[maybe_unused]] const Location pFragmentShadingRates_loc =
                loc.dot(Field::pFragmentShadingRates, pFragmentShadingRateIndex);
            skip |=
                ValidateStructPnext(pFragmentShadingRates_loc, pFragmentShadingRates[pFragmentShadingRateIndex].pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkPhysicalDeviceFragmentShadingRateKHR-pNext-pNext",
                                    kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer,
                                                                      const VkExtent2D* pFragmentSize,
                                                                      const VkFragmentShadingRateCombinerOpKHR combinerOps[2],
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_fragment_shading_rate))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_fragment_shading_rate});
    skip |= ValidateRequiredPointer(loc.dot(Field::pFragmentSize), pFragmentSize,
                                    "VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-parameter");
    if (pFragmentSize != nullptr) {
        [[maybe_unused]] const Location pFragmentSize_loc = loc.dot(Field::pFragmentSize);
        // No xml-driven validation
    }
    skip |= ValidateRangedEnumArray(loc, loc.dot(Field::combinerOps), vvl::Enum::VkFragmentShadingRateCombinerOpKHR, 2, combinerOps,
                                    false, true, kVUIDUndefined, "VUID-vkCmdSetFragmentShadingRateKHR-combinerOps-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRenderingAttachmentLocationsKHR(
    VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfoKHR* pLocationInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering_local_read))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering_local_read});
    skip |=
        ValidateStructType(loc.dot(Field::pLocationInfo), pLocationInfo, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR,
                           true, "VUID-vkCmdSetRenderingAttachmentLocationsKHR-pLocationInfo-parameter",
                           "VUID-VkRenderingAttachmentLocationInfoKHR-sType-sType");
    if (pLocationInfo != nullptr) {
        [[maybe_unused]] const Location pLocationInfo_loc = loc.dot(Field::pLocationInfo);
        skip |= ValidateStructPnext(pLocationInfo_loc, pLocationInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRenderingInputAttachmentIndicesKHR(
    VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfoKHR* pInputAttachmentIndexInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_dynamic_rendering_local_read))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_dynamic_rendering_local_read});
    skip |= ValidateStructType(loc.dot(Field::pInputAttachmentIndexInfo), pInputAttachmentIndexInfo,
                               VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR, true,
                               "VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-pInputAttachmentIndexInfo-parameter",
                               "VUID-VkRenderingInputAttachmentIndexInfoKHR-sType-sType");
    if (pInputAttachmentIndexInfo != nullptr) {
        [[maybe_unused]] const Location pInputAttachmentIndexInfo_loc = loc.dot(Field::pInputAttachmentIndexInfo);
        skip |= ValidateStructPnext(pInputAttachmentIndexInfo_loc, pInputAttachmentIndexInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateWaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId,
                                                           uint64_t timeout, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_present_wait))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_present_wait});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_buffer_device_address});
    skip |= PreCallValidateGetBufferDeviceAddress(device, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_buffer_device_address});
    skip |= PreCallValidateGetBufferOpaqueCaptureAddress(device, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device,
                                                                                const VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_buffer_device_address});
    skip |= PreCallValidateGetDeviceMemoryOpaqueCaptureAddress(device, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks* pAllocator,
                                                                    VkDeferredOperationKHR* pDeferredOperation,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pDeferredOperation), pDeferredOperation,
                                    "VUID-vkCreateDeferredOperationKHR-pDeferredOperation-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                                     const VkAllocationCallbacks* pAllocator,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    skip |= ValidateRequiredHandle(loc.dot(Field::operation), operation);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    skip |= ValidateRequiredHandle(loc.dot(Field::operation), operation);
    return skip;
}

bool StatelessValidation::PreCallValidateDeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_deferred_host_operations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_deferred_host_operations});
    skip |= ValidateRequiredHandle(loc.dot(Field::operation), operation);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR* pPipelineInfo,
                                                                            uint32_t* pExecutableCount,
                                                                            VkPipelineExecutablePropertiesKHR* pProperties,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_executable_properties});
    skip |= ValidateStructType(loc.dot(Field::pPipelineInfo), pPipelineInfo, VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR, true,
                               "VUID-vkGetPipelineExecutablePropertiesKHR-pPipelineInfo-parameter",
                               "VUID-VkPipelineInfoKHR-sType-sType");
    if (pPipelineInfo != nullptr) {
        [[maybe_unused]] const Location pPipelineInfo_loc = loc.dot(Field::pPipelineInfo);
        skip |= ValidateStructPnext(pPipelineInfo_loc, pPipelineInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pPipelineInfo_loc.dot(Field::pipeline), pPipelineInfo->pipeline);
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::pExecutableCount), loc.dot(Field::pProperties), pExecutableCount, pProperties,
                                    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR, true, false, false,
                                    "VUID-VkPipelineExecutablePropertiesKHR-sType-sType",
                                    "VUID-vkGetPipelineExecutablePropertiesKHR-pProperties-parameter",
                                    "VUID-vkGetPipelineExecutablePropertiesKHR-pExecutableCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pExecutableIndex = 0; pExecutableIndex < *pExecutableCount; ++pExecutableIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pExecutableIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pExecutableIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineExecutablePropertiesKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineExecutableStatisticsKHR(VkDevice device,
                                                                            const VkPipelineExecutableInfoKHR* pExecutableInfo,
                                                                            uint32_t* pStatisticCount,
                                                                            VkPipelineExecutableStatisticKHR* pStatistics,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_executable_properties});
    skip |= ValidateStructType(loc.dot(Field::pExecutableInfo), pExecutableInfo, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
                               true, "VUID-vkGetPipelineExecutableStatisticsKHR-pExecutableInfo-parameter",
                               "VUID-VkPipelineExecutableInfoKHR-sType-sType");
    if (pExecutableInfo != nullptr) {
        [[maybe_unused]] const Location pExecutableInfo_loc = loc.dot(Field::pExecutableInfo);
        skip |= ValidateStructPnext(pExecutableInfo_loc, pExecutableInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineExecutableInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pExecutableInfo_loc.dot(Field::pipeline), pExecutableInfo->pipeline);
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::pStatisticCount), loc.dot(Field::pStatistics), pStatisticCount, pStatistics,
                                    VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR, true, false, false,
                                    "VUID-VkPipelineExecutableStatisticKHR-sType-sType",
                                    "VUID-vkGetPipelineExecutableStatisticsKHR-pStatistics-parameter",
                                    "VUID-vkGetPipelineExecutableStatisticsKHR-pStatisticCount-parameter", kVUIDUndefined);
    if (pStatistics != nullptr) {
        for (uint32_t pStatisticIndex = 0; pStatisticIndex < *pStatisticCount; ++pStatisticIndex) {
            [[maybe_unused]] const Location pStatistics_loc = loc.dot(Field::pStatistics, pStatisticIndex);
            skip |=
                ValidateStructPnext(pStatistics_loc, pStatistics[pStatisticIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineExecutableStatisticKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_executable_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_executable_properties});
    skip |= ValidateStructType(loc.dot(Field::pExecutableInfo), pExecutableInfo, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
                               true, "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pExecutableInfo-parameter",
                               "VUID-VkPipelineExecutableInfoKHR-sType-sType");
    if (pExecutableInfo != nullptr) {
        [[maybe_unused]] const Location pExecutableInfo_loc = loc.dot(Field::pExecutableInfo);
        skip |= ValidateStructPnext(pExecutableInfo_loc, pExecutableInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineExecutableInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pExecutableInfo_loc.dot(Field::pipeline), pExecutableInfo->pipeline);
    }
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pInternalRepresentationCount), loc.dot(Field::pInternalRepresentations), pInternalRepresentationCount,
        pInternalRepresentations, VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR, true, false, false,
        "VUID-VkPipelineExecutableInternalRepresentationKHR-sType-sType",
        "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pInternalRepresentations-parameter",
        "VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pInternalRepresentationCount-parameter", kVUIDUndefined);
    if (pInternalRepresentations != nullptr) {
        for (uint32_t pInternalRepresentationIndex = 0; pInternalRepresentationIndex < *pInternalRepresentationCount;
             ++pInternalRepresentationIndex) {
            [[maybe_unused]] const Location pInternalRepresentations_loc =
                loc.dot(Field::pInternalRepresentations, pInternalRepresentationIndex);
            skip |= ValidateStructPnext(pInternalRepresentations_loc, pInternalRepresentations[pInternalRepresentationIndex].pNext,
                                        0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkPipelineExecutableInternalRepresentationKHR-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateMapMemory2KHR(VkDevice device, const VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData,
                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_map_memory2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_map_memory2});
    skip |= ValidateStructType(loc.dot(Field::pMemoryMapInfo), pMemoryMapInfo, VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR, true,
                               "VUID-vkMapMemory2KHR-pMemoryMapInfo-parameter", "VUID-VkMemoryMapInfoKHR-sType-sType");
    if (pMemoryMapInfo != nullptr) {
        [[maybe_unused]] const Location pMemoryMapInfo_loc = loc.dot(Field::pMemoryMapInfo);
        constexpr std::array allowed_structs_VkMemoryMapInfoKHR = {VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT};

        skip |= ValidateStructPnext(pMemoryMapInfo_loc, pMemoryMapInfo->pNext, allowed_structs_VkMemoryMapInfoKHR.size(),
                                    allowed_structs_VkMemoryMapInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryMapInfoKHR-pNext-pNext", "VUID-VkMemoryMapInfoKHR-sType-unique", VK_NULL_HANDLE,
                                    true);

        skip |= ValidateFlags(pMemoryMapInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryMapFlagBits, AllVkMemoryMapFlagBits,
                              pMemoryMapInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkMemoryMapInfoKHR-flags-parameter");

        skip |= ValidateRequiredHandle(pMemoryMapInfo_loc.dot(Field::memory), pMemoryMapInfo->memory);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::ppData), ppData, "VUID-vkMapMemory2KHR-ppData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfoKHR* pMemoryUnmapInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_map_memory2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_map_memory2});
    skip |= ValidateStructType(loc.dot(Field::pMemoryUnmapInfo), pMemoryUnmapInfo, VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR, true,
                               "VUID-vkUnmapMemory2KHR-pMemoryUnmapInfo-parameter", "VUID-VkMemoryUnmapInfoKHR-sType-sType");
    if (pMemoryUnmapInfo != nullptr) {
        [[maybe_unused]] const Location pMemoryUnmapInfo_loc = loc.dot(Field::pMemoryUnmapInfo);
        skip |= ValidateStructPnext(pMemoryUnmapInfo_loc, pMemoryUnmapInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryUnmapInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pMemoryUnmapInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryUnmapFlagBitsKHR,
                              AllVkMemoryUnmapFlagBitsKHR, pMemoryUnmapInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkMemoryUnmapInfoKHR-flags-parameter");

        skip |= ValidateRequiredHandle(pMemoryUnmapInfo_loc.dot(Field::memory), pMemoryUnmapInfo->memory);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo,
    VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pQualityLevelInfo), pQualityLevelInfo,
                               VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR, true,
                               "VUID-vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR-pQualityLevelInfo-parameter",
                               "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-sType-sType");
    if (pQualityLevelInfo != nullptr) {
        [[maybe_unused]] const Location pQualityLevelInfo_loc = loc.dot(Field::pQualityLevelInfo);
        skip |= ValidateStructPnext(pQualityLevelInfo_loc, pQualityLevelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pNext-pNext", kVUIDUndefined,
                                    physicalDevice, true);

        skip |= ValidateStructType(pQualityLevelInfo_loc.dot(Field::pVideoProfile), pQualityLevelInfo->pVideoProfile,
                                   VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, true,
                                   "VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-parameter",
                                   "VUID-VkVideoProfileInfoKHR-sType-sType");

        if (pQualityLevelInfo->pVideoProfile != nullptr) {
            [[maybe_unused]] const Location pVideoProfile_loc = pQualityLevelInfo_loc.dot(Field::pVideoProfile);
            constexpr std::array allowed_structs_VkVideoProfileInfoKHR = {
                VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR,  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR};

            skip |= ValidateStructPnext(pVideoProfile_loc, pQualityLevelInfo->pVideoProfile->pNext,
                                        allowed_structs_VkVideoProfileInfoKHR.size(), allowed_structs_VkVideoProfileInfoKHR.data(),
                                        GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, physicalDevice, true);

            skip |=
                ValidateFlags(pVideoProfile_loc.dot(Field::videoCodecOperation), vvl::FlagBitmask::VkVideoCodecOperationFlagBitsKHR,
                              AllVkVideoCodecOperationFlagBitsKHR, pQualityLevelInfo->pVideoProfile->videoCodecOperation,
                              kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter",
                              "VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter");

            skip |= ValidateFlags(pVideoProfile_loc.dot(Field::chromaSubsampling),
                                  vvl::FlagBitmask::VkVideoChromaSubsamplingFlagBitsKHR, AllVkVideoChromaSubsamplingFlagBitsKHR,
                                  pQualityLevelInfo->pVideoProfile->chromaSubsampling, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter",
                                  "VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask");

            skip |= ValidateFlags(pVideoProfile_loc.dot(Field::lumaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                                  AllVkVideoComponentBitDepthFlagBitsKHR, pQualityLevelInfo->pVideoProfile->lumaBitDepth,
                                  kRequiredFlags, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter",
                                  "VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask");

            skip |=
                ValidateFlags(pVideoProfile_loc.dot(Field::chromaBitDepth), vvl::FlagBitmask::VkVideoComponentBitDepthFlagBitsKHR,
                              AllVkVideoComponentBitDepthFlagBitsKHR, pQualityLevelInfo->pVideoProfile->chromaBitDepth,
                              kOptionalFlags, VK_NULL_HANDLE, "VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter");
        }
    }
    skip |= ValidateStructType(loc.dot(Field::pQualityLevelProperties), pQualityLevelProperties,
                               VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR, true,
                               "VUID-vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR-pQualityLevelProperties-parameter",
                               "VUID-VkVideoEncodeQualityLevelPropertiesKHR-sType-sType");
    if (pQualityLevelProperties != nullptr) {
        [[maybe_unused]] const Location pQualityLevelProperties_loc = loc.dot(Field::pQualityLevelProperties);
        constexpr std::array allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR};

        skip |= ValidateStructPnext(pQualityLevelProperties_loc, pQualityLevelProperties->pNext,
                                    allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR.size(),
                                    allowed_structs_VkVideoEncodeQualityLevelPropertiesKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoEncodeQualityLevelPropertiesKHR-pNext-pNext",
                                    "VUID-VkVideoEncodeQualityLevelPropertiesKHR-sType-unique", physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetEncodedVideoSessionParametersKHR(
    VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo,
    VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_encode_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_encode_queue});
    skip |= ValidateStructType(loc.dot(Field::pVideoSessionParametersInfo), pVideoSessionParametersInfo,
                               VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR, true,
                               "VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-parameter",
                               "VUID-VkVideoEncodeSessionParametersGetInfoKHR-sType-sType");
    if (pVideoSessionParametersInfo != nullptr) {
        [[maybe_unused]] const Location pVideoSessionParametersInfo_loc = loc.dot(Field::pVideoSessionParametersInfo);
        constexpr std::array allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR};

        skip |= ValidateStructPnext(pVideoSessionParametersInfo_loc, pVideoSessionParametersInfo->pNext,
                                    allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR.size(),
                                    allowed_structs_VkVideoEncodeSessionParametersGetInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoEncodeSessionParametersGetInfoKHR-pNext-pNext",
                                    "VUID-VkVideoEncodeSessionParametersGetInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pVideoSessionParametersInfo_loc.dot(Field::videoSessionParameters),
                                       pVideoSessionParametersInfo->videoSessionParameters);
    }
    skip |= ValidateStructType(loc.dot(Field::pFeedbackInfo), pFeedbackInfo,
                               VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR, false,
                               "VUID-vkGetEncodedVideoSessionParametersKHR-pFeedbackInfo-parameter",
                               "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-sType-sType");
    if (pFeedbackInfo != nullptr) {
        [[maybe_unused]] const Location pFeedbackInfo_loc = loc.dot(Field::pFeedbackInfo);
        constexpr std::array allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR = {
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR};

        skip |= ValidateStructPnext(pFeedbackInfo_loc, pFeedbackInfo->pNext,
                                    allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR.size(),
                                    allowed_structs_VkVideoEncodeSessionParametersFeedbackInfoKHR.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-pNext-pNext",
                                    "VUID-VkVideoEncodeSessionParametersFeedbackInfoKHR-sType-unique", VK_NULL_HANDLE, false);
    }
    skip |= ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                 "VUID-vkGetEncodedVideoSessionParametersKHR-pDataSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetEncodedVideoSessionParametersKHR-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR* pEncodeInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_video_encode_queue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_video_encode_queue});
    skip |= ValidateStructType(loc.dot(Field::pEncodeInfo), pEncodeInfo, VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR, true,
                               "VUID-vkCmdEncodeVideoKHR-pEncodeInfo-parameter", "VUID-VkVideoEncodeInfoKHR-sType-sType");
    if (pEncodeInfo != nullptr) {
        [[maybe_unused]] const Location pEncodeInfo_loc = loc.dot(Field::pEncodeInfo);
        constexpr std::array allowed_structs_VkVideoEncodeInfoKHR = {VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR,
                                                                     VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR};

        skip |= ValidateStructPnext(pEncodeInfo_loc, pEncodeInfo->pNext, allowed_structs_VkVideoEncodeInfoKHR.size(),
                                    allowed_structs_VkVideoEncodeInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkVideoEncodeInfoKHR-pNext-pNext", "VUID-VkVideoEncodeInfoKHR-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pEncodeInfo_loc.dot(Field::flags), pEncodeInfo->flags,
                                      "VUID-VkVideoEncodeInfoKHR-flags-zerobitmask");

        skip |= ValidateRequiredHandle(pEncodeInfo_loc.dot(Field::dstBuffer), pEncodeInfo->dstBuffer);

        skip |= ValidateStructType(pEncodeInfo_loc.dot(Field::srcPictureResource), &(pEncodeInfo->srcPictureResource),
                                   VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false, kVUIDUndefined,
                                   "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

        skip |=
            ValidateStructPnext(pEncodeInfo_loc, pEncodeInfo->srcPictureResource.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        // No xml-driven validation

        // No xml-driven validation

        skip |=
            ValidateRequiredHandle(pEncodeInfo_loc.dot(Field::imageViewBinding), pEncodeInfo->srcPictureResource.imageViewBinding);

        skip |= ValidateStructType(pEncodeInfo_loc.dot(Field::pSetupReferenceSlot), pEncodeInfo->pSetupReferenceSlot,
                                   VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false,
                                   "VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-parameter",
                                   "VUID-VkVideoReferenceSlotInfoKHR-sType-sType");

        if (pEncodeInfo->pSetupReferenceSlot != nullptr) {
            [[maybe_unused]] const Location pSetupReferenceSlot_loc = pEncodeInfo_loc.dot(Field::pSetupReferenceSlot);
            constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
                VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

            skip |= ValidateStructPnext(pSetupReferenceSlot_loc, pEncodeInfo->pSetupReferenceSlot->pNext,
                                        allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                        allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                        "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructType(
                pSetupReferenceSlot_loc.dot(Field::pPictureResource), pEncodeInfo->pSetupReferenceSlot->pPictureResource,
                VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

            if (pEncodeInfo->pSetupReferenceSlot->pPictureResource != nullptr) {
                [[maybe_unused]] const Location pPictureResource_loc = pSetupReferenceSlot_loc.dot(Field::pPictureResource);
                skip |= ValidateStructPnext(pPictureResource_loc, pEncodeInfo->pSetupReferenceSlot->pPictureResource->pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                // No xml-driven validation

                // No xml-driven validation

                skip |= ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                               pEncodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding);
            }
        }

        skip |= ValidateStructTypeArray(pEncodeInfo_loc.dot(Field::referenceSlotCount), pEncodeInfo_loc.dot(Field::pReferenceSlots),
                                        pEncodeInfo->referenceSlotCount, pEncodeInfo->pReferenceSlots,
                                        VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, false, true,
                                        "VUID-VkVideoReferenceSlotInfoKHR-sType-sType",
                                        "VUID-VkVideoEncodeInfoKHR-pReferenceSlots-parameter", kVUIDUndefined);

        if (pEncodeInfo->pReferenceSlots != nullptr) {
            for (uint32_t referenceSlotIndex = 0; referenceSlotIndex < pEncodeInfo->referenceSlotCount; ++referenceSlotIndex) {
                [[maybe_unused]] const Location pReferenceSlots_loc =
                    pEncodeInfo_loc.dot(Field::pReferenceSlots, referenceSlotIndex);
                constexpr std::array allowed_structs_VkVideoReferenceSlotInfoKHR = {
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR,
                    VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR};

                skip |= ValidateStructPnext(pReferenceSlots_loc, pEncodeInfo->pReferenceSlots[referenceSlotIndex].pNext,
                                            allowed_structs_VkVideoReferenceSlotInfoKHR.size(),
                                            allowed_structs_VkVideoReferenceSlotInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                            "VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext",
                                            "VUID-VkVideoReferenceSlotInfoKHR-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateStructType(pReferenceSlots_loc.dot(Field::pPictureResource),
                                           pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource,
                                           VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, false,
                                           "VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter",
                                           "VUID-VkVideoPictureResourceInfoKHR-sType-sType");

                if (pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource != nullptr) {
                    [[maybe_unused]] const Location pPictureResource_loc = pReferenceSlots_loc.dot(Field::pPictureResource);
                    skip |= ValidateStructPnext(
                        pPictureResource_loc, pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->pNext, 0, nullptr,
                        GeneratedVulkanHeaderVersion, "VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", kVUIDUndefined,
                        VK_NULL_HANDLE, true);

                    // No xml-driven validation

                    // No xml-driven validation

                    skip |=
                        ValidateRequiredHandle(pPictureResource_loc.dot(Field::imageViewBinding),
                                               pEncodeInfo->pReferenceSlots[referenceSlotIndex].pPictureResource->imageViewBinding);
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                                         const VkDependencyInfo* pDependencyInfo,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdSetEvent2(commandBuffer, event, pDependencyInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                                           VkPipelineStageFlags2 stageMask, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdResetEvent2(commandBuffer, event, stageMask, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                                           const VkEvent* pEvents, const VkDependencyInfo* pDependencyInfos,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer,
                                                                const VkDependencyInfo* pDependencyInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdPipelineBarrier2(commandBuffer, pDependencyInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                                               VkQueryPool queryPool, uint32_t query,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateCmdWriteTimestamp2(commandBuffer, stage, queryPool, query, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                                                         VkFence fence, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= PreCallValidateQueueSubmit2(queue, submitCount, pSubmits, fence, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                                                  VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= ValidateFlags(loc.dot(Field::stage), vvl::FlagBitmask::VkPipelineStageFlagBits2, AllVkPipelineStageFlagBits2, stage,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdWriteBufferMarker2AMD-stage-parameter");
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateGetQueueCheckpointData2NV(VkQueue queue, uint32_t* pCheckpointDataCount,
                                                                   VkCheckpointData2NV* pCheckpointData,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_synchronization2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_synchronization2});
    skip |= ValidateStructTypeArray(loc.dot(Field::pCheckpointDataCount), loc.dot(Field::pCheckpointData), pCheckpointDataCount,
                                    pCheckpointData, VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV, true, false, false,
                                    "VUID-VkCheckpointData2NV-sType-sType",
                                    "VUID-vkGetQueueCheckpointData2NV-pCheckpointData-parameter",
                                    "VUID-vkGetQueueCheckpointData2NV-pCheckpointDataCount-parameter", kVUIDUndefined);
    if (pCheckpointData != nullptr) {
        for (uint32_t pCheckpointDataIndex = 0; pCheckpointDataIndex < *pCheckpointDataCount; ++pCheckpointDataIndex) {
            [[maybe_unused]] const Location pCheckpointData_loc = loc.dot(Field::pCheckpointData, pCheckpointDataIndex);
            skip |= ValidateStructPnext(pCheckpointData_loc, pCheckpointData[pCheckpointDataIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkCheckpointData2NV-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2* pCopyBufferInfo,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyBuffer2(commandBuffer, pCopyBufferInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyImage2(commandBuffer, pCopyImageInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer,
                                                                  const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer,
                                                                  const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2* pBlitImageInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdBlitImage2(commandBuffer, pBlitImageInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdResolveImage2KHR(VkCommandBuffer commandBuffer,
                                                             const VkResolveImageInfo2* pResolveImageInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_copy_commands2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_copy_commands2});
    skip |= PreCallValidateCmdResolveImage2(commandBuffer, pResolveImageInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer,
                                                                  VkDeviceAddress indirectDeviceAddress,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_maintenance1))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_maintenance1});
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceBufferMemoryRequirementsKHR(VkDevice device,
                                                                              const VkDeviceBufferMemoryRequirements* pInfo,
                                                                              VkMemoryRequirements2* pMemoryRequirements,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance4))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance4});
    skip |= PreCallValidateGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageMemoryRequirementsKHR(VkDevice device,
                                                                             const VkDeviceImageMemoryRequirements* pInfo,
                                                                             VkMemoryRequirements2* pMemoryRequirements,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance4))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance4});
    skip |= PreCallValidateGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageSparseMemoryRequirementsKHR(
    VkDevice device, const VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2* pSparseMemoryRequirements, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance4))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance4});
    skip |= PreCallValidateGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                                  pSparseMemoryRequirements, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                                VkDeviceSize size, VkIndexType indexType,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= ValidateRangedEnum(loc.dot(Field::indexType), vvl::Enum::VkIndexType, indexType,
                               "VUID-vkCmdBindIndexBuffer2KHR-indexType-parameter", VK_NULL_HANDLE);
    if (!skip) skip |= manual_PreCallValidateCmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRenderingAreaGranularityKHR(VkDevice device,
                                                                        const VkRenderingAreaInfoKHR* pRenderingAreaInfo,
                                                                        VkExtent2D* pGranularity,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= ValidateStructType(loc.dot(Field::pRenderingAreaInfo), pRenderingAreaInfo, VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR,
                               true, "VUID-vkGetRenderingAreaGranularityKHR-pRenderingAreaInfo-parameter",
                               "VUID-VkRenderingAreaInfoKHR-sType-sType");
    if (pRenderingAreaInfo != nullptr) {
        [[maybe_unused]] const Location pRenderingAreaInfo_loc = loc.dot(Field::pRenderingAreaInfo);
        skip |= ValidateStructPnext(pRenderingAreaInfo_loc, pRenderingAreaInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderingAreaInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pGranularity), pGranularity,
                                    "VUID-vkGetRenderingAreaGranularityKHR-pGranularity-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceImageSubresourceLayoutKHR(VkDevice device,
                                                                            const VkDeviceImageSubresourceInfoKHR* pInfo,
                                                                            VkSubresourceLayout2KHR* pLayout,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR, true,
                               "VUID-vkGetDeviceImageSubresourceLayoutKHR-pInfo-parameter",
                               "VUID-VkDeviceImageSubresourceInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceImageSubresourceInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateStructType(pInfo_loc.dot(Field::pCreateInfo), pInfo->pCreateInfo, VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, true,
                               "VUID-VkDeviceImageSubresourceInfoKHR-pCreateInfo-parameter", "VUID-VkImageCreateInfo-sType-sType");

        if (pInfo->pCreateInfo != nullptr) {
            [[maybe_unused]] const Location pCreateInfo_loc = pInfo_loc.dot(Field::pCreateInfo);
            constexpr std::array allowed_structs_VkImageCreateInfo = {
                VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

            skip |= ValidateStructPnext(pCreateInfo_loc, pInfo->pCreateInfo->pNext, allowed_structs_VkImageCreateInfo.size(),
                                        allowed_structs_VkImageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkImageCreateInfo-pNext-pNext", "VUID-VkImageCreateInfo-sType-unique", VK_NULL_HANDLE,
                                        true);

            skip |=
                ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits,
                              pInfo->pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageCreateInfo-flags-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageType), vvl::Enum::VkImageType, pInfo->pCreateInfo->imageType,
                                       "VUID-VkImageCreateInfo-imageType-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::format), vvl::Enum::VkFormat, pInfo->pCreateInfo->format,
                                       "VUID-VkImageCreateInfo-format-parameter", VK_NULL_HANDLE);

            // No xml-driven validation

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits,
                                  AllVkSampleCountFlagBits, pInfo->pCreateInfo->samples, kRequiredSingleBit, VK_NULL_HANDLE,
                                  "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::tiling), vvl::Enum::VkImageTiling, pInfo->pCreateInfo->tiling,
                                       "VUID-VkImageCreateInfo-tiling-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pCreateInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits,
                                  AllVkImageUsageFlagBits, pInfo->pCreateInfo->usage, kRequiredFlags, VK_NULL_HANDLE,
                                  "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

            skip |=
                ValidateRangedEnum(pCreateInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                   pInfo->pCreateInfo->sharingMode, "VUID-VkImageCreateInfo-sharingMode-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                                       pInfo->pCreateInfo->initialLayout, "VUID-VkImageCreateInfo-initialLayout-parameter",
                                       VK_NULL_HANDLE);
        }

        skip |= ValidateStructType(
            pInfo_loc.dot(Field::pSubresource), pInfo->pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, true,
            "VUID-VkDeviceImageSubresourceInfoKHR-pSubresource-parameter", "VUID-VkImageSubresource2KHR-sType-sType");

        if (pInfo->pSubresource != nullptr) {
            [[maybe_unused]] const Location pSubresource_loc = pInfo_loc.dot(Field::pSubresource);
            skip |= ValidateStructPnext(pSubresource_loc, pInfo->pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkImageSubresource2KHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pSubresource_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pInfo->pSubresource->imageSubresource.aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresource-aspectMask-parameter",
                                  "VUID-VkImageSubresource-aspectMask-requiredbitmask");
        }
    }
    skip |= ValidateStructType(loc.dot(Field::pLayout), pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, true,
                               "VUID-vkGetDeviceImageSubresourceLayoutKHR-pLayout-parameter",
                               "VUID-VkSubresourceLayout2KHR-sType-sType");
    if (pLayout != nullptr) {
        [[maybe_unused]] const Location pLayout_loc = loc.dot(Field::pLayout);
        constexpr std::array allowed_structs_VkSubresourceLayout2KHR = {VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                                                                        VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT};

        skip |= ValidateStructPnext(pLayout_loc, pLayout->pNext, allowed_structs_VkSubresourceLayout2KHR.size(),
                                    allowed_structs_VkSubresourceLayout2KHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSubresourceLayout2KHR-pNext-pNext", "VUID-VkSubresourceLayout2KHR-sType-unique",
                                    VK_NULL_HANDLE, false);
    }
    if (!skip) skip |= manual_PreCallValidateGetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSubresourceLayout2KHR(VkDevice device, VkImage image,
                                                                       const VkImageSubresource2KHR* pSubresource,
                                                                       VkSubresourceLayout2KHR* pLayout,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance5) && loc.function == vvl::Func::vkGetImageSubresourceLayout2KHR)
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance5});
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateStructType(loc.dot(Field::pSubresource), pSubresource, VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, true,
                               "VUID-vkGetImageSubresourceLayout2KHR-pSubresource-parameter",
                               "VUID-VkImageSubresource2KHR-sType-sType");
    if (pSubresource != nullptr) {
        [[maybe_unused]] const Location pSubresource_loc = loc.dot(Field::pSubresource);
        skip |= ValidateStructPnext(pSubresource_loc, pSubresource->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageSubresource2KHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pSubresource_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                              AllVkImageAspectFlagBits, pSubresource->imageSubresource.aspectMask, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkImageSubresource-aspectMask-parameter", "VUID-VkImageSubresource-aspectMask-requiredbitmask");
    }
    skip |=
        ValidateStructType(loc.dot(Field::pLayout), pLayout, VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, true,
                           "VUID-vkGetImageSubresourceLayout2KHR-pLayout-parameter", "VUID-VkSubresourceLayout2KHR-sType-sType");
    if (pLayout != nullptr) {
        [[maybe_unused]] const Location pLayout_loc = loc.dot(Field::pLayout);
        constexpr std::array allowed_structs_VkSubresourceLayout2KHR = {VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
                                                                        VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT};

        skip |= ValidateStructPnext(pLayout_loc, pLayout->pNext, allowed_structs_VkSubresourceLayout2KHR.size(),
                                    allowed_structs_VkSubresourceLayout2KHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSubresourceLayout2KHR-pNext-pNext", "VUID-VkSubresourceLayout2KHR-sType-unique",
                                    VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePipelineBinariesKHR(VkDevice device,
                                                                   const VkPipelineBinaryCreateInfoKHR* pCreateInfo,
                                                                   const VkAllocationCallbacks* pAllocator,
                                                                   VkPipelineBinaryHandlesInfoKHR* pBinaries,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR, true,
                               "VUID-vkCreatePipelineBinariesKHR-pCreateInfo-parameter",
                               "VUID-VkPipelineBinaryCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineBinaryCreateInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        if (pCreateInfo->pKeysAndDataInfo != nullptr) {
            [[maybe_unused]] const Location pKeysAndDataInfo_loc = pCreateInfo_loc.dot(Field::pKeysAndDataInfo);
            skip |= ValidateStructTypeArray(
                pKeysAndDataInfo_loc.dot(Field::binaryCount), pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryKeys),
                pCreateInfo->pKeysAndDataInfo->binaryCount, pCreateInfo->pKeysAndDataInfo->pPipelineBinaryKeys,
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR, true, true, "VUID-VkPipelineBinaryKeyKHR-sType-sType",
                "VUID-VkPipelineBinaryKeysAndDataKHR-pPipelineBinaryKeys-parameter",
                "VUID-VkPipelineBinaryKeysAndDataKHR-binaryCount-arraylength");

            if (pCreateInfo->pKeysAndDataInfo->pPipelineBinaryKeys != nullptr) {
                for (uint32_t binaryIndex = 0; binaryIndex < pCreateInfo->pKeysAndDataInfo->binaryCount; ++binaryIndex) {
                    [[maybe_unused]] const Location pPipelineBinaryKeys_loc =
                        pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryKeys, binaryIndex);
                    skip |= ValidateStructPnext(pPipelineBinaryKeys_loc,
                                                pCreateInfo->pKeysAndDataInfo->pPipelineBinaryKeys[binaryIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkPipelineBinaryKeyKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);
                }
            }

            skip |=
                ValidateArray(pKeysAndDataInfo_loc.dot(Field::binaryCount), pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryData),
                              pCreateInfo->pKeysAndDataInfo->binaryCount, &pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData, true,
                              true, "VUID-VkPipelineBinaryKeysAndDataKHR-binaryCount-arraylength",
                              "VUID-VkPipelineBinaryKeysAndDataKHR-pPipelineBinaryData-parameter");

            if (pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData != nullptr) {
                for (uint32_t binaryIndex = 0; binaryIndex < pCreateInfo->pKeysAndDataInfo->binaryCount; ++binaryIndex) {
                    [[maybe_unused]] const Location pPipelineBinaryData_loc =
                        pKeysAndDataInfo_loc.dot(Field::pPipelineBinaryData, binaryIndex);
                    skip |= ValidateArray(pPipelineBinaryData_loc.dot(Field::dataSize), pPipelineBinaryData_loc.dot(Field::pData),
                                          pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData[binaryIndex].dataSize,
                                          &pCreateInfo->pKeysAndDataInfo->pPipelineBinaryData[binaryIndex].pData, true, true,
                                          "VUID-VkPipelineBinaryDataKHR-dataSize-arraylength",
                                          "VUID-VkPipelineBinaryDataKHR-pData-parameter");
                }
            }
        }

        skip |= ValidateStructType(pCreateInfo_loc.dot(Field::pPipelineCreateInfo), pCreateInfo->pPipelineCreateInfo,
                                   VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR, false,
                                   "VUID-VkPipelineBinaryCreateInfoKHR-pPipelineCreateInfo-parameter",
                                   "VUID-VkPipelineCreateInfoKHR-sType-sType");

        if (pCreateInfo->pPipelineCreateInfo != nullptr) {
            [[maybe_unused]] const Location pPipelineCreateInfo_loc = pCreateInfo_loc.dot(Field::pPipelineCreateInfo);
            // No xml-driven validation
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateStructType(loc.dot(Field::pBinaries), pBinaries, VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR, true,
                               "VUID-vkCreatePipelineBinariesKHR-pBinaries-parameter",
                               "VUID-VkPipelineBinaryHandlesInfoKHR-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary,
                                                                  const VkAllocationCallbacks* pAllocator,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR* pPipelineCreateInfo,
                                                           VkPipelineBinaryKeyKHR* pPipelineKey,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= ValidateStructType(loc.dot(Field::pPipelineCreateInfo), pPipelineCreateInfo, VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR,
                               false, "VUID-vkGetPipelineKeyKHR-pPipelineCreateInfo-parameter",
                               "VUID-VkPipelineCreateInfoKHR-sType-sType");
    if (pPipelineCreateInfo != nullptr) {
        [[maybe_unused]] const Location pPipelineCreateInfo_loc = loc.dot(Field::pPipelineCreateInfo);
        // No xml-driven validation
    }
    skip |= ValidateStructType(loc.dot(Field::pPipelineKey), pPipelineKey, VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR, true,
                               "VUID-vkGetPipelineKeyKHR-pPipelineKey-parameter", "VUID-VkPipelineBinaryKeyKHR-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR* pInfo,
                                                                  VkPipelineBinaryKeyKHR* pPipelineBinaryKey,
                                                                  size_t* pPipelineBinaryDataSize, void* pPipelineBinaryData,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR, true,
                               "VUID-vkGetPipelineBinaryDataKHR-pInfo-parameter", "VUID-VkPipelineBinaryDataInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineBinaryDataInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::pipelineBinary), pInfo->pipelineBinary);
    }
    skip |= ValidateStructType(loc.dot(Field::pPipelineBinaryKey), pPipelineBinaryKey, VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR,
                               true, "VUID-vkGetPipelineBinaryDataKHR-pPipelineBinaryKey-parameter",
                               "VUID-VkPipelineBinaryKeyKHR-sType-sType");
    skip |= ValidatePointerArray(loc.dot(Field::pPipelineBinaryDataSize), loc.dot(Field::pPipelineBinaryData),
                                 pPipelineBinaryDataSize, &pPipelineBinaryData, true, false, false,
                                 "VUID-vkGetPipelineBinaryDataKHR-pPipelineBinaryDataSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetPipelineBinaryDataKHR-pPipelineBinaryData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseCapturedPipelineDataKHR(VkDevice device,
                                                                        const VkReleaseCapturedPipelineDataInfoKHR* pInfo,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_pipeline_binary))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_pipeline_binary});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR, true,
                               "VUID-vkReleaseCapturedPipelineDataKHR-pInfo-parameter",
                               "VUID-VkReleaseCapturedPipelineDataInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkReleaseCapturedPipelineDataInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::pipeline), pInfo->pipeline);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCooperativeMatrixPropertiesKHR(
    VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidateStructTypeArray(loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
                                VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR, true, false, false,
                                "VUID-VkCooperativeMatrixPropertiesKHR-sType-sType",
                                "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR-pProperties-parameter",
                                "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCooperativeMatrixPropertiesKHR-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                                              uint16_t lineStipplePattern, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_line_rasterization) && loc.function == vvl::Func::vkCmdSetLineStippleKHR)
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_line_rasterization});
    // No xml-driven validation
    if (!skip) skip |= manual_PreCallValidateCmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice,
                                                                                      uint32_t* pTimeDomainCount,
                                                                                      VkTimeDomainKHR* pTimeDomains,
                                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |=
        ValidatePointerArray(loc.dot(Field::pTimeDomainCount), loc.dot(Field::pTimeDomains), pTimeDomainCount, &pTimeDomains, true,
                             false, false, "VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsKHR-pTimeDomainCount-parameter",
                             kVUIDUndefined, "VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsKHR-pTimeDomains-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount,
                                                                    const VkCalibratedTimestampInfoKHR* pTimestampInfos,
                                                                    uint64_t* pTimestamps, uint64_t* pMaxDeviation,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_calibrated_timestamps) && loc.function == vvl::Func::vkGetCalibratedTimestampsKHR)
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_calibrated_timestamps});
    skip |= ValidateStructTypeArray(loc.dot(Field::timestampCount), loc.dot(Field::pTimestampInfos), timestampCount,
                                    pTimestampInfos, VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR, true, true,
                                    "VUID-VkCalibratedTimestampInfoKHR-sType-sType",
                                    "VUID-vkGetCalibratedTimestampsKHR-pTimestampInfos-parameter",
                                    "VUID-vkGetCalibratedTimestampsKHR-timestampCount-arraylength");
    if (pTimestampInfos != nullptr) {
        for (uint32_t timestampIndex = 0; timestampIndex < timestampCount; ++timestampIndex) {
            [[maybe_unused]] const Location pTimestampInfos_loc = loc.dot(Field::pTimestampInfos, timestampIndex);
            skip |= ValidateStructPnext(pTimestampInfos_loc, pTimestampInfos[timestampIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkCalibratedTimestampInfoKHR-pNext-pNext",
                                        kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pTimestampInfos_loc.dot(Field::timeDomain), vvl::Enum::VkTimeDomainKHR,
                                       pTimestampInfos[timestampIndex].timeDomain,
                                       "VUID-VkCalibratedTimestampInfoKHR-timeDomain-parameter", VK_NULL_HANDLE);
        }
    }
    skip |= ValidateArray(loc.dot(Field::timestampCount), loc.dot(Field::pTimestamps), timestampCount, &pTimestamps, true, true,
                          "VUID-vkGetCalibratedTimestampsKHR-timestampCount-arraylength",
                          "VUID-vkGetCalibratedTimestampsKHR-pTimestamps-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::pMaxDeviation), pMaxDeviation,
                                    "VUID-vkGetCalibratedTimestampsKHR-pMaxDeviation-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer,
                                                                   const VkBindDescriptorSetsInfoKHR* pBindDescriptorSetsInfo,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance6))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= ValidateStructType(
        loc.dot(Field::pBindDescriptorSetsInfo), pBindDescriptorSetsInfo, VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR, true,
        "VUID-vkCmdBindDescriptorSets2KHR-pBindDescriptorSetsInfo-parameter", "VUID-VkBindDescriptorSetsInfoKHR-sType-sType");
    if (pBindDescriptorSetsInfo != nullptr) {
        [[maybe_unused]] const Location pBindDescriptorSetsInfo_loc = loc.dot(Field::pBindDescriptorSetsInfo);
        constexpr std::array allowed_structs_VkBindDescriptorSetsInfoKHR = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= ValidateStructPnext(
            pBindDescriptorSetsInfo_loc, pBindDescriptorSetsInfo->pNext, allowed_structs_VkBindDescriptorSetsInfoKHR.size(),
            allowed_structs_VkBindDescriptorSetsInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkBindDescriptorSetsInfoKHR-pNext-pNext", "VUID-VkBindDescriptorSetsInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pBindDescriptorSetsInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pBindDescriptorSetsInfo->stageFlags, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkBindDescriptorSetsInfoKHR-stageFlags-parameter",
                              "VUID-VkBindDescriptorSetsInfoKHR-stageFlags-requiredbitmask");

        skip |= ValidateHandleArray(pBindDescriptorSetsInfo_loc.dot(Field::descriptorSetCount),
                                    pBindDescriptorSetsInfo_loc.dot(Field::pDescriptorSets),
                                    pBindDescriptorSetsInfo->descriptorSetCount, pBindDescriptorSetsInfo->pDescriptorSets, true,
                                    true, "VUID-VkBindDescriptorSetsInfoKHR-descriptorSetCount-arraylength");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushConstants2KHR(VkCommandBuffer commandBuffer,
                                                              const VkPushConstantsInfoKHR* pPushConstantsInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance6))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |=
        ValidateStructType(loc.dot(Field::pPushConstantsInfo), pPushConstantsInfo, VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR, true,
                           "VUID-vkCmdPushConstants2KHR-pPushConstantsInfo-parameter", "VUID-VkPushConstantsInfoKHR-sType-sType");
    if (pPushConstantsInfo != nullptr) {
        [[maybe_unused]] const Location pPushConstantsInfo_loc = loc.dot(Field::pPushConstantsInfo);
        constexpr std::array allowed_structs_VkPushConstantsInfoKHR = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= ValidateStructPnext(pPushConstantsInfo_loc, pPushConstantsInfo->pNext,
                                    allowed_structs_VkPushConstantsInfoKHR.size(), allowed_structs_VkPushConstantsInfoKHR.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkPushConstantsInfoKHR-pNext-pNext",
                                    "VUID-VkPushConstantsInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pPushConstantsInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pPushConstantsInfo->stageFlags, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkPushConstantsInfoKHR-stageFlags-parameter",
                              "VUID-VkPushConstantsInfoKHR-stageFlags-requiredbitmask");

        skip |= ValidateArray(pPushConstantsInfo_loc.dot(Field::size), pPushConstantsInfo_loc.dot(Field::pValues),
                              pPushConstantsInfo->size, &pPushConstantsInfo->pValues, true, true,
                              "VUID-VkPushConstantsInfoKHR-size-arraylength", "VUID-VkPushConstantsInfoKHR-pValues-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdPushConstants2KHR(commandBuffer, pPushConstantsInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer,
                                                                  const VkPushDescriptorSetInfoKHR* pPushDescriptorSetInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance6))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= ValidateStructType(
        loc.dot(Field::pPushDescriptorSetInfo), pPushDescriptorSetInfo, VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR, true,
        "VUID-vkCmdPushDescriptorSet2KHR-pPushDescriptorSetInfo-parameter", "VUID-VkPushDescriptorSetInfoKHR-sType-sType");
    if (pPushDescriptorSetInfo != nullptr) {
        [[maybe_unused]] const Location pPushDescriptorSetInfo_loc = loc.dot(Field::pPushDescriptorSetInfo);
        constexpr std::array allowed_structs_VkPushDescriptorSetInfoKHR = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= ValidateStructPnext(
            pPushDescriptorSetInfo_loc, pPushDescriptorSetInfo->pNext, allowed_structs_VkPushDescriptorSetInfoKHR.size(),
            allowed_structs_VkPushDescriptorSetInfoKHR.data(), GeneratedVulkanHeaderVersion,
            "VUID-VkPushDescriptorSetInfoKHR-pNext-pNext", "VUID-VkPushDescriptorSetInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pPushDescriptorSetInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pPushDescriptorSetInfo->stageFlags, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkPushDescriptorSetInfoKHR-stageFlags-parameter",
                              "VUID-VkPushDescriptorSetInfoKHR-stageFlags-requiredbitmask");

        skip |= ValidateStructTypeArray(pPushDescriptorSetInfo_loc.dot(Field::descriptorWriteCount),
                                        pPushDescriptorSetInfo_loc.dot(Field::pDescriptorWrites),
                                        pPushDescriptorSetInfo->descriptorWriteCount, pPushDescriptorSetInfo->pDescriptorWrites,
                                        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, true, true, "VUID-VkWriteDescriptorSet-sType-sType",
                                        "VUID-VkPushDescriptorSetInfoKHR-pDescriptorWrites-parameter",
                                        "VUID-VkPushDescriptorSetInfoKHR-descriptorWriteCount-arraylength");

        if (pPushDescriptorSetInfo->pDescriptorWrites != nullptr) {
            for (uint32_t descriptorWriteIndex = 0; descriptorWriteIndex < pPushDescriptorSetInfo->descriptorWriteCount;
                 ++descriptorWriteIndex) {
                [[maybe_unused]] const Location pDescriptorWrites_loc =
                    pPushDescriptorSetInfo_loc.dot(Field::pDescriptorWrites, descriptorWriteIndex);
                constexpr std::array allowed_structs_VkWriteDescriptorSet = {
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
                    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK};

                skip |= ValidateStructPnext(
                    pDescriptorWrites_loc, pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].pNext,
                    allowed_structs_VkWriteDescriptorSet.size(), allowed_structs_VkWriteDescriptorSet.data(),
                    GeneratedVulkanHeaderVersion, "VUID-VkWriteDescriptorSet-pNext-pNext", "VUID-VkWriteDescriptorSet-sType-unique",
                    VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pDescriptorWrites_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType,
                                           pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].descriptorType,
                                           "VUID-VkWriteDescriptorSet-descriptorType-parameter", VK_NULL_HANDLE);

                skip |= ValidateArray(pDescriptorWrites_loc.dot(Field::descriptorCount), loc,
                                      pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].descriptorCount,
                                      &pPushDescriptorSetInfo->pDescriptorWrites[descriptorWriteIndex].pImageInfo, true, false,
                                      "VUID-VkWriteDescriptorSet-descriptorCount-arraylength", kVUIDUndefined);
            }
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPushDescriptorSetWithTemplate2KHR(
    VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance6))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= ValidateStructType(loc.dot(Field::pPushDescriptorSetWithTemplateInfo), pPushDescriptorSetWithTemplateInfo,
                               VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR, true,
                               "VUID-vkCmdPushDescriptorSetWithTemplate2KHR-pPushDescriptorSetWithTemplateInfo-parameter",
                               "VUID-VkPushDescriptorSetWithTemplateInfoKHR-sType-sType");
    if (pPushDescriptorSetWithTemplateInfo != nullptr) {
        [[maybe_unused]] const Location pPushDescriptorSetWithTemplateInfo_loc = loc.dot(Field::pPushDescriptorSetWithTemplateInfo);
        constexpr std::array allowed_structs_VkPushDescriptorSetWithTemplateInfoKHR = {
            VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= ValidateStructPnext(pPushDescriptorSetWithTemplateInfo_loc, pPushDescriptorSetWithTemplateInfo->pNext,
                                    allowed_structs_VkPushDescriptorSetWithTemplateInfoKHR.size(),
                                    allowed_structs_VkPushDescriptorSetWithTemplateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPushDescriptorSetWithTemplateInfoKHR-pNext-pNext",
                                    "VUID-VkPushDescriptorSetWithTemplateInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pPushDescriptorSetWithTemplateInfo_loc.dot(Field::descriptorUpdateTemplate),
                                       pPushDescriptorSetWithTemplateInfo->descriptorUpdateTemplate);

        skip |= ValidateRequiredPointer(pPushDescriptorSetWithTemplateInfo_loc.dot(Field::pData),
                                        pPushDescriptorSetWithTemplateInfo->pData,
                                        "VUID-VkPushDescriptorSetWithTemplateInfoKHR-pData-parameter");
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo,
                                                                           error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDescriptorBufferOffsets2EXT(
    VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance6))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |= ValidateStructType(loc.dot(Field::pSetDescriptorBufferOffsetsInfo), pSetDescriptorBufferOffsetsInfo,
                               VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT, true,
                               "VUID-vkCmdSetDescriptorBufferOffsets2EXT-pSetDescriptorBufferOffsetsInfo-parameter",
                               "VUID-VkSetDescriptorBufferOffsetsInfoEXT-sType-sType");
    if (pSetDescriptorBufferOffsetsInfo != nullptr) {
        [[maybe_unused]] const Location pSetDescriptorBufferOffsetsInfo_loc = loc.dot(Field::pSetDescriptorBufferOffsetsInfo);
        constexpr std::array allowed_structs_VkSetDescriptorBufferOffsetsInfoEXT = {VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= ValidateStructPnext(pSetDescriptorBufferOffsetsInfo_loc, pSetDescriptorBufferOffsetsInfo->pNext,
                                    allowed_structs_VkSetDescriptorBufferOffsetsInfoEXT.size(),
                                    allowed_structs_VkSetDescriptorBufferOffsetsInfoEXT.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkSetDescriptorBufferOffsetsInfoEXT-pNext-pNext",
                                    "VUID-VkSetDescriptorBufferOffsetsInfoEXT-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pSetDescriptorBufferOffsetsInfo_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pSetDescriptorBufferOffsetsInfo->stageFlags, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkSetDescriptorBufferOffsetsInfoEXT-stageFlags-parameter",
                              "VUID-VkSetDescriptorBufferOffsetsInfoEXT-stageFlags-requiredbitmask");

        skip |= ValidateArray(pSetDescriptorBufferOffsetsInfo_loc.dot(Field::setCount),
                              pSetDescriptorBufferOffsetsInfo_loc.dot(Field::pBufferIndices),
                              pSetDescriptorBufferOffsetsInfo->setCount, &pSetDescriptorBufferOffsetsInfo->pBufferIndices, true,
                              true, "VUID-VkSetDescriptorBufferOffsetsInfoEXT-setCount-arraylength",
                              "VUID-VkSetDescriptorBufferOffsetsInfoEXT-pBufferIndices-parameter");

        skip |= ValidateArray(pSetDescriptorBufferOffsetsInfo_loc.dot(Field::setCount),
                              pSetDescriptorBufferOffsetsInfo_loc.dot(Field::pOffsets), pSetDescriptorBufferOffsetsInfo->setCount,
                              &pSetDescriptorBufferOffsetsInfo->pOffsets, true, true,
                              "VUID-VkSetDescriptorBufferOffsetsInfoEXT-setCount-arraylength",
                              "VUID-VkSetDescriptorBufferOffsetsInfoEXT-pOffsets-parameter");
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorBufferEmbeddedSamplers2EXT(
    VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_maintenance6))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_maintenance6});
    skip |=
        ValidateStructType(loc.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo), pBindDescriptorBufferEmbeddedSamplersInfo,
                           VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT, true,
                           "VUID-vkCmdBindDescriptorBufferEmbeddedSamplers2EXT-pBindDescriptorBufferEmbeddedSamplersInfo-parameter",
                           "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-sType-sType");
    if (pBindDescriptorBufferEmbeddedSamplersInfo != nullptr) {
        [[maybe_unused]] const Location pBindDescriptorBufferEmbeddedSamplersInfo_loc =
            loc.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo);
        constexpr std::array allowed_structs_VkBindDescriptorBufferEmbeddedSamplersInfoEXT = {
            VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |= ValidateStructPnext(pBindDescriptorBufferEmbeddedSamplersInfo_loc, pBindDescriptorBufferEmbeddedSamplersInfo->pNext,
                                    allowed_structs_VkBindDescriptorBufferEmbeddedSamplersInfoEXT.size(),
                                    allowed_structs_VkBindDescriptorBufferEmbeddedSamplersInfoEXT.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-pNext-pNext",
                                    "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pBindDescriptorBufferEmbeddedSamplersInfo_loc.dot(Field::stageFlags),
                              vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                              pBindDescriptorBufferEmbeddedSamplersInfo->stageFlags, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-stageFlags-parameter",
                              "VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-stageFlags-requiredbitmask");
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdBindDescriptorBufferEmbeddedSamplers2EXT(
            commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDebugReportCallbackEXT(VkInstance instance,
                                                                      const VkDebugReportCallbackCreateInfoEXT* pCreateInfo,
                                                                      const VkAllocationCallbacks* pAllocator,
                                                                      VkDebugReportCallbackEXT* pCallback,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_report))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_report});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
                               true, "VUID-vkCreateDebugReportCallbackEXT-pCreateInfo-parameter",
                               "VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined,
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkDebugReportFlagBitsEXT,
                              AllVkDebugReportFlagBitsEXT, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter");

        skip |= ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pfnCallback),
                                        reinterpret_cast<const void*>(pCreateInfo->pfnCallback),
                                        "VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pCallback), pCallback, "VUID-vkCreateDebugReportCallbackEXT-pCallback-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_report))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_report});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags,
                                                               VkDebugReportObjectTypeEXT objectType, uint64_t object,
                                                               size_t location, int32_t messageCode, const char* pLayerPrefix,
                                                               const char* pMessage, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_report))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_report});
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkDebugReportFlagBitsEXT, AllVkDebugReportFlagBitsEXT, flags,
                          kRequiredFlags, VK_NULL_HANDLE, "VUID-vkDebugReportMessageEXT-flags-parameter",
                          "VUID-vkDebugReportMessageEXT-flags-requiredbitmask");
    skip |= ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkDebugReportObjectTypeEXT, objectType,
                               "VUID-vkDebugReportMessageEXT-objectType-parameter", VK_NULL_HANDLE);
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pLayerPrefix), pLayerPrefix, "VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::pMessage), pMessage, "VUID-vkDebugReportMessageEXT-pMessage-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |= ValidateStructType(loc.dot(Field::pTagInfo), pTagInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT, true,
                               "VUID-vkDebugMarkerSetObjectTagEXT-pTagInfo-parameter",
                               "VUID-VkDebugMarkerObjectTagInfoEXT-sType-sType");
    if (pTagInfo != nullptr) {
        [[maybe_unused]] const Location pTagInfo_loc = loc.dot(Field::pTagInfo);
        skip |= ValidateStructPnext(pTagInfo_loc, pTagInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugMarkerObjectTagInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pTagInfo_loc.dot(Field::objectType), vvl::Enum::VkDebugReportObjectTypeEXT, pTagInfo->objectType,
                                   "VUID-VkDebugMarkerObjectTagInfoEXT-objectType-parameter", VK_NULL_HANDLE);

        skip |= ValidateArray(pTagInfo_loc.dot(Field::tagSize), pTagInfo_loc.dot(Field::pTag), pTagInfo->tagSize, &pTagInfo->pTag,
                              true, true, "VUID-VkDebugMarkerObjectTagInfoEXT-tagSize-arraylength",
                              "VUID-VkDebugMarkerObjectTagInfoEXT-pTag-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDebugMarkerSetObjectNameEXT(VkDevice device,
                                                                     const VkDebugMarkerObjectNameInfoEXT* pNameInfo,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |= ValidateStructType(loc.dot(Field::pNameInfo), pNameInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT, true,
                               "VUID-vkDebugMarkerSetObjectNameEXT-pNameInfo-parameter",
                               "VUID-VkDebugMarkerObjectNameInfoEXT-sType-sType");
    if (pNameInfo != nullptr) {
        [[maybe_unused]] const Location pNameInfo_loc = loc.dot(Field::pNameInfo);
        skip |= ValidateStructPnext(pNameInfo_loc, pNameInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugMarkerObjectNameInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateRangedEnum(pNameInfo_loc.dot(Field::objectType), vvl::Enum::VkDebugReportObjectTypeEXT, pNameInfo->objectType,
                               "VUID-VkDebugMarkerObjectNameInfoEXT-objectType-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredPointer(pNameInfo_loc.dot(Field::pObjectName), pNameInfo->pObjectName,
                                        "VUID-VkDebugMarkerObjectNameInfoEXT-pObjectName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer,
                                                                const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |=
        ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, true,
                           "VUID-vkCmdDebugMarkerBeginEXT-pMarkerInfo-parameter", "VUID-VkDebugMarkerMarkerInfoEXT-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pMarkerInfo_loc.dot(Field::pMarkerName), pMarkerInfo->pMarkerName,
                                        "VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer,
                                                                 const VkDebugMarkerMarkerInfoEXT* pMarkerInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_debug_marker))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_marker});
    skip |=
        ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, true,
                           "VUID-vkCmdDebugMarkerInsertEXT-pMarkerInfo-parameter", "VUID-VkDebugMarkerMarkerInfoEXT-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pMarkerInfo_loc.dot(Field::pMarkerName), pMarkerInfo->pMarkerName,
                                        "VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                                                            uint32_t bindingCount, const VkBuffer* pBuffers,
                                                                            const VkDeviceSize* pOffsets,
                                                                            const VkDeviceSize* pSizes,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= ValidateHandleArray(loc.dot(Field::bindingCount), loc.dot(Field::pBuffers), bindingCount, pBuffers, true, true,
                                "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength");
    skip |= ValidateArray(loc.dot(Field::bindingCount), loc.dot(Field::pOffsets), bindingCount, &pOffsets, true, true,
                          "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength",
                          "VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-parameter");
    skip |= ValidateArray(loc.dot(Field::bindingCount), loc, bindingCount, &pSizes, true, false,
                          "VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength", kVUIDUndefined);
    if (!skip)
        skip |= manual_PreCallValidateCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers,
                                                                         pOffsets, pSizes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                                                      uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                                                      const VkDeviceSize* pCounterBufferOffsets,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    // No xml-driven validation
    if (!skip)
        skip |= manual_PreCallValidateCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                                                   pCounterBuffers, pCounterBufferOffsets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                                                    uint32_t counterBufferCount, const VkBuffer* pCounterBuffers,
                                                                    const VkDeviceSize* pCounterBufferOffsets,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    // No xml-driven validation
    if (!skip)
        skip |= manual_PreCallValidateCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount,
                                                                 pCounterBuffers, pCounterBufferOffsets, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                                                 uint32_t query, VkQueryControlFlags flags, uint32_t index,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkQueryControlFlagBits, AllVkQueryControlFlagBits, flags,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdBeginQueryIndexedEXT-flags-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                                               uint32_t index, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount,
                                                                     uint32_t firstInstance, VkBuffer counterBuffer,
                                                                     VkDeviceSize counterBufferOffset, uint32_t counterOffset,
                                                                     uint32_t vertexStride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_transform_feedback))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_transform_feedback});
    skip |= ValidateRequiredHandle(loc.dot(Field::counterBuffer), counterBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCuModuleNVX(VkDevice device, const VkCuModuleCreateInfoNVX* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX, true,
                               "VUID-vkCreateCuModuleNVX-pCreateInfo-parameter", "VUID-VkCuModuleCreateInfoNVX-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCuModuleCreateInfoNVX-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::dataSize), pCreateInfo_loc.dot(Field::pData), pCreateInfo->dataSize,
                              &pCreateInfo->pData, false, true, kVUIDUndefined, "VUID-VkCuModuleCreateInfoNVX-pData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pModule), pModule, "VUID-vkCreateCuModuleNVX-pModule-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCuFunctionNVX(VkDevice device, const VkCuFunctionCreateInfoNVX* pCreateInfo,
                                                             const VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX, true,
                               "VUID-vkCreateCuFunctionNVX-pCreateInfo-parameter", "VUID-VkCuFunctionCreateInfoNVX-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCuFunctionCreateInfoNVX-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::module), pCreateInfo->module);

        skip |= ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pName), pCreateInfo->pName,
                                        "VUID-VkCuFunctionCreateInfoNVX-pName-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFunction), pFunction, "VUID-vkCreateCuFunctionNVX-pFunction-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= ValidateRequiredHandle(loc.dot(Field::module), module);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX function,
                                                              const VkAllocationCallbacks* pAllocator,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= ValidateRequiredHandle(loc.dot(Field::function), function);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX* pLaunchInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_binary_import))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_binary_import});
    skip |= ValidateStructType(loc.dot(Field::pLaunchInfo), pLaunchInfo, VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX, true,
                               "VUID-vkCmdCuLaunchKernelNVX-pLaunchInfo-parameter", "VUID-VkCuLaunchInfoNVX-sType-sType");
    if (pLaunchInfo != nullptr) {
        [[maybe_unused]] const Location pLaunchInfo_loc = loc.dot(Field::pLaunchInfo);
        skip |= ValidateStructPnext(pLaunchInfo_loc, pLaunchInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCuLaunchInfoNVX-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pLaunchInfo_loc.dot(Field::function), pLaunchInfo->function);

        skip |= ValidateArray(pLaunchInfo_loc.dot(Field::paramCount), pLaunchInfo_loc.dot(Field::pParams), pLaunchInfo->paramCount,
                              &pLaunchInfo->pParams, false, true, kVUIDUndefined, "VUID-VkCuLaunchInfoNVX-pParams-parameter");

        skip |= ValidateArray(pLaunchInfo_loc.dot(Field::extraCount), pLaunchInfo_loc.dot(Field::pExtras), pLaunchInfo->extraCount,
                              &pLaunchInfo->pExtras, false, true, kVUIDUndefined, "VUID-VkCuLaunchInfoNVX-pExtras-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX* pInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_image_view_handle))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_image_view_handle});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX, true,
                               "VUID-vkGetImageViewHandleNVX-pInfo-parameter", "VUID-VkImageViewHandleInfoNVX-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageViewHandleInfoNVX-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::imageView), pInfo->imageView);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::descriptorType), vvl::Enum::VkDescriptorType, pInfo->descriptorType,
                                   "VUID-VkImageViewHandleInfoNVX-descriptorType-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageViewAddressNVX(VkDevice device, VkImageView imageView,
                                                                VkImageViewAddressPropertiesNVX* pProperties,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nvx_image_view_handle))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NVX_image_view_handle});
    skip |= ValidateRequiredHandle(loc.dot(Field::imageView), imageView);
    skip |= ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX, true,
                               "VUID-vkGetImageViewAddressNVX-pProperties-parameter",
                               "VUID-VkImageViewAddressPropertiesNVX-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |= ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageViewAddressPropertiesNVX-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                 VkDeviceSize offset, VkBuffer countBuffer,
                                                                 VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                 uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride,
                                                error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                        VkDeviceSize offset, VkBuffer countBuffer,
                                                                        VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                        uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_draw_indirect_count))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_draw_indirect_count});
    skip |= PreCallValidateCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                                       stride, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage,
                                                          VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_shader_info))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_shader_info});
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= ValidateFlags(loc.dot(Field::shaderStage), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                          shaderStage, kRequiredSingleBit, VK_NULL_HANDLE, "VUID-vkGetShaderInfoAMD-shaderStage-parameter",
                          "VUID-vkGetShaderInfoAMD-shaderStage-parameter");
    skip |= ValidateRangedEnum(loc.dot(Field::infoType), vvl::Enum::VkShaderInfoTypeAMD, infoType,
                               "VUID-vkGetShaderInfoAMD-infoType-parameter", VK_NULL_HANDLE);
    skip |= ValidatePointerArray(loc.dot(Field::pInfoSize), loc.dot(Field::pInfo), pInfoSize, &pInfo, true, false, false,
                                 "VUID-vkGetShaderInfoAMD-pInfoSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetShaderInfoAMD-pInfo-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_GGP
bool StatelessValidation::PreCallValidateCreateStreamDescriptorSurfaceGGP(VkInstance instance,
                                                                          const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo,
                                                                          const VkAllocationCallbacks* pAllocator,
                                                                          VkSurfaceKHR* pSurface,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ggp_stream_descriptor_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_GGP_stream_descriptor_surface});
    skip |= ValidateStructType(
        loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP, true,
        "VUID-vkCreateStreamDescriptorSurfaceGGP-pCreateInfo-parameter", "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkStreamDescriptorSurfaceCreateInfoGGP-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateStreamDescriptorSurfaceGGP-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_GGP

bool StatelessValidation::PreCallValidateGetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage,
    VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_nv_external_memory_capabilities))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_external_memory_capabilities});
    skip |= ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, format,
                               "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-format-parameter", physicalDevice);
    skip |= ValidateRangedEnum(loc.dot(Field::type), vvl::Enum::VkImageType, type,
                               "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-type-parameter", physicalDevice);
    skip |= ValidateRangedEnum(loc.dot(Field::tiling), vvl::Enum::VkImageTiling, tiling,
                               "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-tiling-parameter", physicalDevice);
    skip |= ValidateFlags(loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits, usage,
                          kRequiredFlags, physicalDevice, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-parameter",
                          "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-requiredbitmask");
    skip |=
        ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits, AllVkImageCreateFlagBits, flags,
                      kOptionalFlags, physicalDevice, "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-flags-parameter");
    skip |= ValidateFlags(loc.dot(Field::externalHandleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                          AllVkExternalMemoryHandleTypeFlagBitsNV, externalHandleType, kOptionalFlags, physicalDevice,
                          "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-externalHandleType-parameter");
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pExternalImageFormatProperties), pExternalImageFormatProperties,
                                "VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-pExternalImageFormatProperties-parameter");
    if (pExternalImageFormatProperties != nullptr) {
        [[maybe_unused]] const Location pExternalImageFormatProperties_loc = loc.dot(Field::pExternalImageFormatProperties);
        // No xml-driven validation
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory,
                                                                VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_external_memory_win32))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_external_memory_win32});
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    skip |= ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBitsNV,
                          AllVkExternalMemoryHandleTypeFlagBitsNV, handleType, kRequiredFlags, VK_NULL_HANDLE,
                          "VUID-vkGetMemoryWin32HandleNV-handleType-parameter",
                          "VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask");
    skip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, "VUID-vkGetMemoryWin32HandleNV-pHandle-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_VI_NN
bool StatelessValidation::PreCallValidateCreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_nn_vi_surface)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NN_vi_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN, true,
                               "VUID-vkCreateViSurfaceNN-pCreateInfo-parameter", "VUID-VkViSurfaceCreateInfoNN-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkViSurfaceCreateInfoNN-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateViSurfaceNN-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_VI_NN

bool StatelessValidation::PreCallValidateCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_conditional_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_conditional_rendering});
    skip |= ValidateStructType(loc.dot(Field::pConditionalRenderingBegin), pConditionalRenderingBegin,
                               VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT, true,
                               "VUID-vkCmdBeginConditionalRenderingEXT-pConditionalRenderingBegin-parameter",
                               "VUID-VkConditionalRenderingBeginInfoEXT-sType-sType");
    if (pConditionalRenderingBegin != nullptr) {
        [[maybe_unused]] const Location pConditionalRenderingBegin_loc = loc.dot(Field::pConditionalRenderingBegin);
        skip |= ValidateStructPnext(pConditionalRenderingBegin_loc, pConditionalRenderingBegin->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkConditionalRenderingBeginInfoEXT-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pConditionalRenderingBegin_loc.dot(Field::buffer), pConditionalRenderingBegin->buffer);

        skip |= ValidateFlags(pConditionalRenderingBegin_loc.dot(Field::flags), vvl::FlagBitmask::VkConditionalRenderingFlagBitsEXT,
                              AllVkConditionalRenderingFlagBitsEXT, pConditionalRenderingBegin->flags, kOptionalFlags,
                              VK_NULL_HANDLE, "VUID-VkConditionalRenderingBeginInfoEXT-flags-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_conditional_rendering))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_conditional_rendering});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                                  uint32_t viewportCount,
                                                                  const VkViewportWScalingNV* pViewportWScalings,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_clip_space_w_scaling))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_clip_space_w_scaling});
    skip |= ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewportWScalings), viewportCount, &pViewportWScalings,
                          true, true, "VUID-vkCmdSetViewportWScalingNV-viewportCount-arraylength",
                          "VUID-vkCmdSetViewportWScalingNV-pViewportWScalings-parameter");
    if (pViewportWScalings != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewportWScalings_loc = loc.dot(Field::pViewportWScalings, viewportIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings,
                                                               error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_direct_mode_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_direct_mode_display});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
bool StatelessValidation::PreCallValidateAcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_acquire_xlib_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});
    skip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, "VUID-vkAcquireXlibDisplayEXT-dpy-parameter");
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput,
                                                                  VkDisplayKHR* pDisplay, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_acquire_xlib_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});
    skip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, "VUID-vkGetRandROutputDisplayEXT-dpy-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::pDisplay), pDisplay, "VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_XLIB_XRANDR_EXT

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice,
                                                                                  VkSurfaceKHR surface,
                                                                                  VkSurfaceCapabilities2EXT* pSurfaceCapabilities,
                                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_display_surface_counter))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_surface_counter});
    skip |= ValidateRequiredHandle(loc.dot(Field::surface), surface);
    skip |=
        ValidateStructType(loc.dot(Field::pSurfaceCapabilities), pSurfaceCapabilities, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
                           true, "VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter",
                           "VUID-VkSurfaceCapabilities2EXT-sType-sType");
    if (pSurfaceCapabilities != nullptr) {
        [[maybe_unused]] const Location pSurfaceCapabilities_loc = loc.dot(Field::pSurfaceCapabilities);
        skip |= ValidateStructPnext(pSurfaceCapabilities_loc, pSurfaceCapabilities->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSurfaceCapabilities2EXT-pNext-pNext", kVUIDUndefined, physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display,
                                                                const VkDisplayPowerInfoEXT* pDisplayPowerInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |=
        ValidateStructType(loc.dot(Field::pDisplayPowerInfo), pDisplayPowerInfo, VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT, true,
                           "VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter", "VUID-VkDisplayPowerInfoEXT-sType-sType");
    if (pDisplayPowerInfo != nullptr) {
        [[maybe_unused]] const Location pDisplayPowerInfo_loc = loc.dot(Field::pDisplayPowerInfo);
        skip |= ValidateStructPnext(pDisplayPowerInfo_loc, pDisplayPowerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayPowerInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateRangedEnum(pDisplayPowerInfo_loc.dot(Field::powerState), vvl::Enum::VkDisplayPowerStateEXT,
                               pDisplayPowerInfo->powerState, "VUID-VkDisplayPowerInfoEXT-powerState-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo,
                                                                const VkAllocationCallbacks* pAllocator, VkFence* pFence,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= ValidateStructType(loc.dot(Field::pDeviceEventInfo), pDeviceEventInfo, VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT, true,
                               "VUID-vkRegisterDeviceEventEXT-pDeviceEventInfo-parameter", "VUID-VkDeviceEventInfoEXT-sType-sType");
    if (pDeviceEventInfo != nullptr) {
        [[maybe_unused]] const Location pDeviceEventInfo_loc = loc.dot(Field::pDeviceEventInfo);
        skip |= ValidateStructPnext(pDeviceEventInfo_loc, pDeviceEventInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceEventInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateRangedEnum(pDeviceEventInfo_loc.dot(Field::deviceEvent), vvl::Enum::VkDeviceEventTypeEXT,
                               pDeviceEventInfo->deviceEvent, "VUID-VkDeviceEventInfoEXT-deviceEvent-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFence), pFence, "VUID-vkRegisterDeviceEventEXT-pFence-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display,
                                                                 const VkDisplayEventInfoEXT* pDisplayEventInfo,
                                                                 const VkAllocationCallbacks* pAllocator, VkFence* pFence,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    skip |=
        ValidateStructType(loc.dot(Field::pDisplayEventInfo), pDisplayEventInfo, VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT, true,
                           "VUID-vkRegisterDisplayEventEXT-pDisplayEventInfo-parameter", "VUID-VkDisplayEventInfoEXT-sType-sType");
    if (pDisplayEventInfo != nullptr) {
        [[maybe_unused]] const Location pDisplayEventInfo_loc = loc.dot(Field::pDisplayEventInfo);
        skip |= ValidateStructPnext(pDisplayEventInfo_loc, pDisplayEventInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDisplayEventInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pDisplayEventInfo_loc.dot(Field::displayEvent), vvl::Enum::VkDisplayEventTypeEXT,
                                   pDisplayEventInfo->displayEvent, "VUID-VkDisplayEventInfoEXT-displayEvent-parameter",
                                   VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFence), pFence, "VUID-vkRegisterDisplayEventEXT-pFence-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain,
                                                                VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_display_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_display_control});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidateFlags(loc.dot(Field::counter), vvl::FlagBitmask::VkSurfaceCounterFlagBitsEXT, AllVkSurfaceCounterFlagBitsEXT,
                          counter, kRequiredSingleBit, VK_NULL_HANDLE, "VUID-vkGetSwapchainCounterEXT-counter-parameter",
                          "VUID-vkGetSwapchainCounterEXT-counter-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::pCounterValue), pCounterValue,
                                    "VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain,
                                                                       VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_google_display_timing))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_GOOGLE_display_timing});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidateRequiredPointer(loc.dot(Field::pDisplayTimingProperties), pDisplayTimingProperties,
                                    "VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter");
    if (pDisplayTimingProperties != nullptr) {
        [[maybe_unused]] const Location pDisplayTimingProperties_loc = loc.dot(Field::pDisplayTimingProperties);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain,
                                                                         uint32_t* pPresentationTimingCount,
                                                                         VkPastPresentationTimingGOOGLE* pPresentationTimings,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_google_display_timing))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_GOOGLE_display_timing});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidatePointerArray(loc.dot(Field::pPresentationTimingCount), loc.dot(Field::pPresentationTimings),
                                 pPresentationTimingCount, &pPresentationTimings, true, false, false,
                                 "VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimingCount-parameter", kVUIDUndefined,
                                 "VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter");
    if (pPresentationTimings != nullptr) {
        for (uint32_t pPresentationTimingIndex = 0; pPresentationTimingIndex < *pPresentationTimingCount;
             ++pPresentationTimingIndex) {
            [[maybe_unused]] const Location pPresentationTimings_loc =
                loc.dot(Field::pPresentationTimings, pPresentationTimingIndex);
            // No xml-driven validation
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle,
                                                                   uint32_t discardRectangleCount,
                                                                   const VkRect2D* pDiscardRectangles,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_discard_rectangles});
    skip |= ValidateArray(loc.dot(Field::discardRectangleCount), loc.dot(Field::pDiscardRectangles), discardRectangleCount,
                          &pDiscardRectangles, true, true, "VUID-vkCmdSetDiscardRectangleEXT-discardRectangleCount-arraylength",
                          "VUID-vkCmdSetDiscardRectangleEXT-pDiscardRectangles-parameter");
    if (pDiscardRectangles != nullptr) {
        for (uint32_t discardRectangleIndex = 0; discardRectangleIndex < discardRectangleCount; ++discardRectangleIndex) {
            [[maybe_unused]] const Location pDiscardRectangles_loc = loc.dot(Field::pDiscardRectangles, discardRectangleIndex);
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount,
                                                                pDiscardRectangles, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer,
                                                                         VkBool32 discardRectangleEnable,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_discard_rectangles});
    skip |= ValidateBool32(loc.dot(Field::discardRectangleEnable), discardRectangleEnable);
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer,
                                                                       VkDiscardRectangleModeEXT discardRectangleMode,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_discard_rectangles))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_discard_rectangles});
    skip |= ValidateRangedEnum(loc.dot(Field::discardRectangleMode), vvl::Enum::VkDiscardRectangleModeEXT, discardRectangleMode,
                               "VUID-vkCmdSetDiscardRectangleModeEXT-discardRectangleMode-parameter", VK_NULL_HANDLE);
    if (!skip) skip |= manual_PreCallValidateCmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount,
                                                           const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_hdr_metadata))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_hdr_metadata});
    skip |= ValidateHandleArray(loc.dot(Field::swapchainCount), loc.dot(Field::pSwapchains), swapchainCount, pSwapchains, true,
                                true, "VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength");
    skip |= ValidateStructTypeArray(loc.dot(Field::swapchainCount), loc.dot(Field::pMetadata), swapchainCount, pMetadata,
                                    VK_STRUCTURE_TYPE_HDR_METADATA_EXT, true, true, "VUID-VkHdrMetadataEXT-sType-sType",
                                    "VUID-vkSetHdrMetadataEXT-pMetadata-parameter",
                                    "VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength");
    if (pMetadata != nullptr) {
        for (uint32_t swapchainIndex = 0; swapchainIndex < swapchainCount; ++swapchainIndex) {
            [[maybe_unused]] const Location pMetadata_loc = loc.dot(Field::pMetadata, swapchainIndex);
            skip |= ValidateStructPnext(pMetadata_loc, pMetadata[swapchainIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkHdrMetadataEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_IOS_MVK
bool StatelessValidation::PreCallValidateCreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo,
                                                             const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_mvk_ios_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_MVK_ios_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK, true,
                               "VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter", "VUID-VkIOSSurfaceCreateInfoMVK-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateIOSSurfaceMVK-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
bool StatelessValidation::PreCallValidateCreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo,
                                                               const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_mvk_macos_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_MVK_macos_surface});
    skip |=
        ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK, true,
                           "VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter", "VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_MACOS_MVK

bool StatelessValidation::PreCallValidateSetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= ValidateStructType(loc.dot(Field::pNameInfo), pNameInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, true,
                               "VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-parameter",
                               "VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType");
    if (pNameInfo != nullptr) {
        [[maybe_unused]] const Location pNameInfo_loc = loc.dot(Field::pNameInfo);
        skip |= ValidateStructPnext(pNameInfo_loc, pNameInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined,
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pNameInfo_loc.dot(Field::objectType), vvl::Enum::VkObjectType, pNameInfo->objectType,
                                   "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateSetDebugUtilsObjectNameEXT(device, pNameInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateSetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |=
        ValidateStructType(loc.dot(Field::pTagInfo), pTagInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT, true,
                           "VUID-vkSetDebugUtilsObjectTagEXT-pTagInfo-parameter", "VUID-VkDebugUtilsObjectTagInfoEXT-sType-sType");
    if (pTagInfo != nullptr) {
        [[maybe_unused]] const Location pTagInfo_loc = loc.dot(Field::pTagInfo);
        skip |= ValidateStructPnext(pTagInfo_loc, pTagInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugUtilsObjectTagInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pTagInfo_loc.dot(Field::objectType), vvl::Enum::VkObjectType, pTagInfo->objectType,
                                   "VUID-VkDebugUtilsObjectTagInfoEXT-objectType-parameter", VK_NULL_HANDLE);

        skip |= ValidateArray(pTagInfo_loc.dot(Field::tagSize), pTagInfo_loc.dot(Field::pTag), pTagInfo->tagSize, &pTagInfo->pTag,
                              true, true, "VUID-VkDebugUtilsObjectTagInfoEXT-tagSize-arraylength",
                              "VUID-VkDebugUtilsObjectTagInfoEXT-pTag-parameter");
    }
    if (!skip) skip |= manual_PreCallValidateSetDebugUtilsObjectTagEXT(device, pTagInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateQueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                               "VUID-vkQueueBeginDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                        "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateQueueEndDebugUtilsLabelEXT(VkQueue queue, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateQueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |=
        ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                           "VUID-vkQueueInsertDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                        "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer,
                                                                    const VkDebugUtilsLabelEXT* pLabelInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                               "VUID-vkCmdBeginDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                        "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer,
                                                                     const VkDebugUtilsLabelEXT* pLabelInfo,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= ValidateStructType(loc.dot(Field::pLabelInfo), pLabelInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, true,
                               "VUID-vkCmdInsertDebugUtilsLabelEXT-pLabelInfo-parameter", "VUID-VkDebugUtilsLabelEXT-sType-sType");
    if (pLabelInfo != nullptr) {
        [[maybe_unused]] const Location pLabelInfo_loc = loc.dot(Field::pLabelInfo);
        skip |= ValidateStructPnext(pLabelInfo_loc, pLabelInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pLabelInfo_loc.dot(Field::pLabelName), pLabelInfo->pLabelName,
                                        "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateDebugUtilsMessengerEXT(VkInstance instance,
                                                                      const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,
                                                                      const VkAllocationCallbacks* pAllocator,
                                                                      VkDebugUtilsMessengerEXT* pMessenger,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
                               true, "VUID-vkCreateDebugUtilsMessengerEXT-pCreateInfo-parameter",
                               "VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined,
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::messageSeverity), vvl::FlagBitmask::VkDebugUtilsMessageSeverityFlagBitsEXT,
                              AllVkDebugUtilsMessageSeverityFlagBitsEXT, pCreateInfo->messageSeverity, kRequiredFlags,
                              VK_NULL_HANDLE, "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter",
                              "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::messageType), vvl::FlagBitmask::VkDebugUtilsMessageTypeFlagBitsEXT,
                              AllVkDebugUtilsMessageTypeFlagBitsEXT, pCreateInfo->messageType, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter",
                              "VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask");

        skip |= ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pfnUserCallback),
                                        reinterpret_cast<const void*>(pCreateInfo->pfnUserCallback),
                                        "VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pMessenger), pMessenger, "VUID-vkCreateDebugUtilsMessengerEXT-pMessenger-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSubmitDebugUtilsMessageEXT(VkInstance instance,
                                                                    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                                                    VkDebugUtilsMessageTypeFlagsEXT messageTypes,
                                                                    const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_debug_utils))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_debug_utils});
    skip |= ValidateFlags(loc.dot(Field::messageSeverity), vvl::FlagBitmask::VkDebugUtilsMessageSeverityFlagBitsEXT,
                          AllVkDebugUtilsMessageSeverityFlagBitsEXT, messageSeverity, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter",
                          "VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter");
    skip |= ValidateFlags(loc.dot(Field::messageTypes), vvl::FlagBitmask::VkDebugUtilsMessageTypeFlagBitsEXT,
                          AllVkDebugUtilsMessageTypeFlagBitsEXT, messageTypes, kRequiredFlags, VK_NULL_HANDLE,
                          "VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-parameter",
                          "VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask");
    skip |= ValidateStructType(
        loc.dot(Field::pCallbackData), pCallbackData, VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, true,
        "VUID-vkSubmitDebugUtilsMessageEXT-pCallbackData-parameter", "VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-sType");
    if (pCallbackData != nullptr) {
        [[maybe_unused]] const Location pCallbackData_loc = loc.dot(Field::pCallbackData);
        constexpr std::array allowed_structs_VkDebugUtilsMessengerCallbackDataEXT = {
            VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT};

        skip |= ValidateStructPnext(pCallbackData_loc, pCallbackData->pNext,
                                    allowed_structs_VkDebugUtilsMessengerCallbackDataEXT.size(),
                                    allowed_structs_VkDebugUtilsMessengerCallbackDataEXT.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDebugUtilsMessengerCallbackDataEXT-pNext-pNext",
                                    "VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCallbackData_loc.dot(Field::flags), pCallbackData->flags,
                                      "VUID-VkDebugUtilsMessengerCallbackDataEXT-flags-zerobitmask");

        skip |=
            ValidateStructTypeArray(pCallbackData_loc.dot(Field::queueLabelCount), pCallbackData_loc.dot(Field::pQueueLabels),
                                    pCallbackData->queueLabelCount, pCallbackData->pQueueLabels,
                                    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, false, true, "VUID-VkDebugUtilsLabelEXT-sType-sType",
                                    "VUID-VkDebugUtilsMessengerCallbackDataEXT-pQueueLabels-parameter", kVUIDUndefined);

        if (pCallbackData->pQueueLabels != nullptr) {
            for (uint32_t queueLabelIndex = 0; queueLabelIndex < pCallbackData->queueLabelCount; ++queueLabelIndex) {
                [[maybe_unused]] const Location pQueueLabels_loc = pCallbackData_loc.dot(Field::pQueueLabels, queueLabelIndex);
                skip |= ValidateStructPnext(pQueueLabels_loc, pCallbackData->pQueueLabels[queueLabelIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRequiredPointer(pQueueLabels_loc.dot(Field::pLabelName),
                                                pCallbackData->pQueueLabels[queueLabelIndex].pLabelName,
                                                "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
            }
        }

        skip |=
            ValidateStructTypeArray(pCallbackData_loc.dot(Field::cmdBufLabelCount), pCallbackData_loc.dot(Field::pCmdBufLabels),
                                    pCallbackData->cmdBufLabelCount, pCallbackData->pCmdBufLabels,
                                    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, false, true, "VUID-VkDebugUtilsLabelEXT-sType-sType",
                                    "VUID-VkDebugUtilsMessengerCallbackDataEXT-pCmdBufLabels-parameter", kVUIDUndefined);

        if (pCallbackData->pCmdBufLabels != nullptr) {
            for (uint32_t cmdBufLabelIndex = 0; cmdBufLabelIndex < pCallbackData->cmdBufLabelCount; ++cmdBufLabelIndex) {
                [[maybe_unused]] const Location pCmdBufLabels_loc = pCallbackData_loc.dot(Field::pCmdBufLabels, cmdBufLabelIndex);
                skip |= ValidateStructPnext(pCmdBufLabels_loc, pCallbackData->pCmdBufLabels[cmdBufLabelIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkDebugUtilsLabelEXT-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRequiredPointer(pCmdBufLabels_loc.dot(Field::pLabelName),
                                                pCallbackData->pCmdBufLabels[cmdBufLabelIndex].pLabelName,
                                                "VUID-VkDebugUtilsLabelEXT-pLabelName-parameter");
            }
        }

        skip |= ValidateStructTypeArray(pCallbackData_loc.dot(Field::objectCount), pCallbackData_loc.dot(Field::pObjects),
                                        pCallbackData->objectCount, pCallbackData->pObjects,
                                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, false, true,
                                        "VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType",
                                        "VUID-VkDebugUtilsMessengerCallbackDataEXT-pObjects-parameter", kVUIDUndefined);

        if (pCallbackData->pObjects != nullptr) {
            for (uint32_t objectIndex = 0; objectIndex < pCallbackData->objectCount; ++objectIndex) {
                [[maybe_unused]] const Location pObjects_loc = pCallbackData_loc.dot(Field::pObjects, objectIndex);
                skip |= ValidateStructPnext(pObjects_loc, pCallbackData->pObjects[objectIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pObjects_loc.dot(Field::objectType), vvl::Enum::VkObjectType,
                                           pCallbackData->pObjects[objectIndex].objectType,
                                           "VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter", VK_NULL_HANDLE);
            }
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
bool StatelessValidation::PreCallValidateGetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_android_external_memory_android_hardware_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_ANDROID_external_memory_android_hardware_buffer});
    skip |= ValidateRequiredPointer(loc.dot(Field::buffer), buffer,
                                    "VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-parameter");
    skip |=
        ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
                           true, "VUID-vkGetAndroidHardwareBufferPropertiesANDROID-pProperties-parameter",
                           "VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        constexpr std::array allowed_structs_VkAndroidHardwareBufferPropertiesANDROID = {
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID,
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
            VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID};

        skip |= ValidateStructPnext(pProperties_loc, pProperties->pNext,
                                    allowed_structs_VkAndroidHardwareBufferPropertiesANDROID.size(),
                                    allowed_structs_VkAndroidHardwareBufferPropertiesANDROID.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkAndroidHardwareBufferPropertiesANDROID-pNext-pNext",
                                    "VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryAndroidHardwareBufferANDROID(
    VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_android_external_memory_android_hardware_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_ANDROID_external_memory_android_hardware_buffer});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
                               true, "VUID-vkGetMemoryAndroidHardwareBufferANDROID-pInfo-parameter",
                               "VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::memory), pInfo->memory);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pBuffer), pBuffer, "VUID-vkGetMemoryAndroidHardwareBufferANDROID-pBuffer-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_ENABLE_BETA_EXTENSIONS
bool StatelessValidation::PreCallValidateCreateExecutionGraphPipelinesAMDX(
    VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
    const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
                                    VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX, true, true,
                                    "VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-sType",
                                    "VUID-vkCreateExecutionGraphPipelinesAMDX-pCreateInfos-parameter",
                                    "VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX = {
                VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                        allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX.size(),
                                        allowed_structs_VkExecutionGraphPipelineCreateInfoAMDX.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pNext-pNext",
                                        "VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructTypeArray(pCreateInfos_loc.dot(Field::stageCount), pCreateInfos_loc.dot(Field::pStages),
                                            pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages,
                                            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, false,
                                            "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                            "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pStages-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pStages != nullptr) {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex) {
                    [[maybe_unused]] const Location pStages_loc = pCreateInfos_loc.dot(Field::pStages, stageIndex);
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                    skip |= ValidateStructPnext(pStages_loc, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext,
                                                allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                "VUID-VkPipelineShaderStageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateFlags(pStages_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                          AllVkPipelineShaderStageCreateFlagBits,
                                          pCreateInfos[createInfoIndex].pStages[stageIndex].flags, kOptionalFlags, VK_NULL_HANDLE,
                                          "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |=
                        ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage,
                                      kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                    pCreateInfos[createInfoIndex].pStages[stageIndex].pName,
                                                    "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                        [[maybe_unused]] const Location pSpecializationInfo_loc = pStages_loc.dot(Field::pSpecializationInfo);
                        skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                              pSpecializationInfo_loc.dot(Field::pMapEntries),
                                              pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                                              &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries,
                                              false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr) {
                            for (uint32_t mapEntryIndex = 0;
                                 mapEntryIndex <
                                 pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                 ++mapEntryIndex) {
                                [[maybe_unused]] const Location pMapEntries_loc =
                                    pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                // No xml-driven validation
                            }
                        }

                        skip |=
                            ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                          pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                                          &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false,
                                          true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= ValidateStructType(pCreateInfos_loc.dot(Field::pLibraryInfo), pCreateInfos[createInfoIndex].pLibraryInfo,
                                       VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, false,
                                       "VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-parameter",
                                       "VUID-VkPipelineLibraryCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInfo != nullptr) {
                [[maybe_unused]] const Location pLibraryInfo_loc = pCreateInfos_loc.dot(Field::pLibraryInfo);
                skip |= ValidateStructPnext(pLibraryInfo_loc, pCreateInfos[createInfoIndex].pLibraryInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateArray(pLibraryInfo_loc.dot(Field::libraryCount), pLibraryInfo_loc.dot(Field::pLibraries),
                                      pCreateInfos[createInfoIndex].pLibraryInfo->libraryCount,
                                      &pCreateInfos[createInfoIndex].pLibraryInfo->pLibraries, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }

            skip |= ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true, true,
                          "VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength",
                          "VUID-vkCreateExecutionGraphPipelinesAMDX-pPipelines-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetExecutionGraphPipelineScratchSizeAMDX(
    VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= ValidateRequiredHandle(loc.dot(Field::executionGraph), executionGraph);
    skip |= ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo, VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX,
                               true, "VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-pSizeInfo-parameter",
                               "VUID-VkExecutionGraphPipelineScratchSizeAMDX-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetExecutionGraphPipelineNodeIndexAMDX(
    VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint32_t* pNodeIndex,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= ValidateRequiredHandle(loc.dot(Field::executionGraph), executionGraph);
    skip |= ValidateStructType(loc.dot(Field::pNodeInfo), pNodeInfo, VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                               true, "VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeInfo-parameter",
                               "VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType");
    if (pNodeInfo != nullptr) {
        [[maybe_unused]] const Location pNodeInfo_loc = loc.dot(Field::pNodeInfo);
        skip |= ValidateStructPnext(pNodeInfo_loc, pNodeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion, kVUIDUndefined,
                                    kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pNodeIndex), pNodeIndex,
                                    "VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeIndex-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                              const VkDispatchGraphCountInfoAMDX* pCountInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |= ValidateRequiredPointer(loc.dot(Field::pCountInfo), pCountInfo, "VUID-vkCmdDispatchGraphAMDX-pCountInfo-parameter");
    if (pCountInfo != nullptr) {
        [[maybe_unused]] const Location pCountInfo_loc = loc.dot(Field::pCountInfo);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                                      const VkDispatchGraphCountInfoAMDX* pCountInfo,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pCountInfo), pCountInfo, "VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-parameter");
    if (pCountInfo != nullptr) {
        [[maybe_unused]] const Location pCountInfo_loc = loc.dot(Field::pCountInfo);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                                           VkDeviceAddress countInfo,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});
    // No xml-driven validation
    return skip;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

bool StatelessValidation::PreCallValidateCmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer,
                                                                  const VkSampleLocationsInfoEXT* pSampleLocationsInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_sample_locations))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_sample_locations});
    skip |= ValidateStructType(
        loc.dot(Field::pSampleLocationsInfo), pSampleLocationsInfo, VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, true,
        "VUID-vkCmdSetSampleLocationsEXT-pSampleLocationsInfo-parameter", "VUID-VkSampleLocationsInfoEXT-sType-sType");
    if (pSampleLocationsInfo != nullptr) {
        [[maybe_unused]] const Location pSampleLocationsInfo_loc = loc.dot(Field::pSampleLocationsInfo);
        skip |= ValidateStructPnext(pSampleLocationsInfo_loc, pSampleLocationsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

        // No xml-driven validation

        skip |= ValidateArray(pSampleLocationsInfo_loc.dot(Field::sampleLocationsCount),
                              pSampleLocationsInfo_loc.dot(Field::pSampleLocations), pSampleLocationsInfo->sampleLocationsCount,
                              &pSampleLocationsInfo->pSampleLocations, false, true, kVUIDUndefined,
                              "VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter");

        if (pSampleLocationsInfo->pSampleLocations != nullptr) {
            for (uint32_t sampleLocationsIndex = 0; sampleLocationsIndex < pSampleLocationsInfo->sampleLocationsCount;
                 ++sampleLocationsIndex) {
                [[maybe_unused]] const Location pSampleLocations_loc =
                    pSampleLocationsInfo_loc.dot(Field::pSampleLocations, sampleLocationsIndex);
                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceMultisamplePropertiesEXT(
    VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateFlags(loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits, samples,
                          kRequiredSingleBit, physicalDevice, "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter",
                          "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter");
    skip |= ValidateStructType(loc.dot(Field::pMultisampleProperties), pMultisampleProperties,
                               VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, true,
                               "VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-pMultisampleProperties-parameter",
                               "VUID-VkMultisamplePropertiesEXT-sType-sType");
    if (pMultisampleProperties != nullptr) {
        [[maybe_unused]] const Location pMultisampleProperties_loc = loc.dot(Field::pMultisampleProperties);
        skip |=
            ValidateStructPnext(pMultisampleProperties_loc, pMultisampleProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkMultisamplePropertiesEXT-pNext-pNext", kVUIDUndefined, physicalDevice, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image,
                                                                                VkImageDrmFormatModifierPropertiesEXT* pProperties,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_image_drm_format_modifier))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_image_drm_format_modifier});
    skip |= ValidateRequiredHandle(loc.dot(Field::image), image);
    skip |= ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
                               true, "VUID-vkGetImageDrmFormatModifierPropertiesEXT-pProperties-parameter",
                               "VUID-VkImageDrmFormatModifierPropertiesEXT-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |=
            ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkImageDrmFormatModifierPropertiesEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateValidationCacheEXT(VkDevice device,
                                                                  const VkValidationCacheCreateInfoEXT* pCreateInfo,
                                                                  const VkAllocationCallbacks* pAllocator,
                                                                  VkValidationCacheEXT* pValidationCache,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT, true,
                               "VUID-vkCreateValidationCacheEXT-pCreateInfo-parameter",
                               "VUID-VkValidationCacheCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkValidationCacheCreateInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkValidationCacheCreateInfoEXT-flags-zerobitmask");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::initialDataSize), pCreateInfo_loc.dot(Field::pInitialData),
                              pCreateInfo->initialDataSize, &pCreateInfo->pInitialData, false, true, kVUIDUndefined,
                              "VUID-VkValidationCacheCreateInfoEXT-pInitialData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pValidationCache), pValidationCache,
                                    "VUID-vkCreateValidationCacheEXT-pValidationCache-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache,
                                                                   const VkAllocationCallbacks* pAllocator,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateMergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache,
                                                                  uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    skip |= ValidateRequiredHandle(loc.dot(Field::dstCache), dstCache);
    skip |= ValidateHandleArray(loc.dot(Field::srcCacheCount), loc.dot(Field::pSrcCaches), srcCacheCount, pSrcCaches, true, true,
                                "VUID-vkMergeValidationCachesEXT-srcCacheCount-arraylength");
    return skip;
}

bool StatelessValidation::PreCallValidateGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache,
                                                                   size_t* pDataSize, void* pData,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_validation_cache))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_validation_cache});
    skip |= ValidateRequiredHandle(loc.dot(Field::validationCache), validationCache);
    skip |= ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                 "VUID-vkGetValidationCacheDataEXT-pDataSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetValidationCacheDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView,
                                                                   VkImageLayout imageLayout, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_shading_rate_image});
    skip |= ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                               "VUID-vkCmdBindShadingRateImageNV-imageLayout-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                                            uint32_t viewportCount,
                                                                            const VkShadingRatePaletteNV* pShadingRatePalettes,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_shading_rate_image});
    skip |= ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pShadingRatePalettes), viewportCount, &pShadingRatePalettes,
                          true, true, "VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-arraylength",
                          "VUID-vkCmdSetViewportShadingRatePaletteNV-pShadingRatePalettes-parameter");
    if (pShadingRatePalettes != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pShadingRatePalettes_loc = loc.dot(Field::pShadingRatePalettes, viewportIndex);
            skip |= ValidateRangedEnumArray(pShadingRatePalettes_loc.dot(Field::shadingRatePaletteEntryCount),
                                            pShadingRatePalettes_loc.dot(Field::pShadingRatePaletteEntries),
                                            vvl::Enum::VkShadingRatePaletteEntryNV,
                                            pShadingRatePalettes[viewportIndex].shadingRatePaletteEntryCount,
                                            pShadingRatePalettes[viewportIndex].pShadingRatePaletteEntries, true, true,
                                            "VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-arraylength",
                                            "VUID-VkShadingRatePaletteNV-pShadingRatePaletteEntries-parameter");
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount,
                                                                         pShadingRatePalettes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer,
                                                                   VkCoarseSampleOrderTypeNV sampleOrderType,
                                                                   uint32_t customSampleOrderCount,
                                                                   const VkCoarseSampleOrderCustomNV* pCustomSampleOrders,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_shading_rate_image))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_shading_rate_image});
    skip |= ValidateRangedEnum(loc.dot(Field::sampleOrderType), vvl::Enum::VkCoarseSampleOrderTypeNV, sampleOrderType,
                               "VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::customSampleOrderCount), loc.dot(Field::pCustomSampleOrders), customSampleOrderCount,
                          &pCustomSampleOrders, false, true, kVUIDUndefined,
                          "VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-parameter");
    if (pCustomSampleOrders != nullptr) {
        for (uint32_t customSampleOrderIndex = 0; customSampleOrderIndex < customSampleOrderCount; ++customSampleOrderIndex) {
            [[maybe_unused]] const Location pCustomSampleOrders_loc = loc.dot(Field::pCustomSampleOrders, customSampleOrderIndex);
            skip |= ValidateRangedEnum(pCustomSampleOrders_loc.dot(Field::shadingRate), vvl::Enum::VkShadingRatePaletteEntryNV,
                                       pCustomSampleOrders[customSampleOrderIndex].shadingRate,
                                       "VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter", VK_NULL_HANDLE);

            skip |= ValidateArray(pCustomSampleOrders_loc.dot(Field::sampleLocationCount),
                                  pCustomSampleOrders_loc.dot(Field::pSampleLocations),
                                  pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount,
                                  &pCustomSampleOrders[customSampleOrderIndex].pSampleLocations, true, true,
                                  "VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength",
                                  "VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter");

            if (pCustomSampleOrders[customSampleOrderIndex].pSampleLocations != nullptr) {
                for (uint32_t sampleLocationIndex = 0;
                     sampleLocationIndex < pCustomSampleOrders[customSampleOrderIndex].sampleLocationCount; ++sampleLocationIndex) {
                    [[maybe_unused]] const Location pSampleLocations_loc =
                        pCustomSampleOrders_loc.dot(Field::pSampleLocations, sampleLocationIndex);
                    // No xml-driven validation
                }
            }
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount,
                                                                pCustomSampleOrders, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateAccelerationStructureNV(VkDevice device,
                                                                       const VkAccelerationStructureCreateInfoNV* pCreateInfo,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       VkAccelerationStructureNV* pAccelerationStructure,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
                               true, "VUID-vkCreateAccelerationStructureNV-pCreateInfo-parameter",
                               "VUID-VkAccelerationStructureCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkAccelerationStructureCreateInfoNV = {
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkAccelerationStructureCreateInfoNV.size(),
                                    allowed_structs_VkAccelerationStructureCreateInfoNV.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureCreateInfoNV-pNext-pNext",
                                    "VUID-VkAccelerationStructureCreateInfoNV-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateStructType(pCreateInfo_loc.dot(Field::info), &(pCreateInfo->info),
                                   VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, false, kVUIDUndefined,
                                   "VUID-VkAccelerationStructureInfoNV-sType-sType");

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateStructTypeArray(pCreateInfo_loc.dot(Field::geometryCount), pCreateInfo_loc.dot(Field::pGeometries),
                                        pCreateInfo->info.geometryCount, pCreateInfo->info.pGeometries,
                                        VK_STRUCTURE_TYPE_GEOMETRY_NV, false, true, "VUID-VkGeometryNV-sType-sType",
                                        "VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", kVUIDUndefined);

        if (pCreateInfo->info.pGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pCreateInfo->info.geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location pGeometries_loc = pCreateInfo_loc.dot(Field::pGeometries, geometryIndex);
                skip |= ValidateStructPnext(pGeometries_loc, pCreateInfo->info.pGeometries[geometryIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkGeometryNV-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                           pCreateInfo->info.pGeometries[geometryIndex].geometryType,
                                           "VUID-VkGeometryNV-geometryType-parameter", VK_NULL_HANDLE);

                skip |= ValidateStructType(
                    pGeometries_loc.dot(Field::triangles), &(pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles),
                    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, false, kVUIDUndefined, "VUID-VkGeometryTrianglesNV-sType-sType");

                skip |= ValidateStructPnext(pGeometries_loc, pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.pNext,
                                            0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryTrianglesNV-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat,
                                           pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.vertexFormat,
                                           "VUID-VkGeometryTrianglesNV-vertexFormat-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::indexType), vvl::Enum::VkIndexType,
                                           pCreateInfo->info.pGeometries[geometryIndex].geometry.triangles.indexType,
                                           "VUID-VkGeometryTrianglesNV-indexType-parameter", VK_NULL_HANDLE);

                skip |= ValidateStructType(
                    pGeometries_loc.dot(Field::aabbs), &(pCreateInfo->info.pGeometries[geometryIndex].geometry.aabbs),
                    VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, false, kVUIDUndefined, "VUID-VkGeometryAABBNV-sType-sType");

                skip |= ValidateStructPnext(pGeometries_loc, pCreateInfo->info.pGeometries[geometryIndex].geometry.aabbs.pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion, "VUID-VkGeometryAABBNV-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pCreateInfo->info.pGeometries[geometryIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkGeometryNV-flags-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pAccelerationStructure), pAccelerationStructure,
                                    "VUID-vkCreateAccelerationStructureNV-pAccelerationStructure-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyAccelerationStructureNV(VkDevice device,
                                                                        VkAccelerationStructureNV accelerationStructure,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureMemoryRequirementsNV(
    VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
                               true, "VUID-vkGetAccelerationStructureMemoryRequirementsNV-pInfo-parameter",
                               "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-pNext-pNext", kVUIDUndefined,
                                    VK_NULL_HANDLE, true);

        skip |=
            ValidateRangedEnum(pInfo_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureMemoryRequirementsTypeNV, pInfo->type,
                               "VUID-VkAccelerationStructureMemoryRequirementsInfoNV-type-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::accelerationStructure), pInfo->accelerationStructure);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pMemoryRequirements), pMemoryRequirements,
                                    "VUID-vkGetAccelerationStructureMemoryRequirementsNV-pMemoryRequirements-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateBindAccelerationStructureMemoryNV(
    VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateStructTypeArray(loc.dot(Field::bindInfoCount), loc.dot(Field::pBindInfos), bindInfoCount, pBindInfos,
                                    VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV, true, true,
                                    "VUID-VkBindAccelerationStructureMemoryInfoNV-sType-sType",
                                    "VUID-vkBindAccelerationStructureMemoryNV-pBindInfos-parameter",
                                    "VUID-vkBindAccelerationStructureMemoryNV-bindInfoCount-arraylength");
    if (pBindInfos != nullptr) {
        for (uint32_t bindInfoIndex = 0; bindInfoIndex < bindInfoCount; ++bindInfoIndex) {
            [[maybe_unused]] const Location pBindInfos_loc = loc.dot(Field::pBindInfos, bindInfoIndex);
            skip |= ValidateStructPnext(pBindInfos_loc, pBindInfos[bindInfoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkBindAccelerationStructureMemoryInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                        true);

            skip |= ValidateRequiredHandle(pBindInfos_loc.dot(Field::accelerationStructure),
                                           pBindInfos[bindInfoIndex].accelerationStructure);

            skip |= ValidateRequiredHandle(pBindInfos_loc.dot(Field::memory), pBindInfos[bindInfoIndex].memory);

            skip |= ValidateArray(pBindInfos_loc.dot(Field::deviceIndexCount), pBindInfos_loc.dot(Field::pDeviceIndices),
                                  pBindInfos[bindInfoIndex].deviceIndexCount, &pBindInfos[bindInfoIndex].pDeviceIndices, false,
                                  true, kVUIDUndefined, "VUID-VkBindAccelerationStructureMemoryInfoNV-pDeviceIndices-parameter");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildAccelerationStructureNV(
    VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset,
    VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, true,
                               "VUID-vkCmdBuildAccelerationStructureNV-pInfo-parameter",
                               "VUID-VkAccelerationStructureInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateStructTypeArray(pInfo_loc.dot(Field::geometryCount), pInfo_loc.dot(Field::pGeometries), pInfo->geometryCount,
                                    pInfo->pGeometries, VK_STRUCTURE_TYPE_GEOMETRY_NV, false, true, "VUID-VkGeometryNV-sType-sType",
                                    "VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", kVUIDUndefined);

        if (pInfo->pGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pInfo->geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location pGeometries_loc = pInfo_loc.dot(Field::pGeometries, geometryIndex);
                skip |= ValidateStructPnext(pGeometries_loc, pInfo->pGeometries[geometryIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkGeometryNV-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                           pInfo->pGeometries[geometryIndex].geometryType,
                                           "VUID-VkGeometryNV-geometryType-parameter", VK_NULL_HANDLE);

                skip |= ValidateStructType(
                    pGeometries_loc.dot(Field::triangles), &(pInfo->pGeometries[geometryIndex].geometry.triangles),
                    VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, false, kVUIDUndefined, "VUID-VkGeometryTrianglesNV-sType-sType");

                skip |= ValidateStructPnext(pGeometries_loc, pInfo->pGeometries[geometryIndex].geometry.triangles.pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkGeometryTrianglesNV-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::vertexFormat), vvl::Enum::VkFormat,
                                           pInfo->pGeometries[geometryIndex].geometry.triangles.vertexFormat,
                                           "VUID-VkGeometryTrianglesNV-vertexFormat-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::indexType), vvl::Enum::VkIndexType,
                                           pInfo->pGeometries[geometryIndex].geometry.triangles.indexType,
                                           "VUID-VkGeometryTrianglesNV-indexType-parameter", VK_NULL_HANDLE);

                skip |= ValidateStructType(pGeometries_loc.dot(Field::aabbs), &(pInfo->pGeometries[geometryIndex].geometry.aabbs),
                                           VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, false, kVUIDUndefined,
                                           "VUID-VkGeometryAABBNV-sType-sType");

                skip |= ValidateStructPnext(pGeometries_loc, pInfo->pGeometries[geometryIndex].geometry.aabbs.pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkGeometryAABBNV-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfo->pGeometries[geometryIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkGeometryNV-flags-parameter");
            }
        }
    }
    skip |= ValidateBool32(loc.dot(Field::update), update);
    skip |= ValidateRequiredHandle(loc.dot(Field::dst), dst);
    skip |= ValidateRequiredHandle(loc.dot(Field::scratch), scratch);
    if (!skip)
        skip |= manual_PreCallValidateCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update,
                                                                      dst, src, scratch, scratchOffset, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer,
                                                                        VkAccelerationStructureNV dst,
                                                                        VkAccelerationStructureNV src,
                                                                        VkCopyAccelerationStructureModeKHR mode,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateRequiredHandle(loc.dot(Field::dst), dst);
    skip |= ValidateRequiredHandle(loc.dot(Field::src), src);
    skip |= ValidateRangedEnum(loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, mode,
                               "VUID-vkCmdCopyAccelerationStructureNV-mode-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysNV(
    VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset,
    VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride,
    VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride,
    VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride,
    uint32_t width, uint32_t height, uint32_t depth, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateRequiredHandle(loc.dot(Field::raygenShaderBindingTableBuffer), raygenShaderBindingTableBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache,
                                                                     uint32_t createInfoCount,
                                                                     const VkRayTracingPipelineCreateInfoNV* pCreateInfos,
                                                                     const VkAllocationCallbacks* pAllocator,
                                                                     VkPipeline* pPipelines, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
                                    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV, true, true,
                                    "VUID-VkRayTracingPipelineCreateInfoNV-sType-sType",
                                    "VUID-vkCreateRayTracingPipelinesNV-pCreateInfos-parameter",
                                    "VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkRayTracingPipelineCreateInfoNV = {
                VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                        allowed_structs_VkRayTracingPipelineCreateInfoNV.size(),
                                        allowed_structs_VkRayTracingPipelineCreateInfoNV.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkRayTracingPipelineCreateInfoNV-pNext-pNext",
                                        "VUID-VkRayTracingPipelineCreateInfoNV-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructTypeArray(pCreateInfos_loc.dot(Field::stageCount), pCreateInfos_loc.dot(Field::pStages),
                                            pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages,
                                            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, true, true,
                                            "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                            "VUID-VkRayTracingPipelineCreateInfoNV-pStages-parameter",
                                            "VUID-VkRayTracingPipelineCreateInfoNV-stageCount-arraylength");

            if (pCreateInfos[createInfoIndex].pStages != nullptr) {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex) {
                    [[maybe_unused]] const Location pStages_loc = pCreateInfos_loc.dot(Field::pStages, stageIndex);
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                    skip |= ValidateStructPnext(pStages_loc, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext,
                                                allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                "VUID-VkPipelineShaderStageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateFlags(pStages_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                          AllVkPipelineShaderStageCreateFlagBits,
                                          pCreateInfos[createInfoIndex].pStages[stageIndex].flags, kOptionalFlags, VK_NULL_HANDLE,
                                          "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |=
                        ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage,
                                      kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                    pCreateInfos[createInfoIndex].pStages[stageIndex].pName,
                                                    "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                        [[maybe_unused]] const Location pSpecializationInfo_loc = pStages_loc.dot(Field::pSpecializationInfo);
                        skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                              pSpecializationInfo_loc.dot(Field::pMapEntries),
                                              pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                                              &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries,
                                              false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr) {
                            for (uint32_t mapEntryIndex = 0;
                                 mapEntryIndex <
                                 pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                 ++mapEntryIndex) {
                                [[maybe_unused]] const Location pMapEntries_loc =
                                    pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                // No xml-driven validation
                            }
                        }

                        skip |=
                            ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                          pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                                          &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false,
                                          true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= ValidateStructTypeArray(pCreateInfos_loc.dot(Field::groupCount), pCreateInfos_loc.dot(Field::pGroups),
                                            pCreateInfos[createInfoIndex].groupCount, pCreateInfos[createInfoIndex].pGroups,
                                            VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV, true, true,
                                            "VUID-VkRayTracingShaderGroupCreateInfoNV-sType-sType",
                                            "VUID-VkRayTracingPipelineCreateInfoNV-pGroups-parameter",
                                            "VUID-VkRayTracingPipelineCreateInfoNV-groupCount-arraylength");

            if (pCreateInfos[createInfoIndex].pGroups != nullptr) {
                for (uint32_t groupIndex = 0; groupIndex < pCreateInfos[createInfoIndex].groupCount; ++groupIndex) {
                    [[maybe_unused]] const Location pGroups_loc = pCreateInfos_loc.dot(Field::pGroups, groupIndex);
                    skip |=
                        ValidateStructPnext(pGroups_loc, pCreateInfos[createInfoIndex].pGroups[groupIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkRayTracingShaderGroupCreateInfoNV-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(pGroups_loc.dot(Field::type), vvl::Enum::VkRayTracingShaderGroupTypeKHR,
                                               pCreateInfos[createInfoIndex].pGroups[groupIndex].type,
                                               "VUID-VkRayTracingShaderGroupCreateInfoNV-type-parameter", VK_NULL_HANDLE);
                }
            }

            skip |= ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true, true,
                          "VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength",
                          "VUID-vkCreateRayTracingPipelinesNV-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                                  pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline,
                                                                            uint32_t firstGroup, uint32_t groupCount,
                                                                            size_t dataSize, void* pData,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline) &&
        loc.function == vvl::Func::vkGetRayTracingShaderGroupHandlesKHR)
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-arraylength",
                          "VUID-vkGetRayTracingShaderGroupHandlesKHR-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline,
                                                                           uint32_t firstGroup, uint32_t groupCount,
                                                                           size_t dataSize, void* pData,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= PreCallValidateGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureHandleNV(VkDevice device,
                                                                          VkAccelerationStructureNV accelerationStructure,
                                                                          size_t dataSize, void* pData,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateRequiredHandle(loc.dot(Field::accelerationStructure), accelerationStructure);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkGetAccelerationStructureHandleNV-dataSize-arraylength",
                          "VUID-vkGetAccelerationStructureHandleNV-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures,
    VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateHandleArray(loc.dot(Field::accelerationStructureCount), loc.dot(Field::pAccelerationStructures),
                                accelerationStructureCount, pAccelerationStructures, true, true,
                                "VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructureCount-arraylength");
    skip |= ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                               "VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    if (!skip)
        skip |= manual_PreCallValidateCmdWriteAccelerationStructuresPropertiesNV(
            commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_ray_tracing)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_ray_tracing});
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryHostPointerPropertiesEXT(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer,
    VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_external_memory_host))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_external_memory_host});
    skip |= ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                          AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter",
                          "VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter");
    skip |= ValidateRequiredPointer(loc.dot(Field::pHostPointer), pHostPointer,
                                    "VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-parameter");
    skip |= ValidateStructType(loc.dot(Field::pMemoryHostPointerProperties), pMemoryHostPointerProperties,
                               VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, true,
                               "VUID-vkGetMemoryHostPointerPropertiesEXT-pMemoryHostPointerProperties-parameter",
                               "VUID-VkMemoryHostPointerPropertiesEXT-sType-sType");
    if (pMemoryHostPointerProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryHostPointerProperties_loc = loc.dot(Field::pMemoryHostPointerProperties);
        skip |= ValidateStructPnext(pMemoryHostPointerProperties_loc, pMemoryHostPointerProperties->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryHostPointerPropertiesEXT-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer,
                                                                        pMemoryHostPointerProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer,
                                                                 VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer,
                                                                 VkDeviceSize dstOffset, uint32_t marker,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_buffer_marker))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_buffer_marker});
    skip |=
        ValidateFlags(loc.dot(Field::pipelineStage), vvl::FlagBitmask::VkPipelineStageFlagBits, AllVkPipelineStageFlagBits,
                      pipelineStage, kOptionalSingleBit, VK_NULL_HANDLE, "VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-parameter");
    skip |= ValidateRequiredHandle(loc.dot(Field::dstBuffer), dstBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice,
                                                                                      uint32_t* pTimeDomainCount,
                                                                                      VkTimeDomainKHR* pTimeDomains,
                                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= PreCallValidateGetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount,
                                                                    const VkCalibratedTimestampInfoKHR* pTimestampInfos,
                                                                    uint64_t* pTimestamps, uint64_t* pMaxDeviation,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_calibrated_timestamps))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_calibrated_timestamps});
    skip |=
        PreCallValidateGetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_mesh_shader});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                    VkDeviceSize offset, uint32_t drawCount, uint32_t stride,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_mesh_shader});
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                         VkDeviceSize offset, VkBuffer countBuffer,
                                                                         VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                         uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_mesh_shader)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_mesh_shader});
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer,
                                                                        uint32_t firstExclusiveScissor,
                                                                        uint32_t exclusiveScissorCount,
                                                                        const VkBool32* pExclusiveScissorEnables,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_scissor_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_scissor_exclusive});
    skip |= ValidateBool32Array(loc.dot(Field::exclusiveScissorCount), loc.dot(Field::pExclusiveScissorEnables),
                                exclusiveScissorCount, pExclusiveScissorEnables, true, true,
                                "VUID-vkCmdSetExclusiveScissorEnableNV-exclusiveScissorCount-arraylength",
                                "VUID-vkCmdSetExclusiveScissorEnableNV-pExclusiveScissorEnables-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount,
                                                                     pExclusiveScissorEnables, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor,
                                                                  uint32_t exclusiveScissorCount,
                                                                  const VkRect2D* pExclusiveScissors,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_scissor_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_scissor_exclusive});
    skip |= ValidateArray(loc.dot(Field::exclusiveScissorCount), loc.dot(Field::pExclusiveScissors), exclusiveScissorCount,
                          &pExclusiveScissors, true, true, "VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-arraylength",
                          "VUID-vkCmdSetExclusiveScissorNV-pExclusiveScissors-parameter");
    if (pExclusiveScissors != nullptr) {
        for (uint32_t exclusiveScissorIndex = 0; exclusiveScissorIndex < exclusiveScissorCount; ++exclusiveScissorIndex) {
            [[maybe_unused]] const Location pExclusiveScissors_loc = loc.dot(Field::pExclusiveScissors, exclusiveScissorIndex);
            // No xml-driven validation

            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount,
                                                               pExclusiveScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void* pCheckpointMarker,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_diagnostic_checkpoints))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_diagnostic_checkpoints});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetQueueCheckpointDataNV(VkQueue queue, uint32_t* pCheckpointDataCount,
                                                                  VkCheckpointDataNV* pCheckpointData,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_diagnostic_checkpoints))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_diagnostic_checkpoints});
    skip |=
        ValidateStructTypeArray(loc.dot(Field::pCheckpointDataCount), loc.dot(Field::pCheckpointData), pCheckpointDataCount,
                                pCheckpointData, VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV, true, false, false,
                                "VUID-VkCheckpointDataNV-sType-sType", "VUID-vkGetQueueCheckpointDataNV-pCheckpointData-parameter",
                                "VUID-vkGetQueueCheckpointDataNV-pCheckpointDataCount-parameter", kVUIDUndefined);
    if (pCheckpointData != nullptr) {
        for (uint32_t pCheckpointDataIndex = 0; pCheckpointDataIndex < *pCheckpointDataCount; ++pCheckpointDataIndex) {
            [[maybe_unused]] const Location pCheckpointData_loc = loc.dot(Field::pCheckpointData, pCheckpointDataIndex);
            skip |= ValidateStructPnext(pCheckpointData_loc, pCheckpointData[pCheckpointDataIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkCheckpointDataNV-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateInitializePerformanceApiINTEL(VkDevice device,
                                                                       const VkInitializePerformanceApiInfoINTEL* pInitializeInfo,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateStructType(
        loc.dot(Field::pInitializeInfo), pInitializeInfo, VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL, true,
        "VUID-vkInitializePerformanceApiINTEL-pInitializeInfo-parameter", "VUID-VkInitializePerformanceApiInfoINTEL-sType-sType");
    if (pInitializeInfo != nullptr) {
        [[maybe_unused]] const Location pInitializeInfo_loc = loc.dot(Field::pInitializeInfo);
        skip |= ValidateStructPnext(pInitializeInfo_loc, pInitializeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkInitializePerformanceApiInfoINTEL-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUninitializePerformanceApiINTEL(VkDevice device, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer,
                                                                      const VkPerformanceMarkerInfoINTEL* pMarkerInfo,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL, true,
                               "VUID-vkCmdSetPerformanceMarkerINTEL-pMarkerInfo-parameter",
                               "VUID-VkPerformanceMarkerInfoINTEL-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPerformanceMarkerInfoINTEL-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer,
                                                                            const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateStructType(loc.dot(Field::pMarkerInfo), pMarkerInfo, VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
                               true, "VUID-vkCmdSetPerformanceStreamMarkerINTEL-pMarkerInfo-parameter",
                               "VUID-VkPerformanceStreamMarkerInfoINTEL-sType-sType");
    if (pMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pMarkerInfo_loc = loc.dot(Field::pMarkerInfo);
        skip |= ValidateStructPnext(pMarkerInfo_loc, pMarkerInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPerformanceStreamMarkerInfoINTEL-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer,
                                                                        const VkPerformanceOverrideInfoINTEL* pOverrideInfo,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateStructType(loc.dot(Field::pOverrideInfo), pOverrideInfo, VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
                               true, "VUID-vkCmdSetPerformanceOverrideINTEL-pOverrideInfo-parameter",
                               "VUID-VkPerformanceOverrideInfoINTEL-sType-sType");
    if (pOverrideInfo != nullptr) {
        [[maybe_unused]] const Location pOverrideInfo_loc = loc.dot(Field::pOverrideInfo);
        skip |= ValidateStructPnext(pOverrideInfo_loc, pOverrideInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPerformanceOverrideInfoINTEL-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pOverrideInfo_loc.dot(Field::type), vvl::Enum::VkPerformanceOverrideTypeINTEL,
                                   pOverrideInfo->type, "VUID-VkPerformanceOverrideInfoINTEL-type-parameter", VK_NULL_HANDLE);

        skip |= ValidateBool32(pOverrideInfo_loc.dot(Field::enable), pOverrideInfo->enable);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateAcquirePerformanceConfigurationINTEL(
    VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo,
    VkPerformanceConfigurationINTEL* pConfiguration, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateStructType(loc.dot(Field::pAcquireInfo), pAcquireInfo,
                               VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL, true,
                               "VUID-vkAcquirePerformanceConfigurationINTEL-pAcquireInfo-parameter",
                               "VUID-VkPerformanceConfigurationAcquireInfoINTEL-sType-sType");
    if (pAcquireInfo != nullptr) {
        [[maybe_unused]] const Location pAcquireInfo_loc = loc.dot(Field::pAcquireInfo);
        skip |= ValidateStructPnext(pAcquireInfo_loc, pAcquireInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPerformanceConfigurationAcquireInfoINTEL-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRangedEnum(pAcquireInfo_loc.dot(Field::type), vvl::Enum::VkPerformanceConfigurationTypeINTEL,
                                   pAcquireInfo->type, "VUID-VkPerformanceConfigurationAcquireInfoINTEL-type-parameter",
                                   VK_NULL_HANDLE);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pConfiguration), pConfiguration,
                                    "VUID-vkAcquirePerformanceConfigurationINTEL-pConfiguration-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateReleasePerformanceConfigurationINTEL(VkDevice device,
                                                                              VkPerformanceConfigurationINTEL configuration,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateQueueSetPerformanceConfigurationINTEL(VkQueue queue,
                                                                               VkPerformanceConfigurationINTEL configuration,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateRequiredHandle(loc.dot(Field::configuration), configuration);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter,
                                                                      VkPerformanceValueINTEL* pValue,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_intel_performance_query))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});
    skip |= ValidateRangedEnum(loc.dot(Field::parameter), vvl::Enum::VkPerformanceParameterTypeINTEL, parameter,
                               "VUID-vkGetPerformanceParameterINTEL-parameter-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredPointer(loc.dot(Field::pValue), pValue, "VUID-vkGetPerformanceParameterINTEL-pValue-parameter");
    if (pValue != nullptr) {
        [[maybe_unused]] const Location pValue_loc = loc.dot(Field::pValue);
        // No xml-driven validation
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_display_native_hdr))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_display_native_hdr});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapChain), swapChain);
    skip |= ValidateBool32(loc.dot(Field::localDimmingEnable), localDimmingEnable);
    return skip;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateCreateImagePipeSurfaceFUCHSIA(VkInstance instance,
                                                                       const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       VkSurfaceKHR* pSurface, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_fuchsia_imagepipe_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_imagepipe_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
                               true, "VUID-vkCreateImagePipeSurfaceFUCHSIA-pCreateInfo-parameter",
                               "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_METAL_EXT
bool StatelessValidation::PreCallValidateCreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo,
                                                               const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_metal_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_metal_surface});
    skip |=
        ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT, true,
                           "VUID-vkCreateMetalSurfaceEXT-pCreateInfo-parameter", "VUID-VkMetalSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMetalSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkMetalSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateMetalSurfaceEXT-pSurface-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

bool StatelessValidation::PreCallValidateGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo* pInfo,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_buffer_device_address))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_buffer_device_address});
    skip |= PreCallValidateGetBufferDeviceAddress(device, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t* pToolCount,
                                                                            VkPhysicalDeviceToolProperties* pToolProperties,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= PreCallValidateGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pPropertyCount), loc.dot(Field::pProperties), pPropertyCount, pProperties,
        VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV, true, false, false, "VUID-VkCooperativeMatrixPropertiesNV-sType-sType",
        "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pProperties-parameter",
        "VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pPropertyCount-parameter", kVUIDUndefined);
    if (pProperties != nullptr) {
        for (uint32_t pPropertyIndex = 0; pPropertyIndex < *pPropertyCount; ++pPropertyIndex) {
            [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties, pPropertyIndex);
            skip |=
                ValidateStructPnext(pProperties_loc, pProperties[pPropertyIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCooperativeMatrixPropertiesNV-pNext-pNext", kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructTypeArray(
        loc.dot(Field::pCombinationCount), loc.dot(Field::pCombinations), pCombinationCount, pCombinations,
        VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV, true, false, false,
        "VUID-VkFramebufferMixedSamplesCombinationNV-sType-sType",
        "VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-pCombinations-parameter",
        "VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-pCombinationCount-parameter", kVUIDUndefined);
    if (pCombinations != nullptr) {
        for (uint32_t pCombinationIndex = 0; pCombinationIndex < *pCombinationCount; ++pCombinationIndex) {
            [[maybe_unused]] const Location pCombinations_loc = loc.dot(Field::pCombinations, pCombinationIndex);
            skip |= ValidateStructPnext(pCombinations_loc, pCombinations[pCombinationIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkFramebufferMixedSamplesCombinationNV-pNext-pNext",
                                        kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateGetPhysicalDeviceSurfacePresentModes2EXT(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount,
    VkPresentModeKHR* pPresentModes, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pSurfaceInfo), pSurfaceInfo, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
                               true, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-parameter",
                               "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType");
    if (pSurfaceInfo != nullptr) {
        [[maybe_unused]] const Location pSurfaceInfo_loc = loc.dot(Field::pSurfaceInfo);
        constexpr std::array allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR = {
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
            VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT};

        skip |= ValidateStructPnext(pSurfaceInfo_loc, pSurfaceInfo->pNext, allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.size(),
                                    allowed_structs_VkPhysicalDeviceSurfaceInfo2KHR.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext",
                                    "VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", physicalDevice, true);
    }
    skip |=
        ValidatePointerArray(loc.dot(Field::pPresentModeCount), loc.dot(Field::pPresentModes), pPresentModeCount, &pPresentModes,
                             true, false, false, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModeCount-parameter",
                             kVUIDUndefined, "VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModes-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount,
                                                                               pPresentModes, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_full_screen_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_full_screen_exclusive});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_full_screen_exclusive))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_full_screen_exclusive});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

bool StatelessValidation::PreCallValidateCreateHeadlessSurfaceEXT(VkInstance instance,
                                                                  const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo,
                                                                  const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_headless_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_headless_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, true,
                               "VUID-vkCreateHeadlessSurfaceEXT-pCreateInfo-parameter",
                               "VUID-VkHeadlessSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkHeadlessSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkHeadlessSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateHeadlessSurfaceEXT-pSurface-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                                              uint16_t lineStipplePattern, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_line_rasterization))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_line_rasterization});
    skip |= PreCallValidateCmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                                           uint32_t queryCount, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_query_reset))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_query_reset});
    skip |= PreCallValidateResetQueryPool(device, queryPool, firstQuery, queryCount, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetCullMode(commandBuffer, cullMode, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetFrontFace(commandBuffer, frontFace, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer,
                                                                    VkPrimitiveTopology primitiveTopology,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetPrimitiveTopology(commandBuffer, primitiveTopology, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                                                    const VkViewport* pViewports,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                                                   const VkRect2D* pScissors, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                                                  uint32_t bindingCount, const VkBuffer* pBuffers,
                                                                  const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes,
                                                                  const VkDeviceSize* pStrides,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides,
                                                 error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthTestEnable(commandBuffer, depthTestEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthCompareOp(commandBuffer, depthCompareOp, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer,
                                                                        VkBool32 depthBoundsTestEnable,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetStencilTestEnable(commandBuffer, stencilTestEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                            VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp,
                                                            VkCompareOp compareOp, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMemoryToImageEXT(VkDevice device,
                                                              const VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= ValidateStructType(
        loc.dot(Field::pCopyMemoryToImageInfo), pCopyMemoryToImageInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT, true,
        "VUID-vkCopyMemoryToImageEXT-pCopyMemoryToImageInfo-parameter", "VUID-VkCopyMemoryToImageInfoEXT-sType-sType");
    if (pCopyMemoryToImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyMemoryToImageInfo_loc = loc.dot(Field::pCopyMemoryToImageInfo);
        skip |=
            ValidateStructPnext(pCopyMemoryToImageInfo_loc, pCopyMemoryToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkCopyMemoryToImageInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCopyMemoryToImageInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkHostImageCopyFlagBitsEXT,
                              AllVkHostImageCopyFlagBitsEXT, pCopyMemoryToImageInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkCopyMemoryToImageInfoEXT-flags-parameter");

        skip |= ValidateRequiredHandle(pCopyMemoryToImageInfo_loc.dot(Field::dstImage), pCopyMemoryToImageInfo->dstImage);

        skip |= ValidateRangedEnum(pCopyMemoryToImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                   pCopyMemoryToImageInfo->dstImageLayout,
                                   "VUID-VkCopyMemoryToImageInfoEXT-dstImageLayout-parameter", VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(
            pCopyMemoryToImageInfo_loc.dot(Field::regionCount), pCopyMemoryToImageInfo_loc.dot(Field::pRegions),
            pCopyMemoryToImageInfo->regionCount, pCopyMemoryToImageInfo->pRegions, VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT, true,
            true, "VUID-VkMemoryToImageCopyEXT-sType-sType", "VUID-VkCopyMemoryToImageInfoEXT-pRegions-parameter",
            "VUID-VkCopyMemoryToImageInfoEXT-regionCount-arraylength");

        if (pCopyMemoryToImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyMemoryToImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyMemoryToImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= ValidateStructPnext(pRegions_loc, pCopyMemoryToImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkMemoryToImageCopyEXT-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRequiredPointer(pRegions_loc.dot(Field::pHostPointer),
                                                pCopyMemoryToImageInfo->pRegions[regionIndex].pHostPointer,
                                                "VUID-VkMemoryToImageCopyEXT-pHostPointer-parameter");

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits,
                                      pCopyMemoryToImageInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyImageToMemoryEXT(VkDevice device,
                                                              const VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= ValidateStructType(
        loc.dot(Field::pCopyImageToMemoryInfo), pCopyImageToMemoryInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT, true,
        "VUID-vkCopyImageToMemoryEXT-pCopyImageToMemoryInfo-parameter", "VUID-VkCopyImageToMemoryInfoEXT-sType-sType");
    if (pCopyImageToMemoryInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageToMemoryInfo_loc = loc.dot(Field::pCopyImageToMemoryInfo);
        skip |=
            ValidateStructPnext(pCopyImageToMemoryInfo_loc, pCopyImageToMemoryInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkCopyImageToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCopyImageToMemoryInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkHostImageCopyFlagBitsEXT,
                              AllVkHostImageCopyFlagBitsEXT, pCopyImageToMemoryInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkCopyImageToMemoryInfoEXT-flags-parameter");

        skip |= ValidateRequiredHandle(pCopyImageToMemoryInfo_loc.dot(Field::srcImage), pCopyImageToMemoryInfo->srcImage);

        skip |= ValidateRangedEnum(pCopyImageToMemoryInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                   pCopyImageToMemoryInfo->srcImageLayout,
                                   "VUID-VkCopyImageToMemoryInfoEXT-srcImageLayout-parameter", VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(
            pCopyImageToMemoryInfo_loc.dot(Field::regionCount), pCopyImageToMemoryInfo_loc.dot(Field::pRegions),
            pCopyImageToMemoryInfo->regionCount, pCopyImageToMemoryInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT, true,
            true, "VUID-VkImageToMemoryCopyEXT-sType-sType", "VUID-VkCopyImageToMemoryInfoEXT-pRegions-parameter",
            "VUID-VkCopyImageToMemoryInfoEXT-regionCount-arraylength");

        if (pCopyImageToMemoryInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToMemoryInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageToMemoryInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= ValidateStructPnext(pRegions_loc, pCopyImageToMemoryInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageToMemoryCopyEXT-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |= ValidateRequiredPointer(pRegions_loc.dot(Field::pHostPointer),
                                                pCopyImageToMemoryInfo->pRegions[regionIndex].pHostPointer,
                                                "VUID-VkImageToMemoryCopyEXT-pHostPointer-parameter");

                skip |= ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                      AllVkImageAspectFlagBits,
                                      pCopyImageToMemoryInfo->pRegions[regionIndex].imageSubresource.aspectMask, kRequiredFlags,
                                      VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                      "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyImageToImageEXT(VkDevice device,
                                                             const VkCopyImageToImageInfoEXT* pCopyImageToImageInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= ValidateStructType(
        loc.dot(Field::pCopyImageToImageInfo), pCopyImageToImageInfo, VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT, true,
        "VUID-vkCopyImageToImageEXT-pCopyImageToImageInfo-parameter", "VUID-VkCopyImageToImageInfoEXT-sType-sType");
    if (pCopyImageToImageInfo != nullptr) {
        [[maybe_unused]] const Location pCopyImageToImageInfo_loc = loc.dot(Field::pCopyImageToImageInfo);
        skip |=
            ValidateStructPnext(pCopyImageToImageInfo_loc, pCopyImageToImageInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkCopyImageToImageInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCopyImageToImageInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkHostImageCopyFlagBitsEXT,
                              AllVkHostImageCopyFlagBitsEXT, pCopyImageToImageInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkCopyImageToImageInfoEXT-flags-parameter");

        skip |= ValidateRequiredHandle(pCopyImageToImageInfo_loc.dot(Field::srcImage), pCopyImageToImageInfo->srcImage);

        skip |= ValidateRangedEnum(pCopyImageToImageInfo_loc.dot(Field::srcImageLayout), vvl::Enum::VkImageLayout,
                                   pCopyImageToImageInfo->srcImageLayout, "VUID-VkCopyImageToImageInfoEXT-srcImageLayout-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pCopyImageToImageInfo_loc.dot(Field::dstImage), pCopyImageToImageInfo->dstImage);

        skip |= ValidateRangedEnum(pCopyImageToImageInfo_loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout,
                                   pCopyImageToImageInfo->dstImageLayout, "VUID-VkCopyImageToImageInfoEXT-dstImageLayout-parameter",
                                   VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(pCopyImageToImageInfo_loc.dot(Field::regionCount),
                                        pCopyImageToImageInfo_loc.dot(Field::pRegions), pCopyImageToImageInfo->regionCount,
                                        pCopyImageToImageInfo->pRegions, VK_STRUCTURE_TYPE_IMAGE_COPY_2, true, true,
                                        "VUID-VkImageCopy2-sType-sType", "VUID-VkCopyImageToImageInfoEXT-pRegions-parameter",
                                        "VUID-VkCopyImageToImageInfoEXT-regionCount-arraylength");

        if (pCopyImageToImageInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pCopyImageToImageInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pCopyImageToImageInfo_loc.dot(Field::pRegions, regionIndex);
                skip |= ValidateStructPnext(pRegions_loc, pCopyImageToImageInfo->pRegions[regionIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageCopy2-pNext-pNext", kVUIDUndefined,
                                            VK_NULL_HANDLE, true);

                skip |=
                    ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pCopyImageToImageInfo->pRegions[regionIndex].srcSubresource.aspectMask,
                                  kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                skip |=
                    ValidateFlags(pRegions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pCopyImageToImageInfo->pRegions[regionIndex].dstSubresource.aspectMask,
                                  kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");

                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount,
                                                                  const VkHostImageLayoutTransitionInfoEXT* pTransitions,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_host_image_copy))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy});
    skip |= ValidateStructTypeArray(
        loc.dot(Field::transitionCount), loc.dot(Field::pTransitions), transitionCount, pTransitions,
        VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT, true, true, "VUID-VkHostImageLayoutTransitionInfoEXT-sType-sType",
        "VUID-vkTransitionImageLayoutEXT-pTransitions-parameter", "VUID-vkTransitionImageLayoutEXT-transitionCount-arraylength");
    if (pTransitions != nullptr) {
        for (uint32_t transitionIndex = 0; transitionIndex < transitionCount; ++transitionIndex) {
            [[maybe_unused]] const Location pTransitions_loc = loc.dot(Field::pTransitions, transitionIndex);
            skip |=
                ValidateStructPnext(pTransitions_loc, pTransitions[transitionIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkHostImageLayoutTransitionInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |= ValidateRequiredHandle(pTransitions_loc.dot(Field::image), pTransitions[transitionIndex].image);

            skip |= ValidateRangedEnum(pTransitions_loc.dot(Field::oldLayout), vvl::Enum::VkImageLayout,
                                       pTransitions[transitionIndex].oldLayout,
                                       "VUID-VkHostImageLayoutTransitionInfoEXT-oldLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pTransitions_loc.dot(Field::newLayout), vvl::Enum::VkImageLayout,
                                       pTransitions[transitionIndex].newLayout,
                                       "VUID-VkHostImageLayoutTransitionInfoEXT-newLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pTransitions_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pTransitions[transitionIndex].subresourceRange.aspectMask,
                                  kRequiredFlags, VK_NULL_HANDLE, "VUID-VkImageSubresourceRange-aspectMask-parameter",
                                  "VUID-VkImageSubresourceRange-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageSubresourceLayout2EXT(VkDevice device, VkImage image,
                                                                       const VkImageSubresource2KHR* pSubresource,
                                                                       VkSubresourceLayout2KHR* pLayout,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_host_image_copy) ||
          IsExtEnabled(device_extensions.vk_ext_image_compression_control)))
        skip |=
            OutputExtensionError(loc, {vvl::Extension::_VK_EXT_host_image_copy, vvl::Extension::_VK_EXT_image_compression_control});
    skip |= PreCallValidateGetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateReleaseSwapchainImagesEXT(VkDevice device,
                                                                   const VkReleaseSwapchainImagesInfoEXT* pReleaseInfo,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_swapchain_maintenance1))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_swapchain_maintenance1});
    skip |= ValidateStructType(loc.dot(Field::pReleaseInfo), pReleaseInfo, VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT,
                               true, "VUID-vkReleaseSwapchainImagesEXT-pReleaseInfo-parameter",
                               "VUID-VkReleaseSwapchainImagesInfoEXT-sType-sType");
    if (pReleaseInfo != nullptr) {
        [[maybe_unused]] const Location pReleaseInfo_loc = loc.dot(Field::pReleaseInfo);
        skip |= ValidateStructPnext(pReleaseInfo_loc, pReleaseInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkReleaseSwapchainImagesInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pReleaseInfo_loc.dot(Field::swapchain), pReleaseInfo->swapchain);

        skip |= ValidateArray(pReleaseInfo_loc.dot(Field::imageIndexCount), pReleaseInfo_loc.dot(Field::pImageIndices),
                              pReleaseInfo->imageIndexCount, &pReleaseInfo->pImageIndices, true, true,
                              "VUID-VkReleaseSwapchainImagesInfoEXT-imageIndexCount-arraylength",
                              "VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetGeneratedCommandsMemoryRequirementsNV(
    VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV, true,
                               "VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-parameter",
                               "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |=
            ValidateRangedEnum(pInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pInfo->pipelineBindPoint,
                               "VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::indirectCommandsLayout), pInfo->indirectCommandsLayout);
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
                                                                          const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, true,
        "VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoNV-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |=
            ValidateStructPnext(pGeneratedCommandsInfo_loc, pGeneratedCommandsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkGeneratedCommandsInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pGeneratedCommandsInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                   pGeneratedCommandsInfo->pipelineBindPoint,
                                   "VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                       pGeneratedCommandsInfo->indirectCommandsLayout);

        skip |= ValidateArray(pGeneratedCommandsInfo_loc.dot(Field::streamCount), pGeneratedCommandsInfo_loc.dot(Field::pStreams),
                              pGeneratedCommandsInfo->streamCount, &pGeneratedCommandsInfo->pStreams, true, true,
                              "VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength",
                              "VUID-VkGeneratedCommandsInfoNV-pStreams-parameter");

        if (pGeneratedCommandsInfo->pStreams != nullptr) {
            for (uint32_t streamIndex = 0; streamIndex < pGeneratedCommandsInfo->streamCount; ++streamIndex) {
                [[maybe_unused]] const Location pStreams_loc = pGeneratedCommandsInfo_loc.dot(Field::pStreams, streamIndex);
                skip |=
                    ValidateRequiredHandle(pStreams_loc.dot(Field::buffer), pGeneratedCommandsInfo->pStreams[streamIndex].buffer);
            }
        }

        skip |= ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::preprocessBuffer),
                                       pGeneratedCommandsInfo->preprocessBuffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed,
                                                                       const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= ValidateBool32(loc.dot(Field::isPreprocessed), isPreprocessed);
    skip |= ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, true,
        "VUID-vkCmdExecuteGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoNV-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |=
            ValidateStructPnext(pGeneratedCommandsInfo_loc, pGeneratedCommandsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkGeneratedCommandsInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pGeneratedCommandsInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                   pGeneratedCommandsInfo->pipelineBindPoint,
                                   "VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                       pGeneratedCommandsInfo->indirectCommandsLayout);

        skip |= ValidateArray(pGeneratedCommandsInfo_loc.dot(Field::streamCount), pGeneratedCommandsInfo_loc.dot(Field::pStreams),
                              pGeneratedCommandsInfo->streamCount, &pGeneratedCommandsInfo->pStreams, true, true,
                              "VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength",
                              "VUID-VkGeneratedCommandsInfoNV-pStreams-parameter");

        if (pGeneratedCommandsInfo->pStreams != nullptr) {
            for (uint32_t streamIndex = 0; streamIndex < pGeneratedCommandsInfo->streamCount; ++streamIndex) {
                [[maybe_unused]] const Location pStreams_loc = pGeneratedCommandsInfo_loc.dot(Field::pStreams, streamIndex);
                skip |=
                    ValidateRequiredHandle(pStreams_loc.dot(Field::buffer), pGeneratedCommandsInfo->pStreams[streamIndex].buffer);
            }
        }

        skip |= ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::preprocessBuffer),
                                       pGeneratedCommandsInfo->preprocessBuffer);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer,
                                                                      VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline,
                                                                      uint32_t groupIndex, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateIndirectCommandsLayoutNV(VkDevice device,
                                                                        const VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        VkIndirectCommandsLayoutNV* pIndirectCommandsLayout,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
                               true, "VUID-vkCreateIndirectCommandsLayoutNV-pCreateInfo-parameter",
                               "VUID-VkIndirectCommandsLayoutCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkIndirectCommandsLayoutCreateInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkIndirectCommandsLayoutUsageFlagBitsNV,
                              AllVkIndirectCommandsLayoutUsageFlagBitsNV, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkIndirectCommandsLayoutCreateInfoNV-flags-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint,
                                   pCreateInfo->pipelineBindPoint,
                                   "VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);

        skip |= ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::tokenCount), pCreateInfo_loc.dot(Field::pTokens), pCreateInfo->tokenCount,
            pCreateInfo->pTokens, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV, true, true,
            "VUID-VkIndirectCommandsLayoutTokenNV-sType-sType", "VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-parameter",
            "VUID-VkIndirectCommandsLayoutCreateInfoNV-tokenCount-arraylength");

        if (pCreateInfo->pTokens != nullptr) {
            for (uint32_t tokenIndex = 0; tokenIndex < pCreateInfo->tokenCount; ++tokenIndex) {
                [[maybe_unused]] const Location pTokens_loc = pCreateInfo_loc.dot(Field::pTokens, tokenIndex);
                skip |= ValidateStructPnext(pTokens_loc, pCreateInfo->pTokens[tokenIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkIndirectCommandsLayoutTokenNV-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pTokens_loc.dot(Field::tokenType), vvl::Enum::VkIndirectCommandsTokenTypeNV,
                                           pCreateInfo->pTokens[tokenIndex].tokenType,
                                           "VUID-VkIndirectCommandsLayoutTokenNV-tokenType-parameter", VK_NULL_HANDLE);

                skip |= ValidateBool32(pTokens_loc.dot(Field::vertexDynamicStride),
                                       pCreateInfo->pTokens[tokenIndex].vertexDynamicStride);

                skip |= ValidateFlags(pTokens_loc.dot(Field::pushconstantShaderStageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfo->pTokens[tokenIndex].pushconstantShaderStageFlags,
                                      kOptionalFlags, VK_NULL_HANDLE,
                                      "VUID-VkIndirectCommandsLayoutTokenNV-pushconstantShaderStageFlags-parameter");

                skip |=
                    ValidateFlags(pTokens_loc.dot(Field::indirectStateFlags), vvl::FlagBitmask::VkIndirectStateFlagBitsNV,
                                  AllVkIndirectStateFlagBitsNV, pCreateInfo->pTokens[tokenIndex].indirectStateFlags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkIndirectCommandsLayoutTokenNV-indirectStateFlags-parameter");

                skip |= ValidateRangedEnumArray(pTokens_loc.dot(Field::indexTypeCount), pTokens_loc.dot(Field::pIndexTypes),
                                                vvl::Enum::VkIndexType, pCreateInfo->pTokens[tokenIndex].indexTypeCount,
                                                pCreateInfo->pTokens[tokenIndex].pIndexTypes, false, true, kVUIDUndefined,
                                                "VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypes-parameter");

                skip |= ValidateArray(pTokens_loc.dot(Field::indexTypeCount), pTokens_loc.dot(Field::pIndexTypeValues),
                                      pCreateInfo->pTokens[tokenIndex].indexTypeCount,
                                      &pCreateInfo->pTokens[tokenIndex].pIndexTypeValues, false, true, kVUIDUndefined,
                                      "VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypeValues-parameter");
            }
        }

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::streamCount), pCreateInfo_loc.dot(Field::pStreamStrides),
                              pCreateInfo->streamCount, &pCreateInfo->pStreamStrides, true, true,
                              "VUID-VkIndirectCommandsLayoutCreateInfoNV-streamCount-arraylength",
                              "VUID-VkIndirectCommandsLayoutCreateInfoNV-pStreamStrides-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pIndirectCommandsLayout), pIndirectCommandsLayout,
                                    "VUID-vkCreateIndirectCommandsLayoutNV-pIndirectCommandsLayout-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyIndirectCommandsLayoutNV(VkDevice device,
                                                                         VkIndirectCommandsLayoutNV indirectCommandsLayout,
                                                                         const VkAllocationCallbacks* pAllocator,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer,
                                                             const VkDepthBiasInfoEXT* pDepthBiasInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_depth_bias_control))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_depth_bias_control});
    skip |= ValidateStructType(loc.dot(Field::pDepthBiasInfo), pDepthBiasInfo, VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT, true,
                               "VUID-vkCmdSetDepthBias2EXT-pDepthBiasInfo-parameter", "VUID-VkDepthBiasInfoEXT-sType-sType");
    if (pDepthBiasInfo != nullptr) {
        [[maybe_unused]] const Location pDepthBiasInfo_loc = loc.dot(Field::pDepthBiasInfo);
        constexpr std::array allowed_structs_VkDepthBiasInfoEXT = {VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT};

        skip |= ValidateStructPnext(pDepthBiasInfo_loc, pDepthBiasInfo->pNext, allowed_structs_VkDepthBiasInfoEXT.size(),
                                    allowed_structs_VkDepthBiasInfoEXT.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkDepthBiasInfoEXT-pNext-pNext", "VUID-VkDepthBiasInfoEXT-sType-unique", VK_NULL_HANDLE,
                                    true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_acquire_drm_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_drm_display});
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId,
                                                          VkDisplayKHR* display, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_acquire_drm_display))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_drm_display});
    skip |= ValidateRequiredPointer(loc.dot(Field::display), display, "VUID-vkGetDrmDisplayEXT-display-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo* pCreateInfo,
                                                                  const VkAllocationCallbacks* pAllocator,
                                                                  VkPrivateDataSlot* pPrivateDataSlot,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                                                   const VkAllocationCallbacks* pAllocator,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateDestroyPrivateDataSlot(device, privateDataSlot, pAllocator, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                                           VkPrivateDataSlot privateDataSlot, uint64_t data,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateSetPrivateData(device, objectType, objectHandle, privateDataSlot, data, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                                           VkPrivateDataSlot privateDataSlot, uint64_t* pData,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_private_data))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_private_data});
    skip |= PreCallValidateGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV* pCreateInfo,
                                                            const VkAllocationCallbacks* pAllocator, VkCudaModuleNV* pModule,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV, true,
                               "VUID-vkCreateCudaModuleNV-pCreateInfo-parameter", "VUID-VkCudaModuleCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCudaModuleCreateInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::dataSize), pCreateInfo_loc.dot(Field::pData), pCreateInfo->dataSize,
                              &pCreateInfo->pData, true, true, "VUID-VkCudaModuleCreateInfoNV-dataSize-arraylength",
                              "VUID-VkCudaModuleCreateInfoNV-pData-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pModule), pModule, "VUID-vkCreateCudaModuleNV-pModule-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t* pCacheSize,
                                                              void* pCacheData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= ValidateRequiredHandle(loc.dot(Field::module), module);
    skip |= ValidatePointerArray(loc.dot(Field::pCacheSize), loc.dot(Field::pCacheData), pCacheSize, &pCacheData, true, false,
                                 false, "VUID-vkGetCudaModuleCacheNV-pCacheSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetCudaModuleCacheNV-pCacheData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV* pCreateInfo,
                                                              const VkAllocationCallbacks* pAllocator, VkCudaFunctionNV* pFunction,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV, true,
                               "VUID-vkCreateCudaFunctionNV-pCreateInfo-parameter", "VUID-VkCudaFunctionCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCudaFunctionCreateInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::module), pCreateInfo->module);

        skip |= ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pName), pCreateInfo->pName,
                                        "VUID-VkCudaFunctionCreateInfoNV-pName-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pFunction), pFunction, "VUID-vkCreateCudaFunctionNV-pFunction-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module,
                                                             const VkAllocationCallbacks* pAllocator,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= ValidateRequiredHandle(loc.dot(Field::module), module);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function,
                                                               const VkAllocationCallbacks* pAllocator,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= ValidateRequiredHandle(loc.dot(Field::function), function);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV* pLaunchInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_cuda_kernel_launch))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_cuda_kernel_launch});
    skip |= ValidateStructType(loc.dot(Field::pLaunchInfo), pLaunchInfo, VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV, true,
                               "VUID-vkCmdCudaLaunchKernelNV-pLaunchInfo-parameter", "VUID-VkCudaLaunchInfoNV-sType-sType");
    if (pLaunchInfo != nullptr) {
        [[maybe_unused]] const Location pLaunchInfo_loc = loc.dot(Field::pLaunchInfo);
        skip |= ValidateStructPnext(pLaunchInfo_loc, pLaunchInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCudaLaunchInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pLaunchInfo_loc.dot(Field::function), pLaunchInfo->function);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_METAL_EXT
bool StatelessValidation::PreCallValidateExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT* pMetalObjectsInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_metal_objects))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_metal_objects});
    skip |= ValidateStructType(
        loc.dot(Field::pMetalObjectsInfo), pMetalObjectsInfo, VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT, true,
        "VUID-vkExportMetalObjectsEXT-pMetalObjectsInfo-parameter", "VUID-VkExportMetalObjectsInfoEXT-sType-sType");
    if (!skip) skip |= manual_PreCallValidateExportMetalObjectsEXT(device, pMetalObjectsInfo, error_obj);
    return skip;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout,
                                                                       VkDeviceSize* pLayoutSizeInBytes,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= ValidateRequiredPointer(loc.dot(Field::pLayoutSizeInBytes), pLayoutSizeInBytes,
                                    "VUID-vkGetDescriptorSetLayoutSizeEXT-pLayoutSizeInBytes-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout,
                                                                                uint32_t binding, VkDeviceSize* pOffset,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= ValidateRequiredPointer(loc.dot(Field::pOffset), pOffset,
                                    "VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-pOffset-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT* pDescriptorInfo,
                                                          size_t dataSize, void* pDescriptor, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateStructType(loc.dot(Field::pDescriptorInfo), pDescriptorInfo, VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT, true,
                               "VUID-vkGetDescriptorEXT-pDescriptorInfo-parameter", "VUID-VkDescriptorGetInfoEXT-sType-sType");
    if (pDescriptorInfo != nullptr) {
        [[maybe_unused]] const Location pDescriptorInfo_loc = loc.dot(Field::pDescriptorInfo);
        skip |= ValidateStructPnext(pDescriptorInfo_loc, pDescriptorInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorGetInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pDescriptorInfo_loc.dot(Field::type), vvl::Enum::VkDescriptorType, pDescriptorInfo->type,
                                   "VUID-VkDescriptorGetInfoEXT-type-parameter", VK_NULL_HANDLE);
    }
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pDescriptor), dataSize, &pDescriptor, true, true,
                          "VUID-vkGetDescriptorEXT-dataSize-arraylength", "VUID-vkGetDescriptorEXT-pDescriptor-parameter");
    if (!skip) skip |= manual_PreCallValidateGetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount,
                                                                     const VkDescriptorBufferBindingInfoEXT* pBindingInfos,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateStructTypeArray(
        loc.dot(Field::bufferCount), loc.dot(Field::pBindingInfos), bufferCount, pBindingInfos,
        VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT, true, true, "VUID-VkDescriptorBufferBindingInfoEXT-sType-sType",
        "VUID-vkCmdBindDescriptorBuffersEXT-pBindingInfos-parameter", "VUID-vkCmdBindDescriptorBuffersEXT-bufferCount-arraylength");
    if (pBindingInfos != nullptr) {
        for (uint32_t bufferIndex = 0; bufferIndex < bufferCount; ++bufferIndex) {
            [[maybe_unused]] const Location pBindingInfos_loc = loc.dot(Field::pBindingInfos, bufferIndex);
            constexpr std::array allowed_structs_VkDescriptorBufferBindingInfoEXT = {
                VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT};

            skip |= ValidateStructPnext(pBindingInfos_loc, pBindingInfos[bufferIndex].pNext,
                                        allowed_structs_VkDescriptorBufferBindingInfoEXT.size(),
                                        allowed_structs_VkDescriptorBufferBindingInfoEXT.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkDescriptorBufferBindingInfoEXT-pNext-pNext",
                                        "VUID-VkDescriptorBufferBindingInfoEXT-sType-unique", VK_NULL_HANDLE, true);
        }
    }
    if (!skip) skip |= manual_PreCallValidateCmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDescriptorBufferOffsetsEXT(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet,
    uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    skip |= ValidateArray(loc.dot(Field::setCount), loc.dot(Field::pBufferIndices), setCount, &pBufferIndices, true, true,
                          "VUID-vkCmdSetDescriptorBufferOffsetsEXT-setCount-arraylength",
                          "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pBufferIndices-parameter");
    skip |= ValidateArray(loc.dot(Field::setCount), loc.dot(Field::pOffsets), setCount, &pOffsets, true, true,
                          "VUID-vkCmdSetDescriptorBufferOffsetsEXT-setCount-arraylength",
                          "VUID-vkCmdSetDescriptorBufferOffsetsEXT-pOffsets-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer,
                                                                                    VkPipelineBindPoint pipelineBindPoint,
                                                                                    VkPipelineLayout layout, uint32_t set,
                                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdBindDescriptorBufferEmbeddedSamplersEXT-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::layout), layout);
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                                 const VkBufferCaptureDescriptorDataInfoEXT* pInfo,
                                                                                 void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true,
                               "VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                               "VUID-VkBufferCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pData), pData, "VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                                const VkImageCaptureDescriptorDataInfoEXT* pInfo,
                                                                                void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true,
                               "VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                               "VUID-VkImageCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkImageCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pData), pData, "VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetImageViewOpaqueCaptureDescriptorDataEXT(
    VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true,
                               "VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                               "VUID-VkImageViewCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |=
            ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkImageViewCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::imageView), pInfo->imageView);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pData), pData, "VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetSamplerOpaqueCaptureDescriptorDataEXT(
    VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, true,
                               "VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                               "VUID-VkSamplerCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSamplerCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::sampler), pInfo->sampler);
    }
    skip |=
        ValidateRequiredPointer(loc.dot(Field::pData), pData, "VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(
    VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_descriptor_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_descriptor_buffer});
    skip |=
        ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
                           true, "VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-pInfo-parameter",
                           "VUID-VkAccelerationStructureCaptureDescriptorDataInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureCaptureDescriptorDataInfoEXT-pNext-pNext", kVUIDUndefined,
                                    VK_NULL_HANDLE, true);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pData), pData,
                                    "VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer,
                                                                         VkFragmentShadingRateNV shadingRate,
                                                                         const VkFragmentShadingRateCombinerOpKHR combinerOps[2],
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_fragment_shading_rate_enums))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_fragment_shading_rate_enums});
    skip |= ValidateRangedEnum(loc.dot(Field::shadingRate), vvl::Enum::VkFragmentShadingRateNV, shadingRate,
                               "VUID-vkCmdSetFragmentShadingRateEnumNV-shadingRate-parameter", VK_NULL_HANDLE);
    skip |= ValidateRangedEnumArray(loc, loc.dot(Field::combinerOps), vvl::Enum::VkFragmentShadingRateCombinerOpKHR, 2, combinerOps,
                                    false, true, kVUIDUndefined, "VUID-vkCmdSetFragmentShadingRateEnumNV-combinerOps-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts,
                                                               VkDeviceFaultInfoEXT* pFaultInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_fault))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_fault});
    skip |= ValidateStructType(loc.dot(Field::pFaultCounts), pFaultCounts, VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT, true,
                               "VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-parameter", "VUID-VkDeviceFaultCountsEXT-sType-sType");
    skip |= ValidateStructType(loc.dot(Field::pFaultInfo), pFaultInfo, VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT, false,
                               "VUID-vkGetDeviceFaultInfoEXT-pFaultInfo-parameter", "VUID-VkDeviceFaultInfoEXT-sType-sType");
    if (pFaultInfo != nullptr) {
        [[maybe_unused]] const Location pFaultInfo_loc = loc.dot(Field::pFaultInfo);
        skip |= ValidateStructPnext(pFaultInfo_loc, pFaultInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDeviceFaultInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
bool StatelessValidation::PreCallValidateAcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredHandle(loc.dot(Field::display), display);
    return skip;
}

bool StatelessValidation::PreCallValidateGetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId,
                                                           VkDisplayKHR* pDisplay, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateRequiredPointer(loc.dot(Field::pDisplay), pDisplay, "VUID-vkGetWinrtDisplayNV-pDisplay-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
bool StatelessValidation::PreCallValidateCreateDirectFBSurfaceEXT(VkInstance instance,
                                                                  const VkDirectFBSurfaceCreateInfoEXT* pCreateInfo,
                                                                  const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_directfb_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_directfb_surface});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT, true,
                               "VUID-vkCreateDirectFBSurfaceEXT-pCreateInfo-parameter",
                               "VUID-VkDirectFBSurfaceCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDirectFBSurfaceCreateInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkDirectFBSurfaceCreateInfoEXT-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateDirectFBSurfaceEXT-pSurface-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice,
                                                                                         uint32_t queueFamilyIndex, IDirectFB* dfb,
                                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_ext_directfb_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_directfb_surface});
    skip |=
        ValidateRequiredPointer(loc.dot(Field::dfb), dfb, "VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-dfb-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_DIRECTFB_EXT

bool StatelessValidation::PreCallValidateCmdSetVertexInputEXT(
    VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount,
    const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount,
    const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_vertex_input_dynamic_state) ||
          IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |=
            OutputExtensionError(loc, {vvl::Extension::_VK_EXT_vertex_input_dynamic_state, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateStructTypeArray(loc.dot(Field::vertexBindingDescriptionCount), loc.dot(Field::pVertexBindingDescriptions),
                                    vertexBindingDescriptionCount, pVertexBindingDescriptions,
                                    VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT, false, true,
                                    "VUID-VkVertexInputBindingDescription2EXT-sType-sType",
                                    "VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-parameter", kVUIDUndefined);
    if (pVertexBindingDescriptions != nullptr) {
        for (uint32_t vertexBindingDescriptionIndex = 0; vertexBindingDescriptionIndex < vertexBindingDescriptionCount;
             ++vertexBindingDescriptionIndex) {
            [[maybe_unused]] const Location pVertexBindingDescriptions_loc =
                loc.dot(Field::pVertexBindingDescriptions, vertexBindingDescriptionIndex);
            skip |= ValidateRangedEnum(pVertexBindingDescriptions_loc.dot(Field::inputRate), vvl::Enum::VkVertexInputRate,
                                       pVertexBindingDescriptions[vertexBindingDescriptionIndex].inputRate,
                                       "VUID-VkVertexInputBindingDescription2EXT-inputRate-parameter", VK_NULL_HANDLE);
        }
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::vertexAttributeDescriptionCount), loc.dot(Field::pVertexAttributeDescriptions),
                                    vertexAttributeDescriptionCount, pVertexAttributeDescriptions,
                                    VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT, false, true,
                                    "VUID-VkVertexInputAttributeDescription2EXT-sType-sType",
                                    "VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-parameter", kVUIDUndefined);
    if (pVertexAttributeDescriptions != nullptr) {
        for (uint32_t vertexAttributeDescriptionIndex = 0; vertexAttributeDescriptionIndex < vertexAttributeDescriptionCount;
             ++vertexAttributeDescriptionIndex) {
            [[maybe_unused]] const Location pVertexAttributeDescriptions_loc =
                loc.dot(Field::pVertexAttributeDescriptions, vertexAttributeDescriptionIndex);
            skip |= ValidateRangedEnum(pVertexAttributeDescriptions_loc.dot(Field::format), vvl::Enum::VkFormat,
                                       pVertexAttributeDescriptions[vertexAttributeDescriptionIndex].format,
                                       "VUID-VkVertexInputAttributeDescription2EXT-format-parameter", VK_NULL_HANDLE);
        }
    }
    if (!skip)
        skip |=
            manual_PreCallValidateCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions,
                                                       vertexAttributeDescriptionCount, pVertexAttributeDescriptions, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
bool StatelessValidation::PreCallValidateGetMemoryZirconHandleFUCHSIA(
    VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_memory))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_memory});
    skip |= ValidateStructType(loc.dot(Field::pGetZirconHandleInfo), pGetZirconHandleInfo,
                               VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA, true,
                               "VUID-vkGetMemoryZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter",
                               "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-sType-sType");
    if (pGetZirconHandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetZirconHandleInfo_loc = loc.dot(Field::pGetZirconHandleInfo);
        skip |= ValidateStructPnext(pGetZirconHandleInfo_loc, pGetZirconHandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetZirconHandleInfo_loc.dot(Field::memory), pGetZirconHandleInfo->memory);

        skip |= ValidateFlags(pGetZirconHandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                              AllVkExternalMemoryHandleTypeFlagBits, pGetZirconHandleInfo->handleType, kRequiredSingleBit,
                              VK_NULL_HANDLE, "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter",
                              "VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pZirconHandle), pZirconHandle,
                                    "VUID-vkGetMemoryZirconHandleFUCHSIA-pZirconHandle-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryZirconHandlePropertiesFUCHSIA(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle,
    VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_memory))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_memory});
    skip |= ValidateFlags(loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
                          AllVkExternalMemoryHandleTypeFlagBits, handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter",
                          "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter");
    skip |= ValidateStructType(loc.dot(Field::pMemoryZirconHandleProperties), pMemoryZirconHandleProperties,
                               VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA, true,
                               "VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-pMemoryZirconHandleProperties-parameter",
                               "VUID-VkMemoryZirconHandlePropertiesFUCHSIA-sType-sType");
    if (pMemoryZirconHandleProperties != nullptr) {
        [[maybe_unused]] const Location pMemoryZirconHandleProperties_loc = loc.dot(Field::pMemoryZirconHandleProperties);
        skip |= ValidateStructPnext(pMemoryZirconHandleProperties_loc, pMemoryZirconHandleProperties->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryZirconHandlePropertiesFUCHSIA-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateImportSemaphoreZirconHandleFUCHSIA(
    VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_semaphore});
    skip |= ValidateStructType(loc.dot(Field::pImportSemaphoreZirconHandleInfo), pImportSemaphoreZirconHandleInfo,
                               VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA, true,
                               "VUID-vkImportSemaphoreZirconHandleFUCHSIA-pImportSemaphoreZirconHandleInfo-parameter",
                               "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-sType-sType");
    if (pImportSemaphoreZirconHandleInfo != nullptr) {
        [[maybe_unused]] const Location pImportSemaphoreZirconHandleInfo_loc = loc.dot(Field::pImportSemaphoreZirconHandleInfo);
        skip |= ValidateStructPnext(pImportSemaphoreZirconHandleInfo_loc, pImportSemaphoreZirconHandleInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pImportSemaphoreZirconHandleInfo_loc.dot(Field::semaphore),
                                       pImportSemaphoreZirconHandleInfo->semaphore);

        skip |= ValidateFlags(pImportSemaphoreZirconHandleInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkSemaphoreImportFlagBits,
                              AllVkSemaphoreImportFlagBits, pImportSemaphoreZirconHandleInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-flags-parameter");

        skip |= ValidateFlags(pImportSemaphoreZirconHandleInfo_loc.dot(Field::handleType),
                              vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits, AllVkExternalSemaphoreHandleTypeFlagBits,
                              pImportSemaphoreZirconHandleInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter",
                              "VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetSemaphoreZirconHandleFUCHSIA(
    VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_external_semaphore))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_external_semaphore});
    skip |= ValidateStructType(loc.dot(Field::pGetZirconHandleInfo), pGetZirconHandleInfo,
                               VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA, true,
                               "VUID-vkGetSemaphoreZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter",
                               "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-sType-sType");
    if (pGetZirconHandleInfo != nullptr) {
        [[maybe_unused]] const Location pGetZirconHandleInfo_loc = loc.dot(Field::pGetZirconHandleInfo);
        skip |= ValidateStructPnext(pGetZirconHandleInfo_loc, pGetZirconHandleInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pGetZirconHandleInfo_loc.dot(Field::semaphore), pGetZirconHandleInfo->semaphore);

        skip |=
            ValidateFlags(pGetZirconHandleInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalSemaphoreHandleTypeFlagBits,
                          AllVkExternalSemaphoreHandleTypeFlagBits, pGetZirconHandleInfo->handleType, kRequiredSingleBit,
                          VK_NULL_HANDLE, "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter",
                          "VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pZirconHandle), pZirconHandle,
                                    "VUID-vkGetSemaphoreZirconHandleFUCHSIA-pZirconHandle-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCreateBufferCollectionFUCHSIA(VkDevice device,
                                                                       const VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       VkBufferCollectionFUCHSIA* pCollection,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA,
                               true, "VUID-vkCreateBufferCollectionFUCHSIA-pCreateInfo-parameter",
                               "VUID-VkBufferCollectionCreateInfoFUCHSIA-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferCollectionCreateInfoFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pCollection), pCollection,
                                    "VUID-vkCreateBufferCollectionFUCHSIA-pCollection-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateSetBufferCollectionImageConstraintsFUCHSIA(
    VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= ValidateRequiredHandle(loc.dot(Field::collection), collection);
    skip |= ValidateStructType(loc.dot(Field::pImageConstraintsInfo), pImageConstraintsInfo,
                               VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA, true,
                               "VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-pImageConstraintsInfo-parameter",
                               "VUID-VkImageConstraintsInfoFUCHSIA-sType-sType");
    if (pImageConstraintsInfo != nullptr) {
        [[maybe_unused]] const Location pImageConstraintsInfo_loc = loc.dot(Field::pImageConstraintsInfo);
        skip |=
            ValidateStructPnext(pImageConstraintsInfo_loc, pImageConstraintsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkImageConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateStructTypeArray(pImageConstraintsInfo_loc.dot(Field::formatConstraintsCount),
                                        pImageConstraintsInfo_loc.dot(Field::pFormatConstraints),
                                        pImageConstraintsInfo->formatConstraintsCount, pImageConstraintsInfo->pFormatConstraints,
                                        VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA, true, true,
                                        "VUID-VkImageFormatConstraintsInfoFUCHSIA-sType-sType",
                                        "VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-parameter",
                                        "VUID-VkImageConstraintsInfoFUCHSIA-formatConstraintsCount-arraylength");

        if (pImageConstraintsInfo->pFormatConstraints != nullptr) {
            for (uint32_t formatConstraintsIndex = 0; formatConstraintsIndex < pImageConstraintsInfo->formatConstraintsCount;
                 ++formatConstraintsIndex) {
                [[maybe_unused]] const Location pFormatConstraints_loc =
                    pImageConstraintsInfo_loc.dot(Field::pFormatConstraints, formatConstraintsIndex);
                skip |= ValidateStructPnext(pFormatConstraints_loc,
                                            pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageFormatConstraintsInfoFUCHSIA-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateStructType(pFormatConstraints_loc.dot(Field::imageCreateInfo),
                                           &(pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo),
                                           VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, false, kVUIDUndefined,
                                           "VUID-VkImageCreateInfo-sType-sType");

                constexpr std::array allowed_structs_VkImageCreateInfo = {
                    VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA,
                    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
                    VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
                    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX,
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
                    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
                    VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
                    VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
                    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
                    VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
                    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
                    VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT,
                    VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT,
                    VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                    VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
                    VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

                skip |= ValidateStructPnext(pFormatConstraints_loc,
                                            pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.pNext,
                                            allowed_structs_VkImageCreateInfo.size(), allowed_structs_VkImageCreateInfo.data(),
                                            GeneratedVulkanHeaderVersion, "VUID-VkImageCreateInfo-pNext-pNext",
                                            "VUID-VkImageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

                skip |= ValidateFlags(pFormatConstraints_loc.dot(Field::flags), vvl::FlagBitmask::VkImageCreateFlagBits,
                                      AllVkImageCreateFlagBits,
                                      pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkImageCreateInfo-flags-parameter");

                skip |=
                    ValidateRangedEnum(pFormatConstraints_loc.dot(Field::imageType), vvl::Enum::VkImageType,
                                       pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.imageType,
                                       "VUID-VkImageCreateInfo-imageType-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pFormatConstraints_loc.dot(Field::format), vvl::Enum::VkFormat,
                                           pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.format,
                                           "VUID-VkImageCreateInfo-format-parameter", VK_NULL_HANDLE);

                // No xml-driven validation

                skip |= ValidateFlags(
                    pFormatConstraints_loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.samples, kRequiredSingleBit,
                    VK_NULL_HANDLE, "VUID-VkImageCreateInfo-samples-parameter", "VUID-VkImageCreateInfo-samples-parameter");

                skip |= ValidateRangedEnum(pFormatConstraints_loc.dot(Field::tiling), vvl::Enum::VkImageTiling,
                                           pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.tiling,
                                           "VUID-VkImageCreateInfo-tiling-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(
                    pFormatConstraints_loc.dot(Field::usage), vvl::FlagBitmask::VkImageUsageFlagBits, AllVkImageUsageFlagBits,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.usage, kRequiredFlags,
                    VK_NULL_HANDLE, "VUID-VkImageCreateInfo-usage-parameter", "VUID-VkImageCreateInfo-usage-requiredbitmask");

                skip |= ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.sharingMode,
                    "VUID-VkImageCreateInfo-sharingMode-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(
                    pFormatConstraints_loc.dot(Field::initialLayout), vvl::Enum::VkImageLayout,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].imageCreateInfo.initialLayout,
                    "VUID-VkImageCreateInfo-initialLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pFormatConstraints_loc.dot(Field::requiredFormatFeatures),
                                      vvl::FlagBitmask::VkFormatFeatureFlagBits, AllVkFormatFeatureFlagBits,
                                      pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].requiredFormatFeatures,
                                      kRequiredFlags, VK_NULL_HANDLE,
                                      "VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter",
                                      "VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-requiredbitmask");

                skip |= ValidateReservedFlags(pFormatConstraints_loc.dot(Field::flags),
                                              pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].flags,
                                              "VUID-VkImageFormatConstraintsInfoFUCHSIA-flags-zerobitmask");

                skip |= ValidateStructTypeArray(
                    pFormatConstraints_loc.dot(Field::colorSpaceCount), pFormatConstraints_loc.dot(Field::pColorSpaces),
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].colorSpaceCount,
                    pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces,
                    VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA, true, true, "VUID-VkSysmemColorSpaceFUCHSIA-sType-sType",
                    "VUID-VkImageFormatConstraintsInfoFUCHSIA-pColorSpaces-parameter",
                    "VUID-VkImageFormatConstraintsInfoFUCHSIA-colorSpaceCount-arraylength");

                if (pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces != nullptr) {
                    for (uint32_t colorSpaceIndex = 0;
                         colorSpaceIndex < pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].colorSpaceCount;
                         ++colorSpaceIndex) {
                        [[maybe_unused]] const Location pColorSpaces_loc =
                            pFormatConstraints_loc.dot(Field::pColorSpaces, colorSpaceIndex);
                        skip |= ValidateStructPnext(
                            pColorSpaces_loc,
                            pImageConstraintsInfo->pFormatConstraints[formatConstraintsIndex].pColorSpaces[colorSpaceIndex].pNext,
                            0, nullptr, GeneratedVulkanHeaderVersion, "VUID-VkSysmemColorSpaceFUCHSIA-pNext-pNext", kVUIDUndefined,
                            VK_NULL_HANDLE, true);
                    }
                }
            }
        }

        skip |= ValidateStructType(pImageConstraintsInfo_loc.dot(Field::bufferCollectionConstraints),
                                   &(pImageConstraintsInfo->bufferCollectionConstraints),
                                   VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA, false, kVUIDUndefined,
                                   "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType");

        skip |= ValidateStructPnext(pImageConstraintsInfo_loc, pImageConstraintsInfo->bufferCollectionConstraints.pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext",
                                    kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pImageConstraintsInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkImageConstraintsInfoFlagBitsFUCHSIA,
                              AllVkImageConstraintsInfoFlagBitsFUCHSIA, pImageConstraintsInfo->flags, kOptionalFlags,
                              VK_NULL_HANDLE, "VUID-VkImageConstraintsInfoFUCHSIA-flags-parameter");
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSetBufferCollectionBufferConstraintsFUCHSIA(
    VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= ValidateRequiredHandle(loc.dot(Field::collection), collection);
    skip |= ValidateStructType(loc.dot(Field::pBufferConstraintsInfo), pBufferConstraintsInfo,
                               VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA, true,
                               "VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-pBufferConstraintsInfo-parameter",
                               "VUID-VkBufferConstraintsInfoFUCHSIA-sType-sType");
    if (pBufferConstraintsInfo != nullptr) {
        [[maybe_unused]] const Location pBufferConstraintsInfo_loc = loc.dot(Field::pBufferConstraintsInfo);
        skip |=
            ValidateStructPnext(pBufferConstraintsInfo_loc, pBufferConstraintsInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkBufferConstraintsInfoFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateStructType(pBufferConstraintsInfo_loc.dot(Field::createInfo), &(pBufferConstraintsInfo->createInfo),
                               VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, false, kVUIDUndefined, "VUID-VkBufferCreateInfo-sType-sType");

        constexpr std::array allowed_structs_VkBufferCreateInfo = {VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA,
                                                                   VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR,
                                                                   VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
                                                                   VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
                                                                   VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
                                                                   VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR};

        skip |= ValidateStructPnext(pBufferConstraintsInfo_loc, pBufferConstraintsInfo->createInfo.pNext,
                                    allowed_structs_VkBufferCreateInfo.size(), allowed_structs_VkBufferCreateInfo.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkBufferCreateInfo-pNext-pNext",
                                    "VUID-VkBufferCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pBufferConstraintsInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBufferCreateFlagBits,
                              AllVkBufferCreateFlagBits, pBufferConstraintsInfo->createInfo.flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkBufferCreateInfo-flags-parameter");

        skip |= ValidateRangedEnum(pBufferConstraintsInfo_loc.dot(Field::sharingMode), vvl::Enum::VkSharingMode,
                                   pBufferConstraintsInfo->createInfo.sharingMode, "VUID-VkBufferCreateInfo-sharingMode-parameter",
                                   VK_NULL_HANDLE);

        skip |=
            ValidateFlags(pBufferConstraintsInfo_loc.dot(Field::requiredFormatFeatures), vvl::FlagBitmask::VkFormatFeatureFlagBits,
                          AllVkFormatFeatureFlagBits, pBufferConstraintsInfo->requiredFormatFeatures, kOptionalFlags,
                          VK_NULL_HANDLE, "VUID-VkBufferConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter");

        skip |= ValidateStructType(pBufferConstraintsInfo_loc.dot(Field::bufferCollectionConstraints),
                                   &(pBufferConstraintsInfo->bufferCollectionConstraints),
                                   VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA, false, kVUIDUndefined,
                                   "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType");

        skip |=
            ValidateStructPnext(pBufferConstraintsInfo_loc, pBufferConstraintsInfo->bufferCollectionConstraints.pNext, 0, nullptr,
                                GeneratedVulkanHeaderVersion, "VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext",
                                kVUIDUndefined, VK_NULL_HANDLE, true);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= ValidateRequiredHandle(loc.dot(Field::collection), collection);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                                              VkBufferCollectionPropertiesFUCHSIA* pProperties,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_fuchsia_buffer_collection))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_FUCHSIA_buffer_collection});
    skip |= ValidateRequiredHandle(loc.dot(Field::collection), collection);
    skip |= ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA,
                               true, "VUID-vkGetBufferCollectionPropertiesFUCHSIA-pProperties-parameter",
                               "VUID-VkBufferCollectionPropertiesFUCHSIA-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        skip |= ValidateStructPnext(pProperties_loc, pProperties->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkBufferCollectionPropertiesFUCHSIA-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

bool StatelessValidation::PreCallValidateGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass,
                                                                                       VkExtent2D* pMaxWorkgroupSize,
                                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_subpass_shading))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_subpass_shading});
    skip |= ValidateRequiredHandle(loc.dot(Field::renderpass), renderpass);
    skip |= ValidateRequiredPointer(loc.dot(Field::pMaxWorkgroupSize), pMaxWorkgroupSize,
                                    "VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-pMaxWorkgroupSize-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_subpass_shading))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_subpass_shading});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView,
                                                                     VkImageLayout imageLayout,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_invocation_mask))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_invocation_mask});
    skip |= ValidateRangedEnum(loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout, imageLayout,
                               "VUID-vkCmdBindInvocationMaskHUAWEI-imageLayout-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateGetMemoryRemoteAddressNV(VkDevice device,
                                                                  const VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo,
                                                                  VkRemoteAddressNV* pAddress, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_external_memory_rdma))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_external_memory_rdma});
    skip |= ValidateStructType(loc.dot(Field::pMemoryGetRemoteAddressInfo), pMemoryGetRemoteAddressInfo,
                               VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV, true,
                               "VUID-vkGetMemoryRemoteAddressNV-pMemoryGetRemoteAddressInfo-parameter",
                               "VUID-VkMemoryGetRemoteAddressInfoNV-sType-sType");
    if (pMemoryGetRemoteAddressInfo != nullptr) {
        [[maybe_unused]] const Location pMemoryGetRemoteAddressInfo_loc = loc.dot(Field::pMemoryGetRemoteAddressInfo);
        skip |= ValidateStructPnext(pMemoryGetRemoteAddressInfo_loc, pMemoryGetRemoteAddressInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryGetRemoteAddressInfoNV-pNext-pNext", kVUIDUndefined,
                                    VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pMemoryGetRemoteAddressInfo_loc.dot(Field::memory), pMemoryGetRemoteAddressInfo->memory);

        skip |= ValidateFlags(
            pMemoryGetRemoteAddressInfo_loc.dot(Field::handleType), vvl::FlagBitmask::VkExternalMemoryHandleTypeFlagBits,
            AllVkExternalMemoryHandleTypeFlagBits, pMemoryGetRemoteAddressInfo->handleType, kRequiredSingleBit, VK_NULL_HANDLE,
            "VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter", "VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pAddress), pAddress, "VUID-vkGetMemoryRemoteAddressNV-pAddress-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT* pPipelineInfo,
                                                                  VkBaseOutStructure* pPipelineProperties,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_pipeline_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_pipeline_properties});
    skip |= ValidateRequiredPointer(loc.dot(Field::pPipelineInfo), pPipelineInfo,
                                    "VUID-vkGetPipelinePropertiesEXT-pPipelineInfo-parameter");
    if (!skip) skip |= manual_PreCallValidateGetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer,
                                                                          VkBool32 rasterizerDiscardEnable,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRangedEnum(loc.dot(Field::logicOp), vvl::Enum::VkLogicOp, logicOp, "VUID-vkCmdSetLogicOpEXT-logicOp-parameter",
                               VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer,
                                                                         VkBool32 primitiveRestartEnable,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});
    skip |= PreCallValidateCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable, error_obj);
    return skip;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool StatelessValidation::PreCallValidateCreateScreenSurfaceQNX(VkInstance instance,
                                                                const VkScreenSurfaceCreateInfoQNX* pCreateInfo,
                                                                const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_qnx_screen_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_screen_surface});
    skip |=
        ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX, true,
                           "VUID-vkCreateScreenSurfaceQNX-pCreateInfo-parameter", "VUID-VkScreenSurfaceCreateInfoQNX-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkScreenSurfaceCreateInfoQNX-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkScreenSurfaceCreateInfoQNX-flags-zerobitmask");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, "VUID-vkCreateScreenSurfaceQNX-pSurface-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice,
                                                                                       uint32_t queueFamilyIndex,
                                                                                       struct _screen_window* window,
                                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(instance_extensions.vk_qnx_screen_surface))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_screen_surface});
    skip |= ValidateRequiredPointer(loc.dot(Field::window), window,
                                    "VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-window-parameter");
    return skip;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

bool StatelessValidation::PreCallValidateCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                                                   const VkBool32* pColorWriteEnables,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_color_write_enable))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_color_write_enable});
    skip |= ValidateBool32Array(loc.dot(Field::attachmentCount), loc.dot(Field::pColorWriteEnables), attachmentCount,
                                pColorWriteEnables, true, true, "VUID-vkCmdSetColorWriteEnableEXT-attachmentCount-arraylength",
                                "VUID-vkCmdSetColorWriteEnableEXT-pColorWriteEnables-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                                         const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount,
                                                         uint32_t firstInstance, uint32_t stride,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_multi_draw)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_multi_draw});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                                                const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount,
                                                                uint32_t firstInstance, uint32_t stride,
                                                                const int32_t* pVertexOffset, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_multi_draw)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_multi_draw});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT* pCreateInfo,
                                                           const VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT, true,
                               "VUID-vkCreateMicromapEXT-pCreateInfo-parameter", "VUID-VkMicromapCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMicromapCreateInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::createFlags), vvl::FlagBitmask::VkMicromapCreateFlagBitsEXT,
                              AllVkMicromapCreateFlagBitsEXT, pCreateInfo->createFlags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkMicromapCreateInfoEXT-createFlags-parameter");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::buffer), pCreateInfo->buffer);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pCreateInfo->type,
                                   "VUID-VkMicromapCreateInfoEXT-type-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pMicromap), pMicromap, "VUID-vkCreateMicromapEXT-pMicromap-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap,
                                                            const VkAllocationCallbacks* pAllocator,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                              const VkMicromapBuildInfoEXT* pInfos,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                    VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, true,
                                    "VUID-VkMicromapBuildInfoEXT-sType-sType", "VUID-vkCmdBuildMicromapsEXT-pInfos-parameter",
                                    "VUID-vkCmdBuildMicromapsEXT-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pInfos[infoIndex].type,
                                       "VUID-VkMicromapBuildInfoEXT-type-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildMicromapFlagBitsEXT,
                                  AllVkBuildMicromapFlagBitsEXT, pInfos[infoIndex].flags, kOptionalFlags, VK_NULL_HANDLE,
                                  "VUID-VkMicromapBuildInfoEXT-flags-parameter");

            if (pInfos[infoIndex].pUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location pUsageCounts_loc = pInfos_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }

            if (pInfos[infoIndex].ppUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location ppUsageCounts_loc = pInfos_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                           uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |=
        ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true, true, "VUID-VkMicromapBuildInfoEXT-sType-sType",
                                "VUID-vkBuildMicromapsEXT-pInfos-parameter", "VUID-vkBuildMicromapsEXT-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pInfos[infoIndex].type,
                                       "VUID-VkMicromapBuildInfoEXT-type-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildMicromapFlagBitsEXT,
                                  AllVkBuildMicromapFlagBitsEXT, pInfos[infoIndex].flags, kOptionalFlags, VK_NULL_HANDLE,
                                  "VUID-VkMicromapBuildInfoEXT-flags-parameter");

            if (pInfos[infoIndex].pUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location pUsageCounts_loc = pInfos_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }

            if (pInfos[infoIndex].ppUsageCounts != nullptr) {
                for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pInfos[infoIndex].usageCountsCount; ++usageIndexsIndex) {
                    [[maybe_unused]] const Location ppUsageCounts_loc = pInfos_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                    // No xml-driven validation
                }
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                         const VkCopyMicromapInfoEXT* pInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, true,
                               "VUID-vkCopyMicromapEXT-pInfo-parameter", "VUID-VkCopyMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMicromapInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                   "VUID-VkCopyMicromapInfoEXT-mode-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                                 const VkCopyMicromapToMemoryInfoEXT* pInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, true,
                               "VUID-vkCopyMicromapToMemoryEXT-pInfo-parameter", "VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                   "VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                                 const VkCopyMemoryToMicromapInfoEXT* pInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, true,
                               "VUID-vkCopyMemoryToMicromapEXT-pInfo-parameter", "VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                   "VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount,
                                                                     const VkMicromapEXT* pMicromaps, VkQueryType queryType,
                                                                     size_t dataSize, void* pData, size_t stride,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateHandleArray(loc.dot(Field::micromapCount), loc.dot(Field::pMicromaps), micromapCount, pMicromaps, true, true,
                                "VUID-vkWriteMicromapsPropertiesEXT-micromapCount-arraylength");
    skip |= ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                               "VUID-vkWriteMicromapsPropertiesEXT-queryType-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkWriteMicromapsPropertiesEXT-dataSize-arraylength",
                          "VUID-vkWriteMicromapsPropertiesEXT-pData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT* pInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, true,
                               "VUID-vkCmdCopyMicromapEXT-pInfo-parameter", "VUID-VkCopyMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMicromapInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                   "VUID-VkCopyMicromapInfoEXT-mode-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer,
                                                                    const VkCopyMicromapToMemoryInfoEXT* pInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |=
        ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, true,
                           "VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-parameter", "VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                   "VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer,
                                                                    const VkCopyMemoryToMicromapInfoEXT* pInfo,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |=
        ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, true,
                           "VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-parameter", "VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyMicromapModeEXT, pInfo->mode,
                                   "VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount,
                                                                        const VkMicromapEXT* pMicromaps, VkQueryType queryType,
                                                                        VkQueryPool queryPool, uint32_t firstQuery,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateHandleArray(loc.dot(Field::micromapCount), loc.dot(Field::pMicromaps), micromapCount, pMicromaps, true, true,
                                "VUID-vkCmdWriteMicromapsPropertiesEXT-micromapCount-arraylength");
    skip |= ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                               "VUID-vkCmdWriteMicromapsPropertiesEXT-queryType-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceMicromapCompatibilityEXT(VkDevice device,
                                                                           const VkMicromapVersionInfoEXT* pVersionInfo,
                                                                           VkAccelerationStructureCompatibilityKHR* pCompatibility,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateStructType(loc.dot(Field::pVersionInfo), pVersionInfo, VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT, true,
                               "VUID-vkGetDeviceMicromapCompatibilityEXT-pVersionInfo-parameter",
                               "VUID-VkMicromapVersionInfoEXT-sType-sType");
    if (pVersionInfo != nullptr) {
        [[maybe_unused]] const Location pVersionInfo_loc = loc.dot(Field::pVersionInfo);
        skip |= ValidateStructPnext(pVersionInfo_loc, pVersionInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMicromapVersionInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pVersionInfo_loc.dot(Field::pVersionData), pVersionInfo->pVersionData,
                                        "VUID-VkMicromapVersionInfoEXT-pVersionData-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pCompatibility), pCompatibility,
                                    "VUID-vkGetDeviceMicromapCompatibilityEXT-pCompatibility-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
                                                                  const VkMicromapBuildInfoEXT* pBuildInfo,
                                                                  VkMicromapBuildSizesInfoEXT* pSizeInfo,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_opacity_micromap))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_opacity_micromap});
    skip |= ValidateRangedEnum(loc.dot(Field::buildType), vvl::Enum::VkAccelerationStructureBuildTypeKHR, buildType,
                               "VUID-vkGetMicromapBuildSizesEXT-buildType-parameter", VK_NULL_HANDLE);
    skip |= ValidateStructType(loc.dot(Field::pBuildInfo), pBuildInfo, VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, true,
                               "VUID-vkGetMicromapBuildSizesEXT-pBuildInfo-parameter", "VUID-VkMicromapBuildInfoEXT-sType-sType");
    if (pBuildInfo != nullptr) {
        [[maybe_unused]] const Location pBuildInfo_loc = loc.dot(Field::pBuildInfo);
        skip |= ValidateStructPnext(pBuildInfo_loc, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkMicromapBuildInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pBuildInfo_loc.dot(Field::type), vvl::Enum::VkMicromapTypeEXT, pBuildInfo->type,
                                   "VUID-VkMicromapBuildInfoEXT-type-parameter", VK_NULL_HANDLE);

        skip |= ValidateFlags(pBuildInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildMicromapFlagBitsEXT,
                              AllVkBuildMicromapFlagBitsEXT, pBuildInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkMicromapBuildInfoEXT-flags-parameter");

        if (pBuildInfo->pUsageCounts != nullptr) {
            for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pBuildInfo->usageCountsCount; ++usageIndexsIndex) {
                [[maybe_unused]] const Location pUsageCounts_loc = pBuildInfo_loc.dot(Field::pUsageCounts, usageIndexsIndex);
                // No xml-driven validation
            }
        }

        if (pBuildInfo->ppUsageCounts != nullptr) {
            for (uint32_t usageIndexsIndex = 0; usageIndexsIndex < pBuildInfo->usageCountsCount; ++usageIndexsIndex) {
                [[maybe_unused]] const Location ppUsageCounts_loc = pBuildInfo_loc.dot(Field::ppUsageCounts, usageIndexsIndex);
                // No xml-driven validation
            }
        }
    }
    skip |=
        ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo, VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT, true,
                           "VUID-vkGetMicromapBuildSizesEXT-pSizeInfo-parameter", "VUID-VkMicromapBuildSizesInfoEXT-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX,
                                                              uint32_t groupCountY, uint32_t groupCountZ,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_cluster_culling_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_cluster_culling_shader});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                      VkDeviceSize offset, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_huawei_cluster_culling_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_HUAWEI_cluster_culling_shader});
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateSetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_pageable_device_local_memory))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_pageable_device_local_memory});
    skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);
    if (!skip) skip |= manual_PreCallValidateSetDeviceMemoryPriorityEXT(device, memory, priority, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetLayoutHostMappingInfoVALVE(
    VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference,
    VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_valve_descriptor_set_host_mapping))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_VALVE_descriptor_set_host_mapping});
    skip |= ValidateStructType(loc.dot(Field::pBindingReference), pBindingReference,
                               VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE, true,
                               "VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter",
                               "VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType");
    if (pBindingReference != nullptr) {
        [[maybe_unused]] const Location pBindingReference_loc = loc.dot(Field::pBindingReference);
        skip |= ValidateStructPnext(pBindingReference_loc, pBindingReference->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateRequiredHandle(pBindingReference_loc.dot(Field::descriptorSetLayout), pBindingReference->descriptorSetLayout);
    }
    skip |= ValidateStructType(loc.dot(Field::pHostMapping), pHostMapping,
                               VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE, true,
                               "VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter",
                               "VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet,
                                                                          void** ppData, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_valve_descriptor_set_host_mapping))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_VALVE_descriptor_set_host_mapping});
    skip |= ValidateRequiredHandle(loc.dot(Field::descriptorSet), descriptorSet);
    skip |= ValidateRequiredPointer(loc.dot(Field::ppData), ppData, "VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress,
                                                                 uint32_t copyCount, uint32_t stride,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_copy_memory_indirect))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_copy_memory_indirect});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryToImageIndirectNV(
    VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage,
    VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_copy_memory_indirect))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_copy_memory_indirect});
    skip |= ValidateRequiredHandle(loc.dot(Field::dstImage), dstImage);
    skip |= ValidateRangedEnum(loc.dot(Field::dstImageLayout), vvl::Enum::VkImageLayout, dstImageLayout,
                               "VUID-vkCmdCopyMemoryToImageIndirectNV-dstImageLayout-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::copyCount), loc.dot(Field::pImageSubresources), copyCount, &pImageSubresources, true, true,
                          "VUID-vkCmdCopyMemoryToImageIndirectNV-copyCount-arraylength",
                          "VUID-vkCmdCopyMemoryToImageIndirectNV-pImageSubresources-parameter");
    if (pImageSubresources != nullptr) {
        for (uint32_t copyIndex = 0; copyIndex < copyCount; ++copyIndex) {
            [[maybe_unused]] const Location pImageSubresources_loc = loc.dot(Field::pImageSubresources, copyIndex);
            skip |= ValidateFlags(pImageSubresources_loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits,
                                  AllVkImageAspectFlagBits, pImageSubresources[copyIndex].aspectMask, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkImageSubresourceLayers-aspectMask-parameter",
                                  "VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount,
                                                               const VkDecompressMemoryRegionNV* pDecompressMemoryRegions,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_memory_decompression))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_memory_decompression});
    skip |= ValidateArray(loc.dot(Field::decompressRegionCount), loc.dot(Field::pDecompressMemoryRegions), decompressRegionCount,
                          &pDecompressMemoryRegions, true, true, "VUID-vkCmdDecompressMemoryNV-decompressRegionCount-arraylength",
                          "VUID-vkCmdDecompressMemoryNV-pDecompressMemoryRegions-parameter");
    if (pDecompressMemoryRegions != nullptr) {
        for (uint32_t decompressRegionIndex = 0; decompressRegionIndex < decompressRegionCount; ++decompressRegionIndex) {
            [[maybe_unused]] const Location pDecompressMemoryRegions_loc =
                loc.dot(Field::pDecompressMemoryRegions, decompressRegionIndex);
            skip |= ValidateFlags(pDecompressMemoryRegions_loc.dot(Field::decompressionMethod),
                                  vvl::FlagBitmask::VkMemoryDecompressionMethodFlagBitsNV, AllVkMemoryDecompressionMethodFlagBitsNV,
                                  pDecompressMemoryRegions[decompressRegionIndex].decompressionMethod, kRequiredFlags,
                                  VK_NULL_HANDLE, "VUID-VkDecompressMemoryRegionNV-decompressionMethod-parameter",
                                  "VUID-VkDecompressMemoryRegionNV-decompressionMethod-requiredbitmask");
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer,
                                                                            VkDeviceAddress indirectCommandsAddress,
                                                                            VkDeviceAddress indirectCommandsCountAddress,
                                                                            uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_memory_decompression))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_memory_decompression});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineIndirectMemoryRequirementsNV(VkDevice device,
                                                                                 const VkComputePipelineCreateInfo* pCreateInfo,
                                                                                 VkMemoryRequirements2* pMemoryRequirements,
                                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands_compute});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, true,
                               "VUID-vkGetPipelineIndirectMemoryRequirementsNV-pCreateInfo-parameter",
                               "VUID-VkComputePipelineCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkComputePipelineCreateInfo = {
            VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,   VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR,
            VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,  VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR,
            VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,     VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkComputePipelineCreateInfo.size(),
                                    allowed_structs_VkComputePipelineCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkComputePipelineCreateInfo-pNext-pNext", "VUID-VkComputePipelineCreateInfo-sType-unique",
                                    VK_NULL_HANDLE, true);

        skip |= ValidateStructType(pCreateInfo_loc.dot(Field::stage), &(pCreateInfo->stage),
                                   VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, kVUIDUndefined,
                                   "VUID-VkPipelineShaderStageCreateInfo-sType-sType");

        constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
            VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
            VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->stage.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                "VUID-VkPipelineShaderStageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                              AllVkPipelineShaderStageCreateFlagBits, pCreateInfo->stage.flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits,
                              pCreateInfo->stage.stage, kRequiredSingleBit, VK_NULL_HANDLE,
                              "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                              "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

        skip |= ValidateRequiredPointer(pCreateInfo_loc.dot(Field::pName), pCreateInfo->stage.pName,
                                        "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

        if (pCreateInfo->stage.pSpecializationInfo != nullptr) {
            [[maybe_unused]] const Location pSpecializationInfo_loc = pCreateInfo_loc.dot(Field::pSpecializationInfo);
            skip |= ValidateArray(
                pSpecializationInfo_loc.dot(Field::mapEntryCount), pSpecializationInfo_loc.dot(Field::pMapEntries),
                pCreateInfo->stage.pSpecializationInfo->mapEntryCount, &pCreateInfo->stage.pSpecializationInfo->pMapEntries, false,
                true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

            if (pCreateInfo->stage.pSpecializationInfo->pMapEntries != nullptr) {
                for (uint32_t mapEntryIndex = 0; mapEntryIndex < pCreateInfo->stage.pSpecializationInfo->mapEntryCount;
                     ++mapEntryIndex) {
                    [[maybe_unused]] const Location pMapEntries_loc =
                        pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                    // No xml-driven validation
                }
            }

            skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                  pCreateInfo->stage.pSpecializationInfo->dataSize, &pCreateInfo->stage.pSpecializationInfo->pData,
                                  false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
        }

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::layout), pCreateInfo->layout);
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetPipelineIndirectMemoryRequirementsNV-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer,
                                                                           VkPipelineBindPoint pipelineBindPoint,
                                                                           VkPipeline pipeline,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands_compute});
    skip |= ValidateRangedEnum(loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pipelineBindPoint,
                               "VUID-vkCmdUpdatePipelineIndirectBufferNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    return skip;
}

bool StatelessValidation::PreCallValidateGetPipelineIndirectDeviceAddressNV(VkDevice device,
                                                                            const VkPipelineIndirectDeviceAddressInfoNV* pInfo,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_device_generated_commands_compute))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_device_generated_commands_compute});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV, true,
                               "VUID-vkGetPipelineIndirectDeviceAddressNV-pInfo-parameter",
                               "VUID-VkPipelineIndirectDeviceAddressInfoNV-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkPipelineIndirectDeviceAddressInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |=
            ValidateRangedEnum(pInfo_loc.dot(Field::pipelineBindPoint), vvl::Enum::VkPipelineBindPoint, pInfo->pipelineBindPoint,
                               "VUID-VkPipelineIndirectDeviceAddressInfoNV-pipelineBindPoint-parameter", VK_NULL_HANDLE);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::pipeline), pInfo->pipeline);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::depthClampEnable), depthClampEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode,
                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRangedEnum(loc.dot(Field::polygonMode), vvl::Enum::VkPolygonMode, polygonMode,
                               "VUID-vkCmdSetPolygonModeEXT-polygonMode-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer,
                                                                       VkSampleCountFlagBits rasterizationSamples,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateFlags(loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits,
                          rasterizationSamples, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter",
                          "VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples,
                                                             const VkSampleMask* pSampleMask, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateFlags(loc.dot(Field::samples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits, samples,
                          kRequiredSingleBit, VK_NULL_HANDLE, "VUID-vkCmdSetSampleMaskEXT-samples-parameter",
                          "VUID-vkCmdSetSampleMaskEXT-samples-parameter");
    skip |= ValidateArray(loc.dot(Field::samples), loc.dot(Field::pSampleMask), (samples + 31) / 32, &pSampleMask, true, true,
                          kVUIDUndefined, "VUID-vkCmdSetSampleMaskEXT-pSampleMask-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer,
                                                                        VkBool32 alphaToCoverageEnable,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::alphaToCoverageEnable), alphaToCoverageEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::alphaToOneEnable), alphaToOneEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::logicOpEnable), logicOpEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                                   uint32_t attachmentCount, const VkBool32* pColorBlendEnables,
                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32Array(loc.dot(Field::attachmentCount), loc.dot(Field::pColorBlendEnables), attachmentCount,
                                pColorBlendEnables, true, true, "VUID-vkCmdSetColorBlendEnableEXT-attachmentCount-arraylength",
                                "VUID-vkCmdSetColorBlendEnableEXT-pColorBlendEnables-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                                     uint32_t attachmentCount,
                                                                     const VkColorBlendEquationEXT* pColorBlendEquations,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateArray(loc.dot(Field::attachmentCount), loc.dot(Field::pColorBlendEquations), attachmentCount,
                          &pColorBlendEquations, true, true, "VUID-vkCmdSetColorBlendEquationEXT-attachmentCount-arraylength",
                          "VUID-vkCmdSetColorBlendEquationEXT-pColorBlendEquations-parameter");
    if (pColorBlendEquations != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pColorBlendEquations_loc = loc.dot(Field::pColorBlendEquations, attachmentIndex);
            skip |= ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::srcColorBlendFactor), vvl::Enum::VkBlendFactor,
                                       pColorBlendEquations[attachmentIndex].srcColorBlendFactor,
                                       "VUID-VkColorBlendEquationEXT-srcColorBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::dstColorBlendFactor), vvl::Enum::VkBlendFactor,
                                       pColorBlendEquations[attachmentIndex].dstColorBlendFactor,
                                       "VUID-VkColorBlendEquationEXT-dstColorBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::colorBlendOp), vvl::Enum::VkBlendOp,
                                       pColorBlendEquations[attachmentIndex].colorBlendOp,
                                       "VUID-VkColorBlendEquationEXT-colorBlendOp-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::srcAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                       pColorBlendEquations[attachmentIndex].srcAlphaBlendFactor,
                                       "VUID-VkColorBlendEquationEXT-srcAlphaBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::dstAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                       pColorBlendEquations[attachmentIndex].dstAlphaBlendFactor,
                                       "VUID-VkColorBlendEquationEXT-dstAlphaBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pColorBlendEquations_loc.dot(Field::alphaBlendOp), vvl::Enum::VkBlendOp,
                                       pColorBlendEquations[attachmentIndex].alphaBlendOp,
                                       "VUID-VkColorBlendEquationEXT-alphaBlendOp-parameter", VK_NULL_HANDLE);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                                 uint32_t attachmentCount,
                                                                 const VkColorComponentFlags* pColorWriteMasks,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateFlagsArray(loc.dot(Field::attachmentCount), loc.dot(Field::pColorWriteMasks),
                               vvl::FlagBitmask::VkColorComponentFlagBits, AllVkColorComponentFlagBits, attachmentCount,
                               pColorWriteMasks, true, "VUID-vkCmdSetColorWriteMaskEXT-attachmentCount-arraylength",
                               "VUID-vkCmdSetColorWriteMaskEXT-pColorWriteMasks-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer,
                                                                           VkTessellationDomainOrigin domainOrigin,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRangedEnum(loc.dot(Field::domainOrigin), vvl::Enum::VkTessellationDomainOrigin, domainOrigin,
                               "VUID-vkCmdSetTessellationDomainOriginEXT-domainOrigin-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetConservativeRasterizationModeEXT(
    VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRangedEnum(
        loc.dot(Field::conservativeRasterizationMode), vvl::Enum::VkConservativeRasterizationModeEXT, conservativeRasterizationMode,
        "VUID-vkCmdSetConservativeRasterizationModeEXT-conservativeRasterizationMode-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer,
                                                                                   float extraPrimitiveOverestimationSize,
                                                                                   const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::depthClipEnable), depthClipEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer,
                                                                        VkBool32 sampleLocationsEnable,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::sampleLocationsEnable), sampleLocationsEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                                                     uint32_t attachmentCount,
                                                                     const VkColorBlendAdvancedEXT* pColorBlendAdvanced,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateArray(loc.dot(Field::attachmentCount), loc.dot(Field::pColorBlendAdvanced), attachmentCount,
                          &pColorBlendAdvanced, true, true, "VUID-vkCmdSetColorBlendAdvancedEXT-attachmentCount-arraylength",
                          "VUID-vkCmdSetColorBlendAdvancedEXT-pColorBlendAdvanced-parameter");
    if (pColorBlendAdvanced != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pColorBlendAdvanced_loc = loc.dot(Field::pColorBlendAdvanced, attachmentIndex);
            skip |= ValidateRangedEnum(pColorBlendAdvanced_loc.dot(Field::advancedBlendOp), vvl::Enum::VkBlendOp,
                                       pColorBlendAdvanced[attachmentIndex].advancedBlendOp,
                                       "VUID-VkColorBlendAdvancedEXT-advancedBlendOp-parameter", VK_NULL_HANDLE);

            skip |= ValidateBool32(pColorBlendAdvanced_loc.dot(Field::srcPremultiplied),
                                   pColorBlendAdvanced[attachmentIndex].srcPremultiplied);

            skip |= ValidateBool32(pColorBlendAdvanced_loc.dot(Field::dstPremultiplied),
                                   pColorBlendAdvanced[attachmentIndex].dstPremultiplied);

            skip |= ValidateRangedEnum(pColorBlendAdvanced_loc.dot(Field::blendOverlap), vvl::Enum::VkBlendOverlapEXT,
                                       pColorBlendAdvanced[attachmentIndex].blendOverlap,
                                       "VUID-VkColorBlendAdvancedEXT-blendOverlap-parameter", VK_NULL_HANDLE);

            skip |=
                ValidateBool32(pColorBlendAdvanced_loc.dot(Field::clampResults), pColorBlendAdvanced[attachmentIndex].clampResults);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer,
                                                                      VkProvokingVertexModeEXT provokingVertexMode,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRangedEnum(loc.dot(Field::provokingVertexMode), vvl::Enum::VkProvokingVertexModeEXT, provokingVertexMode,
                               "VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer,
                                                                        VkLineRasterizationModeEXT lineRasterizationMode,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::stippledLineEnable), stippledLineEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer,
                                                                            VkBool32 negativeOneToOne,
                                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::negativeOneToOne), negativeOneToOne);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer,
                                                                        VkBool32 viewportWScalingEnable,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::viewportWScalingEnable), viewportWScalingEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                                 uint32_t viewportCount,
                                                                 const VkViewportSwizzleNV* pViewportSwizzles,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateArray(loc.dot(Field::viewportCount), loc.dot(Field::pViewportSwizzles), viewportCount, &pViewportSwizzles, true,
                          true, "VUID-vkCmdSetViewportSwizzleNV-viewportCount-arraylength",
                          "VUID-vkCmdSetViewportSwizzleNV-pViewportSwizzles-parameter");
    if (pViewportSwizzles != nullptr) {
        for (uint32_t viewportIndex = 0; viewportIndex < viewportCount; ++viewportIndex) {
            [[maybe_unused]] const Location pViewportSwizzles_loc = loc.dot(Field::pViewportSwizzles, viewportIndex);
            skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::x), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                       pViewportSwizzles[viewportIndex].x, "VUID-VkViewportSwizzleNV-x-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::y), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                       pViewportSwizzles[viewportIndex].y, "VUID-VkViewportSwizzleNV-y-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::z), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                       pViewportSwizzles[viewportIndex].z, "VUID-VkViewportSwizzleNV-z-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pViewportSwizzles_loc.dot(Field::w), vvl::Enum::VkViewportCoordinateSwizzleNV,
                                       pViewportSwizzles[viewportIndex].w, "VUID-VkViewportSwizzleNV-w-parameter", VK_NULL_HANDLE);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer,
                                                                       VkBool32 coverageToColorEnable,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::coverageToColorEnable), coverageToColorEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer,
                                                                         uint32_t coverageToColorLocation,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer,
                                                                        VkCoverageModulationModeNV coverageModulationMode,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |=
        ValidateRangedEnum(loc.dot(Field::coverageModulationMode), vvl::Enum::VkCoverageModulationModeNV, coverageModulationMode,
                           "VUID-vkCmdSetCoverageModulationModeNV-coverageModulationMode-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer,
                                                                               VkBool32 coverageModulationTableEnable,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::coverageModulationTableEnable), coverageModulationTableEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer,
                                                                         uint32_t coverageModulationTableCount,
                                                                         const float* pCoverageModulationTable,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateArray(loc.dot(Field::coverageModulationTableCount), loc.dot(Field::pCoverageModulationTable),
                          coverageModulationTableCount, &pCoverageModulationTable, true, true,
                          "VUID-vkCmdSetCoverageModulationTableNV-coverageModulationTableCount-arraylength",
                          "VUID-vkCmdSetCoverageModulationTableNV-pCoverageModulationTable-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer,
                                                                        VkBool32 shadingRateImageEnable,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::shadingRateImageEnable), shadingRateImageEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer,
                                                                                  VkBool32 representativeFragmentTestEnable,
                                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateBool32(loc.dot(Field::representativeFragmentTestEnable), representativeFragmentTestEnable);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer,
                                                                       VkCoverageReductionModeNV coverageReductionMode,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3) || IsExtEnabled(device_extensions.vk_ext_shader_object)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state3, vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRangedEnum(loc.dot(Field::coverageReductionMode), vvl::Enum::VkCoverageReductionModeNV, coverageReductionMode,
                               "VUID-vkCmdSetCoverageReductionModeNV-coverageReductionMode-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule,
                                                                      VkShaderModuleIdentifierEXT* pIdentifier,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_module_identifier))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_module_identifier});
    skip |= ValidateRequiredHandle(loc.dot(Field::shaderModule), shaderModule);
    skip |= ValidateStructType(loc.dot(Field::pIdentifier), pIdentifier, VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, true,
                               "VUID-vkGetShaderModuleIdentifierEXT-pIdentifier-parameter",
                               "VUID-VkShaderModuleIdentifierEXT-sType-sType");
    if (pIdentifier != nullptr) {
        [[maybe_unused]] const Location pIdentifier_loc = loc.dot(Field::pIdentifier);
        skip |= ValidateStructPnext(pIdentifier_loc, pIdentifier->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkShaderModuleIdentifierEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderModuleCreateInfoIdentifierEXT(VkDevice device,
                                                                                const VkShaderModuleCreateInfo* pCreateInfo,
                                                                                VkShaderModuleIdentifierEXT* pIdentifier,
                                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_module_identifier))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_module_identifier});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, true,
                               "VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pCreateInfo-parameter",
                               "VUID-VkShaderModuleCreateInfo-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateReservedFlags(pCreateInfo_loc.dot(Field::flags), pCreateInfo->flags,
                                      "VUID-VkShaderModuleCreateInfo-flags-zerobitmask");

        skip |= ValidateArray(pCreateInfo_loc.dot(Field::codeSize), pCreateInfo_loc.dot(Field::pCode), pCreateInfo->codeSize / 4,
                              &pCreateInfo->pCode, true, true, "VUID-VkShaderModuleCreateInfo-codeSize-01085",
                              "VUID-VkShaderModuleCreateInfo-pCode-parameter");
    }
    skip |= ValidateStructType(loc.dot(Field::pIdentifier), pIdentifier, VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, true,
                               "VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pIdentifier-parameter",
                               "VUID-VkShaderModuleIdentifierEXT-sType-sType");
    if (pIdentifier != nullptr) {
        [[maybe_unused]] const Location pIdentifier_loc = loc.dot(Field::pIdentifier);
        skip |= ValidateStructPnext(pIdentifier_loc, pIdentifier->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkShaderModuleIdentifierEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetPhysicalDeviceOpticalFlowImageFormatsNV(
    VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount,
    VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    skip |= ValidateStructType(loc.dot(Field::pOpticalFlowImageFormatInfo), pOpticalFlowImageFormatInfo,
                               VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, true,
                               "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pOpticalFlowImageFormatInfo-parameter",
                               "VUID-VkOpticalFlowImageFormatInfoNV-sType-sType");
    if (pOpticalFlowImageFormatInfo != nullptr) {
        [[maybe_unused]] const Location pOpticalFlowImageFormatInfo_loc = loc.dot(Field::pOpticalFlowImageFormatInfo);
        skip |= ValidateStructPnext(pOpticalFlowImageFormatInfo_loc, pOpticalFlowImageFormatInfo->pNext, 0, nullptr,
                                    GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, physicalDevice, true);

        skip |= ValidateFlags(pOpticalFlowImageFormatInfo_loc.dot(Field::usage), vvl::FlagBitmask::VkOpticalFlowUsageFlagBitsNV,
                              AllVkOpticalFlowUsageFlagBitsNV, pOpticalFlowImageFormatInfo->usage, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter",
                              "VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask");
    }
    skip |= ValidateStructTypeArray(loc.dot(Field::pFormatCount), loc.dot(Field::pImageFormatProperties), pFormatCount,
                                    pImageFormatProperties, VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV, true, false,
                                    false, "VUID-VkOpticalFlowImageFormatPropertiesNV-sType-sType",
                                    "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pImageFormatProperties-parameter",
                                    "VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pFormatCount-parameter", kVUIDUndefined);
    if (pImageFormatProperties != nullptr) {
        for (uint32_t pFormatIndex = 0; pFormatIndex < *pFormatCount; ++pFormatIndex) {
            [[maybe_unused]] const Location pImageFormatProperties_loc = loc.dot(Field::pImageFormatProperties, pFormatIndex);
            skip |= ValidateStructPnext(pImageFormatProperties_loc, pImageFormatProperties[pFormatIndex].pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkOpticalFlowImageFormatPropertiesNV-pNext-pNext",
                                        kVUIDUndefined, physicalDevice, false);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateOpticalFlowSessionNV(VkDevice device,
                                                                    const VkOpticalFlowSessionCreateInfoNV* pCreateInfo,
                                                                    const VkAllocationCallbacks* pAllocator,
                                                                    VkOpticalFlowSessionNV* pSession,
                                                                    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV,
                               true, "VUID-vkCreateOpticalFlowSessionNV-pCreateInfo-parameter",
                               "VUID-VkOpticalFlowSessionCreateInfoNV-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkOpticalFlowSessionCreateInfoNV = {
            VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV};

        skip |= ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkOpticalFlowSessionCreateInfoNV.size(),
                                    allowed_structs_VkOpticalFlowSessionCreateInfoNV.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkOpticalFlowSessionCreateInfoNV-pNext-pNext",
                                    "VUID-VkOpticalFlowSessionCreateInfoNV-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::imageFormat), vvl::Enum::VkFormat, pCreateInfo->imageFormat,
                                   "VUID-VkOpticalFlowSessionCreateInfoNV-imageFormat-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::flowVectorFormat), vvl::Enum::VkFormat, pCreateInfo->flowVectorFormat,
                                   "VUID-VkOpticalFlowSessionCreateInfoNV-flowVectorFormat-parameter", VK_NULL_HANDLE);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::costFormat), vvl::Enum::VkFormat, pCreateInfo->costFormat,
                                   "VUID-VkOpticalFlowSessionCreateInfoNV-costFormat-parameter", VK_NULL_HANDLE);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::outputGridSize), vvl::FlagBitmask::VkOpticalFlowGridSizeFlagBitsNV,
                              AllVkOpticalFlowGridSizeFlagBitsNV, pCreateInfo->outputGridSize, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-parameter",
                              "VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-requiredbitmask");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::hintGridSize), vvl::FlagBitmask::VkOpticalFlowGridSizeFlagBitsNV,
                              AllVkOpticalFlowGridSizeFlagBitsNV, pCreateInfo->hintGridSize, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkOpticalFlowSessionCreateInfoNV-hintGridSize-parameter");

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::performanceLevel), vvl::Enum::VkOpticalFlowPerformanceLevelNV,
                                   pCreateInfo->performanceLevel,
                                   "VUID-VkOpticalFlowSessionCreateInfoNV-performanceLevel-parameter", VK_NULL_HANDLE);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkOpticalFlowSessionCreateFlagBitsNV,
                              AllVkOpticalFlowSessionCreateFlagBitsNV, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkOpticalFlowSessionCreateInfoNV-flags-parameter");
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pSession), pSession, "VUID-vkCreateOpticalFlowSessionNV-pSession-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session,
                                                                     const VkAllocationCallbacks* pAllocator,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= ValidateRequiredHandle(loc.dot(Field::session), session);
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session,
                                                                       VkOpticalFlowSessionBindingPointNV bindingPoint,
                                                                       VkImageView view, VkImageLayout layout,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= ValidateRequiredHandle(loc.dot(Field::session), session);
    skip |= ValidateRangedEnum(loc.dot(Field::bindingPoint), vvl::Enum::VkOpticalFlowSessionBindingPointNV, bindingPoint,
                               "VUID-vkBindOpticalFlowSessionImageNV-bindingPoint-parameter", VK_NULL_HANDLE);
    skip |= ValidateRangedEnum(loc.dot(Field::layout), vvl::Enum::VkImageLayout, layout,
                               "VUID-vkBindOpticalFlowSessionImageNV-layout-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session,
                                                                 const VkOpticalFlowExecuteInfoNV* pExecuteInfo,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_optical_flow))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_optical_flow});
    skip |= ValidateRequiredHandle(loc.dot(Field::session), session);
    skip |=
        ValidateStructType(loc.dot(Field::pExecuteInfo), pExecuteInfo, VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV, true,
                           "VUID-vkCmdOpticalFlowExecuteNV-pExecuteInfo-parameter", "VUID-VkOpticalFlowExecuteInfoNV-sType-sType");
    if (pExecuteInfo != nullptr) {
        [[maybe_unused]] const Location pExecuteInfo_loc = loc.dot(Field::pExecuteInfo);
        skip |= ValidateStructPnext(pExecuteInfo_loc, pExecuteInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkOpticalFlowExecuteInfoNV-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pExecuteInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkOpticalFlowExecuteFlagBitsNV,
                              AllVkOpticalFlowExecuteFlagBitsNV, pExecuteInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkOpticalFlowExecuteInfoNV-flags-parameter");

        skip |= ValidateArray(pExecuteInfo_loc.dot(Field::regionCount), pExecuteInfo_loc.dot(Field::pRegions),
                              pExecuteInfo->regionCount, &pExecuteInfo->pRegions, false, true, kVUIDUndefined,
                              "VUID-VkOpticalFlowExecuteInfoNV-pRegions-parameter");

        if (pExecuteInfo->pRegions != nullptr) {
            for (uint32_t regionIndex = 0; regionIndex < pExecuteInfo->regionCount; ++regionIndex) {
                [[maybe_unused]] const Location pRegions_loc = pExecuteInfo_loc.dot(Field::pRegions, regionIndex);
                // No xml-driven validation

                // No xml-driven validation
            }
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateAntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD* pData,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_amd_anti_lag)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMD_anti_lag});
    skip |= ValidateStructType(loc.dot(Field::pData), pData, VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD, true,
                               "VUID-vkAntiLagUpdateAMD-pData-parameter", "VUID-VkAntiLagDataAMD-sType-sType");
    if (pData != nullptr) {
        [[maybe_unused]] const Location pData_loc = loc.dot(Field::pData);
        skip |= ValidateRangedEnum(pData_loc.dot(Field::mode), vvl::Enum::VkAntiLagModeAMD, pData->mode,
                                   "VUID-VkAntiLagDataAMD-mode-parameter", VK_NULL_HANDLE);

        skip |= ValidateStructType(
            pData_loc.dot(Field::pPresentationInfo), pData->pPresentationInfo, VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD,
            false, "VUID-VkAntiLagDataAMD-pPresentationInfo-parameter", "VUID-VkAntiLagPresentationInfoAMD-sType-sType");

        if (pData->pPresentationInfo != nullptr) {
            [[maybe_unused]] const Location pPresentationInfo_loc = pData_loc.dot(Field::pPresentationInfo);
            skip |= ValidateRangedEnum(pPresentationInfo_loc.dot(Field::stage), vvl::Enum::VkAntiLagStageAMD,
                                       pData->pPresentationInfo->stage, "VUID-VkAntiLagPresentationInfoAMD-stage-parameter",
                                       VK_NULL_HANDLE);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateShadersEXT(VkDevice device, uint32_t createInfoCount,
                                                          const VkShaderCreateInfoEXT* pCreateInfos,
                                                          const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
                                    VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT, true, true, "VUID-VkShaderCreateInfoEXT-sType-sType",
                                    "VUID-vkCreateShadersEXT-pCreateInfos-parameter",
                                    "VUID-vkCreateShadersEXT-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkShaderCreateInfoEXT = {
                VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                        allowed_structs_VkShaderCreateInfoEXT.size(), allowed_structs_VkShaderCreateInfoEXT.data(),
                                        GeneratedVulkanHeaderVersion, "VUID-VkShaderCreateInfoEXT-pNext-pNext",
                                        "VUID-VkShaderCreateInfoEXT-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkShaderCreateFlagBitsEXT,
                                  AllVkShaderCreateFlagBitsEXT, pCreateInfos[createInfoIndex].flags, kOptionalFlags, VK_NULL_HANDLE,
                                  "VUID-VkShaderCreateInfoEXT-flags-parameter");

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                  AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].stage, kRequiredSingleBit, VK_NULL_HANDLE,
                                  "VUID-VkShaderCreateInfoEXT-stage-parameter", "VUID-VkShaderCreateInfoEXT-stage-parameter");

            skip |= ValidateFlags(pCreateInfos_loc.dot(Field::nextStage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                  AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].nextStage, kOptionalFlags, VK_NULL_HANDLE,
                                  "VUID-VkShaderCreateInfoEXT-nextStage-parameter");

            skip |= ValidateRangedEnum(pCreateInfos_loc.dot(Field::codeType), vvl::Enum::VkShaderCodeTypeEXT,
                                       pCreateInfos[createInfoIndex].codeType, "VUID-VkShaderCreateInfoEXT-codeType-parameter",
                                       VK_NULL_HANDLE);

            skip |= ValidateArray(pCreateInfos_loc.dot(Field::codeSize), pCreateInfos_loc.dot(Field::pCode),
                                  pCreateInfos[createInfoIndex].codeSize, &pCreateInfos[createInfoIndex].pCode, true, true,
                                  "VUID-VkShaderCreateInfoEXT-codeSize-arraylength", "VUID-VkShaderCreateInfoEXT-pCode-parameter");

            if (pCreateInfos[createInfoIndex].pPushConstantRanges != nullptr) {
                for (uint32_t pushConstantRangeIndex = 0;
                     pushConstantRangeIndex < pCreateInfos[createInfoIndex].pushConstantRangeCount; ++pushConstantRangeIndex) {
                    [[maybe_unused]] const Location pPushConstantRanges_loc =
                        pCreateInfos_loc.dot(Field::pPushConstantRanges, pushConstantRangeIndex);
                    skip |= ValidateFlags(pPushConstantRanges_loc.dot(Field::stageFlags), vvl::FlagBitmask::VkShaderStageFlagBits,
                                          AllVkShaderStageFlagBits,
                                          pCreateInfos[createInfoIndex].pPushConstantRanges[pushConstantRangeIndex].stageFlags,
                                          kRequiredFlags, VK_NULL_HANDLE, "VUID-VkPushConstantRange-stageFlags-parameter",
                                          "VUID-VkPushConstantRange-stageFlags-requiredbitmask");
                }
            }

            if (pCreateInfos[createInfoIndex].pSpecializationInfo != nullptr) {
                [[maybe_unused]] const Location pSpecializationInfo_loc = pCreateInfos_loc.dot(Field::pSpecializationInfo);
                skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                      pSpecializationInfo_loc.dot(Field::pMapEntries),
                                      pCreateInfos[createInfoIndex].pSpecializationInfo->mapEntryCount,
                                      &pCreateInfos[createInfoIndex].pSpecializationInfo->pMapEntries, false, true, kVUIDUndefined,
                                      "VUID-VkSpecializationInfo-pMapEntries-parameter");

                if (pCreateInfos[createInfoIndex].pSpecializationInfo->pMapEntries != nullptr) {
                    for (uint32_t mapEntryIndex = 0;
                         mapEntryIndex < pCreateInfos[createInfoIndex].pSpecializationInfo->mapEntryCount; ++mapEntryIndex) {
                        [[maybe_unused]] const Location pMapEntries_loc =
                            pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                        // No xml-driven validation
                    }
                }

                skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                      pCreateInfos[createInfoIndex].pSpecializationInfo->dataSize,
                                      &pCreateInfos[createInfoIndex].pSpecializationInfo->pData, false, true, kVUIDUndefined,
                                      "VUID-VkSpecializationInfo-pData-parameter");
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pShaders), createInfoCount, &pShaders, true, true,
                          "VUID-vkCreateShadersEXT-createInfoCount-arraylength", "VUID-vkCreateShadersEXT-pShaders-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyShaderEXT(VkDevice device, VkShaderEXT shader,
                                                          const VkAllocationCallbacks* pAllocator,
                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateRequiredHandle(loc.dot(Field::shader), shader);
    skip |= ValidatePointerArray(loc.dot(Field::pDataSize), loc.dot(Field::pData), pDataSize, &pData, true, false, false,
                                 "VUID-vkGetShaderBinaryDataEXT-pDataSize-parameter", kVUIDUndefined,
                                 "VUID-vkGetShaderBinaryDataEXT-pData-parameter");
    if (!skip) skip |= manual_PreCallValidateGetShaderBinaryDataEXT(device, shader, pDataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount,
                                                           const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders,
                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_shader_object))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object});
    skip |= ValidateArray(loc.dot(Field::stageCount), loc.dot(Field::pStages), stageCount, &pStages, true, true,
                          "VUID-vkCmdBindShadersEXT-stageCount-arraylength", "VUID-vkCmdBindShadersEXT-pStages-parameter");
    skip |= ValidateArray(loc.dot(Field::stageCount), loc.dot(Field::pShaders), stageCount, &pShaders, true, false,
                          "VUID-vkCmdBindShadersEXT-stageCount-arraylength", "VUID-vkCmdBindShadersEXT-pShaders-parameter");
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode,
                                                                  const VkDepthClampRangeEXT* pDepthClampRange,
                                                                  const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!(IsExtEnabled(device_extensions.vk_ext_shader_object) || IsExtEnabled(device_extensions.vk_ext_depth_clamp_control)))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_shader_object, vvl::Extension::_VK_EXT_depth_clamp_control});
    skip |= ValidateRangedEnum(loc.dot(Field::depthClampMode), vvl::Enum::VkDepthClampModeEXT, depthClampMode,
                               "VUID-vkCmdSetDepthClampRangeEXT-depthClampMode-parameter", VK_NULL_HANDLE);
    if (pDepthClampRange != nullptr) {
        [[maybe_unused]] const Location pDepthClampRange_loc = loc.dot(Field::pDepthClampRange);
        // No xml-driven validation
    }
    if (!skip) skip |= manual_PreCallValidateCmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer,
                                                                          uint32_t* pPropertiesCount,
                                                                          VkTilePropertiesQCOM* pProperties,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_qcom_tile_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QCOM_tile_properties});
    skip |= ValidateRequiredHandle(loc.dot(Field::framebuffer), framebuffer);
    skip |=
        ValidateStructTypeArray(loc.dot(Field::pPropertiesCount), loc.dot(Field::pProperties), pPropertiesCount, pProperties,
                                VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, true, false, false, "VUID-VkTilePropertiesQCOM-sType-sType",
                                "VUID-vkGetFramebufferTilePropertiesQCOM-pProperties-parameter",
                                "VUID-vkGetFramebufferTilePropertiesQCOM-pPropertiesCount-parameter", kVUIDUndefined);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDynamicRenderingTilePropertiesQCOM(VkDevice device,
                                                                               const VkRenderingInfo* pRenderingInfo,
                                                                               VkTilePropertiesQCOM* pProperties,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_qcom_tile_properties))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QCOM_tile_properties});
    skip |= ValidateStructType(loc.dot(Field::pRenderingInfo), pRenderingInfo, VK_STRUCTURE_TYPE_RENDERING_INFO, true,
                               "VUID-vkGetDynamicRenderingTilePropertiesQCOM-pRenderingInfo-parameter",
                               "VUID-VkRenderingInfo-sType-sType");
    if (pRenderingInfo != nullptr) {
        [[maybe_unused]] const Location pRenderingInfo_loc = loc.dot(Field::pRenderingInfo);
        constexpr std::array allowed_structs_VkRenderingInfo = {
            VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR};

        skip |= ValidateStructPnext(pRenderingInfo_loc, pRenderingInfo->pNext, allowed_structs_VkRenderingInfo.size(),
                                    allowed_structs_VkRenderingInfo.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkRenderingInfo-pNext-pNext", "VUID-VkRenderingInfo-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pRenderingInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkRenderingFlagBits, AllVkRenderingFlagBits,
                              pRenderingInfo->flags, kOptionalFlags, VK_NULL_HANDLE, "VUID-VkRenderingInfo-flags-parameter");

        // No xml-driven validation

        // No xml-driven validation

        skip |= ValidateStructTypeArray(pRenderingInfo_loc.dot(Field::colorAttachmentCount),
                                        pRenderingInfo_loc.dot(Field::pColorAttachments), pRenderingInfo->colorAttachmentCount,
                                        pRenderingInfo->pColorAttachments, VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false, true,
                                        "VUID-VkRenderingAttachmentInfo-sType-sType",
                                        "VUID-VkRenderingInfo-pColorAttachments-parameter", kVUIDUndefined);

        if (pRenderingInfo->pColorAttachments != nullptr) {
            for (uint32_t colorAttachmentIndex = 0; colorAttachmentIndex < pRenderingInfo->colorAttachmentCount;
                 ++colorAttachmentIndex) {
                [[maybe_unused]] const Location pColorAttachments_loc =
                    pRenderingInfo_loc.dot(Field::pColorAttachments, colorAttachmentIndex);
                skip |= ValidateStructPnext(pColorAttachments_loc, pRenderingInfo->pColorAttachments[colorAttachmentIndex].pNext, 0,
                                            nullptr, GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].imageLayout,
                                           "VUID-VkRenderingAttachmentInfo-imageLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pColorAttachments_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                      AllVkResolveModeFlagBits, pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveMode,
                                      kOptionalSingleBit, VK_NULL_HANDLE, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].resolveImageLayout,
                                           "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].loadOp,
                                           "VUID-VkRenderingAttachmentInfo-loadOp-parameter", VK_NULL_HANDLE);

                skip |= ValidateRangedEnum(pColorAttachments_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                           pRenderingInfo->pColorAttachments[colorAttachmentIndex].storeOp,
                                           "VUID-VkRenderingAttachmentInfo-storeOp-parameter", VK_NULL_HANDLE);

                // No xml-driven validation
            }
        }

        skip |= ValidateStructType(pRenderingInfo_loc.dot(Field::pDepthAttachment), pRenderingInfo->pDepthAttachment,
                                   VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                                   "VUID-VkRenderingInfo-pDepthAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pDepthAttachment != nullptr) {
            [[maybe_unused]] const Location pDepthAttachment_loc = pRenderingInfo_loc.dot(Field::pDepthAttachment);
            skip |= ValidateStructPnext(pDepthAttachment_loc, pRenderingInfo->pDepthAttachment->pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pDepthAttachment->imageLayout,
                                       "VUID-VkRenderingAttachmentInfo-imageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pDepthAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                  AllVkResolveModeFlagBits, pRenderingInfo->pDepthAttachment->resolveMode, kOptionalSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pDepthAttachment->resolveImageLayout,
                                       "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                       pRenderingInfo->pDepthAttachment->loadOp, "VUID-VkRenderingAttachmentInfo-loadOp-parameter",
                                       VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pDepthAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                       pRenderingInfo->pDepthAttachment->storeOp,
                                       "VUID-VkRenderingAttachmentInfo-storeOp-parameter", VK_NULL_HANDLE);

            // No xml-driven validation
        }

        skip |=
            ValidateStructType(pRenderingInfo_loc.dot(Field::pStencilAttachment), pRenderingInfo->pStencilAttachment,
                               VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, false,
                               "VUID-VkRenderingInfo-pStencilAttachment-parameter", "VUID-VkRenderingAttachmentInfo-sType-sType");

        if (pRenderingInfo->pStencilAttachment != nullptr) {
            [[maybe_unused]] const Location pStencilAttachment_loc = pRenderingInfo_loc.dot(Field::pStencilAttachment);
            skip |= ValidateStructPnext(pStencilAttachment_loc, pRenderingInfo->pStencilAttachment->pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkRenderingAttachmentInfo-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::imageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pStencilAttachment->imageLayout,
                                       "VUID-VkRenderingAttachmentInfo-imageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pStencilAttachment_loc.dot(Field::resolveMode), vvl::FlagBitmask::VkResolveModeFlagBits,
                                  AllVkResolveModeFlagBits, pRenderingInfo->pStencilAttachment->resolveMode, kOptionalSingleBit,
                                  VK_NULL_HANDLE, "VUID-VkRenderingAttachmentInfo-resolveMode-parameter");

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::resolveImageLayout), vvl::Enum::VkImageLayout,
                                       pRenderingInfo->pStencilAttachment->resolveImageLayout,
                                       "VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::loadOp), vvl::Enum::VkAttachmentLoadOp,
                                       pRenderingInfo->pStencilAttachment->loadOp,
                                       "VUID-VkRenderingAttachmentInfo-loadOp-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pStencilAttachment_loc.dot(Field::storeOp), vvl::Enum::VkAttachmentStoreOp,
                                       pRenderingInfo->pStencilAttachment->storeOp,
                                       "VUID-VkRenderingAttachmentInfo-storeOp-parameter", VK_NULL_HANDLE);

            // No xml-driven validation
        }
    }
    skip |= ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, true,
                               "VUID-vkGetDynamicRenderingTilePropertiesQCOM-pProperties-parameter",
                               "VUID-VkTilePropertiesQCOM-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain,
                                                               const VkLatencySleepModeInfoNV* pSleepModeInfo,
                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_low_latency2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |=
        ValidateStructType(loc.dot(Field::pSleepModeInfo), pSleepModeInfo, VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV, true,
                           "VUID-vkSetLatencySleepModeNV-pSleepModeInfo-parameter", "VUID-VkLatencySleepModeInfoNV-sType-sType");
    if (pSleepModeInfo != nullptr) {
        [[maybe_unused]] const Location pSleepModeInfo_loc = loc.dot(Field::pSleepModeInfo);
        skip |= ValidateBool32(pSleepModeInfo_loc.dot(Field::lowLatencyMode), pSleepModeInfo->lowLatencyMode);

        skip |= ValidateBool32(pSleepModeInfo_loc.dot(Field::lowLatencyBoost), pSleepModeInfo->lowLatencyBoost);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain,
                                                        const VkLatencySleepInfoNV* pSleepInfo,
                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_low_latency2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidateStructType(loc.dot(Field::pSleepInfo), pSleepInfo, VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV, true,
                               "VUID-vkLatencySleepNV-pSleepInfo-parameter", "VUID-VkLatencySleepInfoNV-sType-sType");
    if (pSleepInfo != nullptr) {
        [[maybe_unused]] const Location pSleepInfo_loc = loc.dot(Field::pSleepInfo);
        skip |= ValidateRequiredHandle(pSleepInfo_loc.dot(Field::signalSemaphore), pSleepInfo->signalSemaphore);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain,
                                                            const VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo,
                                                            const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_low_latency2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidateStructType(loc.dot(Field::pLatencyMarkerInfo), pLatencyMarkerInfo, VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV,
                               true, "VUID-vkSetLatencyMarkerNV-pLatencyMarkerInfo-parameter",
                               "VUID-VkSetLatencyMarkerInfoNV-sType-sType");
    if (pLatencyMarkerInfo != nullptr) {
        [[maybe_unused]] const Location pLatencyMarkerInfo_loc = loc.dot(Field::pLatencyMarkerInfo);
        skip |= ValidateRangedEnum(pLatencyMarkerInfo_loc.dot(Field::marker), vvl::Enum::VkLatencyMarkerNV,
                                   pLatencyMarkerInfo->marker, "VUID-VkSetLatencyMarkerInfoNV-marker-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain,
                                                             VkGetLatencyMarkerInfoNV* pLatencyMarkerInfo,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_low_latency2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);
    skip |= ValidateStructType(loc.dot(Field::pLatencyMarkerInfo), pLatencyMarkerInfo, VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV,
                               true, "VUID-vkGetLatencyTimingsNV-pLatencyMarkerInfo-parameter",
                               "VUID-VkGetLatencyMarkerInfoNV-sType-sType");
    return skip;
}

bool StatelessValidation::PreCallValidateQueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo,
                                                                const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_nv_low_latency2))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_NV_low_latency2});
    skip |=
        ValidateStructType(loc.dot(Field::pQueueTypeInfo), pQueueTypeInfo, VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV, true,
                           "VUID-vkQueueNotifyOutOfBandNV-pQueueTypeInfo-parameter", "VUID-VkOutOfBandQueueTypeInfoNV-sType-sType");
    if (pQueueTypeInfo != nullptr) {
        [[maybe_unused]] const Location pQueueTypeInfo_loc = loc.dot(Field::pQueueTypeInfo);
        skip |=
            ValidateRangedEnum(pQueueTypeInfo_loc.dot(Field::queueType), vvl::Enum::VkOutOfBandQueueTypeNV,
                               pQueueTypeInfo->queueType, "VUID-VkOutOfBandQueueTypeInfoNV-queueType-parameter", VK_NULL_HANDLE);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer,
                                                                               VkImageAspectFlags aspectMask,
                                                                               const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_attachment_feedback_loop_dynamic_state))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_attachment_feedback_loop_dynamic_state});
    skip |= ValidateFlags(loc.dot(Field::aspectMask), vvl::FlagBitmask::VkImageAspectFlagBits, AllVkImageAspectFlagBits, aspectMask,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-aspectMask-parameter");
    return skip;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
bool StatelessValidation::PreCallValidateGetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer* buffer,
                                                                      VkScreenBufferPropertiesQNX* pProperties,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_qnx_external_memory_screen_buffer))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_external_memory_screen_buffer});
    skip |= ValidateRequiredPointer(loc.dot(Field::buffer), buffer, "VUID-vkGetScreenBufferPropertiesQNX-buffer-parameter");
    skip |= ValidateStructType(loc.dot(Field::pProperties), pProperties, VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX, true,
                               "VUID-vkGetScreenBufferPropertiesQNX-pProperties-parameter",
                               "VUID-VkScreenBufferPropertiesQNX-sType-sType");
    if (pProperties != nullptr) {
        [[maybe_unused]] const Location pProperties_loc = loc.dot(Field::pProperties);
        constexpr std::array allowed_structs_VkScreenBufferPropertiesQNX = {VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX};

        skip |= ValidateStructPnext(pProperties_loc, pProperties->pNext, allowed_structs_VkScreenBufferPropertiesQNX.size(),
                                    allowed_structs_VkScreenBufferPropertiesQNX.data(), GeneratedVulkanHeaderVersion,
                                    "VUID-VkScreenBufferPropertiesQNX-pNext-pNext", "VUID-VkScreenBufferPropertiesQNX-sType-unique",
                                    VK_NULL_HANDLE, false);
    }
    return skip;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

bool StatelessValidation::PreCallValidateGetGeneratedCommandsMemoryRequirementsEXT(
    VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT* pInfo, VkMemoryRequirements2* pMemoryRequirements,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
                               true, "VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-pInfo-parameter",
                               "VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        constexpr std::array allowed_structs_VkGeneratedCommandsMemoryRequirementsInfoEXT = {
            VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT};

        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, allowed_structs_VkGeneratedCommandsMemoryRequirementsInfoEXT.size(),
                                    allowed_structs_VkGeneratedCommandsMemoryRequirementsInfoEXT.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-pNext-pNext",
                                    "VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::indirectCommandsLayout), pInfo->indirectCommandsLayout);
    }
    skip |= ValidateStructType(loc.dot(Field::pMemoryRequirements), pMemoryRequirements, VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                               true, "VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-pMemoryRequirements-parameter",
                               "VUID-VkMemoryRequirements2-sType-sType");
    if (pMemoryRequirements != nullptr) {
        [[maybe_unused]] const Location pMemoryRequirements_loc = loc.dot(Field::pMemoryRequirements);
        constexpr std::array allowed_structs_VkMemoryRequirements2 = {VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS};

        skip |= ValidateStructPnext(pMemoryRequirements_loc, pMemoryRequirements->pNext,
                                    allowed_structs_VkMemoryRequirements2.size(), allowed_structs_VkMemoryRequirements2.data(),
                                    GeneratedVulkanHeaderVersion, "VUID-VkMemoryRequirements2-pNext-pNext",
                                    "VUID-VkMemoryRequirements2-sType-unique", VK_NULL_HANDLE, false);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer,
                                                                           const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo,
                                                                           VkCommandBuffer stateCommandBuffer,
                                                                           const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT, true,
        "VUID-vkCmdPreprocessGeneratedCommandsEXT-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoEXT-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |= ValidateFlags(pGeneratedCommandsInfo_loc.dot(Field::shaderStages), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pGeneratedCommandsInfo->shaderStages, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkGeneratedCommandsInfoEXT-shaderStages-parameter",
                              "VUID-VkGeneratedCommandsInfoEXT-shaderStages-requiredbitmask");

        skip |= ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                       pGeneratedCommandsInfo->indirectCommandsLayout);
    }
    skip |= ValidateRequiredHandle(loc.dot(Field::stateCommandBuffer), stateCommandBuffer);
    if (!skip)
        skip |= manual_PreCallValidateCmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer,
                                                                        error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed,
                                                                        const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateBool32(loc.dot(Field::isPreprocessed), isPreprocessed);
    skip |= ValidateStructType(
        loc.dot(Field::pGeneratedCommandsInfo), pGeneratedCommandsInfo, VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT, true,
        "VUID-vkCmdExecuteGeneratedCommandsEXT-pGeneratedCommandsInfo-parameter", "VUID-VkGeneratedCommandsInfoEXT-sType-sType");
    if (pGeneratedCommandsInfo != nullptr) {
        [[maybe_unused]] const Location pGeneratedCommandsInfo_loc = loc.dot(Field::pGeneratedCommandsInfo);
        skip |= ValidateFlags(pGeneratedCommandsInfo_loc.dot(Field::shaderStages), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pGeneratedCommandsInfo->shaderStages, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkGeneratedCommandsInfoEXT-shaderStages-parameter",
                              "VUID-VkGeneratedCommandsInfoEXT-shaderStages-requiredbitmask");

        skip |= ValidateRequiredHandle(pGeneratedCommandsInfo_loc.dot(Field::indirectCommandsLayout),
                                       pGeneratedCommandsInfo->indirectCommandsLayout);
    }
    if (!skip)
        skip |=
            manual_PreCallValidateCmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateIndirectCommandsLayoutEXT(VkDevice device,
                                                                         const VkIndirectCommandsLayoutCreateInfoEXT* pCreateInfo,
                                                                         const VkAllocationCallbacks* pAllocator,
                                                                         VkIndirectCommandsLayoutEXT* pIndirectCommandsLayout,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT,
                               true, "VUID-vkCreateIndirectCommandsLayoutEXT-pCreateInfo-parameter",
                               "VUID-VkIndirectCommandsLayoutCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkIndirectCommandsLayoutCreateInfoEXT = {
            VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkIndirectCommandsLayoutCreateInfoEXT.size(),
                                allowed_structs_VkIndirectCommandsLayoutCreateInfoEXT.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkIndirectCommandsLayoutCreateInfoEXT-pNext-pNext",
                                "VUID-VkIndirectCommandsLayoutCreateInfoEXT-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkIndirectCommandsLayoutUsageFlagBitsEXT,
                              AllVkIndirectCommandsLayoutUsageFlagBitsEXT, pCreateInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkIndirectCommandsLayoutCreateInfoEXT-flags-parameter");

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::shaderStages), vvl::FlagBitmask::VkShaderStageFlagBits,
                              AllVkShaderStageFlagBits, pCreateInfo->shaderStages, kRequiredFlags, VK_NULL_HANDLE,
                              "VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-parameter",
                              "VUID-VkIndirectCommandsLayoutCreateInfoEXT-shaderStages-requiredbitmask");

        skip |= ValidateStructTypeArray(
            pCreateInfo_loc.dot(Field::tokenCount), pCreateInfo_loc.dot(Field::pTokens), pCreateInfo->tokenCount,
            pCreateInfo->pTokens, VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT, true, true,
            "VUID-VkIndirectCommandsLayoutTokenEXT-sType-sType", "VUID-VkIndirectCommandsLayoutCreateInfoEXT-pTokens-parameter",
            "VUID-VkIndirectCommandsLayoutCreateInfoEXT-tokenCount-arraylength");

        if (pCreateInfo->pTokens != nullptr) {
            for (uint32_t tokenIndex = 0; tokenIndex < pCreateInfo->tokenCount; ++tokenIndex) {
                [[maybe_unused]] const Location pTokens_loc = pCreateInfo_loc.dot(Field::pTokens, tokenIndex);
                skip |= ValidateRangedEnum(pTokens_loc.dot(Field::type), vvl::Enum::VkIndirectCommandsTokenTypeEXT,
                                           pCreateInfo->pTokens[tokenIndex].type,
                                           "VUID-VkIndirectCommandsLayoutTokenEXT-type-parameter", VK_NULL_HANDLE);
            }
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pIndirectCommandsLayout), pIndirectCommandsLayout,
                                    "VUID-vkCreateIndirectCommandsLayoutEXT-pIndirectCommandsLayout-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout,
                                                                      error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyIndirectCommandsLayoutEXT(VkDevice device,
                                                                          VkIndirectCommandsLayoutEXT indirectCommandsLayout,
                                                                          const VkAllocationCallbacks* pAllocator,
                                                                          const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateIndirectExecutionSetEXT(VkDevice device,
                                                                       const VkIndirectExecutionSetCreateInfoEXT* pCreateInfo,
                                                                       const VkAllocationCallbacks* pAllocator,
                                                                       VkIndirectExecutionSetEXT* pIndirectExecutionSet,
                                                                       const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT,
                               true, "VUID-vkCreateIndirectExecutionSetEXT-pCreateInfo-parameter",
                               "VUID-VkIndirectExecutionSetCreateInfoEXT-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::type), vvl::Enum::VkIndirectExecutionSetInfoTypeEXT,
                                   pCreateInfo->type, "VUID-VkIndirectExecutionSetCreateInfoEXT-type-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pIndirectExecutionSet), pIndirectExecutionSet,
                                    "VUID-vkCreateIndirectExecutionSetEXT-pIndirectExecutionSet-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateCreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyIndirectExecutionSetEXT(VkDevice device,
                                                                        VkIndirectExecutionSetEXT indirectExecutionSet,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateIndirectExecutionSetPipelineEXT(
    VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount,
    const VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateRequiredHandle(loc.dot(Field::indirectExecutionSet), indirectExecutionSet);
    skip |=
        ValidateStructTypeArray(loc.dot(Field::executionSetWriteCount), loc.dot(Field::pExecutionSetWrites), executionSetWriteCount,
                                pExecutionSetWrites, VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT, true, true,
                                "VUID-VkWriteIndirectExecutionSetPipelineEXT-sType-sType",
                                "VUID-vkUpdateIndirectExecutionSetPipelineEXT-pExecutionSetWrites-parameter",
                                "VUID-vkUpdateIndirectExecutionSetPipelineEXT-executionSetWriteCount-arraylength");
    if (pExecutionSetWrites != nullptr) {
        for (uint32_t executionSetWriteIndex = 0; executionSetWriteIndex < executionSetWriteCount; ++executionSetWriteIndex) {
            [[maybe_unused]] const Location pExecutionSetWrites_loc = loc.dot(Field::pExecutionSetWrites, executionSetWriteIndex);
            skip |= ValidateRequiredHandle(pExecutionSetWrites_loc.dot(Field::pipeline),
                                           pExecutionSetWrites[executionSetWriteIndex].pipeline);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateUpdateIndirectExecutionSetShaderEXT(
    VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount,
    const VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_device_generated_commands))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_device_generated_commands});
    skip |= ValidateRequiredHandle(loc.dot(Field::indirectExecutionSet), indirectExecutionSet);
    skip |=
        ValidateStructTypeArray(loc.dot(Field::executionSetWriteCount), loc.dot(Field::pExecutionSetWrites), executionSetWriteCount,
                                pExecutionSetWrites, VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT, true, true,
                                "VUID-VkWriteIndirectExecutionSetShaderEXT-sType-sType",
                                "VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-parameter",
                                "VUID-vkUpdateIndirectExecutionSetShaderEXT-executionSetWriteCount-arraylength");
    if (pExecutionSetWrites != nullptr) {
        for (uint32_t executionSetWriteIndex = 0; executionSetWriteIndex < executionSetWriteCount; ++executionSetWriteIndex) {
            [[maybe_unused]] const Location pExecutionSetWrites_loc = loc.dot(Field::pExecutionSetWrites, executionSetWriteIndex);
            skip |= ValidateRequiredHandle(pExecutionSetWrites_loc.dot(Field::shader),
                                           pExecutionSetWrites[executionSetWriteIndex].shader);
        }
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCreateAccelerationStructureKHR(VkDevice device,
                                                                        const VkAccelerationStructureCreateInfoKHR* pCreateInfo,
                                                                        const VkAllocationCallbacks* pAllocator,
                                                                        VkAccelerationStructureKHR* pAccelerationStructure,
                                                                        const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pCreateInfo), pCreateInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
                               true, "VUID-vkCreateAccelerationStructureKHR-pCreateInfo-parameter",
                               "VUID-VkAccelerationStructureCreateInfoKHR-sType-sType");
    if (pCreateInfo != nullptr) {
        [[maybe_unused]] const Location pCreateInfo_loc = loc.dot(Field::pCreateInfo);
        constexpr std::array allowed_structs_VkAccelerationStructureCreateInfoKHR = {
            VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV,
            VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT};

        skip |=
            ValidateStructPnext(pCreateInfo_loc, pCreateInfo->pNext, allowed_structs_VkAccelerationStructureCreateInfoKHR.size(),
                                allowed_structs_VkAccelerationStructureCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkAccelerationStructureCreateInfoKHR-pNext-pNext",
                                "VUID-VkAccelerationStructureCreateInfoKHR-sType-unique", VK_NULL_HANDLE, true);

        skip |= ValidateFlags(pCreateInfo_loc.dot(Field::createFlags), vvl::FlagBitmask::VkAccelerationStructureCreateFlagBitsKHR,
                              AllVkAccelerationStructureCreateFlagBitsKHR, pCreateInfo->createFlags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkAccelerationStructureCreateInfoKHR-createFlags-parameter");

        skip |= ValidateRequiredHandle(pCreateInfo_loc.dot(Field::buffer), pCreateInfo->buffer);

        skip |= ValidateRangedEnum(pCreateInfo_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR, pCreateInfo->type,
                                   "VUID-VkAccelerationStructureCreateInfoKHR-type-parameter", VK_NULL_HANDLE);
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pAccelerationStructure), pAccelerationStructure,
                                    "VUID-vkCreateAccelerationStructureKHR-pAccelerationStructure-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure,
                                                                     error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateDestroyAccelerationStructureKHR(VkDevice device,
                                                                         VkAccelerationStructureKHR accelerationStructure,
                                                                         const VkAllocationCallbacks* pAllocator,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    if (!skip) skip |= manual_PreCallValidateDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildAccelerationStructuresKHR(
    VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true,
                                    "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType",
                                    "VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-parameter",
                                    "VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |=
                ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR, pInfos[infoIndex].type,
                                   "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                  AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::pGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location pGeometries_loc = pInfos_loc.dot(Field::pGeometries, geometryIndex);
                    skip |= ValidateStructPnext(pGeometries_loc, pInfos[infoIndex].pGeometries[geometryIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                               pInfos[infoIndex].pGeometries[geometryIndex].geometryType,
                                               "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= ValidateStructPointerTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::ppGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location ppGeometries_loc = pInfos_loc.dot(Field::ppGeometries, geometryIndex);
                    skip |= ValidateStructPnext(ppGeometries_loc, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                               pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType,
                                               "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::ppBuildRangeInfos), infoCount, &ppBuildRangeInfos, true, true,
                          "VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength",
                          "VUID-vkCmdBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter");
    if (ppBuildRangeInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location ppBuildRangeInfos_loc = loc.dot(Field::ppBuildRangeInfos, infoIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |=
            manual_PreCallValidateCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdBuildAccelerationStructuresIndirectKHR(
    VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t* const* ppMaxPrimitiveCounts,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true,
                                    "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType",
                                    "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-parameter",
                                    "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |=
                ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR, pInfos[infoIndex].type,
                                   "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                  AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::pGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location pGeometries_loc = pInfos_loc.dot(Field::pGeometries, geometryIndex);
                    skip |= ValidateStructPnext(pGeometries_loc, pInfos[infoIndex].pGeometries[geometryIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                               pInfos[infoIndex].pGeometries[geometryIndex].geometryType,
                                               "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= ValidateStructPointerTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::ppGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location ppGeometries_loc = pInfos_loc.dot(Field::ppGeometries, geometryIndex);
                    skip |= ValidateStructPnext(ppGeometries_loc, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                               pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType,
                                               "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::pIndirectDeviceAddresses), infoCount, &pIndirectDeviceAddresses,
                          true, true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength",
                          "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-parameter");
    skip |= ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::pIndirectStrides), infoCount, &pIndirectStrides, true, true,
                          "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength",
                          "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-parameter");
    skip |= ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::ppMaxPrimitiveCounts), infoCount, &ppMaxPrimitiveCounts, true,
                          true, "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength",
                          "VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCmdBuildAccelerationStructuresIndirectKHR(
            commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateBuildAccelerationStructuresKHR(
    VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructTypeArray(loc.dot(Field::infoCount), loc.dot(Field::pInfos), infoCount, pInfos,
                                    VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, true, true,
                                    "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType",
                                    "VUID-vkBuildAccelerationStructuresKHR-pInfos-parameter",
                                    "VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength");
    if (pInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location pInfos_loc = loc.dot(Field::pInfos, infoIndex);
            skip |= ValidateStructPnext(pInfos_loc, pInfos[infoIndex].pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                        "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined,
                                        VK_NULL_HANDLE, true);

            skip |=
                ValidateRangedEnum(pInfos_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR, pInfos[infoIndex].type,
                                   "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pInfos_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                                  AllVkBuildAccelerationStructureFlagBitsKHR, pInfos[infoIndex].flags, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

            skip |= ValidateStructTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::pGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].pGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].pGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location pGeometries_loc = pInfos_loc.dot(Field::pGeometries, geometryIndex);
                    skip |= ValidateStructPnext(pGeometries_loc, pInfos[infoIndex].pGeometries[geometryIndex].pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                               pInfos[infoIndex].pGeometries[geometryIndex].geometryType,
                                               "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfos[infoIndex].pGeometries[geometryIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }

            skip |= ValidateStructPointerTypeArray(
                pInfos_loc.dot(Field::geometryCount), pInfos_loc.dot(Field::ppGeometries), pInfos[infoIndex].geometryCount,
                pInfos[infoIndex].ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

            if (pInfos[infoIndex].ppGeometries != nullptr) {
                for (uint32_t geometryIndex = 0; geometryIndex < pInfos[infoIndex].geometryCount; ++geometryIndex) {
                    [[maybe_unused]] const Location ppGeometries_loc = pInfos_loc.dot(Field::ppGeometries, geometryIndex);
                    skip |= ValidateStructPnext(ppGeometries_loc, pInfos[infoIndex].ppGeometries[geometryIndex]->pNext, 0, nullptr,
                                                GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                                kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                               pInfos[infoIndex].ppGeometries[geometryIndex]->geometryType,
                                               "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                    skip |=
                        ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pInfos[infoIndex].ppGeometries[geometryIndex]->flags,
                                      kOptionalFlags, VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
                }
            }
        }
    }
    skip |= ValidateArray(loc.dot(Field::infoCount), loc.dot(Field::ppBuildRangeInfos), infoCount, &ppBuildRangeInfos, true, true,
                          "VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength",
                          "VUID-vkBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter");
    if (ppBuildRangeInfos != nullptr) {
        for (uint32_t infoIndex = 0; infoIndex < infoCount; ++infoIndex) {
            [[maybe_unused]] const Location ppBuildRangeInfos_loc = loc.dot(Field::ppBuildRangeInfos, infoIndex);
            // No xml-driven validation
        }
    }
    if (!skip)
        skip |= manual_PreCallValidateBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos,
                                                                     ppBuildRangeInfos, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                                      const VkCopyAccelerationStructureInfoKHR* pInfo,
                                                                      const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, true,
                               "VUID-vkCopyAccelerationStructureKHR-pInfo-parameter",
                               "VUID-VkCopyAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                   "VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCopyAccelerationStructureKHR(device, deferredOperation, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyAccelerationStructureToMemoryKHR(
    VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR, true,
                               "VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-parameter",
                               "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                   "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCopyMemoryToAccelerationStructureKHR(
    VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo,
    const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR, true,
                               "VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-parameter",
                               "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                   "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateWriteAccelerationStructuresPropertiesKHR(
    VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType, size_t dataSize, void* pData, size_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateHandleArray(loc.dot(Field::accelerationStructureCount), loc.dot(Field::pAccelerationStructures),
                                accelerationStructureCount, pAccelerationStructures, true, true,
                                "VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength");
    skip |= ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                               "VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-parameter", VK_NULL_HANDLE);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-arraylength",
                          "VUID-vkWriteAccelerationStructuresPropertiesKHR-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateWriteAccelerationStructuresPropertiesKHR(
            device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer,
                                                                         const VkCopyAccelerationStructureInfoKHR* pInfo,
                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, true,
                               "VUID-vkCmdCopyAccelerationStructureKHR-pInfo-parameter",
                               "VUID-VkCopyAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                   "VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyAccelerationStructureKHR(commandBuffer, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyAccelerationStructureToMemoryKHR(
    VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR, true,
                               "VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-parameter",
                               "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::src), pInfo->src);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                   "VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdCopyMemoryToAccelerationStructureKHR(
    VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR, true,
                               "VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-parameter",
                               "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::dst), pInfo->dst);

        skip |= ValidateRangedEnum(pInfo_loc.dot(Field::mode), vvl::Enum::VkCopyAccelerationStructureModeKHR, pInfo->mode,
                                   "VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter", VK_NULL_HANDLE);
    }
    if (!skip) skip |= manual_PreCallValidateCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureDeviceAddressKHR(
    VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR* pInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateStructType(loc.dot(Field::pInfo), pInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR, true,
                               "VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-parameter",
                               "VUID-VkAccelerationStructureDeviceAddressInfoKHR-sType-sType");
    if (pInfo != nullptr) {
        [[maybe_unused]] const Location pInfo_loc = loc.dot(Field::pInfo);
        skip |= ValidateStructPnext(pInfo_loc, pInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureDeviceAddressInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::accelerationStructure), pInfo->accelerationStructure);
    }
    return skip;
}

bool StatelessValidation::PreCallValidateCmdWriteAccelerationStructuresPropertiesKHR(
    VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures,
    VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateHandleArray(loc.dot(Field::accelerationStructureCount), loc.dot(Field::pAccelerationStructures),
                                accelerationStructureCount, pAccelerationStructures, true, true,
                                "VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength");
    skip |= ValidateRangedEnum(loc.dot(Field::queryType), vvl::Enum::VkQueryType, queryType,
                               "VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-parameter", VK_NULL_HANDLE);
    skip |= ValidateRequiredHandle(loc.dot(Field::queryPool), queryPool);
    if (!skip)
        skip |= manual_PreCallValidateCmdWriteAccelerationStructuresPropertiesKHR(
            commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice device, const VkAccelerationStructureVersionInfoKHR* pVersionInfo,
    VkAccelerationStructureCompatibilityKHR* pCompatibility, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |=
        ValidateStructType(loc.dot(Field::pVersionInfo), pVersionInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
                           true, "VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pVersionInfo-parameter",
                           "VUID-VkAccelerationStructureVersionInfoKHR-sType-sType");
    if (pVersionInfo != nullptr) {
        [[maybe_unused]] const Location pVersionInfo_loc = loc.dot(Field::pVersionInfo);
        skip |= ValidateStructPnext(pVersionInfo_loc, pVersionInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureVersionInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

        skip |= ValidateRequiredPointer(pVersionInfo_loc.dot(Field::pVersionData), pVersionInfo->pVersionData,
                                        "VUID-VkAccelerationStructureVersionInfoKHR-pVersionData-parameter");
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pCompatibility), pCompatibility,
                                    "VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pCompatibility-parameter");
    if (!skip)
        skip |=
            manual_PreCallValidateGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetAccelerationStructureBuildSizesKHR(
    VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo,
    const uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_acceleration_structure))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_acceleration_structure});
    skip |= ValidateRangedEnum(loc.dot(Field::buildType), vvl::Enum::VkAccelerationStructureBuildTypeKHR, buildType,
                               "VUID-vkGetAccelerationStructureBuildSizesKHR-buildType-parameter", VK_NULL_HANDLE);
    skip |=
        ValidateStructType(loc.dot(Field::pBuildInfo), pBuildInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
                           true, "VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-parameter",
                           "VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType");
    if (pBuildInfo != nullptr) {
        [[maybe_unused]] const Location pBuildInfo_loc = loc.dot(Field::pBuildInfo);
        skip |= ValidateStructPnext(pBuildInfo_loc, pBuildInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                    "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE,
                                    true);

        skip |= ValidateRangedEnum(pBuildInfo_loc.dot(Field::type), vvl::Enum::VkAccelerationStructureTypeKHR, pBuildInfo->type,
                                   "VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter", VK_NULL_HANDLE);

        skip |= ValidateFlags(pBuildInfo_loc.dot(Field::flags), vvl::FlagBitmask::VkBuildAccelerationStructureFlagBitsKHR,
                              AllVkBuildAccelerationStructureFlagBitsKHR, pBuildInfo->flags, kOptionalFlags, VK_NULL_HANDLE,
                              "VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter");

        skip |= ValidateStructTypeArray(pBuildInfo_loc.dot(Field::geometryCount), pBuildInfo_loc.dot(Field::pGeometries),
                                        pBuildInfo->geometryCount, pBuildInfo->pGeometries,
                                        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
                                        "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
                                        "VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", kVUIDUndefined);

        if (pBuildInfo->pGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pBuildInfo->geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location pGeometries_loc = pBuildInfo_loc.dot(Field::pGeometries, geometryIndex);
                skip |= ValidateStructPnext(pGeometries_loc, pBuildInfo->pGeometries[geometryIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(pGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                           pBuildInfo->pGeometries[geometryIndex].geometryType,
                                           "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(pGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pBuildInfo->pGeometries[geometryIndex].flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
            }
        }

        skip |= ValidateStructPointerTypeArray(
            pBuildInfo_loc.dot(Field::geometryCount), pBuildInfo_loc.dot(Field::ppGeometries), pBuildInfo->geometryCount,
            pBuildInfo->ppGeometries, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, false, false,
            "VUID-VkAccelerationStructureGeometryKHR-sType-sType",
            "VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", kVUIDUndefined);

        if (pBuildInfo->ppGeometries != nullptr) {
            for (uint32_t geometryIndex = 0; geometryIndex < pBuildInfo->geometryCount; ++geometryIndex) {
                [[maybe_unused]] const Location ppGeometries_loc = pBuildInfo_loc.dot(Field::ppGeometries, geometryIndex);
                skip |= ValidateStructPnext(ppGeometries_loc, pBuildInfo->ppGeometries[geometryIndex]->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkAccelerationStructureGeometryKHR-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateRangedEnum(ppGeometries_loc.dot(Field::geometryType), vvl::Enum::VkGeometryTypeKHR,
                                           pBuildInfo->ppGeometries[geometryIndex]->geometryType,
                                           "VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", VK_NULL_HANDLE);

                skip |= ValidateFlags(ppGeometries_loc.dot(Field::flags), vvl::FlagBitmask::VkGeometryFlagBitsKHR,
                                      AllVkGeometryFlagBitsKHR, pBuildInfo->ppGeometries[geometryIndex]->flags, kOptionalFlags,
                                      VK_NULL_HANDLE, "VUID-VkAccelerationStructureGeometryKHR-flags-parameter");
            }
        }
    }
    skip |= ValidateStructType(loc.dot(Field::pSizeInfo), pSizeInfo, VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
                               true, "VUID-vkGetAccelerationStructureBuildSizesKHR-pSizeInfo-parameter",
                               "VUID-VkAccelerationStructureBuildSizesInfoKHR-sType-sType");
    if (pSizeInfo != nullptr) {
        [[maybe_unused]] const Location pSizeInfo_loc = loc.dot(Field::pSizeInfo);
        skip |=
            ValidateStructPnext(pSizeInfo_loc, pSizeInfo->pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkAccelerationStructureBuildSizesInfoKHR-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);
    }
    if (!skip)
        skip |= manual_PreCallValidateGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts,
                                                                            pSizeInfo, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysKHR(VkCommandBuffer commandBuffer,
                                                         const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                                                         const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                                                         const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                                                         const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
                                                         uint32_t width, uint32_t height, uint32_t depth,
                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= ValidateRequiredPointer(loc.dot(Field::pRaygenShaderBindingTable), pRaygenShaderBindingTable,
                                    "VUID-vkCmdTraceRaysKHR-pRaygenShaderBindingTable-parameter");
    if (pRaygenShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pRaygenShaderBindingTable_loc = loc.dot(Field::pRaygenShaderBindingTable);
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pMissShaderBindingTable), pMissShaderBindingTable,
                                    "VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-parameter");
    if (pMissShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pMissShaderBindingTable_loc = loc.dot(Field::pMissShaderBindingTable);
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pHitShaderBindingTable), pHitShaderBindingTable,
                                    "VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-parameter");
    if (pHitShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pHitShaderBindingTable_loc = loc.dot(Field::pHitShaderBindingTable);
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pCallableShaderBindingTable), pCallableShaderBindingTable,
                                    "VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-parameter");
    if (pCallableShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pCallableShaderBindingTable_loc = loc.dot(Field::pCallableShaderBindingTable);
        // No xml-driven validation
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable,
                                                      pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth,
                                                      error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                                      VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                                      const VkRayTracingPipelineCreateInfoKHR* pCreateInfos,
                                                                      const VkAllocationCallbacks* pAllocator,
                                                                      VkPipeline* pPipelines, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= ValidateStructTypeArray(loc.dot(Field::createInfoCount), loc.dot(Field::pCreateInfos), createInfoCount, pCreateInfos,
                                    VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR, true, true,
                                    "VUID-VkRayTracingPipelineCreateInfoKHR-sType-sType",
                                    "VUID-vkCreateRayTracingPipelinesKHR-pCreateInfos-parameter",
                                    "VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength");
    if (pCreateInfos != nullptr) {
        for (uint32_t createInfoIndex = 0; createInfoIndex < createInfoCount; ++createInfoIndex) {
            [[maybe_unused]] const Location pCreateInfos_loc = loc.dot(Field::pCreateInfos, createInfoIndex);
            constexpr std::array allowed_structs_VkRayTracingPipelineCreateInfoKHR = {
                VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR, VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR,
                VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT};

            skip |= ValidateStructPnext(pCreateInfos_loc, pCreateInfos[createInfoIndex].pNext,
                                        allowed_structs_VkRayTracingPipelineCreateInfoKHR.size(),
                                        allowed_structs_VkRayTracingPipelineCreateInfoKHR.data(), GeneratedVulkanHeaderVersion,
                                        "VUID-VkRayTracingPipelineCreateInfoKHR-pNext-pNext",
                                        "VUID-VkRayTracingPipelineCreateInfoKHR-sType-unique", VK_NULL_HANDLE, true);

            skip |= ValidateStructTypeArray(pCreateInfos_loc.dot(Field::stageCount), pCreateInfos_loc.dot(Field::pStages),
                                            pCreateInfos[createInfoIndex].stageCount, pCreateInfos[createInfoIndex].pStages,
                                            VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, false, true,
                                            "VUID-VkPipelineShaderStageCreateInfo-sType-sType",
                                            "VUID-VkRayTracingPipelineCreateInfoKHR-pStages-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pStages != nullptr) {
                for (uint32_t stageIndex = 0; stageIndex < pCreateInfos[createInfoIndex].stageCount; ++stageIndex) {
                    [[maybe_unused]] const Location pStages_loc = pCreateInfos_loc.dot(Field::pStages, stageIndex);
                    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
                        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
                        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

                    skip |= ValidateStructPnext(pStages_loc, pCreateInfos[createInfoIndex].pStages[stageIndex].pNext,
                                                allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                                allowed_structs_VkPipelineShaderStageCreateInfo.data(),
                                                GeneratedVulkanHeaderVersion, "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                                "VUID-VkPipelineShaderStageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

                    skip |= ValidateFlags(pStages_loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                                          AllVkPipelineShaderStageCreateFlagBits,
                                          pCreateInfos[createInfoIndex].pStages[stageIndex].flags, kOptionalFlags, VK_NULL_HANDLE,
                                          "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

                    skip |=
                        ValidateFlags(pStages_loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits,
                                      AllVkShaderStageFlagBits, pCreateInfos[createInfoIndex].pStages[stageIndex].stage,
                                      kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                                      "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

                    skip |= ValidateRequiredPointer(pStages_loc.dot(Field::pName),
                                                    pCreateInfos[createInfoIndex].pStages[stageIndex].pName,
                                                    "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

                    if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo != nullptr) {
                        [[maybe_unused]] const Location pSpecializationInfo_loc = pStages_loc.dot(Field::pSpecializationInfo);
                        skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount),
                                              pSpecializationInfo_loc.dot(Field::pMapEntries),
                                              pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount,
                                              &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries,
                                              false, true, kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

                        if (pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pMapEntries != nullptr) {
                            for (uint32_t mapEntryIndex = 0;
                                 mapEntryIndex <
                                 pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->mapEntryCount;
                                 ++mapEntryIndex) {
                                [[maybe_unused]] const Location pMapEntries_loc =
                                    pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                                // No xml-driven validation
                            }
                        }

                        skip |=
                            ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                                          pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->dataSize,
                                          &pCreateInfos[createInfoIndex].pStages[stageIndex].pSpecializationInfo->pData, false,
                                          true, kVUIDUndefined, "VUID-VkSpecializationInfo-pData-parameter");
                    }
                }
            }

            skip |= ValidateStructTypeArray(pCreateInfos_loc.dot(Field::groupCount), pCreateInfos_loc.dot(Field::pGroups),
                                            pCreateInfos[createInfoIndex].groupCount, pCreateInfos[createInfoIndex].pGroups,
                                            VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR, false, true,
                                            "VUID-VkRayTracingShaderGroupCreateInfoKHR-sType-sType",
                                            "VUID-VkRayTracingPipelineCreateInfoKHR-pGroups-parameter", kVUIDUndefined);

            if (pCreateInfos[createInfoIndex].pGroups != nullptr) {
                for (uint32_t groupIndex = 0; groupIndex < pCreateInfos[createInfoIndex].groupCount; ++groupIndex) {
                    [[maybe_unused]] const Location pGroups_loc = pCreateInfos_loc.dot(Field::pGroups, groupIndex);
                    skip |=
                        ValidateStructPnext(pGroups_loc, pCreateInfos[createInfoIndex].pGroups[groupIndex].pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkRayTracingShaderGroupCreateInfoKHR-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                    skip |= ValidateRangedEnum(pGroups_loc.dot(Field::type), vvl::Enum::VkRayTracingShaderGroupTypeKHR,
                                               pCreateInfos[createInfoIndex].pGroups[groupIndex].type,
                                               "VUID-VkRayTracingShaderGroupCreateInfoKHR-type-parameter", VK_NULL_HANDLE);
                }
            }

            skip |= ValidateStructType(pCreateInfos_loc.dot(Field::pLibraryInfo), pCreateInfos[createInfoIndex].pLibraryInfo,
                                       VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, false,
                                       "VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-parameter",
                                       "VUID-VkPipelineLibraryCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInfo != nullptr) {
                [[maybe_unused]] const Location pLibraryInfo_loc = pCreateInfos_loc.dot(Field::pLibraryInfo);
                skip |= ValidateStructPnext(pLibraryInfo_loc, pCreateInfos[createInfoIndex].pLibraryInfo->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, kVUIDUndefined, kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |= ValidateArray(pLibraryInfo_loc.dot(Field::libraryCount), pLibraryInfo_loc.dot(Field::pLibraries),
                                      pCreateInfos[createInfoIndex].pLibraryInfo->libraryCount,
                                      &pCreateInfos[createInfoIndex].pLibraryInfo->pLibraries, false, true, kVUIDUndefined,
                                      "VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter");
            }

            skip |=
                ValidateStructType(pCreateInfos_loc.dot(Field::pLibraryInterface), pCreateInfos[createInfoIndex].pLibraryInterface,
                                   VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR, false,
                                   "VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInterface-parameter",
                                   "VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-sType-sType");

            if (pCreateInfos[createInfoIndex].pLibraryInterface != nullptr) {
                [[maybe_unused]] const Location pLibraryInterface_loc = pCreateInfos_loc.dot(Field::pLibraryInterface);
                skip |=
                    ValidateStructPnext(pLibraryInterface_loc, pCreateInfos[createInfoIndex].pLibraryInterface->pNext, 0, nullptr,
                                        GeneratedVulkanHeaderVersion, "VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-pNext-pNext",
                                        kVUIDUndefined, VK_NULL_HANDLE, true);
            }

            skip |= ValidateStructType(pCreateInfos_loc.dot(Field::pDynamicState), pCreateInfos[createInfoIndex].pDynamicState,
                                       VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, false,
                                       "VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicState-parameter",
                                       "VUID-VkPipelineDynamicStateCreateInfo-sType-sType");

            if (pCreateInfos[createInfoIndex].pDynamicState != nullptr) {
                [[maybe_unused]] const Location pDynamicState_loc = pCreateInfos_loc.dot(Field::pDynamicState);
                skip |= ValidateStructPnext(pDynamicState_loc, pCreateInfos[createInfoIndex].pDynamicState->pNext, 0, nullptr,
                                            GeneratedVulkanHeaderVersion, "VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext",
                                            kVUIDUndefined, VK_NULL_HANDLE, true);

                skip |=
                    ValidateReservedFlags(pDynamicState_loc.dot(Field::flags), pCreateInfos[createInfoIndex].pDynamicState->flags,
                                          "VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask");

                skip |= ValidateRangedEnumArray(pDynamicState_loc.dot(Field::dynamicStateCount),
                                                pDynamicState_loc.dot(Field::pDynamicStates), vvl::Enum::VkDynamicState,
                                                pCreateInfos[createInfoIndex].pDynamicState->dynamicStateCount,
                                                pCreateInfos[createInfoIndex].pDynamicState->pDynamicStates, false, true,
                                                kVUIDUndefined, "VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter");
            }

            skip |= ValidateRequiredHandle(pCreateInfos_loc.dot(Field::layout), pCreateInfos[createInfoIndex].layout);
        }
    }
    if (pAllocator != nullptr) {
        [[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);
        skip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);
    }
    skip |= ValidateArray(loc.dot(Field::createInfoCount), loc.dot(Field::pPipelines), createInfoCount, &pPipelines, true, true,
                          "VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength",
                          "VUID-vkCreateRayTracingPipelinesKHR-pPipelines-parameter");
    if (!skip)
        skip |= manual_PreCallValidateCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount,
                                                                   pCreateInfos, pAllocator, pPipelines, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline,
                                                                                         uint32_t firstGroup, uint32_t groupCount,
                                                                                         size_t dataSize, void* pData,
                                                                                         const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= ValidateArray(loc.dot(Field::dataSize), loc.dot(Field::pData), dataSize, &pData, true, true,
                          "VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-arraylength",
                          "VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pData-parameter");
    if (!skip)
        skip |= manual_PreCallValidateGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount,
                                                                                      dataSize, pData, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer,
                                                                 const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
                                                                 const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
                                                                 const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
                                                                 const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable,
                                                                 VkDeviceAddress indirectDeviceAddress,
                                                                 const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= ValidateRequiredPointer(loc.dot(Field::pRaygenShaderBindingTable), pRaygenShaderBindingTable,
                                    "VUID-vkCmdTraceRaysIndirectKHR-pRaygenShaderBindingTable-parameter");
    if (pRaygenShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pRaygenShaderBindingTable_loc = loc.dot(Field::pRaygenShaderBindingTable);
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pMissShaderBindingTable), pMissShaderBindingTable,
                                    "VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-parameter");
    if (pMissShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pMissShaderBindingTable_loc = loc.dot(Field::pMissShaderBindingTable);
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pHitShaderBindingTable), pHitShaderBindingTable,
                                    "VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-parameter");
    if (pHitShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pHitShaderBindingTable_loc = loc.dot(Field::pHitShaderBindingTable);
        // No xml-driven validation
    }
    skip |= ValidateRequiredPointer(loc.dot(Field::pCallableShaderBindingTable), pCallableShaderBindingTable,
                                    "VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-parameter");
    if (pCallableShaderBindingTable != nullptr) {
        [[maybe_unused]] const Location pCallableShaderBindingTable_loc = loc.dot(Field::pCallableShaderBindingTable);
        // No xml-driven validation
    }
    if (!skip)
        skip |= manual_PreCallValidateCmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable,
                                                              pHitShaderBindingTable, pCallableShaderBindingTable,
                                                              indirectDeviceAddress, error_obj);
    return skip;
}

bool StatelessValidation::PreCallValidateGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group,
                                                                              VkShaderGroupShaderKHR groupShader,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    skip |= ValidateRequiredHandle(loc.dot(Field::pipeline), pipeline);
    skip |= ValidateRangedEnum(loc.dot(Field::groupShader), vvl::Enum::VkShaderGroupShaderKHR, groupShader,
                               "VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-parameter", VK_NULL_HANDLE);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer,
                                                                              uint32_t pipelineStackSize,
                                                                              const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_khr_ray_tracing_pipeline))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_ray_tracing_pipeline});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX,
                                                             uint32_t groupCountY, uint32_t groupCountZ,
                                                             const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_mesh_shader});
    // No xml-driven validation
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                     VkDeviceSize offset, uint32_t drawCount, uint32_t stride,
                                                                     const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_mesh_shader});
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    return skip;
}

bool StatelessValidation::PreCallValidateCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                          VkDeviceSize offset, VkBuffer countBuffer,
                                                                          VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                                                          uint32_t stride, const ErrorObject& error_obj) const {
    bool skip = false;
    [[maybe_unused]] const Location loc = error_obj.location;
    if (!IsExtEnabled(device_extensions.vk_ext_mesh_shader))
        skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_mesh_shader});
    skip |= ValidateRequiredHandle(loc.dot(Field::buffer), buffer);
    skip |= ValidateRequiredHandle(loc.dot(Field::countBuffer), countBuffer);
    return skip;
}

bool StatelessValidation::ValidatePipelineViewportStateCreateInfo(const VkPipelineViewportStateCreateInfo& info,
                                                                  const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineViewportStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineViewportStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineViewportStateCreateInfo.size(),
                                allowed_structs_VkPipelineViewportStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineViewportStateCreateInfo-pNext-pNext",
                                "VUID-VkPipelineViewportStateCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |= ValidateReservedFlags(loc.dot(Field::flags), info.flags, "VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask");
    return skip;
}
bool StatelessValidation::ValidatePipelineTessellationStateCreateInfo(const VkPipelineTessellationStateCreateInfo& info,
                                                                      const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineTessellationStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineTessellationStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineTessellationStateCreateInfo.size(),
                                allowed_structs_VkPipelineTessellationStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext",
                                "VUID-VkPipelineTessellationStateCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |=
        ValidateReservedFlags(loc.dot(Field::flags), info.flags, "VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask");
    return skip;
}
bool StatelessValidation::ValidatePipelineVertexInputStateCreateInfo(const VkPipelineVertexInputStateCreateInfo& info,
                                                                     const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineVertexInputStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineVertexInputStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineVertexInputStateCreateInfo.size(),
                                allowed_structs_VkPipelineVertexInputStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext",
                                "VUID-VkPipelineVertexInputStateCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |= ValidateReservedFlags(loc.dot(Field::flags), info.flags, "VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask");

    skip |= ValidateArray(loc.dot(Field::vertexBindingDescriptionCount), loc.dot(Field::pVertexBindingDescriptions),
                          info.vertexBindingDescriptionCount, &info.pVertexBindingDescriptions, false, true, kVUIDUndefined,
                          "VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter");

    if (info.pVertexBindingDescriptions != nullptr) {
        for (uint32_t vertexBindingDescriptionIndex = 0; vertexBindingDescriptionIndex < info.vertexBindingDescriptionCount;
             ++vertexBindingDescriptionIndex) {
            [[maybe_unused]] const Location pVertexBindingDescriptions_loc =
                loc.dot(Field::pVertexBindingDescriptions, vertexBindingDescriptionIndex);
            skip |= ValidateRangedEnum(pVertexBindingDescriptions_loc.dot(Field::inputRate), vvl::Enum::VkVertexInputRate,
                                       info.pVertexBindingDescriptions[vertexBindingDescriptionIndex].inputRate,
                                       "VUID-VkVertexInputBindingDescription-inputRate-parameter", VK_NULL_HANDLE);
        }
    }

    skip |= ValidateArray(loc.dot(Field::vertexAttributeDescriptionCount), loc.dot(Field::pVertexAttributeDescriptions),
                          info.vertexAttributeDescriptionCount, &info.pVertexAttributeDescriptions, false, true, kVUIDUndefined,
                          "VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter");

    if (info.pVertexAttributeDescriptions != nullptr) {
        for (uint32_t vertexAttributeDescriptionIndex = 0; vertexAttributeDescriptionIndex < info.vertexAttributeDescriptionCount;
             ++vertexAttributeDescriptionIndex) {
            [[maybe_unused]] const Location pVertexAttributeDescriptions_loc =
                loc.dot(Field::pVertexAttributeDescriptions, vertexAttributeDescriptionIndex);
            skip |= ValidateRangedEnum(pVertexAttributeDescriptions_loc.dot(Field::format), vvl::Enum::VkFormat,
                                       info.pVertexAttributeDescriptions[vertexAttributeDescriptionIndex].format,
                                       "VUID-VkVertexInputAttributeDescription-format-parameter", VK_NULL_HANDLE);
        }
    }
    return skip;
}
bool StatelessValidation::ValidatePipelineMultisampleStateCreateInfo(const VkPipelineMultisampleStateCreateInfo& info,
                                                                     const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineMultisampleStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineMultisampleStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
        VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineMultisampleStateCreateInfo.size(),
                                allowed_structs_VkPipelineMultisampleStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext",
                                "VUID-VkPipelineMultisampleStateCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |= ValidateReservedFlags(loc.dot(Field::flags), info.flags, "VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask");

    skip |= ValidateFlags(loc.dot(Field::rasterizationSamples), vvl::FlagBitmask::VkSampleCountFlagBits, AllVkSampleCountFlagBits,
                          info.rasterizationSamples, kRequiredSingleBit, VK_NULL_HANDLE,
                          "VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter",
                          "VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter");

    skip |= ValidateBool32(loc.dot(Field::sampleShadingEnable), info.sampleShadingEnable);

    skip |= ValidateArray(loc.dot(Field::rasterizationSamples), loc.dot(Field::pSampleMask), info.rasterizationSamples,
                          &info.pSampleMask, true, false, kVUIDUndefined,
                          "VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter");

    skip |= ValidateBool32(loc.dot(Field::alphaToCoverageEnable), info.alphaToCoverageEnable);

    skip |= ValidateBool32(loc.dot(Field::alphaToOneEnable), info.alphaToOneEnable);
    return skip;
}
bool StatelessValidation::ValidatePipelineColorBlendStateCreateInfo(const VkPipelineColorBlendStateCreateInfo& info,
                                                                    const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineColorBlendStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineColorBlendStateCreateInfo = {
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineColorBlendStateCreateInfo.size(),
                                allowed_structs_VkPipelineColorBlendStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext",
                                "VUID-VkPipelineColorBlendStateCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineColorBlendStateCreateFlagBits,
                          AllVkPipelineColorBlendStateCreateFlagBits, info.flags, kOptionalFlags, VK_NULL_HANDLE,
                          "VUID-VkPipelineColorBlendStateCreateInfo-flags-parameter");

    skip |= ValidateBool32(loc.dot(Field::logicOpEnable), info.logicOpEnable);

    if (info.pAttachments != nullptr) {
        for (uint32_t attachmentIndex = 0; attachmentIndex < info.attachmentCount; ++attachmentIndex) {
            [[maybe_unused]] const Location pAttachments_loc = loc.dot(Field::pAttachments, attachmentIndex);
            skip |= ValidateBool32(pAttachments_loc.dot(Field::blendEnable), info.pAttachments[attachmentIndex].blendEnable);

            skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::srcColorBlendFactor), vvl::Enum::VkBlendFactor,
                                       info.pAttachments[attachmentIndex].srcColorBlendFactor,
                                       "VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::dstColorBlendFactor), vvl::Enum::VkBlendFactor,
                                       info.pAttachments[attachmentIndex].dstColorBlendFactor,
                                       "VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::colorBlendOp), vvl::Enum::VkBlendOp,
                                       info.pAttachments[attachmentIndex].colorBlendOp,
                                       "VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::srcAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                       info.pAttachments[attachmentIndex].srcAlphaBlendFactor,
                                       "VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::dstAlphaBlendFactor), vvl::Enum::VkBlendFactor,
                                       info.pAttachments[attachmentIndex].dstAlphaBlendFactor,
                                       "VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter", VK_NULL_HANDLE);

            skip |= ValidateRangedEnum(pAttachments_loc.dot(Field::alphaBlendOp), vvl::Enum::VkBlendOp,
                                       info.pAttachments[attachmentIndex].alphaBlendOp,
                                       "VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter", VK_NULL_HANDLE);

            skip |= ValidateFlags(pAttachments_loc.dot(Field::colorWriteMask), vvl::FlagBitmask::VkColorComponentFlagBits,
                                  AllVkColorComponentFlagBits, info.pAttachments[attachmentIndex].colorWriteMask, kOptionalFlags,
                                  VK_NULL_HANDLE, "VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter");
        }
    }
    return skip;
}
bool StatelessValidation::ValidatePipelineDepthStencilStateCreateInfo(const VkPipelineDepthStencilStateCreateInfo& info,
                                                                      const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType");

    skip |= ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineDepthStencilStateCreateFlagBits,
                          AllVkPipelineDepthStencilStateCreateFlagBits, info.flags, kOptionalFlags, VK_NULL_HANDLE,
                          "VUID-VkPipelineDepthStencilStateCreateInfo-flags-parameter");

    skip |= ValidateBool32(loc.dot(Field::depthTestEnable), info.depthTestEnable);

    skip |= ValidateBool32(loc.dot(Field::depthWriteEnable), info.depthWriteEnable);

    skip |= ValidateRangedEnum(loc.dot(Field::depthCompareOp), vvl::Enum::VkCompareOp, info.depthCompareOp,
                               "VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateBool32(loc.dot(Field::depthBoundsTestEnable), info.depthBoundsTestEnable);

    skip |= ValidateBool32(loc.dot(Field::stencilTestEnable), info.stencilTestEnable);

    skip |= ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, info.front.failOp,
                               "VUID-VkStencilOpState-failOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, info.front.passOp,
                               "VUID-VkStencilOpState-passOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::depthFailOp), vvl::Enum::VkStencilOp, info.front.depthFailOp,
                               "VUID-VkStencilOpState-depthFailOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::compareOp), vvl::Enum::VkCompareOp, info.front.compareOp,
                               "VUID-VkStencilOpState-compareOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, info.back.failOp,
                               "VUID-VkStencilOpState-failOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, info.back.passOp,
                               "VUID-VkStencilOpState-passOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::depthFailOp), vvl::Enum::VkStencilOp, info.back.depthFailOp,
                               "VUID-VkStencilOpState-depthFailOp-parameter", VK_NULL_HANDLE);

    skip |= ValidateRangedEnum(loc.dot(Field::compareOp), vvl::Enum::VkCompareOp, info.back.compareOp,
                               "VUID-VkStencilOpState-compareOp-parameter", VK_NULL_HANDLE);
    return skip;
}
bool StatelessValidation::ValidatePipelineInputAssemblyStateCreateInfo(const VkPipelineInputAssemblyStateCreateInfo& info,
                                                                       const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType");

    skip |= ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, true);

    skip |=
        ValidateReservedFlags(loc.dot(Field::flags), info.flags, "VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask");

    skip |= ValidateRangedEnum(loc.dot(Field::topology), vvl::Enum::VkPrimitiveTopology, info.topology,
                               "VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter", VK_NULL_HANDLE);

    skip |= ValidateBool32(loc.dot(Field::primitiveRestartEnable), info.primitiveRestartEnable);
    return skip;
}
bool StatelessValidation::ValidatePipelineRasterizationStateCreateInfo(const VkPipelineRasterizationStateCreateInfo& info,
                                                                       const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, false, kVUIDUndefined,
                               "VUID-VkPipelineRasterizationStateCreateInfo-sType-sType");

    constexpr std::array allowed_structs_VkPipelineRasterizationStateCreateInfo = {
        VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineRasterizationStateCreateInfo.size(),
                                allowed_structs_VkPipelineRasterizationStateCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext",
                                "VUID-VkPipelineRasterizationStateCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |=
        ValidateReservedFlags(loc.dot(Field::flags), info.flags, "VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask");

    skip |= ValidateBool32(loc.dot(Field::depthClampEnable), info.depthClampEnable);

    skip |= ValidateBool32(loc.dot(Field::rasterizerDiscardEnable), info.rasterizerDiscardEnable);

    skip |= ValidateRangedEnum(loc.dot(Field::polygonMode), vvl::Enum::VkPolygonMode, info.polygonMode,
                               "VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter", VK_NULL_HANDLE);

    skip |= ValidateFlags(loc.dot(Field::cullMode), vvl::FlagBitmask::VkCullModeFlagBits, AllVkCullModeFlagBits, info.cullMode,
                          kOptionalFlags, VK_NULL_HANDLE, "VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter");

    skip |= ValidateRangedEnum(loc.dot(Field::frontFace), vvl::Enum::VkFrontFace, info.frontFace,
                               "VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter", VK_NULL_HANDLE);

    skip |= ValidateBool32(loc.dot(Field::depthBiasEnable), info.depthBiasEnable);
    return skip;
}
bool StatelessValidation::ValidatePipelineShaderStageCreateInfo(const VkPipelineShaderStageCreateInfo& info,
                                                                const Location& loc) const {
    bool skip = false;
    constexpr std::array allowed_structs_VkPipelineShaderStageCreateInfo = {
        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX,
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT};

    skip |= ValidateStructPnext(loc, info.pNext, allowed_structs_VkPipelineShaderStageCreateInfo.size(),
                                allowed_structs_VkPipelineShaderStageCreateInfo.data(), GeneratedVulkanHeaderVersion,
                                "VUID-VkPipelineShaderStageCreateInfo-pNext-pNext",
                                "VUID-VkPipelineShaderStageCreateInfo-sType-unique", VK_NULL_HANDLE, true);

    skip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkPipelineShaderStageCreateFlagBits,
                          AllVkPipelineShaderStageCreateFlagBits, info.flags, kOptionalFlags, VK_NULL_HANDLE,
                          "VUID-VkPipelineShaderStageCreateInfo-flags-parameter");

    skip |= ValidateFlags(loc.dot(Field::stage), vvl::FlagBitmask::VkShaderStageFlagBits, AllVkShaderStageFlagBits, info.stage,
                          kRequiredSingleBit, VK_NULL_HANDLE, "VUID-VkPipelineShaderStageCreateInfo-stage-parameter",
                          "VUID-VkPipelineShaderStageCreateInfo-stage-parameter");

    skip |= ValidateRequiredPointer(loc.dot(Field::pName), info.pName, "VUID-VkPipelineShaderStageCreateInfo-pName-parameter");

    if (info.pSpecializationInfo != nullptr) {
        [[maybe_unused]] const Location pSpecializationInfo_loc = loc.dot(Field::pSpecializationInfo);
        skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::mapEntryCount), pSpecializationInfo_loc.dot(Field::pMapEntries),
                              info.pSpecializationInfo->mapEntryCount, &info.pSpecializationInfo->pMapEntries, false, true,
                              kVUIDUndefined, "VUID-VkSpecializationInfo-pMapEntries-parameter");

        if (info.pSpecializationInfo->pMapEntries != nullptr) {
            for (uint32_t mapEntryIndex = 0; mapEntryIndex < info.pSpecializationInfo->mapEntryCount; ++mapEntryIndex) {
                [[maybe_unused]] const Location pMapEntries_loc = pSpecializationInfo_loc.dot(Field::pMapEntries, mapEntryIndex);
                // No xml-driven validation
            }
        }

        skip |= ValidateArray(pSpecializationInfo_loc.dot(Field::dataSize), pSpecializationInfo_loc.dot(Field::pData),
                              info.pSpecializationInfo->dataSize, &info.pSpecializationInfo->pData, false, true, kVUIDUndefined,
                              "VUID-VkSpecializationInfo-pData-parameter");
    }
    return skip;
}
bool StatelessValidation::ValidateDescriptorAddressInfoEXT(const VkDescriptorAddressInfoEXT& info, const Location& loc) const {
    bool skip = false;
    skip |= ValidateStructType(loc, &info, VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT, false, kVUIDUndefined,
                               "VUID-VkDescriptorAddressInfoEXT-sType-sType");

    skip |= ValidateStructPnext(loc, info.pNext, 0, nullptr, GeneratedVulkanHeaderVersion,
                                "VUID-VkDescriptorAddressInfoEXT-pNext-pNext", kVUIDUndefined, VK_NULL_HANDLE, false);

    skip |= ValidateRangedEnum(loc.dot(Field::format), vvl::Enum::VkFormat, info.format,
                               "VUID-VkDescriptorAddressInfoEXT-format-parameter", VK_NULL_HANDLE);
    return skip;
}

// NOLINTEND
