/* Copyright (c) 2023 The Khronos Group Inc.
 * Copyright (c) 2023 LunarG, Inc.
 * Copyright (C) 2023 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "chassis.h"
#include "state_tracker/state_tracker.h"

#include "state_tracker/buffer_state.h"
#include "state_tracker/cmd_buffer_state.h"
#include "state_tracker/descriptor_sets.h"
#include "state_tracker/device_memory_state.h"
#include "state_tracker/device_state.h"
#include "state_tracker/image_layout_map.h"
#include "state_tracker/image_state.h"
#include "state_tracker/pipeline_layout_state.h"
#include "state_tracker/pipeline_state.h"
#include "state_tracker/query_state.h"
#include "state_tracker/queue_state.h"
#include "state_tracker/ray_tracing_state.h"
#include "state_tracker/render_pass_state.h"
#include "state_tracker/sampler_state.h"
#include "state_tracker/shader_instruction.h"
#include "state_tracker/shader_module.h"
#include "state_tracker/video_session_state.h"

class ExplicitValidation : public ValidationStateTracker {
  public:
    // Constructor for autogenerated explicit valication
    ExplicitValidation() {
        container_type = LayerObjectTypeExplicitValidation;
    }
    ~ExplicitValidation() {
    }

    // Called when a require() condition fails.  This is simliar to LogError() elsewhere in VVL, but
    // uses the special LogFormattedMsg instead of LogMsg.
    bool DECORATE_PRINTF(4, 5) LogFail(const LogObjectList &objlist, const std::string &vuid_text, const char *format, ...) const {
        va_list argptr;
        va_start(argptr, format);
        const bool result = LogFormattedMsg(report_data, kErrorBit, objlist, vuid_text, format, argptr);
        va_end(argptr);
        return result;
    }

    /*
     * Builtin implementations.  For every builtin `foo` in the spec, there's a corresponding
     * `Builtin_foo` function in this class that implements it.  In most cases, these are trivial
     * inlinable functions.
     */

    template <typename S>
    bool Builtin_has_pnext(const void *pNext) const
    {
        return LvlFindInChain<S>(pNext) != nullptr;
    }

    template <typename S>
    const S *Builtin_pnext(const void *pNext) const
    {
        return LvlFindInChain<S>(pNext);
    }

    bool Builtin_ext_enabled(const char *name) const
    {
        // TODO
        return false;
    }

    template <typename Handle>
    bool Builtin_externally_synchronized(Handle) const
    {
        // Cannot be verified by autogen
        return true;
    }

    template <typename Flags, typename Bit>
    bool Builtin_has_bit(Flags flags, Bit bit) const
    {
        return (flags >> bit & 1) != 0;
    }

    template <typename Flags>
    bool Builtin_any(Flags flags) const
    {
        return flags != 0;
    }

    template <typename Flags>
    bool Builtin_none(Flags flags) const
    {
        return flags == 0;
    }

    template <typename Handle>
    bool Builtin_valid(Handle handle) const
    {
        return handle != VK_NULL_HANDLE;
    }

    template <typename State>
    const auto &Builtin_create_info(State &state) const
    {
        return state->createInfo;
    }

    const auto &Builtin_graphics_create_info(PIPELINE_STATE *state) const
    {
        return state->GetCreateInfo<VkGraphicsPipelineCreateInfo>();
    }

    const auto &Builtin_compute_create_info(PIPELINE_STATE *state) const
    {
        return state->GetCreateInfo<VkComputePipelineCreateInfo>();
    }

    const auto &Builtin_raytracing_create_info(PIPELINE_STATE *state) const
    {
        return state->GetCreateInfo<VkRayTracingPipelineCreateInfoKHR>();
    }

    /*
     * Manual ignore rules.  There is currently no machine-readable form for "ignore this field
     * given the contents of the rest of the fields".  For example, when no tessellation shaders are
     * present, VkGraphicsPipelineCreateInfo::pTessellationState should be ignored, even if it's not
     * nullptr.
     *
     * TODO: complete as necessary
     */

    bool shouldIgnore_VkGraphicsPipelineCreateInfo_pTessellationState(const VkStructureType sType,
                const void* pNext,
                const VkPipelineCreateFlags flags,
                const uint32_t stageCount,
                const VkPipelineShaderStageCreateInfo* pStages,
                const VkPipelineVertexInputStateCreateInfo* pVertexInputState,
                const VkPipelineInputAssemblyStateCreateInfo* pInputAssemblyState,
                const VkPipelineTessellationStateCreateInfo* pTessellationState,
                const VkPipelineViewportStateCreateInfo* pViewportState,
                const VkPipelineRasterizationStateCreateInfo* pRasterizationState,
                const VkPipelineMultisampleStateCreateInfo* pMultisampleState,
                const VkPipelineDepthStencilStateCreateInfo* pDepthStencilState,
                const VkPipelineColorBlendStateCreateInfo* pColorBlendState,
                const VkPipelineDynamicStateCreateInfo* pDynamicState,
                const VkPipelineLayout layout,
                const VkRenderPass renderPass,
                const uint32_t subpass,
                const VkPipeline basePipelineHandle,
                const int32_t basePipelineIndex) const;

#include "explicit_validation_decl.h"
};
