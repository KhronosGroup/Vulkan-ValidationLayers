/* THIS FILE IS GENERATED - DO NOT EDIT (scripts/vk_validation_stats.py) */
/* Vulkan specification version: 1.3.230 */
/*
 * Vulkan
 *
 * Copyright (c) 2016-2022 Google Inc.
 * Copyright (c) 2016-2022 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author: Tobin Ehlis <tobine@google.com>
 * Author: Dave Houlton <daveh@lunarg.com>
 */

#pragma once

// Disable auto-formatting for generated file
// clang-format off

// Mapping from VUID string to the corresponding spec text
typedef struct _vuid_spec_text_pair {
    const char * vuid;
    const char * spec_text;
    const char * url_id;
} vuid_spec_text_pair;

static const vuid_spec_text_pair vuid_spec_text[] = {
    {"VUID-BaryCoordKHR-BaryCoordKHR-04154", "The BaryCoordKHR decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordKHR-BaryCoordKHR-04155", "The variable decorated with BaryCoordKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordKHR-BaryCoordKHR-04156", "The variable decorated with BaryCoordKHR must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspAMD-BaryCoordNoPerspAMD-04157", "The BaryCoordNoPerspAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspAMD-BaryCoordNoPerspAMD-04158", "The variable decorated with BaryCoordNoPerspAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspAMD-BaryCoordNoPerspAMD-04159", "The variable decorated with BaryCoordNoPerspAMD must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspCentroidAMD-BaryCoordNoPerspCentroidAMD-04163", "The BaryCoordNoPerspCentroidAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspCentroidAMD-BaryCoordNoPerspCentroidAMD-04164", "The variable decorated with BaryCoordNoPerspCentroidAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspCentroidAMD-BaryCoordNoPerspCentroidAMD-04165", "The variable decorated with BaryCoordNoPerspCentroidAMD must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspKHR-BaryCoordNoPerspKHR-04160", "The BaryCoordNoPerspKHR decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspKHR-BaryCoordNoPerspKHR-04161", "The variable decorated with BaryCoordNoPerspKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspKHR-BaryCoordNoPerspKHR-04162", "The variable decorated with BaryCoordNoPerspKHR must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspSampleAMD-BaryCoordNoPerspSampleAMD-04166", "The BaryCoordNoPerspSampleAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspSampleAMD-BaryCoordNoPerspSampleAMD-04167", "The variable decorated with BaryCoordNoPerspSampleAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordNoPerspSampleAMD-BaryCoordNoPerspSampleAMD-04168", "The variable decorated with BaryCoordNoPerspSampleAMD must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordPullModelAMD-BaryCoordPullModelAMD-04169", "The BaryCoordPullModelAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordPullModelAMD-BaryCoordPullModelAMD-04170", "The variable decorated with BaryCoordPullModelAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordPullModelAMD-BaryCoordPullModelAMD-04171", "The variable decorated with BaryCoordPullModelAMD must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordSmoothAMD-BaryCoordSmoothAMD-04172", "The BaryCoordSmoothAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordSmoothAMD-BaryCoordSmoothAMD-04173", "The variable decorated with BaryCoordSmoothAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordSmoothAMD-BaryCoordSmoothAMD-04174", "The variable decorated with BaryCoordSmoothAMD must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordSmoothCentroidAMD-BaryCoordSmoothCentroidAMD-04175", "The BaryCoordSmoothCentroidAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordSmoothCentroidAMD-BaryCoordSmoothCentroidAMD-04176", "The variable decorated with BaryCoordSmoothCentroidAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordSmoothCentroidAMD-BaryCoordSmoothCentroidAMD-04177", "The variable decorated with BaryCoordSmoothCentroidAMD must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaryCoordSmoothSampleAMD-BaryCoordSmoothSampleAMD-04178", "The BaryCoordSmoothSampleAMD decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaryCoordSmoothSampleAMD-BaryCoordSmoothSampleAMD-04179", "The variable decorated with BaryCoordSmoothSampleAMD must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaryCoordSmoothSampleAMD-BaryCoordSmoothSampleAMD-04180", "The variable decorated with BaryCoordSmoothSampleAMD must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-BaseInstance-BaseInstance-04181", "The BaseInstance decoration must be used only within the Vertex {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaseInstance-BaseInstance-04182", "The variable decorated with BaseInstance must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaseInstance-BaseInstance-04183", "The variable decorated with BaseInstance must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-BaseVertex-BaseVertex-04184", "The BaseVertex decoration must be used only within the Vertex {ExecutionModel}", "1.3-extensions"},
    {"VUID-BaseVertex-BaseVertex-04185", "The variable decorated with BaseVertex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-BaseVertex-BaseVertex-04186", "The variable decorated with BaseVertex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-ClipDistance-ClipDistance-04187", "The ClipDistance decoration must be used only within the MeshEXT, MeshNV, Vertex, Fragment, TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-ClipDistance-ClipDistance-04188", "The variable decorated with ClipDistance within the MeshEXT, MeshNV, or Vertex {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-ClipDistance-ClipDistance-04189", "The variable decorated with ClipDistance within the Fragment {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ClipDistance-ClipDistance-04190", "The variable decorated with ClipDistance within the TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel} must not be declared in a {StorageClass} other than Input or Output", "1.3-extensions"},
    {"VUID-ClipDistance-ClipDistance-04191", "The variable decorated with ClipDistance must be declared as an array of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-ClipDistancePerViewNV-ClipDistancePerViewNV-04192", "The ClipDistancePerViewNV decoration must be used only within the MeshNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-ClipDistancePerViewNV-ClipDistancePerViewNV-04193", "The variable decorated with ClipDistancePerViewNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-ClipDistancePerViewNV-ClipDistancePerViewNV-04194", "The variable decorated with ClipDistancePerViewNV must also be decorated with the PerViewNV decoration", "1.3-extensions"},
    {"VUID-ClipDistancePerViewNV-ClipDistancePerViewNV-04195", "The variable decorated with ClipDistancePerViewNV must be declared as a two-dimensional array of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-CullDistance-CullDistance-04196", "The CullDistance decoration must be used only within the MeshEXT, MeshNV, Vertex, Fragment, TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-CullDistance-CullDistance-04197", "The variable decorated with CullDistance within the MeshEXT, MeshNV or Vertex {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-CullDistance-CullDistance-04198", "The variable decorated with CullDistance within the Fragment {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-CullDistance-CullDistance-04199", "The variable decorated with CullDistance within the TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel} must not be declared using a {StorageClass} other than Input or Output", "1.3-extensions"},
    {"VUID-CullDistance-CullDistance-04200", "The variable decorated with CullDistance must be declared as an array of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-CullDistancePerViewNV-CullDistancePerViewNV-04201", "The CullDistancePerViewNV decoration must be used only within the MeshNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-CullDistancePerViewNV-CullDistancePerViewNV-04202", "The variable decorated with CullDistancePerViewNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-CullDistancePerViewNV-CullDistancePerViewNV-04203", "The variable decorated with CullDistancePerViewNV must also be decorated with the PerViewNV decoration", "1.3-extensions"},
    {"VUID-CullDistancePerViewNV-CullDistancePerViewNV-04204", "The variable decorated with CullDistancePerViewNV must be declared as a two-dimensional array of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-CullMaskKHR-CullMaskKHR-06735", "The CullMaskKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-CullMaskKHR-CullMaskKHR-06736", "The variable decorated with CullMaskKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-CullMaskKHR-CullMaskKHR-06737", "The variable decorated with CullMaskKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-CullPrimitiveEXT-CullPrimitiveEXT-07034", "The CullPrimitiveEXT decoration must be used only within the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-CullPrimitiveEXT-CullPrimitiveEXT-07035", "The variable decorated with CullPrimitiveEXT must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-CullPrimitiveEXT-CullPrimitiveEXT-07036", "The variable decorated with CullPrimitiveEXT must be declared as an array of boolean values", "1.3-extensions"},
    {"VUID-CullPrimitiveEXT-CullPrimitiveEXT-07037", "The size of the array decorated with CullPrimitiveEXT must match the value specified by OutputPrimitivesEXT", "1.3-extensions"},
    {"VUID-CullPrimitiveEXT-CullPrimitiveEXT-07038", "The variable decorated with CullPrimitiveEXT within the MeshEXT {ExecutionModel} must also be decorated with the PerPrimitiveEXT decoration", "1.3-extensions"},
    {"VUID-CurrentRayTimeNV-CurrentRayTimeNV-04942", "The CurrentRayTimeNV decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-CurrentRayTimeNV-CurrentRayTimeNV-04943", "The variable decorated with CurrentRayTimeNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-CurrentRayTimeNV-CurrentRayTimeNV-04944", "The variable decorated with CurrentRayTimeNV must be declared as a scalar 32-bit floating-point value", "1.3-extensions"},
    {"VUID-DeviceIndex-DeviceIndex-04205", "The variable decorated with DeviceIndex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-DeviceIndex-DeviceIndex-04206", "The variable decorated with DeviceIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-DrawIndex-DrawIndex-04207", "The DrawIndex decoration must be used only within the Vertex, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-DrawIndex-DrawIndex-04208", "The variable decorated with DrawIndex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-DrawIndex-DrawIndex-04209", "The variable decorated with DrawIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-FragCoord-FragCoord-04210", "The FragCoord decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FragCoord-FragCoord-04211", "The variable decorated with FragCoord must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-FragCoord-FragCoord-04212", "The variable decorated with FragCoord must be declared as a four-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-FragDepth-FragDepth-04213", "The FragDepth decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FragDepth-FragDepth-04214", "The variable decorated with FragDepth must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-FragDepth-FragDepth-04215", "The variable decorated with FragDepth must be declared as a scalar 32-bit floating-point value", "1.3-extensions"},
    {"VUID-FragDepth-FragDepth-04216", "If the shader dynamically writes to the variable decorated with FragDepth, the DepthReplacing {ExecutionMode} must be declared", "1.3-extensions"},
    {"VUID-FragInvocationCountEXT-FragInvocationCountEXT-04217", "The FragInvocationCountEXT decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FragInvocationCountEXT-FragInvocationCountEXT-04218", "The variable decorated with FragInvocationCountEXT must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-FragInvocationCountEXT-FragInvocationCountEXT-04219", "The variable decorated with FragInvocationCountEXT must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-FragSizeEXT-FragSizeEXT-04220", "The FragSizeEXT decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FragSizeEXT-FragSizeEXT-04221", "The variable decorated with FragSizeEXT must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-FragSizeEXT-FragSizeEXT-04222", "The variable decorated with FragSizeEXT must be declared as a two-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-FragStencilRefEXT-FragStencilRefEXT-04223", "The FragStencilRefEXT decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FragStencilRefEXT-FragStencilRefEXT-04224", "The variable decorated with FragStencilRefEXT must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-FragStencilRefEXT-FragStencilRefEXT-04225", "The variable decorated with FragStencilRefEXT must be declared as a scalar integer value", "1.3-extensions"},
    {"VUID-FragmentSizeNV-FragmentSizeNV-04226", "The FragmentSizeNV decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FragmentSizeNV-FragmentSizeNV-04227", "The variable decorated with FragmentSizeNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-FragmentSizeNV-FragmentSizeNV-04228", "The variable decorated with FragmentSizeNV must be declared as a two-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-FrontFacing-FrontFacing-04229", "The FrontFacing decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FrontFacing-FrontFacing-04230", "The variable decorated with FrontFacing must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-FrontFacing-FrontFacing-04231", "The variable decorated with FrontFacing must be declared as a boolean value", "1.3-extensions"},
    {"VUID-FullyCoveredEXT-FullyCoveredEXT-04232", "The FullyCoveredEXT decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-FullyCoveredEXT-FullyCoveredEXT-04233", "The variable decorated with FullyCoveredEXT must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-FullyCoveredEXT-FullyCoveredEXT-04234", "The variable decorated with FullyCoveredEXT must be declared as a boolean value", "1.3-extensions"},
    {"VUID-FullyCoveredEXT-conservativeRasterizationPostDepthCoverage-04235", "If VkPhysicalDeviceConservativeRasterizationPropertiesEXT::conservativeRasterizationPostDepthCoverage is not supported the PostDepthCoverage {ExecutionMode} must not be declared, when a variable with the FullyCoveredEXT decoration is declared", "1.3-extensions"},
    {"VUID-GlobalInvocationId-GlobalInvocationId-04236", "The GlobalInvocationId decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-GlobalInvocationId-GlobalInvocationId-04237", "The variable decorated with GlobalInvocationId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-GlobalInvocationId-GlobalInvocationId-04238", "The variable decorated with GlobalInvocationId must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-HelperInvocation-HelperInvocation-04239", "The HelperInvocation decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-HelperInvocation-HelperInvocation-04240", "The variable decorated with HelperInvocation must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-HelperInvocation-HelperInvocation-04241", "The variable decorated with HelperInvocation must be declared as a boolean value", "1.3-extensions"},
    {"VUID-HitKindKHR-HitKindKHR-04242", "The HitKindKHR decoration must be used only within the AnyHitKHR or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-HitKindKHR-HitKindKHR-04243", "The variable decorated with HitKindKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-HitKindKHR-HitKindKHR-04244", "The variable decorated with HitKindKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-HitTNV-HitTNV-04245", "The HitTNV decoration must be used only within the AnyHitNV or ClosestHitNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-HitTNV-HitTNV-04246", "The variable decorated with HitTNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-HitTNV-HitTNV-04247", "The variable decorated with HitTNV must be declared as a scalar 32-bit floating-point value", "1.3-extensions"},
    {"VUID-IncomingRayFlagsKHR-IncomingRayFlagsKHR-04248", "The IncomingRayFlagsKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-IncomingRayFlagsKHR-IncomingRayFlagsKHR-04249", "The variable decorated with IncomingRayFlagsKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-IncomingRayFlagsKHR-IncomingRayFlagsKHR-04250", "The variable decorated with IncomingRayFlagsKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-InstanceCustomIndexKHR-InstanceCustomIndexKHR-04251", "The InstanceCustomIndexKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-InstanceCustomIndexKHR-InstanceCustomIndexKHR-04252", "The variable decorated with InstanceCustomIndexKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-InstanceCustomIndexKHR-InstanceCustomIndexKHR-04253", "The variable decorated with InstanceCustomIndexKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-InstanceId-InstanceId-04254", "The InstanceId decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-InstanceId-InstanceId-04255", "The variable decorated with InstanceId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-InstanceId-InstanceId-04256", "The variable decorated with InstanceId must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-InstanceIndex-InstanceIndex-04263", "The InstanceIndex decoration must be used only within the Vertex {ExecutionModel}", "1.3-extensions"},
    {"VUID-InstanceIndex-InstanceIndex-04264", "The variable decorated with InstanceIndex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-InstanceIndex-InstanceIndex-04265", "The variable decorated with InstanceIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-InvocationId-InvocationId-04257", "The InvocationId decoration must be used only within the TessellationControl or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-InvocationId-InvocationId-04258", "The variable decorated with InvocationId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-InvocationId-InvocationId-04259", "The variable decorated with InvocationId must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-InvocationsPerPixelNV-InvocationsPerPixelNV-04260", "The InvocationsPerPixelNV decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-InvocationsPerPixelNV-InvocationsPerPixelNV-04261", "The variable decorated with InvocationsPerPixelNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-InvocationsPerPixelNV-InvocationsPerPixelNV-04262", "The variable decorated with InvocationsPerPixelNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-LaunchIdKHR-LaunchIdKHR-04266", "The LaunchIdKHR decoration must be used only within the RayGenerationKHR, IntersectionKHR, AnyHitKHR, ClosestHitKHR, MissKHR, or CallableKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-LaunchIdKHR-LaunchIdKHR-04267", "The variable decorated with LaunchIdKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-LaunchIdKHR-LaunchIdKHR-04268", "The variable decorated with LaunchIdKHR must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-LaunchSizeKHR-LaunchSizeKHR-04269", "The LaunchSizeKHR decoration must be used only within the RayGenerationKHR, IntersectionKHR, AnyHitKHR, ClosestHitKHR, MissKHR, or CallableKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-LaunchSizeKHR-LaunchSizeKHR-04270", "The variable decorated with LaunchSizeKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-LaunchSizeKHR-LaunchSizeKHR-04271", "The variable decorated with LaunchSizeKHR must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-Layer-Layer-04272", "The Layer decoration must be used only within the MeshEXT, MeshNV, Vertex, TessellationEvaluation, Geometry, or Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-Layer-Layer-04273", "If the shaderOutputLayer feature is not enabled then the Layer decoration must be used only within the Geometry or Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-Layer-Layer-04274", "The variable decorated with Layer within the MeshEXT, MeshNV, Vertex, TessellationEvaluation, or Geometry {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-Layer-Layer-04275", "The variable decorated with Layer within the Fragment {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-Layer-Layer-04276", "The variable decorated with Layer must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-Layer-Layer-07039", "The variable decorated with Layer within the MeshEXT {ExecutionModel} must also be decorated with the PerPrimitiveEXT decoration", "1.3-extensions"},
    {"VUID-LayerPerViewNV-LayerPerViewNV-04277", "The LayerPerViewNV decoration must be used only within the MeshNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-LayerPerViewNV-LayerPerViewNV-04278", "The variable decorated with LayerPerViewNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-LayerPerViewNV-LayerPerViewNV-04279", "The variable decorated with LayerPerViewNV must also be decorated with the PerViewNV decoration", "1.3-extensions"},
    {"VUID-LayerPerViewNV-LayerPerViewNV-04280", "The variable decorated with LayerPerViewNV must be declared as an array of scalar 32-bit integer values", "1.3-extensions"},
    {"VUID-LocalInvocationId-LocalInvocationId-04281", "The LocalInvocationId decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-LocalInvocationId-LocalInvocationId-04282", "The variable decorated with LocalInvocationId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-LocalInvocationId-LocalInvocationId-04283", "The variable decorated with LocalInvocationId must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-LocalInvocationIndex-LocalInvocationIndex-04284", "The LocalInvocationIndex decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-LocalInvocationIndex-LocalInvocationIndex-04285", "The variable decorated with LocalInvocationIndex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-LocalInvocationIndex-LocalInvocationIndex-04286", "The variable decorated with LocalInvocationIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-MeshViewCountNV-MeshViewCountNV-04287", "The MeshViewCountNV decoration must be used only within the MeshNV or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-MeshViewCountNV-MeshViewCountNV-04288", "The variable decorated with MeshViewCountNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-MeshViewCountNV-MeshViewCountNV-04289", "The variable decorated with MeshViewCountNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-MeshViewIndicesNV-MeshViewIndicesNV-04290", "The MeshViewIndicesNV decoration must be used only within the MeshNV or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-MeshViewIndicesNV-MeshViewIndicesNV-04291", "The variable decorated with MeshViewIndicesNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-MeshViewIndicesNV-MeshViewIndicesNV-04292", "The variable decorated with MeshViewIndicesNV must be declared as an array of scalar 32-bit integer values", "1.3-extensions"},
    {"VUID-NumSubgroups-NumSubgroups-04293", "The NumSubgroups decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-NumSubgroups-NumSubgroups-04294", "The variable decorated with NumSubgroups must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-NumSubgroups-NumSubgroups-04295", "The variable decorated with NumSubgroups must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-NumWorkgroups-NumWorkgroups-04296", "The NumWorkgroups decoration must be used only within the GLCompute, MeshEXT, or TaskEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-NumWorkgroups-NumWorkgroups-04297", "The variable decorated with NumWorkgroups must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-NumWorkgroups-NumWorkgroups-04298", "The variable decorated with NumWorkgroups must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-ObjectRayDirectionKHR-ObjectRayDirectionKHR-04299", "The ObjectRayDirectionKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-ObjectRayDirectionKHR-ObjectRayDirectionKHR-04300", "The variable decorated with ObjectRayDirectionKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ObjectRayDirectionKHR-ObjectRayDirectionKHR-04301", "The variable decorated with ObjectRayDirectionKHR must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-ObjectRayOriginKHR-ObjectRayOriginKHR-04302", "The ObjectRayOriginKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-ObjectRayOriginKHR-ObjectRayOriginKHR-04303", "The variable decorated with ObjectRayOriginKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ObjectRayOriginKHR-ObjectRayOriginKHR-04304", "The variable decorated with ObjectRayOriginKHR must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-ObjectToWorldKHR-ObjectToWorldKHR-04305", "The ObjectToWorldKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-ObjectToWorldKHR-ObjectToWorldKHR-04306", "The variable decorated with ObjectToWorldKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ObjectToWorldKHR-ObjectToWorldKHR-04307", "The variable decorated with ObjectToWorldKHR must be declared as a matrix with four columns of three-component vectors of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-PFN_vkDebugUtilsMessengerCallbackEXT-None-04769", "The callback must not make calls to any Vulkan commands", "1.3-extensions"},
    {"VUID-PatchVertices-PatchVertices-04308", "The PatchVertices decoration must be used only within the TessellationControl or TessellationEvaluation {ExecutionModel}", "1.3-extensions"},
    {"VUID-PatchVertices-PatchVertices-04309", "The variable decorated with PatchVertices must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-PatchVertices-PatchVertices-04310", "The variable decorated with PatchVertices must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-PointCoord-PointCoord-04311", "The PointCoord decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-PointCoord-PointCoord-04312", "The variable decorated with PointCoord must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-PointCoord-PointCoord-04313", "The variable decorated with PointCoord must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-PointSize-PointSize-04314", "The PointSize decoration must be used only within the MeshEXT, MeshNV, Vertex, TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-PointSize-PointSize-04315", "The variable decorated with PointSize within the MeshEXT, MeshNV, or Vertex {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PointSize-PointSize-04316", "The variable decorated with PointSize within the TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel} must not be declared using a {StorageClass} other than Input or Output", "1.3-extensions"},
    {"VUID-PointSize-PointSize-04317", "The variable decorated with PointSize must be declared as a scalar 32-bit floating-point value", "1.3-extensions"},
    {"VUID-Position-Position-04318", "The Position decoration must be used only within the MeshEXT, MeshNV, Vertex, TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-Position-Position-04319", "The variable decorated with Position within the MeshEXT, MeshNV, or Vertex {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-Position-Position-04320", "The variable decorated with Position within the TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel} must not be declared using a {StorageClass} other than Input or Output", "1.3-extensions"},
    {"VUID-Position-Position-04321", "The variable decorated with Position must be declared as a four-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-PositionPerViewNV-PositionPerViewNV-04322", "The PositionPerViewNV decoration must be used only within the MeshNV, Vertex, TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-PositionPerViewNV-PositionPerViewNV-04323", "The variable decorated with PositionPerViewNV within the Vertex, or MeshNV {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PositionPerViewNV-PositionPerViewNV-04324", "The variable decorated with PositionPerViewNV within the TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel} must not be declared using a {StorageClass} other than Input or Output", "1.3-extensions"},
    {"VUID-PositionPerViewNV-PositionPerViewNV-04325", "The variable decorated with PositionPerViewNV must be declared as an array of four-component vector of 32-bit floating-point values with at least as many elements as the maximum view in the subpass's view mask plus one", "1.3-extensions"},
    {"VUID-PositionPerViewNV-PositionPerViewNV-04326", "The array variable decorated with PositionPerViewNV must only be indexed by a constant or specialization constant", "1.3-extensions"},
    {"VUID-PrimitiveCountNV-PrimitiveCountNV-04327", "The PrimitiveCountNV decoration must be used only within the MeshNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitiveCountNV-PrimitiveCountNV-04328", "The variable decorated with PrimitiveCountNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveCountNV-PrimitiveCountNV-04329", "The variable decorated with PrimitiveCountNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-PrimitiveId-Fragment-04331", "If pipeline contains both the Fragment and Geometry {ExecutionModel} and a variable decorated with PrimitiveId is read from Fragment shader, then the Geometry shader must write to the output variables decorated with PrimitiveId in all execution paths", "1.3-extensions"},
    {"VUID-PrimitiveId-Fragment-04332", "If pipeline contains both the Fragment and MeshEXT or MeshNV {ExecutionModel} and a variable decorated with PrimitiveId is read from Fragment shader, then the MeshEXT or MeshNV shader must write to the output variables decorated with PrimitiveId in all execution paths", "1.3-extensions"},
    {"VUID-PrimitiveId-Fragment-04333", "If Fragment {ExecutionModel} contains a variable decorated with PrimitiveId, then either the MeshShadingEXT, MeshShadingNV, Geometry or Tessellation capability must also be declared", "1.3-extensions"},
    {"VUID-PrimitiveId-PrimitiveId-04330", "The PrimitiveId decoration must be used only within the MeshEXT, MeshNV, IntersectionKHR, AnyHitKHR, ClosestHitKHR, TessellationControl, TessellationEvaluation, Geometry, or Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitiveId-PrimitiveId-04334", "The variable decorated with PrimitiveId within the TessellationControl, TessellationEvaluation, Fragment, IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveId-PrimitiveId-04335", "The variable decorated with PrimitiveId within the Geometry {ExecutionModel} must be declared using the Input or Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveId-PrimitiveId-04336", "The variable decorated with PrimitiveId within the MeshEXT or MeshNV {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveId-PrimitiveId-04337", "The variable decorated with PrimitiveId must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-PrimitiveId-PrimitiveId-07040", "The variable decorated with PrimitiveId within the MeshEXT {ExecutionModel} must also be decorated with the PerPrimitiveEXT decoration", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-OutputLinesNV-04343", "If the {ExecutionMode} is OutputLinesNV, then the array decorated with PrimitiveIndicesNV must be the size of two times the value specified by OutputPrimitivesNV", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-OutputPoints-04342", "If the {ExecutionMode} is OutputPoints, then the array decorated with PrimitiveIndicesNV must be the size of the value specified by OutputPrimitivesNV", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-OutputTrianglesNV-04344", "If the {ExecutionMode} is OutputTrianglesNV, then the array decorated with PrimitiveIndicesNV must be the size of three times the value specified by OutputPrimitivesNV", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-PrimitiveIndicesNV-04338", "The PrimitiveIndicesNV decoration must be used only within the MeshNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-PrimitiveIndicesNV-04339", "The variable decorated with PrimitiveIndicesNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-PrimitiveIndicesNV-04340", "The variable decorated with PrimitiveIndicesNV must be declared as an array of scalar 32-bit integer values", "1.3-extensions"},
    {"VUID-PrimitiveIndicesNV-PrimitiveIndicesNV-04341", "All index values of the array decorated with PrimitiveIndicesNV must be in the range [0, N-1], where N is the value specified by the OutputVertices {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07047", "The PrimitiveLineIndicesEXT decoration must be used only within the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07048", "The PrimitiveLineIndicesEXT decoration must be used only with the the OutputLinesEXT {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07049", "The variable decorated with PrimitiveLineIndicesEXT must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07050", "The variable decorated with PrimitiveLineIndicesEXT must be declared as an array of two component vector 32-bit integer values", "1.3-extensions"},
    {"VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07051", "All index values of the array decorated with PrimitiveLineIndicesEXT must be in the range [0, N-1], where N is the value specified by the OutputVertices {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitiveLineIndicesEXT-PrimitiveLineIndicesEXT-07052", "The size of the array decorated with PrimitiveLineIndicesEXT must match the value specified by OutputPrimitivesEXT", "1.3-extensions"},
    {"VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07041", "The PrimitivePointIndicesEXT decoration must be used only within the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07042", "The PrimitivePointIndicesEXT decoration must be used only with the the OutputPoints {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07043", "The variable decorated with PrimitivePointIndicesEXT must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07044", "The variable decorated with PrimitivePointIndicesEXT must be declared as an array of scalar 32-bit integer values", "1.3-extensions"},
    {"VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07045", "All index values of the array decorated with PrimitivePointIndicesEXT must be in the range [0, N-1], where N is the value specified by the OutputVertices {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitivePointIndicesEXT-PrimitivePointIndicesEXT-07046", "The size of the array decorated with PrimitivePointIndicesEXT must match the value specified by OutputPrimitivesEXT", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04484", "The PrimitiveShadingRateKHR decoration must be used only within the MeshEXT, MeshNV, Vertex, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04485", "The variable decorated with PrimitiveShadingRateKHR must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04486", "The variable decorated with PrimitiveShadingRateKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04487", "The value written to PrimitiveShadingRateKHR must include no more than one of Vertical2Pixels and Vertical4Pixels", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04488", "The value written to PrimitiveShadingRateKHR must include no more than one of Horizontal2Pixels and Horizontal4Pixels", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-04489", "The value written to PrimitiveShadingRateKHR must not have any bits set other than those defined by Fragment Shading Rate Flags enumerants in the SPIR-V specification", "1.3-extensions"},
    {"VUID-PrimitiveShadingRateKHR-PrimitiveShadingRateKHR-07059", "The variable decorated with PrimitiveShadingRateKHR within the MeshEXT {ExecutionModel} must also be decorated with the PerPrimitiveEXT decoration", "1.3-extensions"},
    {"VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07053", "The PrimitiveTriangleIndicesEXT decoration must be used only within the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07054", "The PrimitiveTriangleIndicesEXT decoration must be used only with the the OutputTrianglesEXT {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07055", "The variable decorated with PrimitiveTriangleIndicesEXT must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07056", "The variable decorated with PrimitiveTriangleIndicesEXT must be declared as an array of three component vector 32-bit integer values", "1.3-extensions"},
    {"VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07057", "All index values of the array decorated with PrimitiveTriangleIndicesEXT must be in the range [0, N-1], where N is the value specified by the OutputVertices {ExecutionMode}", "1.3-extensions"},
    {"VUID-PrimitiveTriangleIndicesEXT-PrimitiveTriangleIndicesEXT-07058", "The size of the array decorated with PrimitiveTriangleIndicesEXT must match the value specified by OutputPrimitivesEXT", "1.3-extensions"},
    {"VUID-RayGeometryIndexKHR-RayGeometryIndexKHR-04345", "The RayGeometryIndexKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-RayGeometryIndexKHR-RayGeometryIndexKHR-04346", "The variable decorated with RayGeometryIndexKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-RayGeometryIndexKHR-RayGeometryIndexKHR-04347", "The variable decorated with RayGeometryIndexKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-RayTmaxKHR-RayTmaxKHR-04348", "The RayTmaxKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-RayTmaxKHR-RayTmaxKHR-04349", "The variable decorated with RayTmaxKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-RayTmaxKHR-RayTmaxKHR-04350", "The variable decorated with RayTmaxKHR must be declared as a scalar 32-bit floating-point value", "1.3-extensions"},
    {"VUID-RayTminKHR-RayTminKHR-04351", "The RayTminKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-RayTminKHR-RayTminKHR-04352", "The variable decorated with RayTminKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-RayTminKHR-RayTminKHR-04353", "The variable decorated with RayTminKHR must be declared as a scalar 32-bit floating-point value", "1.3-extensions"},
    {"VUID-RuntimeSpirv-DescriptorSet-06323", "DescriptorSet and Binding decorations must obey the constraints on storage class, type, and descriptor type described in DescriptorSet and Binding Assignment", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Fragment-06427", "When blending is enabled and one of the dual source blend modes is in use, the maximum number of output attachments written to in the Fragment {ExecutionModel} must be less than or equal to maxFragmentDualSrcAttachments", "1.3-extensions"},
    {"VUID-RuntimeSpirv-LocalSizeId-06433", "The execution mode LocalSizeId must not be used", "1.2"},
    {"VUID-RuntimeSpirv-LocalSizeId-06434", "If execution mode LocalSizeId is used, maintenance4 must be enabled", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Location-06272", "The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching {ExecutionModel} defined in Shader Input and Output Locations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Location-06428", "The maximum number of storage buffers, storage images, and output Location decorated color attachments written to in the Fragment {ExecutionModel} must be less than or equal to maxFragmentCombinedOutputResources", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07115", "For mesh shaders using the MeshEXT {ExecutionModel} the OutputVertices OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshOutputVertices.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07116", "For mesh shaders using the MeshEXT {ExecutionModel} the OutputPrimitivesEXT OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshOutputPrimitives.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07118", "In mesh shaders using the MeshEXT {ExecutionModel} OpSetMeshOutputsEXT must be called at most once under dynamically uniform conditions", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07295", "For mesh shaders using the MeshEXT {ExecutionModel} the x size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupSize[0]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07296", "For mesh shaders using the MeshEXT {ExecutionModel} the y size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupSize[1]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07297", "For mesh shaders using the MeshEXT {ExecutionModel} the z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupSize[2]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07298", "For mesh shaders using the MeshEXT {ExecutionModel} the product of x size, y size, and z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupInvocations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07332", "For mesh shaders using the MeshEXT {ExecutionModel} the \"Vertex Count\" operand of OpSetMeshOutputsEXT must be less than or equal to OutputVertices OpExecutionMode", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshEXT-07333", "For mesh shaders using the MeshEXT {ExecutionModel} the \"Primitive Count\" operand of OpSetMeshOutputsEXT must be less than or equal to OutputPrimitivesEXT OpExecutionMode", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshNV-07113", "For mesh shaders using the MeshNV {ExecutionModel} the OutputVertices OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputVertices.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-MeshNV-07114", "For mesh shaders using the MeshNV {ExecutionModel} the OutputPrimitivesNV OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputPrimitives.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-NonUniform-06274", "If an instruction loads from or stores to a resource (including atomics and image instructions) and the resource descriptor being accessed is not dynamically uniform, then the operand corresponding to that resource (e.g. the pointer or sampled image operand) must be decorated with NonUniform.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-NonWritable-06340", "If fragmentStoresAndAtomics is not enabled, then all storage image, storage texel buffer, and storage buffer variables in the fragment stage must be decorated with the NonWritable decoration.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-NonWritable-06341", "If vertexPipelineStoresAndAtomics is not enabled, then all storage image, storage texel buffer, and storage buffer variables in the vertex, tessellation, and geometry stages must be decorated with the NonWritable decoration.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06275", "shaderSubgroupExtendedTypes must be enabled for group operations to use 8-bit integer, 16-bit integer, 64-bit integer, 16-bit floating-point, and vectors of these types", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06278", "shaderBufferInt64Atomics must be enabled for 64-bit integer atomic operations to be supported on a Pointer with a Storage Class of StorageBuffer or Uniform.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06279", "shaderSharedInt64Atomics must be enabled for 64-bit integer atomic operations to be supported on a Pointer with a Storage Class of Workgroup.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06280", "shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd must be enabled for floating-point atomic operations to be supported on a Pointer with a Storage Class of StorageBuffer.", "default"},
    {"VUID-RuntimeSpirv-None-06281", "shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd must be enabled for floating-point atomic operations to be supported on a Pointer with a Storage Class of Workgroup.", "default"},
    {"VUID-RuntimeSpirv-None-06282", "shaderImageFloat32Atomics or shaderImageFloat32AtomicAdd must be enabled for 32-bit floating-point atomic operations to be supported on a Pointer with a Storage Class of Image.", "default"},
    {"VUID-RuntimeSpirv-None-06283", "sparseImageFloat32Atomics or sparseImageFloat32AtomicAdd must be enabled for 32-bit floating-point atomics to be supported on sparse images.", "default"},
    {"VUID-RuntimeSpirv-None-06284", "shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderBufferFloat32AtomicMinMax, or shaderBufferFloat64AtomicMinMax must be enabled for floating-point atomic operations to be supported on a Pointer with a Storage Class of StorageBuffer.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06285", "shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderSharedFloat64AtomicMinMax must be enabled for floating-point atomic operations to be supported on a Pointer with a Storage Class of Workgroup.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06286", "shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations to be supported on a Pointer with a Storage Class of Image.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06287", "sparseImageFloat32Atomics, or sparseImageFloat32AtomicAdd, or sparseImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomics to be supported on sparse images.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06288", "shaderImageInt64Atomics must be enabled for 64-bit integer atomic operations to be supported on a Pointer with a Storage Class of Image.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06335", "shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd must be enabled for 32-bit floating point atomic operations", "default"},
    {"VUID-RuntimeSpirv-None-06336", "shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd must be enabled for 64-bit floating point atomic operations", "default"},
    {"VUID-RuntimeSpirv-None-06337", "shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax must be enabled for 16-bit floating point atomic operations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06338", "shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating point atomic operations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06339", "shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderBufferFloat64AtomicMinMax, or shaderSharedFloat64AtomicMinMax, must be enabled for 64-bit floating point atomic operations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06342", "If subgroupQuadOperationsInAllStages is VK_FALSE, then quad subgroup operations must not be used except for in fragment and compute stages.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-None-06343", "Group operations with subgroup scope must not be used if the shader stage is not in subgroupSupportedStages.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Offset-06308", "The Offset plus size of the type of each variable, in the output interface of the entry point being compiled, decorated with XfbBuffer must not be greater than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferDataSize", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Offset-06344", "The first element of the Offset operand of InterpolateAtOffset must be greater than or equal to:", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Offset-06345", "The first element of the Offset operand of InterpolateAtOffset must be less than or equal to:", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Offset-06346", "The second element of the Offset operand of InterpolateAtOffset must be greater than or equal to:", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Offset-06347", "The second element of the Offset operand of InterpolateAtOffset must be less than or equal to:", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpCooperativeMatrixLoadNV-06324", "For OpCooperativeMatrixLoadNV and OpCooperativeMatrixStoreNV instructions, the Pointer and Stride operands must be aligned to at least the lesser of 16 bytes or the natural alignment of a row or column (depending on ColumnMajor) of the matrix (where the natural alignment is the number of columns/rows multiplied by the component size).", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddNV-06317", "For OpCooperativeMatrixMulAddNV, the type of A must have VkCooperativeMatrixPropertiesNV::MSize rows and VkCooperativeMatrixPropertiesNV::KSize columns and have a component type that matches VkCooperativeMatrixPropertiesNV::AType.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddNV-06318", "For OpCooperativeMatrixMulAddNV, the type of B must have VkCooperativeMatrixPropertiesNV::KSize rows and VkCooperativeMatrixPropertiesNV::NSize columns and have a component type that matches VkCooperativeMatrixPropertiesNV::BType.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddNV-06319", "For OpCooperativeMatrixMulAddNV, the type of C must have VkCooperativeMatrixPropertiesNV::MSize rows and VkCooperativeMatrixPropertiesNV::NSize columns and have a component type that matches VkCooperativeMatrixPropertiesNV::CType.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddNV-06320", "For OpCooperativeMatrixMulAddNV, the type of Result must have VkCooperativeMatrixPropertiesNV::MSize rows and VkCooperativeMatrixPropertiesNV::NSize columns and have a component type that matches VkCooperativeMatrixPropertiesNV::DType.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddNV-06321", "For OpCooperativeMatrixMulAddNV, the type of A, B, C, and Result must all have a scope of scope.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpEmitStreamVertex-06310", "The Stream value to OpEmitStreamVertex and OpEndStreamPrimitive must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImage-06376", "If an OpImage*Gather operation has an image operand of Offset, ConstOffset, or ConstOffsets the offset value must be greater than or equal to minTexelGatherOffset", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImage-06377", "If an OpImage*Gather operation has an image operand of Offset, ConstOffset, or ConstOffsets the offset value must be less than or equal to maxTexelGatherOffset", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSADQCOM-06982", "If an OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM operation is used, then the target sampled image, reference sampled image, and Block Size parameters must both be dynamically uniform for the quad.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSSDQCOM-06983", "If an OpImageBlockMatchSSDQCOM or OpImageBlockMatchSADQCOM operation is used, then target sampled image and reference sampled image parameters must be of storage class UniformConstant and type OpTypeImage with Depth=0, Dim=2D, Arrayed=0, MS=0, and Sampled=1.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSSDQCOM-06984", "If an OpImageBlockMatchSSDQCOM or OpImageBlockMatchSADQCOM operation is used, then the target sampled image and reference sampled image parameters must be decorated with BlockMatchTextureQCOM.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSSDQCOM-06985", "If an OpImageBlockMatchSSDQCOM or OpImageBlockMatchSADQCOM operation is used, then target sampled image and reference sampled image parameters must have been created using an identical sampler object.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSSDQCOM-06986", "If an OpImageBlockMatchSSDQCOM or OpImageBlockMatchSADQCOM    operation is used, then target sampled image and    reference sampled image parameters must have been    created with sampler object with unnormalizeCordinates equal to VK_TRUE.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSSDQCOM-06987", "If an OpImageBlockMatchSSDQCOM or OpImageBlockMatchSADQCOM    operation is used, then target sampled image and    reference sampled image parameters must have been    created with sampler object with unnormalizeCordinates equal to VK_TRUE.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBlockMatchSSDQCOM-06988", "If an OpImageBlockMatchSSDQCOM or OpImageBlockMatchSADQCOM operation is used, then Block Size less than or equal to maxBlockMatchRegion.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBoxFilterQCOM-06989", "If an OpImageBoxFilterQCOM operation is used, then Box Size.y must be equal to or greater than 1.0 and less than or equal to maxBoxFilterBlockSize.height.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageBoxFilterQCOM-06990", "If an OpImageBoxFilterQCOM operation is used, then Sampled Texture Image and Box Size parameters must be dynamically uniform.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageSample-06435", "If an OpImageSample* or OpImageFetch* operation has an image operand of ConstOffset then the offset value must be greater than or equal to minTexelOffset", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageSample-06436", "If an OpImageSample* or OpImageFetch* operation has an image operand of ConstOffset then the offset value must be less than or equal to maxTexelOffset", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageWeightedSampleQCOM-06979", "If an OpImageWeightedSampleQCOM operation is used, then the Texture Sampled Image and Weight Image parameters must both be dynamically uniform for the quad.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageWeightedSampleQCOM-06980", "If an OpImageWeightedSampleQCOM operation is used, then the Weight Image parameter must be of storage class UniformConstant and type OpTypeImage with Depth=0, Dim=2D, Arrayed=1, MS=0, and Sampled=1.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageWeightedSampleQCOM-06981", "If an OpImageWeightedSampleQCOM operation is used, then the Weight Image parameter must be decorated with WeightTextureQCOM.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpImageWrite-07112", "OpImageWrite to any Image whose Image Format is not Unknown must have the Texel operand contain at least as many components as the corresponding VkFormat as given in the SPIR-V Image Format compatibility table", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryGenerateIntersectionKHR-06353", "For OpRayQueryGenerateIntersectionKHR instructions, Hit T must satisfy the condition RayTmin {leq} Hit T {leq} RayTmax, where RayTmin is equal to the value returned by OpRayQueryGetRayTMinKHR with the same ray query object, and RayTmax is equal to the value of OpRayQueryGetIntersectionTKHR for the current committed intersection with the same ray query object.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryGenerateIntersectionKHR-06354", "For OpRayQueryGenerateIntersectionKHR instructions, Acceleration Structure must not be built with VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in flags.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06348", "For OpRayQueryInitializeKHR instructions, all components of the RayOrigin and RayDirection operands must be finite floating-point values.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06349", "For OpRayQueryInitializeKHR instructions, the RayTmin and RayTmax operands must be non-negative floating-point values.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06350", "For OpRayQueryInitializeKHR instructions, the RayTmin operand must be less than or equal to the RayTmax operand.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06351", "For OpRayQueryInitializeKHR instructions, RayOrigin, RayDirection, RayTmin, and RayTmax operands must not contain NaNs.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06352", "For OpRayQueryInitializeKHR instructions, Acceleration Structure must be an acceleration structure built as a top-level acceleration structure.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06889", "For OpRayQueryInitializeKHR instructions, the Rayflags operand must not contain both SkipTrianglesKHR and SkipAABBsKHR", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06890", "For OpRayQueryInitializeKHR instructions, the Rayflags operand must not contain more than one of SkipTrianglesKHR, CullBackFacingTrianglesKHR, and CullFrontFacingTrianglesKHR", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpRayQueryInitializeKHR-06891", "For OpRayQueryInitializeKHR instructions, the Rayflags operand must not contain more than one of OpaqueKHR, NoOpaqueKHR, CullOpaqueKHR, and CullNoOpaqueKHR", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpReportIntersectionKHR-06998", "The value of the \"Hit Kind\" operand of OpReportIntersectionKHR must be in the range [0,127]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06355", "For OpTraceRayKHR instructions, all components of the RayOrigin and RayDirection operands must be finite floating-point values.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06356", "For OpTraceRayKHR instructions, the RayTmin and RayTmax operands must be non-negative floating-point values.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06357", "For OpTraceRayKHR instructions, the RayTmin operand must be less than or equal to the RayTmax operand.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06358", "For OpTraceRayKHR instructions, RayOrigin, RayDirection, RayTmin, and RayTmax operands must not contain NaNs.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06359", "For OpTraceRayKHR instructions, Acceleration Structure must be an acceleration structure built as a top-level acceleration structure.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06360", "For OpTraceRayKHR instructions, if Acceleration Structure was built with VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in flags, the pipeline must have been created with VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV set", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06552", "For OpTraceRayKHR instructions, the Rayflags operand must not contain both SkipTrianglesKHR and SkipAABBsKHR", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06553", "For OpTraceRayKHR instructions, if the Rayflags operand contains SkipTrianglesKHR, the pipeline must not have been created with VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR set", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06554", "For OpTraceRayKHR instructions, if the Rayflags operand contains SkipAABBsKHR, the pipeline must not have been created with VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR set", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06892", "For OpTraceRayKHR instructions, the Rayflags operand must not contain more than one of SkipTrianglesKHR, CullBackFacingTrianglesKHR, and CullFrontFacingTrianglesKHR", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayKHR-06893", "For OpTraceRayKHR instructions, the Rayflags operand must not contain more than one of OpaqueKHR, NoOpaqueKHR, CullOpaqueKHR, and CullNoOpaqueKHR", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06361", "For OpTraceRayMotionNV instructions, all components of the RayOrigin and RayDirection operands must be finite floating-point values.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06362", "For OpTraceRayMotionNV instructions, the RayTmin and RayTmax operands must be non-negative floating-point values.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06363", "For OpTraceRayMotionNV instructions, the RayTmin operand must be less than or equal to the RayTmax operand.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06364", "For OpTraceRayMotionNV instructions, RayOrigin, RayDirection, RayTmin, and RayTmax operands must not contain NaNs.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06365", "For OpTraceRayMotionNV instructions, Acceleration Structure must be an acceleration structure built as a top-level acceleration structure with VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV in flags", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06366", "For OpTraceRayMotionNV instructions the time operand must be between 0.0 and 1.0", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTraceRayMotionNV-06367", "For OpTraceRayMotionNV instructions the pipeline must have been created with VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV set", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTypeCooperativeMatrixNV-06316", "For OpTypeCooperativeMatrixNV, the component type, scope, number of rows, and number of columns must match one of the matrices in any of the supported VkCooperativeMatrixPropertiesNV.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTypeCooperativeMatrixNV-06322", "OpTypeCooperativeMatrixNV and OpCooperativeMatrix* instructions must not be used in shader stages not included in VkPhysicalDeviceCooperativeMatrixPropertiesNV::cooperativeMatrixSupportedStages.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-OpTypeImage-06269", "If shaderStorageImageWriteWithoutFormat is not enabled, any variable created with a \"Type\" of OpTypeImage that has a \"Sampled\" operand of 2 and an \"Image Format\" operand of Unknown must be decorated with NonWritable.", "1.2"},
    {"VUID-RuntimeSpirv-OpTypeImage-06270", "If shaderStorageImageReadWithoutFormat is not enabled, any variable created with a \"Type\" of OpTypeImage that has a \"Sampled\" operand of 2 and an \"Image Format\" operand of Unknown must be decorated with NonReadable.", "1.2"},
    {"VUID-RuntimeSpirv-OpTypeVector-06816", "Any OpTypeVector output interface variables must not have a higher Component Count than a matching OpTypeVector input interface variable", "1.2"},
    {"VUID-RuntimeSpirv-OpVariable-06373", "Any OpVariable with Workgroup as its Storage Class must not have an Initializer operand", "1.2"},
    {"VUID-RuntimeSpirv-PhysicalStorageBuffer64-06314", "If the PhysicalStorageBuffer64 addressing model is enabled any load or store through a physical pointer type must be aligned to a multiple of the size of the largest scalar type in the pointed-to type.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-PhysicalStorageBuffer64-06315", "If the PhysicalStorageBuffer64 addressing model is enabled the pointer value of a memory access instruction must be at least as aligned as specified by the Aligned memory access operand.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-SampleRateShading-06378", "If the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the SPIR-V fragment shader Capability SampleRateShading must not be enabled.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Stream-06312", "The stream number value to Stream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-RuntimeSpirv-SubgroupUniformControlFlowKHR-06379", "The execution mode SubgroupUniformControlFlowKHR must not be applied to an entry point unless shaderSubgroupUniformControlFlow is enabled and the corresponding shader stage bit is set in subgroup supportedStages and the entry point does not execute any invocation repack instructions.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07117", "In task shaders using the TaskEXT {ExecutionModel} OpEmitMeshTasksEXT must be called exactly once under dynamically uniform conditions", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07291", "In task shaders using the TaskEXT {ExecutionModel} the x size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupSize[0]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07292", "In task shaders using the TaskEXT {ExecutionModel} the y size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupSize[1]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07293", "In task shaders using the TaskEXT {ExecutionModel} the z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupSize[2]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07294", "In task shaders using the TaskEXT {ExecutionModel} the product of x size, y size, and z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupInvocations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07299", "In task shaders using the TaskEXT {ExecutionModel} the value of the \"Group Count X\" operand of OpEmitMeshTasksEXT must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07300", "In task shaders using the TaskEXT {ExecutionModel} the value of the \"Group Count Y\" operand of OpEmitMeshTasksEXT must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07301", "In task shaders using the TaskEXT {ExecutionModel} the value of the \"Group Count Z\" operand of OpEmitMeshTasksEXT must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-TaskEXT-07302", "In task shaders using the TaskEXT {ExecutionModel} the product of the \"Group Count\" operands of OpEmitMeshTasksEXT must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupTotalCount", "1.3-extensions"},
    {"VUID-RuntimeSpirv-Workgroup-06530", "The sum of size in bytes for variables and padding in the Workgroup storage class in the GLCompute {ExecutionModel} must be less than or equal to maxComputeSharedMemorySize", "1.3-extensions"},
    {"VUID-RuntimeSpirv-XfbBuffer-06309", "For any given XfbBuffer value, define the buffer data size to be smallest number of bytes such that, for all outputs decorated with the same XfbBuffer value, the size of the output interface variable plus the Offset is less than or equal to the buffer data size. For a given Stream, the sum of all the buffer data sizes for all buffers writing to that stream the must not exceed VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreamDataSize", "1.3-extensions"},
    {"VUID-RuntimeSpirv-XfbStride-06313", "The XFB Stride value to XfbStride must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferDataStride", "1.3-extensions"},
    {"VUID-RuntimeSpirv-denormBehaviorIndependence-06289", "If denormBehaviorIndependence is VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY, then the entry point must use the same denormals execution mode for both 16-bit and 64-bit floating-point types.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-denormBehaviorIndependence-06290", "If denormBehaviorIndependence is VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE, then the entry point must use the same denormals execution mode for all floating-point types.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-maintenance4-06817", "If maintenance4 is not enabled, any OpTypeVector output interface variables must not have a higher Component Count than a matching OpTypeVector input interface variable", "1.3-extensions"},
    {"VUID-RuntimeSpirv-roundingModeIndependence-06291", "If roundingModeIndependence is VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY, then the entry point must use the same rounding execution mode for both 16-bit and 64-bit floating-point types.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-roundingModeIndependence-06292", "If roundingModeIndependence is VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE, then the entry point must use the same rounding execution mode for all floating-point types.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat16-06299", "If shaderDenormFlushToZeroFloat16 is VK_FALSE, then DenormFlushToZero for 16-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat32-06300", "If shaderDenormFlushToZeroFloat32 is VK_FALSE, then DenormFlushToZero for 32-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat64-06301", "If shaderDenormFlushToZeroFloat64 is VK_FALSE, then DenormFlushToZero for 64-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDenormPreserveFloat16-06296", "If shaderDenormPreserveFloat16 is VK_FALSE, then DenormPreserve for 16-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDenormPreserveFloat32-06297", "If shaderDenormPreserveFloat32 is VK_FALSE, then DenormPreserve for 32-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDenormPreserveFloat64-06298", "If shaderDenormPreserveFloat64 is VK_FALSE, then DenormPreserve for 64-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderDeviceClock-06268", "If shaderDeviceClock is not enabled, the Device scope must not be used for OpReadClockKHR.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06767", "If shaderEarlyAndLateFragmentTests is not enabled, the EarlyAndLateFragmentTestsEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06768", "If shaderEarlyAndLateFragmentTests feature is not enabled, the StencilRefUnchangedFrontEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06769", "If shaderEarlyAndLateFragmentTests is not enabled, the StencilRefUnchangedBackEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06770", "If shaderEarlyAndLateFragmentTests is not enabled, the StencilRefGreaterFrontEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06771", "If shaderEarlyAndLateFragmentTests is not enabled, the StencilRefGreaterBackEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06772", "If shaderEarlyAndLateFragmentTests is not enabled, the StencilRefLessFrontEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderEarlyAndLateFragmentTests-06773", "If shaderEarlyAndLateFragmentTests is not enabled, the StencilRefLessBackEXT Execution Mode must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat16-06302", "If shaderRoundingModeRTEFloat16 is VK_FALSE, then RoundingModeRTE for 16-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat32-06303", "If shaderRoundingModeRTEFloat32 is VK_FALSE, then RoundingModeRTE for 32-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat64-06304", "If shaderRoundingModeRTEFloat64 is VK_FALSE, then RoundingModeRTE for 64-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat16-06305", "If shaderRoundingModeRTZFloat16 is VK_FALSE, then RoundingModeRTZ for 16-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat32-06306", "If shaderRoundingModeRTZFloat32 is VK_FALSE, then RoundingModeRTZ for 32-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat64-06307", "If shaderRoundingModeRTZFloat64 is VK_FALSE, then RoundingModeRTZ for 64-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderSampleRateInterpolationFunctions-06325", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::shaderSampleRateInterpolationFunctions is VK_FALSE, then GLSL.std.450 fragment interpolation functions are not supported by the implementation and OpCapability must not be set to InterpolationFunction.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-06293", "If shaderSignedZeroInfNanPreserveFloat16 is VK_FALSE, then SignedZeroInfNanPreserve for 16-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-06294", "If shaderSignedZeroInfNanPreserveFloat32 is VK_FALSE, then SignedZeroInfNanPreserve for 32-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-06295", "If shaderSignedZeroInfNanPreserveFloat64 is VK_FALSE, then SignedZeroInfNanPreserve for 64-bit floating-point type must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderSubgroupClock-06267", "If shaderSubgroupClock is not enabled, the Subgroup scope must not be used for OpReadClockKHR.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-shaderZeroInitializeWorkgroupMemory-06372", "If shaderZeroInitializeWorkgroupMemory is not enabled, any OpVariable with Workgroup as its Storage Class must not have an Initializer operand", "1.3-extensions"},
    {"VUID-RuntimeSpirv-storageBuffer16BitAccess-06331", "If storageBuffer16BitAccess is VK_FALSE, then objects containing 16-bit integer or 16-bit floating-point elements must not have storage class of StorageBuffer, ShaderRecordBufferKHR, or PhysicalStorageBuffer.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-storageBuffer8BitAccess-06328", "If storageBuffer8BitAccess is VK_FALSE, then objects containing an 8-bit integer element must not have storage class of StorageBuffer, ShaderRecordBufferKHR, or PhysicalStorageBuffer.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-storageInputOutput16-06334", "If storageInputOutput16 is VK_FALSE, then objects containing 16-bit integer or 16-bit floating-point elements must not have storage class of Input or Output.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-storagePushConstant16-06333", "If storagePushConstant16 is VK_FALSE, then objects containing 16-bit integer or 16-bit floating-point elements must not have storage class of PushConstant.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-storagePushConstant8-06330", "If storagePushConstant8 is VK_FALSE, then objects containing an 8-bit integer element must not have storage class of PushConstant.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-subgroupBroadcastDynamicId-06276", "If subgroupBroadcastDynamicId is VK_TRUE, and the shader module version is 1.5 or higher, the \"Index\" for OpGroupNonUniformQuadBroadcast must be dynamically uniform within the derivative group. Otherwise, \"Index\" must be a constant.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-subgroupBroadcastDynamicId-06277", "If subgroupBroadcastDynamicId is VK_TRUE, and the shader module version is 1.5 or higher, the \"Id\" for OpGroupNonUniformBroadcast must be dynamically uniform within the subgroup. Otherwise, \"Id\" must be a constant.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-tessellationShader-06326", "If tessellationShader is enabled, and the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::tessellationIsolines is VK_FALSE, then OpExecutionMode must not be set to IsoLines.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-tessellationShader-06327", "If tessellationShader is enabled, and the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::tessellationPointMode is VK_FALSE, then OpExecutionMode must not be set to PointMode.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-transformFeedbackStreamsLinesTriangles-06311", "If the geometry shader emits to more than one vertex stream and VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackStreamsLinesTriangles is VK_FALSE, then execution mode must be OutputPoints", "1.3-extensions"},
    {"VUID-RuntimeSpirv-uniformAndStorageBuffer16BitAccess-06332", "If uniformAndStorageBuffer16BitAccess is VK_FALSE, then objects in the Uniform storage class with the Block decoration must not have 16-bit integer or 16-bit floating-point members.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-uniformAndStorageBuffer8BitAccess-06329", "If uniformAndStorageBuffer8BitAccess is VK_FALSE, then objects in the Uniform storage class with the Block decoration must not have an 8-bit integer member.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-vulkanMemoryModel-06265", "If vulkanMemoryModel is enabled and vulkanMemoryModelDeviceScope is not enabled, Device memory scope must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-vulkanMemoryModel-06266", "If vulkanMemoryModel is not enabled, QueueFamily memory scope must not be used.", "1.3-extensions"},
    {"VUID-RuntimeSpirv-x-06429", "The x size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-x-06432", "The product of x size, y size, and z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupInvocations", "1.3-extensions"},
    {"VUID-RuntimeSpirv-y-06430", "The y size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]", "1.3-extensions"},
    {"VUID-RuntimeSpirv-z-06431", "The z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]", "1.3-extensions"},
    {"VUID-SMCountNV-SMCountNV-04363", "The variable decorated with SMCountNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SMCountNV-SMCountNV-04364", "The variable decorated with SMCountNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-SMIDNV-SMIDNV-04365", "The variable decorated with SMIDNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SMIDNV-SMIDNV-04366", "The variable decorated with SMIDNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-SampleId-SampleId-04354", "The SampleId decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-SampleId-SampleId-04355", "The variable decorated with SampleId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SampleId-SampleId-04356", "The variable decorated with SampleId must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-SampleMask-SampleMask-04357", "The SampleMask decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-SampleMask-SampleMask-04358", "The variable decorated with SampleMask must be declared using the Input or Output {StorageClass}", "1.3-extensions"},
    {"VUID-SampleMask-SampleMask-04359", "The variable decorated with SampleMask must be declared as an array of 32-bit integer values", "1.3-extensions"},
    {"VUID-SamplePosition-SamplePosition-04360", "The SamplePosition decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-SamplePosition-SamplePosition-04361", "The variable decorated with SamplePosition must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SamplePosition-SamplePosition-04362", "The variable decorated with SamplePosition must be declared as a two-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-ShadingRateKHR-ShadingRateKHR-04490", "The ShadingRateKHR decoration must be used only within the Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-ShadingRateKHR-ShadingRateKHR-04491", "The variable decorated with ShadingRateKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ShadingRateKHR-ShadingRateKHR-04492", "The variable decorated with ShadingRateKHR must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Base-04707", "The Base operand of OpPtrAccessChain must point to one of the following: Workgroup, if VariablePointers is enabled; StorageBuffer, if VariablePointers or VariablePointersStorageBuffer is enabled; PhysicalStorageBuffer, if the PhysicalStorageBuffer64 addressing model is enabled", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Base-04781", "The Base operand of any OpBitCount, OpBitReverse, OpBitFieldInsert, OpBitFieldSExtract, or OpBitFieldUExtract instruction must be a 32-bit integer scalar or a vector of 32-bit integers", "1.3-extensions"},
    {"VUID-StandaloneSpirv-BuiltIn-04668", "Any BuiltIn decoration not listed in Built-In Variables must not be used", "1.3-extensions"},
    {"VUID-StandaloneSpirv-CallableDataKHR-04704", "CallableDataKHR storage class must only be used in ray generation, closest hit, miss, and callable shaders", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Component-04920", "The Component decoration value must not be greater than 3", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Component-04921", "If the Component decoration is used on an OpVariable that has a OpTypeVector type with a Component Type with a Width that is less than or equal to 32, the sum of its Component Count and the Component decoration value must be less than 4", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Component-04922", "If the Component decoration is used on an OpVariable that has a OpTypeVector type with a Component Type with a Width that is equal to 64, the sum of two times its Component Count and the Component decoration value must be less than 4", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Component-04923", "The Component decorations value must not be 1 or 3 for scalar or two-component 64-bit data types", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Component-04924", "The Component decorations must not used with any type that is not a scalar or vector", "1.3-extensions"},
    {"VUID-StandaloneSpirv-DerivativeGroupLinearNV-04778", "For compute shaders using the DerivativeGroupLinearNV execution mode, the product of the dimensions of the local workgroup size must be a multiple of four", "1.3-extensions"},
    {"VUID-StandaloneSpirv-DerivativeGroupQuadsNV-04684", "For compute shaders using the DerivativeGroupQuadsNV execution mode, the first two dimensions of the local workgroup size must be a multiple of two", "1.3-extensions"},
    {"VUID-StandaloneSpirv-DescriptorSet-06491", "If a variable is decorated by DescriptorSet or Binding, the storage class must correspond to an entry in Shader Resource and Storage Class Correspondence", "1.3-extensions"},
    {"VUID-StandaloneSpirv-ExecutionModel-07320", "If the ExecutionModel is TessellationControl, and the MemoryModel is GLSL450, the Scope for memory must not be Workgroup", "1.3-extensions"},
    {"VUID-StandaloneSpirv-FPRoundingMode-04675", "Rounding modes other than round-to-nearest-even and round-towards-zero must not be used for the FPRoundingMode decoration", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Flat-04670", "The Flat, NoPerspective, Sample, and Centroid decorations must only be used on variables with the Output or Input storage class", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Flat-04744", "Any variable with integer or double-precision floating-point type and with Input storage class in a fragment shader, must be decorated Flat", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Flat-06201", "The Flat, NoPerspective, Sample, and Centroid decorations must not be used on variables with the Output storage class in a fragment shader", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Flat-06202", "The Flat, NoPerspective, Sample, and Centroid decorations must not be used on variables with the Input storage class in a vertex shader", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Function-04681", "A type T that is an array sized with a specialization constant must neither be, nor be contained in, the type T2 of a variable V, unless either: a) T is equal to T2, b) V is declared in the Function, or Private storage classes, c) V is a non-Block variable in the Workgroup storage class, or d) V is an interface variable with an additional level of arrayness, as described in interface matching, and T is the member type of the array type T2", "1.3-extensions"},
    {"VUID-StandaloneSpirv-GLSLShared-04669", "The GLSLShared and GLSLPacked decorations must not be used", "1.3-extensions"},
    {"VUID-StandaloneSpirv-HitAttributeKHR-04701", "HitAttributeKHR storage class must only be used in intersection, any-hit, or closest hit shaders", "1.3-extensions"},
    {"VUID-StandaloneSpirv-HitAttributeKHR-04702", "There must be at most one variable with the HitAttributeKHR storage class in the input interface of an entry point", "1.3-extensions"},
    {"VUID-StandaloneSpirv-HitAttributeKHR-04703", "A variable with HitAttributeKHR storage class must only be written to in an intersection shader", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Image-04965", "The converted bit width, signedness, and numeric type of the Image Format operand of an OpTypeImage must match the Sampled Type, as defined in Image Format and Type Matching", "1.3-extensions"},
    {"VUID-StandaloneSpirv-IncomingCallableDataKHR-04705", "IncomingCallableDataKHR storage class must only be used in callable shaders", "1.3-extensions"},
    {"VUID-StandaloneSpirv-IncomingCallableDataKHR-04706", "There must be at most one variable with the IncomingCallableDataKHR storage class in the input interface of an entry point", "1.3-extensions"},
    {"VUID-StandaloneSpirv-IncomingRayPayloadKHR-04699", "IncomingRayPayloadKHR storage class must only be used in closest hit, any-hit, or miss shaders", "1.3-extensions"},
    {"VUID-StandaloneSpirv-IncomingRayPayloadKHR-04700", "There must be at most one variable with the IncomingRayPayloadKHR storage class in the input interface of an entry point", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Input-06778", "Variables with a storage class of Input in a fragment shader stage that are decorated with PerVertexKHR must be declared as arrays", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Input-07290", "Variables with a storage class of Input or Output and a type of OpTypeBool must be decorated with the BuiltIn decoration", "1.3-extensions"},
    {"VUID-StandaloneSpirv-InputAttachmentIndex-06678", "Variables decorated with InputAttachmentIndex must be in the UniformConstant storage class", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Invariant-04677", "Variables decorated with Invariant and variables with structure types that have any members decorated with Invariant must be in the Output or Input storage class, Invariant used on an Input storage class variable or structure member has no effect", "1.3-extensions"},
    {"VUID-StandaloneSpirv-LocalSize-06426", "For each compute shader entry point, either a LocalSize or LocalSizeId execution mode, or an object decorated with the WorkgroupSize decoration must be specified", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Location-04915", "The Location or Component decorations must not be used with BuiltIn", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Location-04916", "The Location decorations must be used on user-defined variables", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Location-04917", "The Location decorations must be used on an OpVariable with a structure type that is not a block", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Location-04918", "The Location decorations must not be used on the members of OpVariable with a structure type that is decorated with Location", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Location-04919", "The Location decorations must be used on each member of OpVariable with a structure type that is a block not decorated with Location", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Location-06672", "The Location or Component decorations must only be used with the Input, Output, RayPayloadKHR, IncomingRayPayloadKHR, HitAttributeKHR, CallableDataKHR, IncomingCallableDataKHR, or ShaderRecordBufferKHR storage classes", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07102", "The module must not contain both an entry point that uses the TaskEXT or MeshEXT {ExecutionModel} and an entry point that uses the TaskNV or MeshNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07106", "In mesh shaders using the MeshEXT {ExecutionModel} OpSetMeshOutputsEXT must be called before any outputs are written", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07107", "In mesh shaders using the MeshEXT {ExecutionModel} all variables declared as output must not be read from", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07108", "In mesh shaders using the MeshEXT {ExecutionModel} for OpSetMeshOutputsEXT instructions, the \"Vertex Count\" and \"Primitive Count\" operands must not depend on ViewIndex", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07109", "In mesh shaders using the MeshEXT {ExecutionModel} variables decorated with PrimitivePointIndicesEXT, PrimitiveLineIndicesEXT, or PrimitiveTriangleIndicesEXT declared as an array must not be accessed by indices that depend on ViewIndex", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07110", "In mesh shaders using the MeshEXT {ExecutionModel} any values stored in variables decorated with PrimitivePointIndicesEXT, PrimitiveLineIndicesEXT, or PrimitiveTriangleIndicesEXT must not depend on ViewIndex", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07111", "In mesh shaders using the MeshEXT {ExecutionModel} variables in workgroup or private storage class declared as or containing a composite type must not be accessed by indices that depend on ViewIndex", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07330", "In mesh shaders using the MeshEXT {ExecutionModel} the OutputVertices OpExecutionMode must be greater than 0", "1.3-extensions"},
    {"VUID-StandaloneSpirv-MeshEXT-07331", "In mesh shaders using the MeshEXT {ExecutionModel} the OutputPrimitivesEXT OpExecutionMode must be greater than 0", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04633", "Every entry point must have no return value and accept no arguments", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04634", "The static function-call graph for an entry point must not contain cycles; that is, static recursion is not allowed", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04635", "The Logical or PhysicalStorageBuffer64 addressing model must be selected", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04636", "Scope for execution must be limited to Workgroup or Subgroup", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04637", "If the Scope for execution is Workgroup, then it must only be used in the task, mesh, tessellation control, or compute execution models", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04638", "Scope for memory must be limited to Device, QueueFamily, Workgroup, ShaderCallKHR, Subgroup, or Invocation", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04640", "If the Scope for memory is ShaderCallKHR, then it must only be used in ray generation, intersection, closest hit, any-hit, miss, and callable execution models", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04641", "If the Scope for memory is Invocation, then memory semantics must be None", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04642", "Scope for group operations must be limited to Subgroup", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04643", "Storage Class must be limited to UniformConstant, Input, Uniform, Output, Workgroup, Private, Function, PushConstant, Image, StorageBuffer, RayPayloadKHR, IncomingRayPayloadKHR, HitAttributeKHR, CallableDataKHR, IncomingCallableDataKHR, ShaderRecordBufferKHR, or PhysicalStorageBuffer", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04644", "If the Storage Class is Output, then it must not be used in the GlCompute, RayGenerationKHR, IntersectionKHR, AnyHitKHR, ClosestHitKHR, MissKHR, or CallableKHR execution models", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04645", "If the Storage Class is Workgroup, then it must only be used in the task, mesh, or compute execution models", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04667", "Structure types must not contain opaque types", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04686", "The Pointer operand of all atomic instructions must have a Storage Class limited to Uniform, Workgroup, Image, StorageBuffer, PhysicalStorageBuffer, or TaskPayloadWorkgroupEXT", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-04745", "All block members in a variable with a storage class of PushConstant declared as an array must only be accessed by dynamically uniform indices", "1.3-extensions"},
    {"VUID-StandaloneSpirv-None-07321", "If the Scope for memory is Workgroup, then it must only be used in the task, mesh, tessellation control, or compute execution models", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04662", "Any image operation must use at most one of the Offset, ConstOffset, and ConstOffsets image operands", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04663", "Image operand Offset must only be used with OpImage*Gather instructions", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04687", "Output variables or block members decorated with Offset that have a 64-bit type, or a composite type containing a 64-bit type, must specify an Offset value aligned to a 8 byte boundary", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04689", "The size of any output block containing any member decorated with Offset that is a 64-bit type must be a multiple of 8", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04690", "The first member of an output block specifying a Offset decoration must specify a Offset value that is aligned to an 8 byte boundary if that block contains any member decorated with Offset and is a 64-bit type", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04691", "Output variables or block members decorated with Offset that have a 32-bit type, or a composite type contains a 32-bit type, must specify an Offset value aligned to a 4 byte boundary", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04692", "Output variables, blocks or block members decorated with Offset must only contain base types that have components that are either 32-bit or 64-bit in size", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04716", "Only variables or block members in the output interface decorated with Offset can be captured for transform feedback, and those variables or block members must also be decorated with XfbBuffer and XfbStride, or inherit XfbBuffer and XfbStride decorations from a block containing them", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Offset-04865", "Any image instruction which uses an Offset, ConstOffset, or ConstOffsets image operand, must only consume a \"Sampled Image\" operand whose type has its \"Sampled\" operand set to 1", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpAtomicLoad-04731", "OpAtomicLoad must not use Release, AcquireRelease, or SequentiallyConsistent memory semantics", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpAtomicStore-04730", "OpAtomicStore must not use Acquire, AcquireRelease, or SequentiallyConsistent memory semantics", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpControlBarrier-04650", "If the semantics for OpControlBarrier includes one of Acquire, Release, AcquireRelease, or SequentiallyConsistent memory semantics, then it must include at least one storage class", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpControlBarrier-04682", "If OpControlBarrier is used in ray generation, intersection, any-hit, closest hit, miss, fragment, vertex, tessellation evaluation, or geometry shaders, the execution Scope must be Subgroup", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpEntryPoint-06674", "Each OpEntryPoint must not statically use more than one OpVariable in the PushConstant storage class", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpGroupNonUniformBallotBitCount-04685", "If OpGroupNonUniformBallotBitCount is used, the group operation must be limited to Reduce, InclusiveScan, or ExclusiveScan", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpImage-04777", "OpImage*Dref* instructions must not consume an image whose Dim is 3D", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpImageGather-04664", "The \"Component\" operand of OpImageGather, and OpImageSparseGather must be the <id> of a constant instruction", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpImageQuerySizeLod-04659", "OpImageQuerySizeLod, OpImageQueryLod, and OpImageQueryLevels must only consume an \"Image\" operand whose type has its \"Sampled\" operand set to 1", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpImageTexelPointer-04658", "If an OpImageTexelPointer is used in an atomic operation, the image type of the image parameter to OpImageTexelPointer must have an image format of R64i, R64ui, R32f, R32i, or R32ui", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpMemoryBarrier-04732", "OpMemoryBarrier must use one of Acquire, Release, AcquireRelease, or SequentiallyConsistent memory semantics", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpMemoryBarrier-04733", "OpMemoryBarrier must include at least one storage class", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpReadClockKHR-04652", "Scope for OpReadClockKHR must be limited to Subgroup or Device", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeForwardPointer-04711", "OpTypeForwardPointer must have a storage class of PhysicalStorageBuffer", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeImage-04656", "OpTypeImage must declare a scalar 32-bit float, 64-bit integer, or 32-bit integer type for the \"Sampled Type\" (RelaxedPrecision can be applied to a sampling instruction and to the variable holding the result of a sampling instruction)", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeImage-04657", "OpTypeImage must have a \"Sampled\" operand of 1 (sampled image) or 2 (storage image)", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeImage-06214", "An OpTypeImage with a \"Dim\" operand of SubpassData must have an \"Arrayed\" operand of 0 (non-arrayed) and a \"Sampled\" operand of 2 (storage image)", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeImage-06924", "Objects of types OpTypeImage, OpTypeSampler, OpTypeSampledImage, OpTypeAccelerationStructureKHR, and arrays of these types must not be stored to or modified", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeRuntimeArray-04680", "OpTypeRuntimeArray must only be used for the last member of a Block-decorated OpTypeStruct in StorageBuffer or PhysicalStorageBuffer storage classes; BufferBlock-decorated OpTypeStruct in Uniform storage class; the outermost dimension of an arrayed variable in the StorageBuffer, Uniform, or UniformConstant storage classes.", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpTypeSampledImage-06671", "OpTypeSampledImage must have a OpTypeImage with a \"Sampled\" operand of 1 (sampled image)", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpVariable-04651", "Any OpVariable with an Initializer operand must have Output, Private, Function, or Workgroup as its Storage Class operand", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpVariable-04734", "Any OpVariable with an Initializer operand and Workgroup as its Storage Class operand must use OpConstantNull as the initializer", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OpVariable-06673", "There must not be more than one OpVariable in the PushConstant storage class listed in the Interface for each OpEntryPoint", "1.3-extensions"},
    {"VUID-StandaloneSpirv-OriginLowerLeft-04653", "The OriginLowerLeft execution mode must not be used; fragment entry points must declare OriginUpperLeft", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PerVertexKHR-06777", "The PerVertexKHR decoration must only be used on variables with the Input storage class in a fragment shader", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PhysicalStorageBuffer64-04708", "If the PhysicalStorageBuffer64 addressing model is enabled, all instructions that support memory access operands and that use a physical pointer must include the Aligned operand", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PhysicalStorageBuffer64-04709", "If the PhysicalStorageBuffer64 addressing model is enabled, any access chain instruction that accesses into a RowMajor matrix must only be used as the Pointer operand to OpLoad or OpStore", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PhysicalStorageBuffer64-04710", "If the PhysicalStorageBuffer64 addressing model is enabled, OpConvertUToPtr and OpConvertPtrToU must use an integer type whose Width is 64", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PixelCenterInteger-04654", "The PixelCenterInteger execution mode must not be used (pixels are always centered at half-integer coordinates)", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PushConstant-06675", "Any variable in the PushConstant or StorageBuffer storage class must be decorated as Block", "1.3-extensions"},
    {"VUID-StandaloneSpirv-PushConstant-06808", "Any variable in the PushConstant storage class must be typed as OpTypeStruct", "1.3-extensions"},
    {"VUID-StandaloneSpirv-RayPayloadKHR-04698", "RayPayloadKHR storage class must only be used in ray generation, closest hit or miss shaders", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Result-04780", "The Result Type operand of any OpImageRead or OpImageSparseRead instruction must be a vector of four components", "1.3-extensions"},
    {"VUID-StandaloneSpirv-ShaderRecordBufferKHR-07119", "ShaderRecordBufferKHR storage class must only be used in ray generation, intersection, any-hit, closest hit, callable, or miss shaders", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Stream-04694", "If any variables or block members in the output interface of the entry point being compiled are decorated with Stream, then all variables belonging to the same XfbBuffer must specify the same Stream value", "1.3-extensions"},
    {"VUID-StandaloneSpirv-SubgroupVoteKHR-06997", "If the SubgroupVoteKHR or SubgroupBallotKHR capability is not declared, Scope for memory must not be Subgroup", "1.0-extensions"},
    {"VUID-StandaloneSpirv-SubpassData-04660", "The (u,v) coordinates used for a SubpassData must be the <id> of a constant vector (0,0), or if a layer coordinate is used, must be a vector that was formed with constant 0 for the u and v components", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Uniform-06676", "Any variable in the Uniform storage class must be decorated as Block or BufferBlock", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Uniform-06807", "Any variable in the Uniform or StorageBuffer storage class must be typed as OpTypeStruct or an array of this type", "1.3-extensions"},
    {"VUID-StandaloneSpirv-Uniform-06925", "Any variable in the Uniform storage class decorated as Block must not be stored to or modified", "1.3-extensions"},
    {"VUID-StandaloneSpirv-UniformConstant-04655", "Any variable in the UniformConstant storage class must be typed as either OpTypeImage, OpTypeSampler, OpTypeSampledImage, OpTypeAccelerationStructureKHR, or an array of one of these types", "1.3-extensions"},
    {"VUID-StandaloneSpirv-UniformConstant-06677", "Any variable in the UniformConstant, StorageBuffer, or Uniform storage class must be decorated with DescriptorSet and Binding", "1.3-extensions"},
    {"VUID-StandaloneSpirv-ViewportMaskNV-04674", "The ViewportMaskNV and ViewportIndex decorations must not both be statically used by one or more OpEntryPoint's that form the pre-rasterization shader stages of a graphics pipeline", "1.3-extensions"},
    {"VUID-StandaloneSpirv-ViewportRelativeNV-04672", "The ViewportRelativeNV decoration must only be used on a variable decorated with Layer in the vertex, tessellation evaluation, or geometry shader stages", "1.3-extensions"},
    {"VUID-StandaloneSpirv-ViewportRelativeNV-04673", "The ViewportRelativeNV decoration must not be used unless a variable decorated with one of ViewportIndex or ViewportMaskNV is also statically used by the same OpEntryPoint", "1.3-extensions"},
    {"VUID-StandaloneSpirv-VulkanMemoryModel-04678", " If the VulkanMemoryModel capability is not declared, the Volatile decoration must be used on any variable declaration that includes one of the SMIDNV, WarpIDNV, SubgroupSize, SubgroupLocalInvocationId, SubgroupEqMask, SubgroupGeMask, SubgroupGtMask, SubgroupLeMask, or SubgroupLtMask BuiltIn decorations when used in the ray generation, closest hit, miss, intersection, or callable shaders, or with the RayTmaxKHR Builtin decoration when used in an intersection shader", "1.3-extensions"},
    {"VUID-StandaloneSpirv-VulkanMemoryModel-04679", "If the VulkanMemoryModel capability is declared, the OpLoad instruction must use the Volatile memory semantics when it accesses into any variable that includes one of the SMIDNV, WarpIDNV, SubgroupSize, SubgroupLocalInvocationId, SubgroupEqMask, SubgroupGeMask, SubgroupGtMask, SubgroupLeMask, or SubgroupLtMask BuiltIn decorations when used in the ray generation, closest hit, miss, intersection, or callable shaders, or with the RayTmaxKHR Builtin decoration when used in an intersection shader", "1.3-extensions"},
    {"VUID-StandaloneSpirv-XfbBuffer-04693", "All variables or block members in the output interface of the entry point being compiled decorated with a specific XfbBuffer value must all be decorated with identical XfbStride values", "1.3-extensions"},
    {"VUID-StandaloneSpirv-XfbBuffer-04696", "For any two variables or block members in the output interface of the entry point being compiled with the same XfbBuffer value, the ranges determined by the Offset decoration and the size of the type must not overlap", "1.3-extensions"},
    {"VUID-StandaloneSpirv-XfbBuffer-04697", "All block members in the output interface of the entry point being compiled that are in the same block and have a declared or inherited XfbBuffer decoration must specify the same XfbBuffer value", "1.3-extensions"},
    {"VUID-SubgroupEqMask-SubgroupEqMask-04370", "The variable decorated with SubgroupEqMask must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupEqMask-SubgroupEqMask-04371", "The variable decorated with SubgroupEqMask must be declared as a four-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-SubgroupGeMask-SubgroupGeMask-04372", "The variable decorated with SubgroupGeMask must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupGeMask-SubgroupGeMask-04373", "The variable decorated with SubgroupGeMask must be declared as a four-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-SubgroupGtMask-SubgroupGtMask-04374", "The variable decorated with SubgroupGtMask must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupGtMask-SubgroupGtMask-04375", "The variable decorated with SubgroupGtMask must be declared as a four-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-SubgroupId-SubgroupId-04367", "The SubgroupId decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-SubgroupId-SubgroupId-04368", "The variable decorated with SubgroupId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupId-SubgroupId-04369", "The variable decorated with SubgroupId must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-SubgroupLeMask-SubgroupLeMask-04376", "The variable decorated with SubgroupLeMask must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupLeMask-SubgroupLeMask-04377", "The variable decorated with SubgroupLeMask must be declared as a four-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-SubgroupLocalInvocationId-SubgroupLocalInvocationId-04380", "The variable decorated with SubgroupLocalInvocationId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupLocalInvocationId-SubgroupLocalInvocationId-04381", "The variable decorated with SubgroupLocalInvocationId must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-SubgroupLtMask-SubgroupLtMask-04378", "The variable decorated with SubgroupLtMask must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupLtMask-SubgroupLtMask-04379", "The variable decorated with SubgroupLtMask must be declared as a four-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-SubgroupSize-SubgroupSize-04382", "The variable decorated with SubgroupSize must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-SubgroupSize-SubgroupSize-04383", "The variable decorated with SubgroupSize must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-TaskCountNV-TaskCountNV-04384", "The TaskCountNV decoration must be used only within the TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-TaskCountNV-TaskCountNV-04385", "The variable decorated with TaskCountNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-TaskCountNV-TaskCountNV-04386", "The variable decorated with TaskCountNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-TessCoord-TessCoord-04387", "The TessCoord decoration must be used only within the TessellationEvaluation {ExecutionModel}", "1.3-extensions"},
    {"VUID-TessCoord-TessCoord-04388", "The variable decorated with TessCoord must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-TessCoord-TessCoord-04389", "The variable decorated with TessCoord must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-TessLevelInner-TessLevelInner-04394", "The TessLevelInner decoration must be used only within the TessellationControl or TessellationEvaluation {ExecutionModel}", "1.3-extensions"},
    {"VUID-TessLevelInner-TessLevelInner-04395", "The variable decorated with TessLevelInner within the TessellationControl {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-TessLevelInner-TessLevelInner-04396", "The variable decorated with TessLevelInner within the TessellationEvaluation {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-TessLevelInner-TessLevelInner-04397", "The variable decorated with TessLevelInner must be declared as an array of size two, containing 32-bit floating-point values", "1.3-extensions"},
    {"VUID-TessLevelOuter-TessLevelOuter-04390", "The TessLevelOuter decoration must be used only within the TessellationControl or TessellationEvaluation {ExecutionModel}", "1.3-extensions"},
    {"VUID-TessLevelOuter-TessLevelOuter-04391", "The variable decorated with TessLevelOuter within the TessellationControl {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-TessLevelOuter-TessLevelOuter-04392", "The variable decorated with TessLevelOuter within the TessellationEvaluation {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-TessLevelOuter-TessLevelOuter-04393", "The variable decorated with TessLevelOuter must be declared as an array of size four, containing 32-bit floating-point values", "1.3-extensions"},
    {"VUID-VertexIndex-VertexIndex-04398", "The VertexIndex decoration must be used only within the Vertex {ExecutionModel}", "1.3-extensions"},
    {"VUID-VertexIndex-VertexIndex-04399", "The variable decorated with VertexIndex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-VertexIndex-VertexIndex-04400", "The variable decorated with VertexIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-ViewIndex-ViewIndex-04401", "The ViewIndex decoration must be used only within the MeshEXT, Vertex, Geometry, TessellationControl, TessellationEvaluation or Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-ViewIndex-ViewIndex-04402", "The variable decorated with ViewIndex must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ViewIndex-ViewIndex-04403", "The variable decorated with ViewIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-ViewportIndex-ViewportIndex-04404", "The ViewportIndex decoration must be used only within the MeshEXT, MeshNV, Vertex, TessellationEvaluation, Geometry, or Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-ViewportIndex-ViewportIndex-04405", "If the shaderOutputViewportIndex feature is not enabled then the ViewportIndex decoration must be used only within the Geometry or Fragment {ExecutionModel}", "1.3-extensions"},
    {"VUID-ViewportIndex-ViewportIndex-04406", "The variable decorated with ViewportIndex within the MeshEXT, MeshNV, Vertex, TessellationEvaluation, or Geometry {ExecutionModel} must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-ViewportIndex-ViewportIndex-04407", "The variable decorated with ViewportIndex within the Fragment {ExecutionModel} must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-ViewportIndex-ViewportIndex-04408", "The variable decorated with ViewportIndex must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-ViewportIndex-ViewportIndex-07060", "The variable decorated with ViewportIndex within the MeshEXT {ExecutionModel} must also be decorated with the PerPrimitiveEXT decoration", "1.3-extensions"},
    {"VUID-ViewportMaskNV-ViewportMaskNV-04409", "The ViewportMaskNV decoration must be used only within the Vertex, MeshNV, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-ViewportMaskNV-ViewportMaskNV-04410", "The variable decorated with ViewportMaskNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-ViewportMaskNV-ViewportMaskNV-04411", "The variable decorated with ViewportMaskNV must be declared as an array of 32-bit integer values", "1.3-extensions"},
    {"VUID-ViewportMaskPerViewNV-ViewportMaskPerViewNV-04412", "The ViewportMaskPerViewNV decoration must be used only within the Vertex, MeshNV, TessellationControl, TessellationEvaluation, or Geometry {ExecutionModel}", "1.3-extensions"},
    {"VUID-ViewportMaskPerViewNV-ViewportMaskPerViewNV-04413", "The variable decorated with ViewportMaskPerViewNV must be declared using the Output {StorageClass}", "1.3-extensions"},
    {"VUID-ViewportMaskPerViewNV-ViewportMaskPerViewNV-04414", "The variable decorated with ViewportMaskPerViewNV must be declared as an array of 32-bit integer values", "1.3-extensions"},
    {"VUID-ViewportMaskPerViewNV-ViewportMaskPerViewNV-04415", "The array decorated with ViewportMaskPerViewNV must be a size less than or equal to 32", "1.3-extensions"},
    {"VUID-ViewportMaskPerViewNV-ViewportMaskPerViewNV-04416", "The array decorated with ViewportMaskPerViewNV must be a size greater than the maximum view in the subpass's view mask", "1.3-extensions"},
    {"VUID-ViewportMaskPerViewNV-ViewportMaskPerViewNV-04417", "The array variable decorated with ViewportMaskPerViewNV must only be indexed by a constant or specialization constant", "1.3-extensions"},
    {"VUID-VkAabbPositionsKHR-minX-03546", "minX must be less than or equal to maxX", "1.3-extensions"},
    {"VUID-VkAabbPositionsKHR-minY-03547", "minY must be less than or equal to maxY", "1.3-extensions"},
    {"VUID-VkAabbPositionsKHR-minZ-03548", "minZ must be less than or equal to maxZ", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-commonparent", "Both of dstAccelerationStructure, and srcAccelerationStructure that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-dstAccelerationStructure-04927", "If dstAccelerationStructure was created with VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV set in VkAccelerationStructureCreateInfoKHR::flags, VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV must be set in flags", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-03796", "If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-04928", "If VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV is set in flags, dstAccelerationStructure must have been created with VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV set in VkAccelerationStructureCreateInfoKHR::flags", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-04929", "If VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV is set in flags, type must not be VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-07334", "If flags has the VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT bit set then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT bit set.", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-parameter", "flags must be a valid combination of VkBuildAccelerationStructureFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788", "Only one of pGeometries or ppGeometries can be a valid pointer, the other must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-parameter", "If geometryCount is not 0, and pGeometries is not NULL, pGeometries must be a valid pointer to an array of geometryCount valid VkAccelerationStructureGeometryKHR structures", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-ppGeometries-parameter", "If geometryCount is not 0, and ppGeometries is not NULL, ppGeometries must be a valid pointer to an array of geometryCount valid pointers to valid VkAccelerationStructureGeometryKHR structures", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03654", "type must not be VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03789", "If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, the geometryType member of elements of either pGeometries or ppGeometries must be VK_GEOMETRY_TYPE_INSTANCES_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03790", "If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, geometryCount must be 1", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03791", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR the geometryType member of elements of either pGeometries or ppGeometries must not be VK_GEOMETRY_TYPE_INSTANCES_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03792", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR then the geometryType member of each geometry in either pGeometries or ppGeometries must be the same", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03793", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR then geometryCount must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxGeometryCount", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03794", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR and the geometryType member of either pGeometries or ppGeometries is VK_GEOMETRY_TYPE_AABBS_KHR, the total number of AABBs in all geometries must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPrimitiveCount", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03795", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR and the geometryType member of either pGeometries or ppGeometries is VK_GEOMETRY_TYPE_TRIANGLES_KHR, the total number of triangles in all geometries must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPrimitiveCount", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-parameter", "type must be a valid VkAccelerationStructureTypeKHR value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03656", "For geometries of type VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the geometry uses indices, the offset primitiveOffset from VkAccelerationStructureGeometryTrianglesDataKHR::indexData must be a multiple of the element size of VkAccelerationStructureGeometryTrianglesDataKHR::indexType", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03657", "For geometries of type VK_GEOMETRY_TYPE_TRIANGLES_KHR, if the geometry does not use indices, the offset primitiveOffset from VkAccelerationStructureGeometryTrianglesDataKHR::vertexData must be a multiple of the component size of VkAccelerationStructureGeometryTrianglesDataKHR::vertexFormat", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03659", "For geometries of type VK_GEOMETRY_TYPE_AABBS_KHR, the offset primitiveOffset from VkAccelerationStructureGeometryAabbsDataKHR::data must be a multiple of 8", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildRangeInfoKHR-primitiveOffset-03660", "For geometries of type VK_GEOMETRY_TYPE_INSTANCES_KHR, the offset primitiveOffset from VkAccelerationStructureGeometryInstancesDataKHR::data must be a multiple of 16", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildRangeInfoKHR-transformOffset-03658", "For geometries of type VK_GEOMETRY_TYPE_TRIANGLES_KHR, the offset transformOffset from VkAccelerationStructureGeometryTrianglesDataKHR::transformData must be a multiple of 16", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildSizesInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureBuildSizesInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-buffer-03614", "buffer must have been created with a usage value containing VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-buffer-03615", "buffer must not have been created with VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-createFlags-03613", "If createFlags includes VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureCaptureReplay must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-createFlags-parameter", "createFlags must be a valid combination of VkAccelerationStructureCreateFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-03612", "If deviceAddress is not zero, createFlags must include VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-flags-04954", "If VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV is set in    flags and type is    VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, one member of the pNext chain must be a pointer to a valid instance of VkAccelerationStructureMotionInfoNV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-flags-04955", "If any geometry includes VkAccelerationStructureGeometryMotionTrianglesDataNV then flags must contain VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-offset-03616", "The sum of offset and size must be less than the size of buffer", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-offset-03734", "offset must be a multiple of 256 bytes", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkAccelerationStructureMotionInfoNV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoKHR-type-parameter", "type must be a valid VkAccelerationStructureTypeKHR value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoNV-compactedSize-02421", "If compactedSize is not 0 then both info.geometryCount and info.instanceCount must be 0", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoNV-info-parameter", "info must be a valid VkAccelerationStructureInfoNV structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureDeviceAddressInfoKHR-accelerationStructure-parameter", "accelerationStructure must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-VkAccelerationStructureDeviceAddressInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureDeviceAddressInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryAabbsDataKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryAabbsDataKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03545", "stride must be a multiple of 8", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03820", "stride must be less than or equal to 232-1", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryInstancesDataKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryInstancesDataKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-aabbs-parameter", "If geometryType is VK_GEOMETRY_TYPE_AABBS_KHR, the aabbs member of geometry must be a valid VkAccelerationStructureGeometryAabbsDataKHR structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-flags-parameter", "flags must be a valid combination of VkGeometryFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-geometryType-parameter", "geometryType must be a valid VkGeometryTypeKHR value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-instances-parameter", "If geometryType is VK_GEOMETRY_TYPE_INSTANCES_KHR, the instances member of geometry must be a valid VkAccelerationStructureGeometryInstancesDataKHR structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryKHR-triangles-parameter", "If geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, the triangles member of geometry must be a valid VkAccelerationStructureGeometryTrianglesDataKHR structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryMotionTrianglesDataNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-03798", "indexType must be VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-parameter", "indexType must be a valid VkIndexType value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAccelerationStructureGeometryMotionTrianglesDataNV or VkAccelerationStructureTrianglesOpacityMicromapEXT", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-03797", "vertexFormat must support the VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR in VkFormatProperties::bufferFeatures as returned by vkGetPhysicalDeviceFormatProperties2", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-parameter", "vertexFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03735", "vertexStride must be a multiple of the size in bytes of the smallest component of vertexFormat", "1.3-extensions"},
    {"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03819", "vertexStride must be less than or equal to 232-1", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-flags-02592", "If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-flags-parameter", "flags must be a valid combination of VkBuildAccelerationStructureFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-geometryCount-02422", "geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-instanceCount-02423", "instanceCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxInstanceCount", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-instanceData-02782", "If instanceData is not VK_NULL_HANDLE, instanceData must have been created with VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-maxTriangleCount-02424", "The total number of triangles in all geometries must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxTriangleCount", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-pGeometries-parameter", "If geometryCount is not 0, pGeometries must be a valid pointer to an array of geometryCount valid VkGeometryNV structures", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-scratch-02781", "scratch must have been created with VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-type-02425", "If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then geometryCount must be 0", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-type-02426", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then instanceCount must be 0", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-type-02786", "If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then the geometryType member of each geometry in pGeometries must be the same", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-type-04623", "type must not be VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInfoNV-type-parameter", "type must be a valid VkAccelerationStructureTypeNV value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureInstanceKHR-flags-parameter", "flags must be a valid combination of VkGeometryInstanceFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMatrixMotionInstanceNV-flags-parameter", "flags must be a valid combination of VkGeometryInstanceFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMemoryRequirementsInfoNV-accelerationStructure-parameter", "accelerationStructure must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMemoryRequirementsInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMemoryRequirementsInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMemoryRequirementsInfoNV-type-parameter", "type must be a valid VkAccelerationStructureMemoryRequirementsTypeNV value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInfoNV-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInstanceNV-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInstanceNV-matrixMotionInstance-parameter", "If type is VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV, the matrixMotionInstance member of data must be a valid VkAccelerationStructureMatrixMotionInstanceNV structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInstanceNV-srtMotionInstance-parameter", "If type is VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV, the srtMotionInstance member of data must be a valid VkAccelerationStructureSRTMotionInstanceNV structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInstanceNV-staticInstance-parameter", "If type is VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV, the staticInstance member of data must be a valid VkAccelerationStructureInstanceKHR structure", "1.3-extensions"},
    {"VUID-VkAccelerationStructureMotionInstanceNV-type-parameter", "type must be a valid VkAccelerationStructureMotionInstanceTypeNV value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureSRTMotionInstanceNV-flags-parameter", "flags must be a valid combination of VkGeometryInstanceFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-indexType-parameter", "indexType must be a valid VkIndexType value", "1.3-extensions"},
    {"VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-micromap-parameter", "micromap must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-pUsageCounts-07335", "Only one of pUsageCounts or ppUsageCounts can be a valid pointer, the other must be NULL.", "1.3-extensions"},
    {"VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-pUsageCounts-parameter", "If usageCountsCount is not 0, and pUsageCounts is not NULL, pUsageCounts must be a valid pointer to an array of usageCountsCount VkMicromapUsageEXT structures", "1.3-extensions"},
    {"VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-ppUsageCounts-parameter", "If usageCountsCount is not 0, and ppUsageCounts is not NULL, ppUsageCounts must be a valid pointer to an array of usageCountsCount valid pointers to VkMicromapUsageEXT structures", "1.3-extensions"},
    {"VUID-VkAccelerationStructureTrianglesOpacityMicromapEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT", "1.3-extensions"},
    {"VUID-VkAccelerationStructureVersionInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAccelerationStructureVersionInfoKHR-pVersionData-parameter", "pVersionData must be a valid pointer to an array of \\(2 \\times \\mathtt{VK\\_UUID\\_SIZE}\\) uint8_t values", "1.3-extensions"},
    {"VUID-VkAccelerationStructureVersionInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-commonparent", "Each of fence, semaphore, and swapchain that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-deviceMask-01290", "deviceMask must be a valid device mask", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-deviceMask-01291", "deviceMask must not be zero", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-fence-01289", "If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-fence-parameter", "If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-semaphore-01288", "If semaphore is not VK_NULL_HANDLE it must be unsignaled", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-semaphore-01781", "If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-semaphore-01782", "semaphore and fence must not both be equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-semaphore-03266", "semaphore must have a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-semaphore-parameter", "If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-swapchain-01675", "swapchain must not be in the retired state", "1.3-extensions"},
    {"VUID-VkAcquireNextImageInfoKHR-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-VkAcquireProfilingLockInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkAcquireProfilingLockInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAcquireProfilingLockInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAllocationCallbacks-pfnAllocation-00632", "pfnAllocation must be a valid pointer to a valid user-defined PFN_vkAllocationFunction", "1.3-extensions"},
    {"VUID-VkAllocationCallbacks-pfnFree-00634", "pfnFree must be a valid pointer to a valid user-defined PFN_vkFreeFunction", "1.3-extensions"},
    {"VUID-VkAllocationCallbacks-pfnInternalAllocation-00635", "If either of pfnInternalAllocation or pfnInternalFree is not NULL, both must be valid callbacks", "1.3-extensions"},
    {"VUID-VkAllocationCallbacks-pfnReallocation-00633", "pfnReallocation must be a valid pointer to a valid user-defined PFN_vkReallocationFunction", "1.3-extensions"},
    {"VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType", "sType must be VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC", "1.3-extensions"},
    {"VUID-VkAndroidHardwareBufferFormatProperties2ANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID", "1.3-extensions"},
    {"VUID-VkAndroidHardwareBufferFormatPropertiesANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID", "1.3-extensions"},
    {"VUID-VkAndroidHardwareBufferPropertiesANDROID-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAndroidHardwareBufferFormatProperties2ANDROID or VkAndroidHardwareBufferFormatPropertiesANDROID", "1.3-extensions"},
    {"VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID", "1.3-extensions"},
    {"VUID-VkAndroidHardwareBufferPropertiesANDROID-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkAndroidHardwareBufferUsageANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID", "1.3-extensions"},
    {"VUID-VkAndroidSurfaceCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkAndroidSurfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkAndroidSurfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkAndroidSurfaceCreateInfoKHR-window-01248", "window must point to a valid Android ANativeWindow", "1.3-extensions"},
    {"VUID-VkApplicationInfo-apiVersion-04010", "If apiVersion is not 0, then it must be greater than or equal to VK_API_VERSION_1_0", "1.3-extensions"},
    {"VUID-VkApplicationInfo-pApplicationName-parameter", "If pApplicationName is not NULL, pApplicationName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkApplicationInfo-pEngineName-parameter", "If pEngineName is not NULL, pEngineName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkApplicationInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkApplicationInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_APPLICATION_INFO", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-attachmentFeedbackLoopLayout-07309", "If the attachmentFeedbackLoopLayout feature is not enabled, initialLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-attachmentFeedbackLoopLayout-07310", "If the attachmentFeedbackLoopLayout feature is not enabled, finalLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-finalLayout-00843", "finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-finalLayout-parameter", "finalLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-flags-parameter", "flags must be a valid combination of VkAttachmentDescriptionFlagBits values", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03280", "If format is a color format, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03281", "If format is a depth/stencil format, initialLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03282", "If format is a color format, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03283", "If format is a depth/stencil format, finalLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03286", "If format is a color format, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03287", "If format is a color format, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03290", "If format is a depth/stencil format which includes only the depth aspect, initialLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03291", "If format is a depth/stencil format which includes only the depth aspect, finalLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03292", "If format is a depth/stencil format which includes only the stencil aspect, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-03293", "If format is a depth/stencil format which includes only the stencil aspect, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06242", "If format is a depth/stencil format which includes both depth and stencil aspects, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06243", "If format is a depth/stencil format which includes both depth and stencil aspects, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06487", "If format is a color format, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06488", "If format is a color format, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06698", "format must not be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06699", "If format includes a color or depth aspect and loadOp is VK_ATTACHMENT_LOAD_OP_LOAD, then initialLayout must not be VK_IMAGE_LAYOUT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06700", "If format includes a stencil aspect and stencilLoadOp is VK_ATTACHMENT_LOAD_OP_LOAD, then initialLayout must not be VK_IMAGE_LAYOUT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06906", "If format is a depth/stencil format which includes both depth and stencil aspects, initialLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-06907", "If format is a depth/stencil format which includes both depth and stencil aspects, finalLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-initialLayout-parameter", "initialLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-loadOp-parameter", "loadOp must be a valid VkAttachmentLoadOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-separateDepthStencilLayouts-03284", "If the separateDepthStencilLayouts feature is not enabled, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-separateDepthStencilLayouts-03285", "If the separateDepthStencilLayouts feature is not enabled, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-stencilLoadOp-parameter", "stencilLoadOp must be a valid VkAttachmentLoadOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-stencilStoreOp-parameter", "stencilStoreOp must be a valid VkAttachmentStoreOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-storeOp-parameter", "storeOp must be a valid VkAttachmentStoreOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-synchronization2-06908", "If the synchronization2 feature is not enabled, initialLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentDescription-synchronization2-06909", "If the synchronization2 feature is not enabled, finalLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-attachmentFeedbackLoopLayout-07309", "If the attachmentFeedbackLoopLayout feature is not enabled, initialLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-attachmentFeedbackLoopLayout-07310", "If the attachmentFeedbackLoopLayout feature is not enabled, finalLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-finalLayout-00843", "finalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-finalLayout-parameter", "finalLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-flags-parameter", "flags must be a valid combination of VkAttachmentDescriptionFlagBits values", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03280", "If format is a color format, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03281", "If format is a depth/stencil format, initialLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03282", "If format is a color format, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03283", "If format is a depth/stencil format, finalLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03286", "If format is a color format, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03287", "If format is a color format, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03290", "If format is a depth/stencil format which includes only the depth aspect, initialLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-03291", "If format is a depth/stencil format which includes only the depth aspect, finalLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06247", "If the pNext chain does not include a VkAttachmentDescriptionStencilLayout structure and format only includes a stencil aspect, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06248", "If the pNext chain does not include a VkAttachmentDescriptionStencilLayout structure and format only includes a stencil aspect, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06249", "If format is a depth/stencil format which includes both depth and stencil aspects, and initialLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, the pNext chain must include a VkAttachmentDescriptionStencilLayout structure", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06250", "If format is a depth/stencil format which includes both depth and stencil aspects, and finalLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, the pNext chain must include a VkAttachmentDescriptionStencilLayout structure", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06487", "If format is a color format, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06488", "If format is a color format, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06698", "format must not be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06699", "If format includes a color or depth aspect and loadOp is VK_ATTACHMENT_LOAD_OP_LOAD, then initialLayout must not be VK_IMAGE_LAYOUT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06703", "If format includes a stencil aspect and stencilLoadOp is VK_ATTACHMENT_LOAD_OP_LOAD, then initialLayout must not be VK_IMAGE_LAYOUT_UNDEFINED", "default"},
    {"VUID-VkAttachmentDescription2-format-06906", "If format is a depth/stencil format which includes both depth and stencil aspects, initialLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-06907", "If format is a depth/stencil format which includes both depth and stencil aspects, finalLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-initialLayout-parameter", "initialLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-loadOp-parameter", "loadOp must be a valid VkAttachmentLoadOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-pNext-06704", "If the pNext chain does not include a VkAttachmentDescriptionStencilLayout structure, format includes a stencil aspect, and stencilLoadOp is VK_ATTACHMENT_LOAD_OP_LOAD, then initialLayout must not be VK_IMAGE_LAYOUT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-pNext-06705", "If the pNext chain does includes a VkAttachmentDescriptionStencilLayout structure, format includes a stencil aspect, and stencilLoadOp is VK_ATTACHMENT_LOAD_OP_LOAD, then VkAttachmentDescriptionStencilLayout::stencilInitialLayout must not be VK_IMAGE_LAYOUT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkAttachmentDescriptionStencilLayout", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-sType-sType", "sType must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-separateDepthStencilLayouts-03284", "If the separateDepthStencilLayouts feature is not enabled, initialLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-separateDepthStencilLayouts-03285", "If the separateDepthStencilLayouts feature is not enabled, finalLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-stencilLoadOp-parameter", "stencilLoadOp must be a valid VkAttachmentLoadOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-stencilStoreOp-parameter", "stencilStoreOp must be a valid VkAttachmentStoreOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-storeOp-parameter", "storeOp must be a valid VkAttachmentStoreOp value", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-synchronization2-06908", "If the synchronization2 feature is not enabled, initialLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentDescription2-synchronization2-06909", "If the synchronization2 feature is not enabled, finalLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentDescriptionStencilLayout-sType-sType", "sType must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT", "1.3-extensions"},
    {"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-03309", "stencilFinalLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-03310", "stencilFinalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-parameter", "stencilFinalLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-03308", "stencilInitialLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-parameter", "stencilInitialLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentReference-attachmentFeedbackLoopLayout-07311", "If the attachmentFeedbackLoopLayout feature is not enabled, layout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkAttachmentReference-layout-03077", "If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PREINITIALIZED, or VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentReference-layout-parameter", "layout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentReference-separateDepthStencilLayouts-03313", "If the separateDepthStencilLayouts feature is not enabled, and attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,", "1.3-extensions"},
    {"VUID-VkAttachmentReference-synchronization2-06910", "If the synchronization2 feature is not enabled, layout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-attachmentFeedbackLoopLayout-07311", "If the attachmentFeedbackLoopLayout feature is not enabled, layout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-layout-03077", "If attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PREINITIALIZED, or VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-layout-parameter", "layout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkAttachmentReferenceStencilLayout", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-sType-sType", "sType must be VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-separateDepthStencilLayouts-03313", "If the separateDepthStencilLayouts feature is not enabled, and attachment is not VK_ATTACHMENT_UNUSED, layout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,", "1.3-extensions"},
    {"VUID-VkAttachmentReference2-synchronization2-06910", "If the synchronization2 feature is not enabled, layout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentReferenceStencilLayout-sType-sType", "sType must be VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT", "1.3-extensions"},
    {"VUID-VkAttachmentReferenceStencilLayout-stencilLayout-03318", "stencilLayout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PREINITIALIZED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", "1.3-extensions"},
    {"VUID-VkAttachmentReferenceStencilLayout-stencilLayout-parameter", "stencilLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkAttachmentSampleCountInfoAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD", "1.3-extensions"},
    {"VUID-VkAttachmentSampleLocationsEXT-attachmentIndex-01531", "attachmentIndex must be less than the attachmentCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with", "1.3-extensions"},
    {"VUID-VkAttachmentSampleLocationsEXT-sampleLocationsInfo-parameter", "sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-03620", "accelerationStructure must not already be backed by a memory object", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-parameter", "accelerationStructure must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-commonparent", "Both of accelerationStructure, and memory must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-memory-03622", "memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-03621", "memoryOffset must be less than the size of memory", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-03623", "memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-pDeviceIndices-parameter", "If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV", "1.3-extensions"},
    {"VUID-VkBindAccelerationStructureMemoryInfoNV-size-03624", "The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV must be less than or equal to the size of memory minus memoryOffset", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryDeviceGroupInfo-deviceIndexCount-01606", "deviceIndexCount must either be zero or equal to the number of physical devices in the logical device", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-01607", "All elements of pDeviceIndices must be valid device indices", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryDeviceGroupInfo-pDeviceIndices-parameter", "If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryDeviceGroupInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-None-01898", "If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit set, the buffer must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-None-01899", "If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit not set, the buffer must not be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-buffer-01030", "buffer must not have been created with any sparse memory binding flags", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-buffer-01038", "If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been allocated with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to a buffer handle created with identical creation parameters to buffer and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-buffer-01039", "If buffer was not created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image", "default"},
    {"VUID-VkBindBufferMemoryInfo-buffer-01444", "If buffer requires a dedicated allocation (as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been allocated with VkMemoryDedicatedAllocateInfo::buffer equal to buffer", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-buffer-06408", "If buffer was created with VkBufferCollectionBufferCreateInfoFUCHSIA chained to VkBufferCreateInfo::pNext, memory must be allocated with a VkImportMemoryBufferCollectionFUCHSIA chained to VkMemoryAllocateInfo::pNext", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-buffer-07459", "buffer must not have been bound to a memory object", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-bufferDeviceAddress-03339", "If the VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress feature is enabled and buffer was created with the VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT bit set, memory must have been allocated with the VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT bit set", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-commonparent", "Both of buffer, and memory must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-01035", "memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-01508", "If the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer, and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-02726", "If the value of VkExportMemoryAllocateInfo::handleTypes used to allocate memory is not 0, it must include at least one of the handles set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-02727", "If memory was allocated by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-khr-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-02985", "If memory was allocated by a memory import operation, that is not VkImportAndroidHardwareBufferInfoANDROID with a non-NULL buffer value, the external handle type of the imported memory must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-02986", "If memory was allocated with the VkImportAndroidHardwareBufferInfoANDROID memory import operation with a non-NULL buffer value, VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memoryOffset-01031", "memoryOffset must be less than the size of memory", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-memoryOffset-01036", "memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-pNext-01605", "If the pNext chain includes a VkBindBufferMemoryDeviceGroupInfo structure, all instances of memory specified by VkBindBufferMemoryDeviceGroupInfo::pDeviceIndices must have been allocated", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkBindBufferMemoryDeviceGroupInfo", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkBindBufferMemoryInfo-size-01037", "The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01633", "At least one of deviceIndexCount and splitInstanceBindRegionCount must be zero", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01634", "deviceIndexCount must either be zero or equal to the number of physical devices in the logical device", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-extent-01640", "The extent.width member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block width of all non-metadata aspects of the image, or else extent.width + offset.x must equal the width of the image subresource", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-extent-01641", "The extent.height member of any element of pSplitInstanceBindRegions must either be a multiple of the sparse image block height of all non-metadata aspects of the image, or else extent.height + offset.y must equal the height of the image subresource", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-offset-01638", "The offset.x member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of all non-metadata aspects of the image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-offset-01639", "The offset.y member of any element of pSplitInstanceBindRegions must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of all non-metadata aspects of the image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-01635", "All elements of pDeviceIndices must be valid device indices", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-pDeviceIndices-parameter", "If deviceIndexCount is not 0, pDeviceIndices must be a valid pointer to an array of deviceIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-01637", "Elements of pSplitInstanceBindRegions that correspond to the same instance of an image must not overlap", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-pSplitInstanceBindRegions-parameter", "If splitInstanceBindRegionCount is not 0, pSplitInstanceBindRegions must be a valid pointer to an array of splitInstanceBindRegionCount VkRect2D structures", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO", "1.3-extensions"},
    {"VUID-VkBindImageMemoryDeviceGroupInfo-splitInstanceBindRegionCount-01636", "splitInstanceBindRegionCount must either be zero or equal to the number of physical devices in the logical device squared", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-None-01901", "If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit set, the image must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-None-01902", "If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit not set, the image must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-commonparent", "Both of image, and memory that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-image-01045", "image must not have been created with any sparse memory binding flags", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-image-01050", "If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to an image handle created with identical creation parameters to image and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-image-01051", "If image was not created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image", "default"},
    {"VUID-VkBindImageMemoryInfo-image-01445", "If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-image-01630", "If image was created with a valid swapchain handle in VkImageSwapchainCreateInfoKHR::swapchain, then the pNext chain must include a VkBindImageMemorySwapchainInfoKHR structure containing the same swapchain handle", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-image-07460", "image must not have been bound to a memory object", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-01509", "If the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero", "1.3-khr-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-01612", "memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image", "default"},
    {"VUID-VkBindImageMemoryInfo-memory-01614", "The difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with the same image", "default"},
    {"VUID-VkBindImageMemoryInfo-memory-01625", "memory must be a valid VkDeviceMemory handle", "1.3"},
    {"VUID-VkBindImageMemoryInfo-memory-02628", "If the dedicatedAllocationImageAliasing feature is not enabled, and the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-02629", "If the dedicatedAllocationImageAliasing feature is enabled, and the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then memoryOffset must be zero, and image must be either equal to VkMemoryDedicatedAllocateInfo::image or an image that was created using the same parameters in VkImageCreateInfo, with the exception that extent and arrayLayers may differ subject to the following restrictions: every dimension in the extent parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created; and the arrayLayers parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-02728", "If the value of VkExportMemoryAllocateInfo::handleTypes used to allocate memory is not 0, it must include at least one of the handles set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-02729", "If memory was created by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-khr-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-02989", "If memory was created by a memory import operation, that is not VkImportAndroidHardwareBufferInfoANDROID with a non-NULL buffer value, the external handle type of the imported memory must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memory-02990", "If memory was created with the VkImportAndroidHardwareBufferInfoANDROID memory import operation with a non-NULL buffer value, VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memoryOffset-01046", "memoryOffset must be less than the size of memory", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-memoryOffset-01613", "memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image", "default"},
    {"VUID-VkBindImageMemoryInfo-pNext-01615", "If the pNext chain does not include a VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01616", "If the pNext chain does not include a VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01617", "If the pNext chain does not include a VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01618", "If the pNext chain includes a VkBindImagePlaneMemoryInfo structure, image must have been created with the VK_IMAGE_CREATE_DISJOINT_BIT bit set", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01619", "If the pNext chain includes a VkBindImagePlaneMemoryInfo structure, memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and where VkBindImagePlaneMemoryInfo::planeAspect corresponds to the VkImagePlaneMemoryRequirementsInfo::planeAspect in the VkImageMemoryRequirementsInfo2 structure's pNext chain", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01620", "If the pNext chain includes a VkBindImagePlaneMemoryInfo structure, memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with image and where VkBindImagePlaneMemoryInfo::planeAspect corresponds to the VkImagePlaneMemoryRequirementsInfo::planeAspect in the VkImageMemoryRequirementsInfo2 structure's pNext chain", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01621", "If the pNext chain includes a VkBindImagePlaneMemoryInfo structure, the difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements2 with the same image and where VkBindImagePlaneMemoryInfo::planeAspect corresponds to the VkImagePlaneMemoryRequirementsInfo::planeAspect in the VkImageMemoryRequirementsInfo2 structure's pNext chain", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01626", "If the pNext chain includes a VkBindImageMemoryDeviceGroupInfo structure, all instances of memory specified by VkBindImageMemoryDeviceGroupInfo::pDeviceIndices must have been allocated", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01627", "If the pNext chain includes a VkBindImageMemoryDeviceGroupInfo structure, and VkBindImageMemoryDeviceGroupInfo::splitInstanceBindRegionCount is not zero, then image must have been created with the VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01628", "If the pNext chain includes a VkBindImageMemoryDeviceGroupInfo structure, all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions must be valid rectangles contained within the dimensions of image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01629", "If the pNext chain includes a VkBindImageMemoryDeviceGroupInfo structure, the union of the areas of all elements of VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions that correspond to the same instance of image must cover the entire image", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01631", "If the pNext chain includes a VkBindImageMemorySwapchainInfoKHR structure, memory must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-01632", "If the pNext chain does not include a VkBindImageMemorySwapchainInfoKHR structure, memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBindImageMemoryDeviceGroupInfo, VkBindImageMemorySwapchainInfoKHR, or VkBindImagePlaneMemoryInfo", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO", "1.3-extensions"},
    {"VUID-VkBindImageMemoryInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkBindImageMemorySwapchainInfoKHR-imageIndex-01644", "imageIndex must be less than the number of images in swapchain", "1.3-extensions"},
    {"VUID-VkBindImageMemorySwapchainInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR", "1.3-extensions"},
    {"VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-VkBindImagePlaneMemoryInfo-planeAspect-02283", "If the image's tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image (that is, for a two-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT, and for a three-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT)", "1.3-extensions"},
    {"VUID-VkBindImagePlaneMemoryInfo-planeAspect-02284", "If the image's tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image (that is, aspectMask must specify a plane index that is less than the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with the image's format and VkImageDrmFormatModifierPropertiesEXT::drmFormatModifier)", "1.3-extensions"},
    {"VUID-VkBindImagePlaneMemoryInfo-planeAspect-parameter", "planeAspect must be a valid VkImageAspectFlagBits value", "1.3-extensions"},
    {"VUID-VkBindImagePlaneMemoryInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO", "1.3-extensions"},
    {"VUID-VkBindIndexBufferIndirectCommandNV-None-02946", "The buffer's usage flag from which the address was acquired must have the VK_BUFFER_USAGE_INDEX_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-VkBindIndexBufferIndirectCommandNV-None-02948", "Each element of the buffer from which the address was acquired and that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBindIndexBufferIndirectCommandNV-bufferAddress-02947", "The bufferAddress must be aligned to the indexType used", "1.3-extensions"},
    {"VUID-VkBindIndexBufferIndirectCommandNV-indexType-parameter", "indexType must be a valid VkIndexType value", "1.3-extensions"},
    {"VUID-VkBindShaderGroupIndirectCommandNV-None-02944", "The current bound graphics pipeline, as well as the pipelines it may reference, must have been created with VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV", "1.3-extensions"},
    {"VUID-VkBindShaderGroupIndirectCommandNV-index-02945", "The index must be within range of the accessible shader groups of the current bound graphics pipeline. See vkCmdBindPipelineShaderGroupNV for further details", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-commonparent", "Both of the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pBufferBinds-parameter", "If bufferBindCount is not 0, pBufferBinds must be a valid pointer to an array of bufferBindCount valid VkSparseBufferMemoryBindInfo structures", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pImageBinds-parameter", "If imageBindCount is not 0, pImageBinds must be a valid pointer to an array of imageBindCount valid VkSparseImageMemoryBindInfo structures", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter", "If imageOpaqueBindCount is not 0, pImageOpaqueBinds must be a valid pointer to an array of imageOpaqueBindCount valid VkSparseImageOpaqueMemoryBindInfo structures", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pNext-03247", "If the pNext chain of this structure includes a VkTimelineSemaphoreSubmitInfo structure and any element of pWaitSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE then its waitSemaphoreValueCount member must equal waitSemaphoreCount", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pNext-03248", "If the pNext chain of this structure includes a VkTimelineSemaphoreSubmitInfo structure and any element of pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE then its signalSemaphoreValueCount member must equal signalSemaphoreCount", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupBindSparseInfo or VkTimelineSemaphoreSubmitInfo", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pSignalSemaphores-03249", "For each element of pSignalSemaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE the corresponding element of VkTimelineSemaphoreSubmitInfo::pSignalSemaphoreValues must have a value greater than the current value of the semaphore when the semaphore signal operation is executed", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pSignalSemaphores-03251", "For each element of pSignalSemaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE the corresponding element of VkTimelineSemaphoreSubmitInfo::pSignalSemaphoreValues must have a value which does not differ from the current value of the semaphore or from the value of any outstanding semaphore wait or signal operation on that semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pSignalSemaphores-parameter", "If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pWaitSemaphores-03246", "If any element of pWaitSemaphores or pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE then the pNext chain must include a VkTimelineSemaphoreSubmitInfo structure", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pWaitSemaphores-03250", "For each element of pWaitSemaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE the corresponding element of VkTimelineSemaphoreSubmitInfo::pWaitSemaphoreValues must have a value which does not differ from the current value of the semaphore or from the value of any outstanding semaphore wait or signal operation on that semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-pWaitSemaphores-parameter", "If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO", "1.3-extensions"},
    {"VUID-VkBindSparseInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkBindVertexBufferIndirectCommandNV-None-02949", "The buffer's usage flag from which the address was acquired must have the VK_BUFFER_USAGE_VERTEX_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-VkBindVertexBufferIndirectCommandNV-None-02950", "Each element of the buffer from which the address was acquired and that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBindVideoSessionMemoryInfoKHR-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkBindVideoSessionMemoryInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBindVideoSessionMemoryInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-aspectMask-00241", "For each element of pRegions, srcSubresource.aspectMask must specify aspects present in srcImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-aspectMask-00242", "For each element of pRegions, dstSubresource.aspectMask must specify aspects present in dstImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-commonparent", "Both of dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-00224", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-00225", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-00234", "dstImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-00250", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffsets[0].y must be 0 and dstOffsets[1].y must be 1", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-00252", "If dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, dstOffsets[0].z must be 0 and dstOffsets[1].z must be 1", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-02000", "The format features of dstImage must contain VK_FORMAT_FEATURE_BLIT_DST_BIT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-02545", "dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-06422", "dstImage must not use a format that requires a sampler {YCbCr} conversion", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImageLayout-00226", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImageLayout-00227", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkBlitImageInfo2-dstImageLayout-01399", "dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstOffset-00248", "For each element of pRegions, dstOffsets[0].x and dstOffsets[1].x must both be greater than or equal to 0 and less than or equal to the width of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstOffset-00249", "For each element of pRegions, dstOffsets[0].y and dstOffsets[1].y must both be greater than or equal to 0 and less than or equal to the height of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstOffset-00251", "For each element of pRegions, dstOffsets[0].z and dstOffsets[1].z must both be greater than or equal to 0 and less than or equal to the depth of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstSubresource-01706", "The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-dstSubresource-01708", "The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-filter-00237", "If filter is VK_FILTER_CUBIC_EXT, srcImage must be of type VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-filter-02001", "If filter is VK_FILTER_LINEAR, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-filter-02002", "If filter is VK_FILTER_CUBIC_EXT, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-filter-parameter", "filter must be a valid VkFilter value", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-pRegions-00215", "The source region specified by each element of pRegions must be a region that is contained within srcImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-pRegions-00216", "The destination region specified by each element of pRegions must be a region that is contained within dstImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-pRegions-00217", "The union of all destination regions, specified by the elements of pRegions, must not overlap in memory with any texel that may be sampled during the blit operation", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-pRegions-04561", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then srcImage and dstImage must not be block-compressed images", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkImageBlit2 structures", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00219", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00220", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00229", "If either of srcImage or dstImage was created with a signed integer VkFormat, the other must also have been created with a signed integer VkFormat", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00230", "If either of srcImage or dstImage was created with an unsigned integer VkFormat, the other must also have been created with an unsigned integer VkFormat", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00231", "If either of srcImage or dstImage was created with a depth/stencil format, the other must have exactly the same format", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00232", "If srcImage was created with a depth/stencil format, filter must be VK_FILTER_NEAREST", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00233", "srcImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00240", "If either srcImage or dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer and dstSubresource.baseArrayLayer must each be 0, and srcSubresource.layerCount and dstSubresource.layerCount must each be 1", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00245", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffsets[0].y must be 0 and srcOffsets[1].y must be 1", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-00247", "If srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, srcOffsets[0].z must be 0 and srcOffsets[1].z must be 1", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-01999", "The format features of srcImage must contain VK_FORMAT_FEATURE_BLIT_SRC_BIT", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-06421", "srcImage must not use a format that requires a sampler {YCbCr} conversion", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImageLayout-00221", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImageLayout-00222", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkBlitImageInfo2-srcImageLayout-01398", "srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcOffset-00243", "For each element of pRegions, srcOffsets[0].x and srcOffsets[1].x must both be greater than or equal to 0 and less than or equal to the width of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcOffset-00244", "For each element of pRegions, srcOffsets[0].y and srcOffsets[1].y must both be greater than or equal to 0 and less than or equal to the height of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcOffset-00246", "For each element of pRegions, srcOffsets[0].z and srcOffsets[1].z must both be greater than or equal to 0 and less than or equal to the depth of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcSubresource-01705", "The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2-srcSubresource-01707", "The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2KHR-pRegions-06207", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then srcImage must be of type VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkBlitImageInfo2KHR-pRegions-06208", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then srcImage must not have a multi-planar format", "1.3-extensions"},
    {"VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-index-06388", "index must be less than VkBufferCollectionPropertiesFUCHSIA::bufferCount", "1.3-extensions"},
    {"VUID-VkBufferCollectionBufferCreateInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkBufferCollectionConstraintsInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferCollectionConstraintsInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkBufferCollectionCreateInfoFUCHSIA-collectionToken-06393", "collectionToken must be a valid zx_handle_t to a Zircon channel allocated from Sysmem (fuchsia.sysmem.Allocator/AllocateSharedCollection) with ZX_DEFAULT_CHANNEL_RIGHTS rights", "1.3-extensions"},
    {"VUID-VkBufferCollectionCreateInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferCollectionCreateInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkBufferCollectionImageCreateInfoFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-VkBufferCollectionImageCreateInfoFUCHSIA-index-06391", "index must be less than VkBufferCollectionPropertiesFUCHSIA::bufferCount", "1.3-extensions"},
    {"VUID-VkBufferCollectionImageCreateInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-formatFeatures-parameter", "formatFeatures must be a valid combination of VkFormatFeatureFlagBits values", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-formatFeatures-requiredbitmask", "formatFeatures must not be 0", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-samplerYcbcrConversionComponents-parameter", "samplerYcbcrConversionComponents must be a valid VkComponentMapping structure", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-suggestedXChromaOffset-parameter", "suggestedXChromaOffset must be a valid VkChromaLocation value", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-suggestedYChromaOffset-parameter", "suggestedYChromaOffset must be a valid VkChromaLocation value", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-suggestedYcbcrModel-parameter", "suggestedYcbcrModel must be a valid VkSamplerYcbcrModelConversion value", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-suggestedYcbcrRange-parameter", "suggestedYcbcrRange must be a valid VkSamplerYcbcrRange value", "1.3-extensions"},
    {"VUID-VkBufferCollectionPropertiesFUCHSIA-sysmemColorSpaceIndex-parameter", "sysmemColorSpaceIndex must be a valid VkSysmemColorSpaceFUCHSIA structure", "1.3-extensions"},
    {"VUID-VkBufferConstraintsInfoFUCHSIA-bufferCollectionConstraints-parameter", "bufferCollectionConstraints must be a valid VkBufferCollectionConstraintsInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-VkBufferConstraintsInfoFUCHSIA-createInfo-parameter", "createInfo must be a valid VkBufferCreateInfo structure", "1.3-extensions"},
    {"VUID-VkBufferConstraintsInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferConstraintsInfoFUCHSIA-requiredFormatFeatures-06404", "The requiredFormatFeatures bitmask of VkFormatFeatureFlagBits must be chosen from among the buffer compatible format features listed in buffer compatible format features", "1.3-extensions"},
    {"VUID-VkBufferConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter", "requiredFormatFeatures must be a valid combination of VkFormatFeatureFlagBits values", "1.3-extensions"},
    {"VUID-VkBufferConstraintsInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkBufferCopy-size-01988", "The size must be greater than 0", "1.3-extensions"},
    {"VUID-VkBufferCopy2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferCopy2-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_COPY_2", "1.3-extensions"},
    {"VUID-VkBufferCopy2-size-01988", "The size must be greater than 0", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-None-01888", "If any of the bits VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set, VK_BUFFER_CREATE_PROTECTED_BIT must not also be set", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-deviceAddress-02604", "If VkBufferDeviceAddressCreateInfoEXT::deviceAddress is not zero, flags must include VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-00915", "If the sparseBinding feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-00916", "If the sparseResidencyBuffer feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-00917", "If the sparseResidencyAliased feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-00918", "If flags contains VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-01887", "If the protectedMemory feature is not enabled, flags must not contain VK_BUFFER_CREATE_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-03338", "If flags includes VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, the bufferDeviceAddressCaptureReplay or bufferDeviceAddressCaptureReplayEXT feature must be enabled", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-flags-06549", "If flags includes VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, the bufferDeviceAddressCaptureReplay feature must be enabled", "1.3-khr-extensions"},
    {"VUID-VkBufferCreateInfo-flags-parameter", "flags must be a valid combination of VkBufferCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-opaqueCaptureAddress-03337", "If VkBufferOpaqueCaptureAddressCreateInfo::opaqueCaptureAddress is not zero, flags must include VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-pNext-00920", "If the pNext chain includes a VkExternalMemoryBufferCreateInfo structure, its handleTypes member must only contain bits that are also in VkExternalBufferProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalBufferProperties with pExternalBufferInfo->handleType equal to any one of the handle types specified in VkExternalMemoryBufferCreateInfo::handleTypes", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-pNext-01571", "If the pNext chain includes a VkDedicatedAllocationBufferCreateInfoNV structure, and the dedicatedAllocation member of the chained structure is VK_TRUE, then flags must not include VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBufferCollectionBufferCreateInfoFUCHSIA, VkBufferDeviceAddressCreateInfoEXT, VkBufferOpaqueCaptureAddressCreateInfo, VkDedicatedAllocationBufferCreateInfoNV, VkExternalMemoryBufferCreateInfo, or VkVideoProfileListInfoKHR", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-sharingMode-00913", "If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-sharingMode-00914", "If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-sharingMode-01391", "If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device", "1.0"},
    {"VUID-VkBufferCreateInfo-sharingMode-01419", "If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-sharingMode-parameter", "sharingMode must be a valid VkSharingMode value", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-size-00912", "size must be greater than 0", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-size-06409", "size must be less than or equal to VkPhysicalDeviceMaintenance4Properties::maxBufferSize", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-usage-04813", "If usage includes VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR, VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR, then the pNext chain must include a valid VkVideoProfileListInfoKHR structure with profileCount greater than 0 and pProfiles including at least one VkVideoProfileInfoKHR::videoCodecOperation specifying a decode operation", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-usage-04814", "If usage includes VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR, then the pNext chain must include a valid VkVideoProfileListInfoKHR structure with profileCount greater than 0 and pProfiles including at least one VkVideoProfileInfoKHR::videoCodecOperation specifying an encode operation", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-usage-parameter", "usage must be a valid combination of VkBufferUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkBufferCreateInfo-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkBufferDeviceAddressCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkBufferDeviceAddressInfo-buffer-02600", "If buffer is non-sparse and was not created with the VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT flag, then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBufferDeviceAddressInfo-buffer-02601", "buffer must have been created with VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT", "1.3-extensions"},
    {"VUID-VkBufferDeviceAddressInfo-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkBufferDeviceAddressInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferDeviceAddressInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-aspectMask-00212", "The aspectMask member of imageSubresource must only have a single bit set", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-bufferImageHeight-00196", "bufferImageHeight must be 0, or greater than or equal to the height member of imageExtent", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-bufferRowLength-00195", "bufferRowLength must be 0, or greater than or equal to the width member of imageExtent", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-imageExtent-06659", "imageExtent.width must not be 0", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-imageExtent-06660", "imageExtent.height must not be 0", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-imageExtent-06661", "imageExtent.depth must not be 0", "1.3-extensions"},
    {"VUID-VkBufferImageCopy-imageSubresource-parameter", "imageSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-aspectMask-00212", "The aspectMask member of imageSubresource must only have a single bit set", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-bufferImageHeight-00196", "bufferImageHeight must be 0, or greater than or equal to the height member of imageExtent", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-bufferRowLength-00195", "bufferRowLength must be 0, or greater than or equal to the width member of imageExtent", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-imageExtent-06659", "imageExtent.width must not be 0", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-imageExtent-06660", "imageExtent.height must not be 0", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-imageExtent-06661", "imageExtent.depth must not be 0", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-imageSubresource-parameter", "imageSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkCopyCommandTransformInfoQCOM", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2", "1.3-extensions"},
    {"VUID-VkBufferImageCopy2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-buffer-01931", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-buffer-04086", "If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must be valid queue families", "1.0"},
    {"VUID-VkBufferMemoryBarrier-buffer-04088", "If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is one of the special queue family values reserved for external memory transfers, the other must be VK_QUEUE_FAMILY_IGNORED", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-buffer-04089", "If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-offset-01187", "offset must be less than the size of buffer", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-size-01188", "If size is not equal to VK_WHOLE_SIZE, size must be greater than 0", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-size-01189", "If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to than the size of buffer minus offset", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-srcQueueFamilyIndex-04087", "If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, at least one must not be a special queue family reserved for external memory ownership transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier-synchronization2-03852", "If the synchronization2 feature is not enabled, and buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex must both be VK_QUEUE_FAMILY_IGNORED", "1.0"},
    {"VUID-VkBufferMemoryBarrier-synchronization2-03853", "If the synchronization2 feature is not enabled, and buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-buffer-01931", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-buffer-04086", "If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must be valid queue families", "default"},
    {"VUID-VkBufferMemoryBarrier2-buffer-04088", "If buffer was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is one of the special queue family values reserved for external memory transfers, the other must be VK_QUEUE_FAMILY_IGNORED", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-buffer-04089", "If buffer was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03900", "If pname:dstAccessMask includes VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03901", "If pname:dstAccessMask includes VK_ACCESS_2_INDEX_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03902", "If pname:dstAccessMask includes VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03903", "If pname:dstAccessMask includes VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03904", "If pname:dstAccessMask includes VK_ACCESS_2_UNIFORM_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03905", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_SAMPLED_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03906", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_STORAGE_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03907", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03908", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-khr-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03909", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03910", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03911", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03912", "If pname:dstAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03913", "If pname:dstAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03914", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03915", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFER_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_CLEAR_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03916", "If pname:dstAccessMask includes VK_ACCESS_2_HOST_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03917", "If pname:dstAccessMask includes VK_ACCESS_2_HOST_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03918", "If pname:dstAccessMask includes VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03919", "If pname:dstAccessMask includes VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03920", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03922", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03923", "If pname:dstAccessMask includes VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03924", "If pname:dstAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03925", "If pname:dstAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03926", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03927", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-03928", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-04747", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-04858", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-04859", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-04860", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-04861", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-04994", "If pname:dstAccessMask includes VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI, pname:dstStageMask must include VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-06254", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "default"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-06255", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-06256", "If the rayQuery feature is not enabled and pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-06257", "If the rayQuery feature is not enabled and pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-07272", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT or VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-07454", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-07455", "If pname:dstAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-07456", "If pname:dstAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-07457", "If pname:dstAccessMask includes VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-07458", "If pname:dstAccessMask includes VK_ACCESS_2_MICROMAP_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstAccessMask-parameter", "dstAccessMask must be a valid combination of VkAccessFlagBits2 values", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03929", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03930", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03931", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03933", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03934", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-03935", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-04956", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-04957", "If the subpassShading feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-04995", "If the invocationMask feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkBufferMemoryBarrier2-offset-01187", "offset must be less than the size of buffer", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-size-01188", "If size is not equal to VK_WHOLE_SIZE, size must be greater than 0", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-size-01189", "If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to than the size of buffer minus offset", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03900", "If pname:srcAccessMask includes VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03901", "If pname:srcAccessMask includes VK_ACCESS_2_INDEX_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03902", "If pname:srcAccessMask includes VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03903", "If pname:srcAccessMask includes VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03904", "If pname:srcAccessMask includes VK_ACCESS_2_UNIFORM_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03905", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_SAMPLED_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03906", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_STORAGE_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03907", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03908", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-khr-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03909", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03910", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03911", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03912", "If pname:srcAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03913", "If pname:srcAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03914", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03915", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFER_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_CLEAR_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03916", "If pname:srcAccessMask includes VK_ACCESS_2_HOST_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03917", "If pname:srcAccessMask includes VK_ACCESS_2_HOST_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03918", "If pname:srcAccessMask includes VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03919", "If pname:srcAccessMask includes VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03920", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03922", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03923", "If pname:srcAccessMask includes VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03924", "If pname:srcAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03925", "If pname:srcAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03926", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03927", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-03928", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-04747", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-04858", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-04859", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-04860", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-04861", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-04994", "If pname:srcAccessMask includes VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI, pname:srcStageMask must include VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-06254", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "default"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-06255", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-06256", "If the rayQuery feature is not enabled and pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-06257", "If the rayQuery feature is not enabled and pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-07272", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT or VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-07454", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-07455", "If pname:srcAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-07456", "If pname:srcAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-07457", "If pname:srcAccessMask includes VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-07458", "If pname:srcAccessMask includes VK_ACCESS_2_MICROMAP_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcAccessMask-parameter", "srcAccessMask must be a valid combination of VkAccessFlagBits2 values", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcQueueFamilyIndex-04087", "If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, at least one must not be a special queue family reserved for external memory ownership transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03851", "If either srcStageMask or dstStageMask includes VK_PIPELINE_STAGE_2_HOST_BIT, srcQueueFamilyIndex and dstQueueFamilyIndex must be equal", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03929", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03930", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03931", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03933", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03934", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-03935", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-04956", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-04957", "If the subpassShading feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-04995", "If the invocationMask feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkBufferMemoryBarrier2-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkBufferMemoryRequirementsInfo2-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkBufferMemoryRequirementsInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkBufferMemoryRequirementsInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2", "1.3-extensions"},
    {"VUID-VkBufferOpaqueCaptureAddressCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-00932", "buffer must have been created with a usage value containing at least one of VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT or VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-00933", "If buffer was created with usage containing VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, format must be supported for uniform texel buffers, as specified by the VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-00934", "If buffer was created with usage containing VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, format must be supported for storage texel buffers, as specified by the VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-00935", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-02750", "If the texelBufferAlignment feature is enabled and if buffer was created with usage containing VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, offset must be a multiple of the lesser of VkPhysicalDeviceTexelBufferAlignmentProperties::storageTexelBufferOffsetAlignmentBytes or, if VkPhysicalDeviceTexelBufferAlignmentProperties::storageTexelBufferOffsetSingleTexelAlignment is VK_TRUE, the size of a texel of the requested format. If the size of a texel is a multiple of three bytes, then the size of a single component of format is used instead", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-02751", "If the texelBufferAlignment feature is enabled and if buffer was created with usage containing VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, offset must be a multiple of the lesser of VkPhysicalDeviceTexelBufferAlignmentProperties::uniformTexelBufferOffsetAlignmentBytes or, if VkPhysicalDeviceTexelBufferAlignmentProperties::uniformTexelBufferOffsetSingleTexelAlignment is VK_TRUE, the size of a texel of the requested format. If the size of a texel is a multiple of three bytes, then the size of a single component of format is used instead", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-offset-00925", "offset must be less than the size of buffer", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-offset-00926", "offset must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment", "1.2-khr-extensions"},
    {"VUID-VkBufferViewCreateInfo-offset-00931", "If range is not equal to VK_WHOLE_SIZE, the sum of offset and range must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-offset-02749", "If the texelBufferAlignment feature is not enabled, offset must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-pNext-06782", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-range-00928", "If range is not equal to VK_WHOLE_SIZE, range must be greater than 0", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-range-00929", "If range is not equal to VK_WHOLE_SIZE, range must be an integer multiple of the texel block size of format", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-range-00930", "If range is not equal to VK_WHOLE_SIZE, the number of texel buffer elements given by ({lfloor}range / (texel block size){rfloor} {times} (texels per block)) where texel block size and texels per block are as defined in the Compatible Formats table for format, must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-range-04059", "If range is equal to VK_WHOLE_SIZE, the number of texel buffer elements given by ({lfloor}(size - offset) / (texel block size){rfloor} {times} (texels per block)) where size is the size of buffer, and texel block size and texels per block are as defined in the Compatible Formats table for format, must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkBufferViewCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkCalibratedTimestampInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCalibratedTimestampInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT", "1.3-extensions"},
    {"VUID-VkCalibratedTimestampInfoEXT-timeDomain-02354", "timeDomain must be one of the VkTimeDomainEXT values returned by vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", "1.3-extensions"},
    {"VUID-VkCalibratedTimestampInfoEXT-timeDomain-parameter", "timeDomain must be a valid VkTimeDomainEXT value", "1.3-extensions"},
    {"VUID-VkCheckpointData2NV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCheckpointData2NV-sType-sType", "sType must be VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV", "1.3-extensions"},
    {"VUID-VkCheckpointDataNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCheckpointDataNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV", "1.3-extensions"},
    {"VUID-VkClearAttachment-aspectMask-00019", "If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, it must not include VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkClearAttachment-aspectMask-00020", "aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT", "1.3-extensions"},
    {"VUID-VkClearAttachment-aspectMask-02246", "aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT for any index i", "1.3-extensions"},
    {"VUID-VkClearAttachment-aspectMask-parameter", "aspectMask must be a valid combination of VkImageAspectFlagBits values", "1.3-extensions"},
    {"VUID-VkClearAttachment-aspectMask-requiredbitmask", "aspectMask must not be 0", "1.3-extensions"},
    {"VUID-VkClearAttachment-clearValue-00021", "clearValue must be a valid VkClearValue union", "1.3-extensions"},
    {"VUID-VkClearDepthStencilValue-depth-00022", "Unless the VK_EXT_depth_range_unrestricted extension is enabled depth must be between 0.0 and 1.0, inclusive", "1.3-extensions"},
    {"VUID-VkClearDepthStencilValue-depth-02506", "depth must be between 0.0 and 1.0, inclusive", "1.3-khr-extensions"},
    {"VUID-VkCoarseSampleLocationNV-pixelX-02078", "pixelX must be less than the width (in pixels) of the fragment", "1.3-extensions"},
    {"VUID-VkCoarseSampleLocationNV-pixelY-02079", "pixelY must be less than the height (in pixels) of the fragment", "1.3-extensions"},
    {"VUID-VkCoarseSampleLocationNV-sample-02080", "sample must be less than the number of coverage samples in each pixel belonging to the fragment", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-02077", "The array pSampleLocations must contain exactly one entry for every combination of valid values for pixelX, pixelY, and sample in the structure VkCoarseSampleOrderCustomNV", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-pSampleLocations-parameter", "pSampleLocations must be a valid pointer to an array of sampleLocationCount VkCoarseSampleLocationNV structures", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-sampleCount-02074", "sampleCount must correspond to a sample count enumerated in VkSampleCountFlags whose corresponding bit is set in VkPhysicalDeviceLimits::framebufferNoAttachmentsSampleCounts", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02075", "sampleLocationCount must be equal to the product of sampleCount, the fragment width for shadingRate, and the fragment height for shadingRate", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02076", "sampleLocationCount must be less than or equal to the value of VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRateMaxCoarseSamples", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-arraylength", "sampleLocationCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-shadingRate-02073", "shadingRate must be a shading rate that generates fragments with more than one pixel", "1.3-extensions"},
    {"VUID-VkCoarseSampleOrderCustomNV-shadingRate-parameter", "shadingRate must be a valid VkShadingRatePaletteEntryNV value", "1.3-extensions"},
    {"VUID-VkColorBlendAdvancedEXT-advancedBlendOp-parameter", "advancedBlendOp must be a valid VkBlendOp value", "1.3-extensions"},
    {"VUID-VkColorBlendAdvancedEXT-blendOverlap-07507", "If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT", "1.3-extensions"},
    {"VUID-VkColorBlendAdvancedEXT-blendOverlap-parameter", "blendOverlap must be a valid VkBlendOverlapEXT value", "1.3-extensions"},
    {"VUID-VkColorBlendAdvancedEXT-dstPremultiplied-07506", "If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkColorBlendAdvancedEXT-srcPremultiplied-07505", "If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-alphaBlendOp-parameter", "alphaBlendOp must be a valid VkBlendOp value", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-colorBlendOp-07361", "colorBlendOp and alphaBlendOp must not be VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-colorBlendOp-parameter", "colorBlendOp must be a valid VkBlendOp value", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-constantAlphaColorBlendFactors-07362", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, srcColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-constantAlphaColorBlendFactors-07363", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, dstColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-dstAlphaBlendFactor-parameter", "dstAlphaBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-dstColorBlendFactor-parameter", "dstColorBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-dualSrcBlend-07357", "If the dualSrcBlend feature is not enabled, srcColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-dualSrcBlend-07358", "If the dualSrcBlend feature is not enabled, dstColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-dualSrcBlend-07359", "If the dualSrcBlend feature is not enabled, srcAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-dualSrcBlend-07360", "If the dualSrcBlend feature is not enabled, dstAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-srcAlphaBlendFactor-parameter", "srcAlphaBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkColorBlendEquationEXT-srcColorBlendFactor-parameter", "srcColorBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkCommandBufferAllocateInfo-commandPool-parameter", "commandPool must be a valid VkCommandPool handle", "1.3-extensions"},
    {"VUID-VkCommandBufferAllocateInfo-level-parameter", "level must be a valid VkCommandBufferLevel value", "1.3-extensions"},
    {"VUID-VkCommandBufferAllocateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCommandBufferAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-flags-00053", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the renderPass member of pInheritanceInfo must be a valid VkRenderPass", "1.2"},
    {"VUID-VkCommandBufferBeginInfo-flags-00054", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the subpass member of pInheritanceInfo must be a valid subpass index within the renderPass member of pInheritanceInfo", "1.2"},
    {"VUID-VkCommandBufferBeginInfo-flags-00055", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the framebuffer member of pInheritanceInfo must be either VK_NULL_HANDLE, or a valid VkFramebuffer that is compatible with the renderPass member of pInheritanceInfo", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-flags-06000", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT and the renderPass member of pInheritanceInfo is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-flags-06001", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT and the renderPass member of pInheritanceInfo is not VK_NULL_HANDLE, the subpass member of pInheritanceInfo must be a valid subpass index within the renderPass member of pInheritanceInfo", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-flags-06002", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT and the renderPass member of pInheritanceInfo is VK_NULL_HANDLE, the pNext chain of pInheritanceInfo must include a VkCommandBufferInheritanceRenderingInfo structure", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-flags-06003", "If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the renderPass member of pInheritanceInfo is VK_NULL_HANDLE, and the pNext chain of pInheritanceInfo includes a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, the colorAttachmentCount member of that structure must be equal to the value of VkCommandBufferInheritanceRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-flags-parameter", "flags must be a valid combination of VkCommandBufferUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkDeviceGroupCommandBufferBeginInfo", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO", "1.3-extensions"},
    {"VUID-VkCommandBufferBeginInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-conditionalRenderingEnable-01977", "If the inheritedConditionalRendering feature is not enabled, conditionalRenderingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceConditionalRenderingInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-commonparent", "Both of framebuffer, and renderPass that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-occlusionQueryEnable-00056", "If the inheritedQueries feature is not enabled, occlusionQueryEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAttachmentSampleCountInfoAMD, VkCommandBufferInheritanceConditionalRenderingInfoEXT, VkCommandBufferInheritanceRenderPassTransformInfoQCOM, VkCommandBufferInheritanceRenderingInfo, VkCommandBufferInheritanceViewportScissorInfoNV, or VkMultiviewPerViewAttributesInfoNVX", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-00058", "If the pipelineStatisticsQuery feature is not enabled, pipelineStatistics must be 0", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-02789", "If the pipelineStatisticsQuery feature is enabled, pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits values", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-queryFlags-00057", "If the inheritedQueries feature is enabled, queryFlags must be a valid combination of VkQueryControlFlagBits values", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-queryFlags-02788", "If the inheritedQueries feature is not enabled, queryFlags must be 0", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderPassTransformInfoQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderPassTransformInfoQCOM-transform-02864", "transform must be VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, or VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-colorAttachmentCount-06004", "If colorAttachmentCount is not 0, rasterizationSamples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-06007", "If depthAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-06200", "If depthAttachmentFormat is not VK_FORMAT_UNDEFINED and stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, depthAttachmentFormat must equal stencilAttachmentFormat", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-06540", "If depthAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format that includes a depth aspect", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-depthAttachmentFormat-parameter", "depthAttachmentFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-flags-parameter", "flags must be a valid combination of VkRenderingFlagBits values", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-multiview-06008", "If the multiview feature is not enabled, viewMask must be 0", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-pColorAttachmentFormats-06006", "If any element of pColorAttachmentFormats is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-pColorAttachmentFormats-parameter", "If colorAttachmentCount is not 0, pColorAttachmentFormats must be a valid pointer to an array of colorAttachmentCount valid VkFormat values", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-rasterizationSamples-parameter", "If rasterizationSamples is not 0, rasterizationSamples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-stencilAttachmentFormat-06199", "If stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-stencilAttachmentFormat-06541", "If stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format that includes a stencil aspect", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-stencilAttachmentFormat-parameter", "stencilAttachmentFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-variableMultisampleRate-06005", "If the variableMultisampleRate feature is not enabled, rasterizationSamples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfo-viewMask-06009", "The index of the most significant bit in viewMask must be less than maxMultiviewViewCount", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceRenderingInfoKHR-pColorAttachmentFormats-06492", "When rendering to a Linear Color attachment, if any element of pColorAttachmentFormats is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04782", "If the inheritedViewportScissor2D feature is not enabled, viewportScissor2D must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04783", "If the multiViewport feature is not enabled and viewportScissor2D is VK_TRUE, then viewportDepthCount must be 1", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04784", "If viewportScissor2D is VK_TRUE, then viewportDepthCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04785", "If viewportScissor2D is VK_TRUE, then pViewportDepths must be a valid pointer to an array of viewportDepthCount valid VkViewport structures, except any requirements on x, y, width, and height do not apply", "1.3-extensions"},
    {"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04786", "If viewportScissor2D is VK_TRUE, then the command buffer must be recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", "1.3-extensions"},
    {"VUID-VkCommandBufferSubmitInfo-commandBuffer-03890", "commandBuffer must not have been allocated with VK_COMMAND_BUFFER_LEVEL_SECONDARY", "1.3-extensions"},
    {"VUID-VkCommandBufferSubmitInfo-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-VkCommandBufferSubmitInfo-deviceMask-03891", "If deviceMask is not 0, it must be a valid device mask", "1.3-extensions"},
    {"VUID-VkCommandBufferSubmitInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCommandBufferSubmitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO", "1.3-extensions"},
    {"VUID-VkCommandPoolCreateInfo-flags-02860", "If the protectedMemory feature is not enabled, the VK_COMMAND_POOL_CREATE_PROTECTED_BIT bit of flags must not be set", "1.3-extensions"},
    {"VUID-VkCommandPoolCreateInfo-flags-parameter", "flags must be a valid combination of VkCommandPoolCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkCommandPoolCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCommandPoolCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkComponentMapping-a-parameter", "a must be a valid VkComponentSwizzle value", "1.3-extensions"},
    {"VUID-VkComponentMapping-b-parameter", "b must be a valid VkComponentSwizzle value", "1.3-extensions"},
    {"VUID-VkComponentMapping-g-parameter", "g must be a valid VkComponentSwizzle value", "1.3-extensions"},
    {"VUID-VkComponentMapping-r-parameter", "r must be a valid VkComponentSwizzle value", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-commonparent", "Both of basePipelineHandle, and layout that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-00697", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a compute VkPipeline", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-00698", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-00699", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-00700", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-02874", "flags must not include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03364", "flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03365", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03366", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03367", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03368", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03369", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03370", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-03576", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-04945", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-07367", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-layout-00703", "layout must be consistent with the layout of the compute shader specified in stage", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-layout-01687", "The number of resources in layout accessible to the compute shader stage must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreationFeedbackCreateInfo, VkPipelineRobustnessCreateInfoEXT, or VkSubpassShadingPipelineCreateInfoHUAWEI", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-pipelineCreationCacheControl-02875", "If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-pipelineStageCreationFeedbackCount-06566", "If VkPipelineCreationFeedbackCreateInfo::pipelineStageCreationFeedbackCount is not 0, it must be 1", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-stage-00701", "The stage member of stage must be VK_SHADER_STAGE_COMPUTE_BIT", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-stage-00702", "The shader code for the entry point identified by stage and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter", "1.3-extensions"},
    {"VUID-VkComputePipelineCreateInfo-stage-parameter", "stage must be a valid VkPipelineShaderStageCreateInfo structure", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-buffer-01981", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-buffer-01982", "buffer must have been created with the VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-flags-parameter", "flags must be a valid combination of VkConditionalRenderingFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-offset-01983", "offset must be less than the size of buffer by at least 32 bits", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-offset-01984", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkConditionalRenderingBeginInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-AType-parameter", "AType must be a valid VkComponentTypeNV value", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-BType-parameter", "BType must be a valid VkComponentTypeNV value", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-CType-parameter", "CType must be a valid VkComponentTypeNV value", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-DType-parameter", "DType must be a valid VkComponentTypeNV value", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkCooperativeMatrixPropertiesNV-scope-parameter", "scope must be a valid VkScopeNV value", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-buffer-03718", "The buffer used to create src must be bound to device memory", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-buffer-03719", "The buffer used to create dst must be bound to device memory", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-commonparent", "Both of dst, and src must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-dst-parameter", "dst must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-mode-03410", "mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-mode-parameter", "mode must be a valid VkCopyAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-src-03411", "If mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR, src must have been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR in the build", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-src-04963", "The source acceleration structure src must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureInfoKHR-src-parameter", "src must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-dst-03561", "The memory pointed to by dst must be at least as large as the serialization size of src, as reported by vkWriteAccelerationStructuresPropertiesKHR or vkCmdWriteAccelerationStructuresPropertiesKHR with a query type of VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-03412", "mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-parameter", "mode must be a valid VkCopyAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-src-04959", "The source acceleration structure src must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-src-parameter", "src must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-commonparent", "Both of dstBuffer, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-dstBuffer-00120", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-dstBuffer-00121", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-dstOffset-00114", "The dstOffset member of each element of pRegions must be less than the size of dstBuffer", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-pRegions-00117", "The union of the source regions, and the union of the destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkBufferCopy2 structures", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-size-00115", "The size member of each element of pRegions must be less than or equal to the size of srcBuffer minus srcOffset", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-size-00116", "The size member of each element of pRegions must be less than or equal to the size of dstBuffer minus dstOffset", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-srcBuffer-00118", "srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-srcBuffer-00119", "If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-srcBuffer-parameter", "srcBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkCopyBufferInfo2-srcOffset-00113", "The srcOffset member of each element of pRegions must be less than the size of srcBuffer", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-None-00214", "For each element of pRegions whose imageSubresource contains a depth aspect, the data in srcBuffer must be in the range [0,1]", "1.3-khr-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-aspectMask-00211", "For each element of pRegions, imageSubresource.aspectMask must specify aspects present in pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-aspectMask-01560", "If pname:dstImage has a multi-planar format, then for each element of pRegions, imageSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-baseArrayLayer-00213", "If pname:dstImage is of type VK_IMAGE_TYPE_3D, for each element of pRegions, imageSubresource.baseArrayLayer must be 0 and imageSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-bufferImageHeight-00204", "For each element of pRegions, bufferImageHeight must be a multiple of the texel block extent height of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-bufferOffset-00193", "If pname:dstImage does not have a depth/stencil format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "default"},
    {"VUID-VkCopyBufferToImageInfo2-bufferOffset-01558", "If pname:dstImage does not have either a depth/stencil or a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-bufferOffset-01559", "If pname:dstImage has a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in Compatible formats of planes of multi-planar formats", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-bufferRowLength-00203", "For each element of pRegions, bufferRowLength must be a multiple of the texel block extent width of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-commandBuffer-04052", "If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-commandBuffer-04477", "If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT, for each element of pRegions, the aspectMask member of imageSubresource must not be VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-commonparent", "Both of dstImage, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImage-00177", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImage-00178", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImage-00179", "dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImage-01997", "The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImage-02543", "dstImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImageLayout-00180", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImageLayout-00181", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkCopyBufferToImageInfo2-dstImageLayout-01396", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageExtent-00207", "For each element of pRegions, if the sum of imageOffset.x and extent.width does not equal the width of the the subresource specified by srcSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageExtent-00208", "For each element of pRegions, if the sum of imageOffset.y and extent.height does not equal the height of the the subresource specified by srcSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageExtent-00209", "For each element of pRegions, if the sum of imageOffset.z and extent.depth does not equal the depth of the the subresource specified by srcSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageOffset-00200", "For each element of pRegions, imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified imageSubresource of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageOffset-01793", "The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageSubresource-01701", "The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-imageSubresource-01702", "The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-00171", "srcBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-00172", "The image region specified by each element of pRegions must be contained within the specified imageSubresource of dstImage", "1.3-khr-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-00173", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-04565", "If the image region specified by each element of pRegions does not contain VkCopyCommandTransformInfoQCOM in its pNext chain, it must be a region that is contained within the specified imageSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-06223", "For each element of pRegions not containing VkCopyCommandTransformInfoQCOM in its pNext chain, imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified imageSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-06224", "For each element of pRegions not containing VkCopyCommandTransformInfoQCOM in its pNext chain, imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified imageSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-07273", "For each element of pRegions, bufferOffset must be a multiple of the texel block size of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-07274", "For each element of pRegions, imageOffset.x must be a multiple of the texel block extent width of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-07275", "For each element of pRegions, imageOffset.y must be a multiple of the texel block extent height of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-07276", "For each element of pRegions, imageOffset.z must be a multiple of the texel block extent depth of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-07277", "For each element of pRegions, bufferRowLength divided by the texel block extent width and then multiplied by the texel block size of pname:dstImage must be less than or equal to 231-1", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy2 structures", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-srcBuffer-00174", "srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-srcBuffer-00176", "If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-srcBuffer-parameter", "srcBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-srcImage-00199", "If pname:dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, imageOffset.y must be 0 and imageExtent.height must be 1", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-srcImage-00201", "If pname:dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, imageOffset.z must be 0 and imageExtent.depth must be 1", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2-srcImage-04053", "If pname:dstImage has a depth/stencil format, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2KHR-pRegions-04554", "If the image region specified by each element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, the rotated destination region as described in Buffer and Image Addressing with Rotation must be contained within dstImage", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2KHR-pRegions-04555", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then dstImage must have a 1x1x1 texel block extent", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2KHR-pRegions-06203", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then dstImage must be of type VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkCopyBufferToImageInfo2KHR-pRegions-06204", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then dstImage must not have a multi-planar format", "1.3-extensions"},
    {"VUID-VkCopyCommandTransformInfoQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM", "1.3-extensions"},
    {"VUID-VkCopyCommandTransformInfoQCOM-transform-04560", "transform must be VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, or VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-commonparent", "Both of dstSet, and srcSet must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstArrayElement-00348", "The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstBinding-00347", "dstBinding must be a valid binding within dstSet", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstBinding-02224", "If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, dstArrayElement must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstBinding-02632", "The type of dstBinding within dstSet must be equal to the type of srcBinding within srcSet", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstBinding-02753", "If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_SAMPLER, then dstSet must not have been allocated with a layout that included immutable samplers for dstBinding", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstSet-04612", "If VkDescriptorSetLayoutBinding for dstSet at dstBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the new active descriptor type must exist in the corresponding pMutableDescriptorTypeLists list for dstBinding if the new active descriptor type is not VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstSet-04614", "If VkDescriptorSetLayoutBinding for dstSet at dstBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, and the new active descriptor type is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the pMutableDescriptorTypeLists for srcBinding and dstBinding must match exactly", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-dstSet-parameter", "dstSet must be a valid VkDescriptorSet handle", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcArrayElement-00346", "The sum of srcArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by srcBinding, and all applicable consecutive bindings, as described by consecutive binding updates", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcBinding-00345", "srcBinding must be a valid binding within srcSet", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcBinding-02223", "If the descriptor type of the descriptor set binding specified by srcBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, srcArrayElement must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcBinding-02225", "If the descriptor type of the descriptor set binding specified by either srcBinding or dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, descriptorCount must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-00349", "If srcSet is equal to dstSet, then the source and destination ranges of descriptors must not overlap, where the ranges may include array elements from consecutive bindings as described by consecutive binding updates", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-01918", "If srcSet's layout was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set, then dstSet's layout must also have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-01920", "If the descriptor pool from which srcSet was allocated was created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set, then the descriptor pool from which dstSet was allocated must also have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-04613", "If VkDescriptorSetLayoutBinding for srcSet at srcBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT and the VkDescriptorSetLayoutBinding for dstSet at dstBinding is not VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the active descriptor type for the source descriptor must match the descriptor type of dstBinding", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-04885", "If srcSet's layout was created with neither VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT nor VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT flags set, then dstSet's layout must have been created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-04886", "If srcSet's layout was created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set, then dstSet's layout must also have been created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set", "1.3-khr-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-04887", "If the descriptor pool from which srcSet was allocated was created with neither VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT nor VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT flags set, then the descriptor pool from which dstSet was allocated must have been created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set", "1.3-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-04888", "If the descriptor pool from which srcSet was allocated was created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set, then the descriptor pool from which dstSet was allocated must also have been created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set", "1.3-khr-extensions"},
    {"VUID-VkCopyDescriptorSet-srcSet-parameter", "srcSet must be a valid VkDescriptorSet handle", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-None-01549", "In a copy to or from a plane of a multi-planar image, the VkFormat of the image and plane must be compatible according to the description of compatible planes for the plane being copied", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-aspect-06662", "If the aspect member of any element of pRegions includes any flag other than VK_IMAGE_ASPECT_STENCIL_BIT or srcImage was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_SRC_BIT must have been included in the VkImageCreateInfo::usage used to create srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-aspect-06663", "If the aspect member of any element of pRegions includes any flag other than VK_IMAGE_ASPECT_STENCIL_BIT or dstImage was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-aspect-06664", "If the aspect member of any element of pRegions includes VK_IMAGE_ASPECT_STENCIL_BIT, and srcImage was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_SRC_BIT must have been included in the VkImageStencilUsageCreateInfo::stencilUsage used to create srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-aspect-06665", "If the aspect member of any element of pRegions includes VK_IMAGE_ASPECT_STENCIL_BIT, and dstImage was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageStencilUsageCreateInfo::stencilUsage used to create dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-aspectMask-00142", "For each element of pRegions, srcSubresource.aspectMask must specify aspects present in srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-aspectMask-00143", "For each element of pRegions, dstSubresource.aspectMask must specify aspects present in dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-commonparent", "Both of dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-00131", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.1-khr-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-00132", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "default"},
    {"VUID-VkCopyImageInfo2-dstImage-00152", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01547", "If dstImage is non-sparse then the image or disjoint plane that is the destination of the copy must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01554", "If dstImage has a VkFormat with two planes then for each element of pRegions, dstSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01555", "If dstImage has a VkFormat with three planes then for each element of pRegions, dstSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01557", "If dstImage has a multi-planar image format and the srcImage does not have a multi-planar image format, then for each element of pRegions, srcSubresource.aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01732", "For each element of pRegions, if the sum of dstOffset.x and extent.width does not equal the width of the the subresource specified by dstSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01733", "For each element of pRegions, if the sum of dstOffset.y and extent.height does not equal the height of the the subresource specified by dstSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01734", "For each element of pRegions, if the sum of dstOffset.z and extent.depth does not equal the depth of the the subresource specified by dstSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01786", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01788", "If dstImage is of type VK_IMAGE_TYPE_2D, then for each element of pRegions, dstOffset.z must be 0", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01792", "If dstImage is of type VK_IMAGE_TYPE_2D, and srcImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, extent.depth must equal dstSubresource.layerCount", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-01996", "The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-02542", "dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-04444", "If dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, dstSubresource.baseArrayLayer must be 0 and dstSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImageLayout-00133", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImageLayout-00134", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkCopyImageInfo2-dstImageLayout-01395", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstOffset-00150", "For each element of pRegions, dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstOffset-00151", "For each element of pRegions, dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstOffset-00153", "If dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstOffset-01784", "The dstOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstSubresource-01697", "The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-dstSubresource-01699", "The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-00124", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-07278", "For each element of pRegions, srcOffset.x must be a multiple of the texel block extent width of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-07279", "For each element of pRegions, srcOffset.y must be a multiple of the texel block extent height of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-07280", "For each element of pRegions, srcOffset.z must be a multiple of the texel block extent depth of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-07281", "For each element of pRegions, dstOffset.x must be a multiple of the texel block extent width of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-07282", "For each element of pRegions, dstOffset.y must be a multiple of the texel block extent height of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-07283", "For each element of pRegions, dstOffset.z must be a multiple of the texel block extent depth of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkImageCopy2 structures", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-00126", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.1-khr-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-00127", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "default"},
    {"VUID-VkCopyImageInfo2-srcImage-00135", "The VkFormat of each of srcImage and dstImage must be size-compatible", "default"},
    {"VUID-VkCopyImageInfo2-srcImage-00136", "The sample count of srcImage and dstImage must match", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-00139", "If either srcImage or dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer and dstSubresource.baseArrayLayer must each be 0, and srcSubresource.layerCount and dstSubresource.layerCount must each be 1", "default"},
    {"VUID-VkCopyImageInfo2-srcImage-00146", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01546", "If srcImage is non-sparse then the image or disjoint plane to be copied must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01548", "If the VkFormat of each of srcImage and dstImage is not a multi-planar format, the VkFormat of each of srcImage and dstImage must be size-compatible", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01551", "If neither srcImage nor dstImage has a multi-planar image format then for each element of pRegions, srcSubresource.aspectMask and dstSubresource.aspectMask must match", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01552", "If srcImage has a VkFormat with two planes then for each element of pRegions, srcSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01553", "If srcImage has a VkFormat with three planes then for each element of pRegions, srcSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01556", "If srcImage has a multi-planar image format and the dstImage does not have a multi-planar image format, then for each element of pRegions, dstSubresource.aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01728", "For each element of pRegions, if the sum of srcOffset.x and extent.width does not equal the width of the the subresource specified by srcSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01729", "For each element of pRegions, if the sum of srcOffset.y and extent.height does not equal the height of the the subresource specified by srcSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01730", "For each element of pRegions, if the sum of srcOffset.z and extent.depth does not equal the depth of the the subresource specified by srcSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01785", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01787", "If srcImage is of type VK_IMAGE_TYPE_2D, then for each element of pRegions, srcOffset.z must be 0", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01789", "If srcImage or dstImage is of type VK_IMAGE_TYPE_2D, then for each element of pRegions, extent.depth must be 1", "default"},
    {"VUID-VkCopyImageInfo2-srcImage-01790", "If srcImage and dstImage are both of type VK_IMAGE_TYPE_2D, then for each element of pRegions, extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01791", "If srcImage is of type VK_IMAGE_TYPE_2D, and dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, extent.depth must equal srcSubresource.layerCount", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-01995", "The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-04443", "If srcImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer must be 0 and srcSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImageLayout-00128", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImageLayout-00129", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkCopyImageInfo2-srcImageLayout-01917", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcOffset-00144", "For each element of pRegions, srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcOffset-00145", "For each element of pRegions, srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcOffset-00147", "If srcImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcOffset-01783", "The srcOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcSubresource-01696", "The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkCopyImageInfo2-srcSubresource-01698", "The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-aspectMask-00211", "For each element of pRegions, imageSubresource.aspectMask must specify aspects present in pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-aspectMask-01560", "If pname:srcImage has a multi-planar format, then for each element of pRegions, imageSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-baseArrayLayer-00213", "If pname:srcImage is of type VK_IMAGE_TYPE_3D, for each element of pRegions, imageSubresource.baseArrayLayer must be 0 and imageSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-bufferImageHeight-00204", "For each element of pRegions, bufferImageHeight must be a multiple of the texel block extent height of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-bufferOffset-00193", "If pname:srcImage does not have a depth/stencil format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "default"},
    {"VUID-VkCopyImageToBufferInfo2-bufferOffset-01558", "If pname:srcImage does not have either a depth/stencil or a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-bufferOffset-01559", "If pname:srcImage has a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in Compatible formats of planes of multi-planar formats", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-bufferRowLength-00203", "For each element of pRegions, bufferRowLength must be a multiple of the texel block extent width of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-commandBuffer-04052", "If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-commonparent", "Both of dstBuffer, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-dstBuffer-00191", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-dstBuffer-00192", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageExtent-00207", "For each element of pRegions, if the sum of imageOffset.x and extent.width does not equal the width of the the subresource specified by srcSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageExtent-00208", "For each element of pRegions, if the sum of imageOffset.y and extent.height does not equal the height of the the subresource specified by srcSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageExtent-00209", "For each element of pRegions, if the sum of imageOffset.z and extent.depth does not equal the depth of the the subresource specified by srcSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageOffset-00197", "For each element of pRegions not containing VkCopyCommandTransformInfoQCOM in its pNext chain, imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified imageSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageOffset-00198", "For each element of pRegions not containing VkCopyCommandTransformInfoQCOM in its pNext chain, imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified imageSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageOffset-00200", "For each element of pRegions, imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified imageSubresource of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageOffset-01794", "The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageSubresource-01703", "The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-imageSubresource-01704", "The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-00182", "The image region specified by each element of pRegions must be contained within the specified imageSubresource of srcImage", "1.3-khr-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-00183", "dstBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-00184", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-04566", "If the image region specified by each element of pRegions does not contain VkCopyCommandTransformInfoQCOM in its pNext chain, it must be contained within the specified imageSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-07273", "For each element of pRegions, bufferOffset must be a multiple of the texel block size of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-07274", "For each element of pRegions, imageOffset.x must be a multiple of the texel block extent width of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-07275", "For each element of pRegions, imageOffset.y must be a multiple of the texel block extent height of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-07276", "For each element of pRegions, imageOffset.z must be a multiple of the texel block extent depth of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-07277", "For each element of pRegions, bufferRowLength divided by the texel block extent width and then multiplied by the texel block size of pname:srcImage must be less than or equal to 231-1", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy2 structures", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-00186", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-00187", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-00188", "srcImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-00199", "If pname:srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, imageOffset.y must be 0 and imageExtent.height must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-00201", "If pname:srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, imageOffset.z must be 0 and imageExtent.depth must be 1", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-01998", "The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-02544", "srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-04053", "If pname:srcImage has a depth/stencil format, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImageLayout-00189", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImageLayout-00190", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkCopyImageToBufferInfo2-srcImageLayout-01397", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2KHR-pRegions-04557", "If the image region specified by each element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, the rotated source region as described in Buffer and Image Addressing with Rotation must be contained within srcImage", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2KHR-pRegions-04558", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then srcImage must have a 1x1x1 texel block extent", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2KHR-pRegions-06205", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then srcImage must be of type VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkCopyImageToBufferInfo2KHR-pRegions-06206", "If any element of pRegions contains VkCopyCommandTransformInfoQCOM in its pNext chain, then srcImage must not have a multi-planar format", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-dst-03746", "dst must have been created with a size greater than or equal to that used to serialize the data in src", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-dst-parameter", "dst must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-03413", "mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-parameter", "mode must be a valid VkCopyAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pInfo-03414", "The data in src must have a format compatible with the destination physical device as returned by vkGetDeviceAccelerationStructureCompatibilityKHR", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-src-04960", "The source memory pointed to by src must contain data previously serialized using vkCmdCopyAccelerationStructureToMemoryKHR, potentially modified to relocate acceleration structure references as described in that command", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-dst-07550", "dst must have been created with a size greater than or equal to that used to serialize the data in src", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-dst-parameter", "dst must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-mode-07548", "mode must be VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-mode-parameter", "mode must be a valid VkCopyMicromapModeEXT value", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-src-07547", "The source memory pointed to by src must contain data previously serialized using vkCmdCopyMicromapToMemoryEXT", "1.3-extensions"},
    {"VUID-VkCopyMemoryToMicromapInfoEXT-src-07549", "The data in src must have a format compatible with the destination physical device as returned by vkGetDeviceMicromapCompatibilityEXT", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-buffer-07534", "The buffer used to create src must be bound to device memory", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-buffer-07535", "The buffer used to create dst must be bound to device memory", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-commonparent", "Both of dst, and src must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-dst-parameter", "dst must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-mode-07531", "mode must be VK_COPY_MICROMAP_MODE_COMPACT_EXT or VK_COPY_MICROMAP_MODE_CLONE_EXT", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-mode-07533", "If mode is VK_COPY_MICROMAP_MODE_COMPACT_EXT, src must have been constructed with VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT in the build", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-mode-parameter", "mode must be a valid VkCopyMicromapModeEXT value", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-src-07532", "The source acceleration structure src must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-VkCopyMicromapInfoEXT-src-parameter", "src must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-dst-07541", "The memory pointed to by dst must be at least as large as the serialization size of src, as reported by vkWriteMicromapsPropertiesEXT or vkCmdWriteMicromapsPropertiesEXT with a query type of VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-mode-07542", "mode must be VK_COPY_MICROMAP_MODE_SERIALIZE_EXT", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-mode-parameter", "mode must be a valid VkCopyMicromapModeEXT value", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-src-07540", "The source micromap src must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-VkCopyMicromapToMemoryInfoEXT-src-parameter", "src must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-VkCuFunctionCreateInfoNVX-module-parameter", "module must be a valid VkCuModuleNVX handle", "1.3-extensions"},
    {"VUID-VkCuFunctionCreateInfoNVX-pName-parameter", "pName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkCuFunctionCreateInfoNVX-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCuFunctionCreateInfoNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX", "1.3-extensions"},
    {"VUID-VkCuLaunchInfoNVX-function-parameter", "function must be a valid VkCuFunctionNVX handle", "1.3-extensions"},
    {"VUID-VkCuLaunchInfoNVX-pExtras-parameter", "If extraCount is not 0, pExtras must be a valid pointer to an array of extraCount bytes", "1.3-extensions"},
    {"VUID-VkCuLaunchInfoNVX-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCuLaunchInfoNVX-pParams-parameter", "If paramCount is not 0, pParams must be a valid pointer to an array of paramCount bytes", "1.3-extensions"},
    {"VUID-VkCuLaunchInfoNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX", "1.3-extensions"},
    {"VUID-VkCuModuleCreateInfoNVX-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-VkCuModuleCreateInfoNVX-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-VkCuModuleCreateInfoNVX-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkCuModuleCreateInfoNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX", "1.3-extensions"},
    {"VUID-VkD3D12FenceSubmitInfoKHR-pSignalSemaphoreValues-parameter", "If signalSemaphoreValuesCount is not 0, and pSignalSemaphoreValues is not NULL, pSignalSemaphoreValues must be a valid pointer to an array of signalSemaphoreValuesCount uint64_t values", "1.3-extensions"},
    {"VUID-VkD3D12FenceSubmitInfoKHR-pWaitSemaphoreValues-parameter", "If waitSemaphoreValuesCount is not 0, and pWaitSemaphoreValues is not NULL, pWaitSemaphoreValues must be a valid pointer to an array of waitSemaphoreValuesCount uint64_t values", "1.3-extensions"},
    {"VUID-VkD3D12FenceSubmitInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkD3D12FenceSubmitInfoKHR-signalSemaphoreValuesCount-00080", "signalSemaphoreValuesCount must be the same value as VkSubmitInfo::signalSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure", "1.3-extensions"},
    {"VUID-VkD3D12FenceSubmitInfoKHR-waitSemaphoreValuesCount-00079", "waitSemaphoreValuesCount must be the same value as VkSubmitInfo::waitSemaphoreCount, where VkSubmitInfo is in the pNext chain of this VkD3D12FenceSubmitInfoKHR structure", "1.3-extensions"},
    {"VUID-VkDebugMarkerMarkerInfoEXT-pMarkerName-parameter", "pMarkerName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkDebugMarkerMarkerInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDebugMarkerMarkerInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-object-01491", "object must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-object-01492", "object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-objectType-01490", "objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-objectType-parameter", "objectType must be a valid VkDebugReportObjectTypeEXT value", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-pObjectName-parameter", "pObjectName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectNameInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-object-01494", "object must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-object-01495", "object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-objectType-01493", "objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-objectType-parameter", "objectType must be a valid VkDebugReportObjectTypeEXT value", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-pTag-parameter", "pTag must be a valid pointer to an array of tagSize bytes", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugMarkerObjectTagInfoEXT-tagSize-arraylength", "tagSize must be greater than 0", "1.3-extensions"},
    {"VUID-VkDebugReportCallbackCreateInfoEXT-flags-parameter", "flags must be a valid combination of VkDebugReportFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkDebugReportCallbackCreateInfoEXT-pfnCallback-parameter", "pfnCallback must be a valid PFN_vkDebugReportCallbackEXT value", "1.3-extensions"},
    {"VUID-VkDebugReportCallbackCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsLabelEXT-pLabelName-parameter", "pLabelName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkDebugUtilsLabelEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDebugUtilsLabelEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-pCmdBufLabels-parameter", "If cmdBufLabelCount is not 0, pCmdBufLabels must be a valid pointer to an array of cmdBufLabelCount valid VkDebugUtilsLabelEXT structures", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessage-parameter", "pMessage must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-pMessageIdName-parameter", "If pMessageIdName is not NULL, pMessageIdName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkDeviceAddressBindingCallbackDataEXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-pObjects-parameter", "If objectCount is not 0, pObjects must be a valid pointer to an array of objectCount valid VkDebugUtilsObjectNameInfoEXT structures", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-pQueueLabels-parameter", "If queueLabelCount is not 0, pQueueLabels must be a valid pointer to an array of queueLabelCount valid VkDebugUtilsLabelEXT structures", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCallbackDataEXT-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-parameter", "messageSeverity must be a valid combination of VkDebugUtilsMessageSeverityFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-messageSeverity-requiredbitmask", "messageSeverity must not be 0", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-parameter", "messageType must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-messageType-requiredbitmask", "messageType must not be 0", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-01914", "pfnUserCallback must be a valid PFN_vkDebugUtilsMessengerCallbackEXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-pfnUserCallback-parameter", "pfnUserCallback must be a valid PFN_vkDebugUtilsMessengerCallbackEXT value", "1.3-extensions"},
    {"VUID-VkDebugUtilsMessengerCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02589", "If objectType is VK_OBJECT_TYPE_UNKNOWN, objectHandle must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02590", "If objectType is not VK_OBJECT_TYPE_UNKNOWN, objectHandle must be VK_NULL_HANDLE or a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-parameter", "objectType must be a valid VkObjectType value", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectNameInfoEXT-pObjectName-parameter", "If pObjectName is not NULL, pObjectName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectNameInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01910", "objectHandle must be a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-objectType-01908", "objectType must not be VK_OBJECT_TYPE_UNKNOWN", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-objectType-parameter", "objectType must be a valid VkObjectType value", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-pTag-parameter", "pTag must be a valid pointer to an array of tagSize bytes", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDebugUtilsObjectTagInfoEXT-tagSize-arraylength", "tagSize must be greater than 0", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationBufferCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationImageCreateInfoNV-dedicatedAllocation-00994", "If dedicatedAllocation is VK_TRUE, VkImageCreateInfo::flags must not include VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationImageCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00651", "If buffer is not VK_NULL_HANDLE, the buffer must have been created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00653", "If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-00655", "If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-buffer-parameter", "If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-commonparent", "Both of buffer, and image that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00649", "At least one of image and buffer must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00650", "If image is not VK_NULL_HANDLE, the image must have been created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00652", "If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-00654", "If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-image-parameter", "If image is not VK_NULL_HANDLE, image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkDedicatedAllocationMemoryAllocateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkDependencyInfo-dependencyFlags-parameter", "dependencyFlags must be a valid combination of VkDependencyFlagBits values", "1.3-extensions"},
    {"VUID-VkDependencyInfo-pBufferMemoryBarriers-parameter", "If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier2 structures", "1.3-extensions"},
    {"VUID-VkDependencyInfo-pImageMemoryBarriers-parameter", "If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier2 structures", "1.3-extensions"},
    {"VUID-VkDependencyInfo-pMemoryBarriers-parameter", "If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier2 structures", "1.3-extensions"},
    {"VUID-VkDependencyInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDependencyInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEPENDENCY_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorBufferInfo-buffer-02998", "If the nullDescriptor feature is not enabled, buffer must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkDescriptorBufferInfo-buffer-02999", "If buffer is VK_NULL_HANDLE, offset must be zero and range must be VK_WHOLE_SIZE", "1.3-extensions"},
    {"VUID-VkDescriptorBufferInfo-buffer-parameter", "If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkDescriptorBufferInfo-offset-00340", "offset must be less than the size of buffer", "1.3-extensions"},
    {"VUID-VkDescriptorBufferInfo-range-00341", "If range is not equal to VK_WHOLE_SIZE, range must be greater than 0", "1.3-extensions"},
    {"VUID-VkDescriptorBufferInfo-range-00342", "If range is not equal to VK_WHOLE_SIZE, range must be less than or equal to the size of buffer minus offset", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-commonparent", "Both of imageView, and sampler that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-descriptorType-06713", "If the image2DViewOf3D feature is not enabled and descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE then imageView must not be a 2D view created from a 3D image", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-descriptorType-06714", "If the sampler2DViewOf3D feature is not enabled and descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER then imageView must not be a 2D view created from a 3D image", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-imageLayout-00344", "imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time this descriptor is accessed as defined by the image layout matching rules", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-imageView-01976", "If imageView is created from a depth/stencil image, the aspectMask used to create the imageView must include either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT but not both", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-imageView-06711", "imageView must not be 2D image view created from a 3D image", "1.3-khr-extensions"},
    {"VUID-VkDescriptorImageInfo-imageView-06712", "imageView must not be a 2D array image view created from a 3D image", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-mutableComparisonSamplers-04450", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::mutableComparisonSamplers is VK_FALSE, then sampler must have been created with VkSamplerCreateInfo::compareEnable set to VK_FALSE", "1.3-extensions"},
    {"VUID-VkDescriptorImageInfo-sampler-01564", "If sampler is used and the VkFormat of the image is a multi-planar format, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the imageView must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or (for three-plane formats only) VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-flags-04607", "If flags has the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT bit set, then the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT bit must not be set", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-flags-04609", "If flags has the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT bit set, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType must be enabled", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-flags-parameter", "flags must be a valid combination of VkDescriptorPoolCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-maxSets-00301", "maxSets must be greater than 0", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-mutableDescriptorType-04608", "If VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType is not enabled, pPoolSizes must not contain a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDescriptorPoolInlineUniformBlockCreateInfo or VkMutableDescriptorTypeCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-pPoolSizes-04787", "If pPoolSizes contains a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT, any other VK_DESCRIPTOR_TYPE_MUTABLE_EXT element in pPoolSizes must not have sets of supported descriptor types which partially overlap", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter", "If poolSizeCount is not 0, pPoolSizes must be a valid pointer to an array of poolSizeCount valid VkDescriptorPoolSize structures", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorPoolCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkDescriptorPoolInlineUniformBlockCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorPoolSize-descriptorCount-00302", "descriptorCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkDescriptorPoolSize-type-02218", "If type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK then descriptorCount must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkDescriptorPoolSize-type-parameter", "type must be a valid VkDescriptorType value", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-commonparent", "Both of descriptorPool, and the elements of pSetLayouts must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-descriptorPool-00307", "descriptorPool must have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts", "1.0"},
    {"VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter", "descriptorPool must be a valid VkDescriptorPool handle", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-00306", "descriptorSetCount must not be greater than the number of sets that are currently available for allocation in descriptorPool", "1.0"},
    {"VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength", "descriptorSetCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountAllocateInfo", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308", "Each element of pSetLayouts must not have been created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044", "If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-04610", "If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT flag set", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter", "pSetLayouts must be a valid pointer to an array of descriptorSetCount valid VkDescriptorSetLayout handles", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorSetAllocateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkDescriptorSetBindingReferenceVALVE-descriptorSetLayout-parameter", "descriptorSetLayout must be a valid VkDescriptorSetLayout handle", "1.3-extensions"},
    {"VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283", "If descriptorCount is not 0, stageFlags must be a valid combination of VkShaderStageFlagBits values", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-00282", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and descriptorCount is not 0 and pImmutableSamplers is not NULL, pImmutableSamplers must be a valid pointer to an array of descriptorCount valid VkSampler handles", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-01510", "If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT and descriptorCount is not 0, then stageFlags must be 0 or VK_SHADER_STAGE_FRAGMENT_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-02209", "If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK then descriptorCount must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-02210", "If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK then descriptorCount must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxInlineUniformBlockSize", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-04604", "If the inlineUniformBlock feature is not enabled, descriptorType must not be VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-04605", "If descriptorType is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, then pImmutableSamplers must be NULL", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter", "descriptorType must be a valid VkDescriptorType value", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBinding-pImmutableSamplers-04009", "The sampler objects indicated by pImmutableSamplers must not have a borderColor with one of the values VK_BORDER_COLOR_FLOAT_CUSTOM_EXT or VK_BORDER_COLOR_INT_CUSTOM_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-None-03011", "All bindings with descriptor type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-bindingCount-03002", "If bindingCount is not zero, bindingCount must equal VkDescriptorSetLayoutCreateInfo::bindingCount", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingAccelerationStructureUpdateAfterBind-03570", "If VkPhysicalDeviceAccelerationStructureFeaturesKHR::descriptorBindingAccelerationStructureUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR or VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingInlineUniformBlockUpdateAfterBind-02211", "If VkPhysicalDeviceInlineUniformBlockFeatures::descriptorBindingInlineUniformBlockUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingPartiallyBound-03013", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingPartiallyBound is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingSampledImageUpdateAfterBind-03006", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingSampledImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, or VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageBufferUpdateAfterBind-03008", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingStorageBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageImageUpdateAfterBind-03007", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingStorageImageUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingStorageTexelBufferUpdateAfterBind-03010", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingStorageTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformBufferUpdateAfterBind-03005", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingUniformBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUniformTexelBufferUpdateAfterBind-03009", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingUniformTexelBufferUpdateAfterBind is not enabled, all bindings with descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUpdateUnusedWhilePending-03012", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingUpdateUnusedWhilePending is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingVariableDescriptorCount-03014", "If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingVariableDescriptorCount is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-flags-03003", "If VkDescriptorSetLayoutCreateInfo::flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT, or VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03004", "If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, then all other elements of VkDescriptorSetLayoutCreateInfo::pBindings must have a smaller value of binding", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03015", "If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, that element's descriptorType must not be VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-parameter", "If bindingCount is not 0, pBindingFlags must be a valid pointer to an array of bindingCount valid combinations of VkDescriptorBindingFlagBits values", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-binding-00279", "The VkDescriptorSetLayoutBinding::binding members of the elements of the pBindings array must each have different values", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001", "If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT bit set, then all bindings must not have descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04594", "If a binding has a descriptorType value of VK_DESCRIPTOR_TYPE_MUTABLE_EXT, then pImmutableSamplers must be NULL", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-00280", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-00281", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then the total number of elements of all bindings must be less than or equal to VkPhysicalDevicePushDescriptorPropertiesKHR::maxPushDescriptors", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-02208", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-03000", "If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT bit set, flags must include VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-04590", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, flags must not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-04591", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-04592", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT, flags must not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-04596", "If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType must be enabled", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter", "flags must be a valid combination of VkDescriptorSetLayoutCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-mutableDescriptorType-04595", "If VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType is not enabled, pBindings must not contain a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-pBindings-07303", "If any element pBindings[i] has a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT, then a VkMutableDescriptorTypeCreateInfoEXT must be present in the pNext chain, and mutableDescriptorTypeListCount must be greater than i.", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter", "If bindingCount is not 0, pBindings must be a valid pointer to an array of bindingCount valid VkDescriptorSetLayoutBinding structures", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDescriptorSetLayoutBindingFlagsCreateInfo or VkMutableDescriptorTypeCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutSupport-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkDescriptorSetVariableDescriptorCountLayoutSupport", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutSupport-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT", "1.3-extensions"},
    {"VUID-VkDescriptorSetLayoutSupport-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-descriptorSetCount-03045", "If descriptorSetCount is not zero, descriptorSetCount must equal VkDescriptorSetAllocateInfo::descriptorSetCount", "1.3-extensions"},
    {"VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pDescriptorCounts-parameter", "If descriptorSetCount is not 0, pDescriptorCounts must be a valid pointer to an array of descriptorSetCount uint32_t values", "1.3-extensions"},
    {"VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-pSetLayouts-03046", "If VkDescriptorSetAllocateInfo::pSetLayouts[i] has a variable-sized descriptor binding, then pDescriptorCounts[i] must be less than or equal to the descriptor count specified for that binding when the descriptor set layout was created", "1.3-extensions"},
    {"VUID-VkDescriptorSetVariableDescriptorCountAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorSetVariableDescriptorCountLayoutSupport-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-commonparent", "Both of descriptorSetLayout, and pipelineLayout that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-descriptorUpdateEntryCount-arraylength", "descriptorUpdateEntryCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-pDescriptorUpdateEntries-parameter", "pDescriptorUpdateEntries must be a valid pointer to an array of descriptorUpdateEntryCount valid VkDescriptorUpdateTemplateEntry structures", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350", "If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET, descriptorSetLayout must be a valid VkDescriptorSetLayout handle", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351", "If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352", "If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineLayout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00353", "If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-04615", "If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET, descriptorSetLayout must not contain a binding with type VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-parameter", "templateType must be a valid VkDescriptorUpdateTemplateType value", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226", "If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, dstArrayElement must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227", "If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, descriptorCount must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateEntry-descriptorType-parameter", "descriptorType must be a valid VkDescriptorType value", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateEntry-dstArrayElement-00355", "dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding implicitly specified when using a descriptor update template to update descriptors, and all applicable consecutive bindings, as described by consecutive binding updates", "1.3-extensions"},
    {"VUID-VkDescriptorUpdateTemplateEntry-dstBinding-00354", "dstBinding must be a valid binding in the descriptor set layout implicitly specified when using a descriptor update template to update descriptors", "1.3-extensions"},
    {"VUID-VkDeviceAddressBindingCallbackDataEXT-bindingType-parameter", "bindingType must be a valid VkDeviceAddressBindingTypeEXT value", "1.3-extensions"},
    {"VUID-VkDeviceAddressBindingCallbackDataEXT-flags-parameter", "flags must be a valid combination of VkDeviceAddressBindingFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkDeviceAddressBindingCallbackDataEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT", "1.3-extensions"},
    {"VUID-VkDeviceBufferMemoryRequirements-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkBufferCreateInfo structure", "1.3-extensions"},
    {"VUID-VkDeviceBufferMemoryRequirements-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceBufferMemoryRequirements-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-None-04896", "If sparseImageInt64Atomics is enabled, shaderImageInt64Atomics must be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-None-04897", "If sparseImageFloat32Atomics is enabled, shaderImageFloat32Atomics must be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-None-04898", "If sparseImageFloat32AtomicAdd is enabled, shaderImageFloat32AtomicAdd must be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-fragmentDensityMap-04481", "If the fragmentDensityMap feature is enabled, the pipelineFragmentShadingRate feature must not be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-fragmentDensityMap-04482", "If the fragmentDensityMap feature is enabled, the primitiveFragmentShadingRate feature must not be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-fragmentDensityMap-04483", "If the fragmentDensityMap feature is enabled, the attachmentFragmentShadingRate feature must not be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pEnabledFeatures-parameter", "If pEnabledFeatures is not NULL, pEnabledFeatures must be a valid pointer to a valid VkPhysicalDeviceFeatures structure", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pNext-00373", "If the pNext chain includes a VkPhysicalDeviceFeatures2 structure, then pEnabledFeatures must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pNext-02829", "If the pNext chain includes a VkPhysicalDeviceVulkan11Features structure, then it must not include a VkPhysicalDevice16BitStorageFeatures, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceSamplerYcbcrConversionFeatures, or VkPhysicalDeviceShaderDrawParametersFeatures structure", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pNext-02830", "If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures, or VkPhysicalDeviceVulkanMemoryModelFeatures structure", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pNext-04748", "if the pNext chain includes a VkPhysicalDeviceVulkan12Features structure and VkPhysicalDeviceVulkan12Features::bufferDeviceAddress is VK_TRUE, ppEnabledExtensionNames must not contain VK_EXT_buffer_device_address", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pNext-06532", "If the pNext chain includes a VkPhysicalDeviceVulkan13Features structure, then it must not include a VkPhysicalDeviceDynamicRenderingFeatures, VkPhysicalDeviceImageRobustnessFeatures, VkPhysicalDeviceInlineUniformBlockFeatures, VkPhysicalDeviceMaintenance4Features, VkPhysicalDevicePipelineCreationCacheControlFeatures, VkPhysicalDevicePrivateDataFeatures, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, VkPhysicalDeviceShaderIntegerDotProductFeatures, VkPhysicalDeviceShaderTerminateInvocationFeatures, VkPhysicalDeviceSubgroupSizeControlFeatures, VkPhysicalDeviceSynchronization2Features, VkPhysicalDeviceTextureCompressionASTCHDRFeatures, or VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceDeviceMemoryReportCreateInfoEXT, VkDeviceDiagnosticsConfigCreateInfoNV, VkDeviceGroupDeviceCreateInfo, VkDeviceMemoryOverallocationCreateInfoAMD, VkDevicePrivateDataCreateInfo, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice4444FormatsFeaturesEXT, VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceAccelerationStructureFeaturesKHR, VkPhysicalDeviceAddressBindingReportFeaturesEXT, VkPhysicalDeviceAmigoProfilingFeaturesSEC, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceColorWriteEnableFeaturesEXT, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCustomBorderColorFeaturesEXT, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, VkPhysicalDeviceDepthClipControlFeaturesEXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, VkPhysicalDeviceDiagnosticsConfigFeaturesNV, VkPhysicalDeviceDynamicRenderingFeatures, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, VkPhysicalDeviceFaultFeaturesEXT, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, VkPhysicalDeviceFragmentShadingRateFeaturesKHR, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, VkPhysicalDeviceImageCompressionControlFeaturesEXT, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, VkPhysicalDeviceImageProcessingFeaturesQCOM, VkPhysicalDeviceImageRobustnessFeatures, VkPhysicalDeviceImageViewMinLodFeaturesEXT, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceIndexTypeUint8FeaturesEXT, VkPhysicalDeviceInheritedViewportScissorFeaturesNV, VkPhysicalDeviceInlineUniformBlockFeatures, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, VkPhysicalDeviceLegacyDitheringFeaturesEXT, VkPhysicalDeviceLineRasterizationFeaturesEXT, VkPhysicalDeviceLinearColorAttachmentFeaturesNV, VkPhysicalDeviceMaintenance4Features, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiDrawFeaturesEXT, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, VkPhysicalDeviceOpacityMicromapFeaturesEXT, VkPhysicalDeviceOpticalFlowFeaturesNV, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, VkPhysicalDevicePerformanceQueryFeaturesKHR, VkPhysicalDevicePipelineCreationCacheControlFeatures, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, VkPhysicalDevicePipelinePropertiesFeaturesEXT, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, VkPhysicalDevicePipelineRobustnessFeaturesEXT, VkPhysicalDevicePortabilitySubsetFeaturesKHR, VkPhysicalDevicePresentBarrierFeaturesNV, VkPhysicalDevicePresentIdFeaturesKHR, VkPhysicalDevicePresentWaitFeaturesKHR, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, VkPhysicalDevicePrivateDataFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProvokingVertexFeaturesEXT, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, VkPhysicalDeviceRayQueryFeaturesKHR, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, VkPhysicalDeviceRayTracingPipelineFeaturesKHR, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceRobustness2FeaturesEXT, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderClockFeaturesKHR, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderIntegerDotProductFeatures, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, VkPhysicalDeviceShaderTerminateInvocationFeatures, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceSubgroupSizeControlFeatures, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, VkPhysicalDeviceSynchronization2Features, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeatures, VkPhysicalDeviceTilePropertiesFeaturesQCOM, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, VkPhysicalDeviceVulkan11Features, VkPhysicalDeviceVulkan12Features, VkPhysicalDeviceVulkan13Features, VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, or VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pProperties-04451", "If the VK_KHR_portability_subset extension is included in pProperties of vkEnumerateDeviceExtensionProperties, ppEnabledExtensionNames must include \"VK_KHR_portability_subset\"", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pQueueCreateInfos-06654", "If multiple elements of pQueueCreateInfos share the same queueFamilyIndex, then all of such elements must have the same global priority level, which can be specified explicitly by the including a VkDeviceQueueGlobalPriorityCreateInfoKHR structure in the pNext chain, or by the implicit default value", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pQueueCreateInfos-06755", "If multiple elements of pQueueCreateInfos share the same queueFamilyIndex, the sum of their queueCount members must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex]", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter", "pQueueCreateInfos must be a valid pointer to an array of queueCreateInfoCount valid VkDeviceQueueCreateInfo structures", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-00374", "ppEnabledExtensionNames must not contain both VK_KHR_maintenance1 and VK_AMD_negative_viewport_height", "1.0-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-01840", "ppEnabledExtensionNames must not contain VK_AMD_negative_viewport_height", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02831", "If ppEnabledExtensionNames contains \"VK_KHR_draw_indirect_count\" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::drawIndirectCount must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02832", "If ppEnabledExtensionNames contains \"VK_KHR_sampler_mirror_clamp_to_edge\" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::samplerMirrorClampToEdge must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02833", "If ppEnabledExtensionNames contains \"VK_EXT_descriptor_indexing\" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::descriptorIndexing must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02834", "If ppEnabledExtensionNames contains \"VK_EXT_sampler_filter_minmax\" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::samplerFilterMinmax must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02835", "If ppEnabledExtensionNames contains \"VK_EXT_shader_viewport_index_layer\" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::shaderOutputViewportIndex and VkPhysicalDeviceVulkan12Features::shaderOutputLayer must both be VK_TRUE", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-03328", "ppEnabledExtensionNames must not contain both VK_KHR_buffer_device_address and VK_EXT_buffer_device_address", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-04476", "If ppEnabledExtensionNames contains \"VK_KHR_shader_draw_parameters\" and the pNext chain includes a VkPhysicalDeviceVulkan11Features structure, then VkPhysicalDeviceVulkan11Features::shaderDrawParameters must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter", "If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter", "If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength", "queueCreateInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-queueFamilyIndex-00372", "The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos", "1.0-extensions"},
    {"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802", "The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos, except that two members can share the same queueFamilyIndex if one describes protected-capable queues and one describes queues that are not protected-capable", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkDeviceDeviceMemoryReportCreateInfoEXT or VkDevicePrivateDataCreateInfo", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-shadingRateImage-04478", "If the shadingRateImage feature is enabled, the pipelineFragmentShadingRate feature must not be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-shadingRateImage-04479", "If the shadingRateImage feature is enabled, the primitiveFragmentShadingRate feature must not be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-shadingRateImage-04480", "If the shadingRateImage feature is enabled, the attachmentFragmentShadingRate feature must not be enabled", "1.3-extensions"},
    {"VUID-VkDeviceCreateInfo-sparseImageFloat32AtomicMinMax-04975", "If sparseImageFloat32AtomicMinMax is enabled, shaderImageFloat32AtomicMinMax must be enabled", "1.3-extensions"},
    {"VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pUserData-parameter", "pUserData must be a pointer value", "1.3-extensions"},
    {"VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pfnUserCallback-parameter", "pfnUserCallback must be a valid PFN_vkDeviceMemoryReportCallbackEXT value", "1.3-extensions"},
    {"VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDeviceDiagnosticsConfigCreateInfoNV-flags-parameter", "flags must be a valid combination of VkDeviceDiagnosticsConfigFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkDeviceDiagnosticsConfigCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkDeviceEventInfoEXT-deviceEvent-parameter", "deviceEvent must be a valid VkDeviceEventTypeEXT value", "1.3-extensions"},
    {"VUID-VkDeviceEventInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceEventInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDeviceFaultAddressInfoEXT-addressType-parameter", "addressType must be a valid VkDeviceFaultAddressTypeEXT value", "1.3-extensions"},
    {"VUID-VkDeviceFaultCountsEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceFaultCountsEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT", "1.3-extensions"},
    {"VUID-VkDeviceFaultInfoEXT-pAddressInfos-parameter", "If pAddressInfos is not NULL, pAddressInfos must be a valid pointer to a VkDeviceFaultAddressInfoEXT structure", "1.3-extensions"},
    {"VUID-VkDeviceFaultInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceFaultInfoEXT-pVendorInfos-parameter", "If pVendorInfos is not NULL, pVendorInfos must be a valid pointer to a VkDeviceFaultVendorInfoEXT structure", "1.3-extensions"},
    {"VUID-VkDeviceFaultInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDeviceFaultVendorBinaryHeaderVersionOneEXT-headerSize-07340", "headerSize must be 56", "1.3-extensions"},
    {"VUID-VkDeviceFaultVendorBinaryHeaderVersionOneEXT-headerVersion-07341", "headerVersion must be VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT", "1.3-extensions"},
    {"VUID-VkDeviceFaultVendorBinaryHeaderVersionOneEXT-headerVersion-parameter", "headerVersion must be a valid VkDeviceFaultVendorBinaryHeaderVersionEXT value", "1.3-extensions"},
    {"VUID-VkDeviceGroupBindSparseInfo-memoryDeviceIndex-01119", "Each memory allocation bound in this batch must have allocated an instance for memoryDeviceIndex", "1.3-extensions"},
    {"VUID-VkDeviceGroupBindSparseInfo-resourceDeviceIndex-01118", "resourceDeviceIndex and memoryDeviceIndex must both be valid device indices", "1.3-extensions"},
    {"VUID-VkDeviceGroupBindSparseInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO", "1.3-extensions"},
    {"VUID-VkDeviceGroupCommandBufferBeginInfo-deviceMask-00106", "deviceMask must be a valid device mask value", "1.3-extensions"},
    {"VUID-VkDeviceGroupCommandBufferBeginInfo-deviceMask-00107", "deviceMask must not be zero", "1.3-extensions"},
    {"VUID-VkDeviceGroupCommandBufferBeginInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO", "1.3-extensions"},
    {"VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00375", "Each element of pPhysicalDevices must be unique", "1.3-extensions"},
    {"VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00376", "All elements of pPhysicalDevices must be in the same device group as enumerated by vkEnumeratePhysicalDeviceGroups", "1.3-extensions"},
    {"VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter", "If physicalDeviceCount is not 0, pPhysicalDevices must be a valid pointer to an array of physicalDeviceCount valid VkPhysicalDevice handles", "1.3-extensions"},
    {"VUID-VkDeviceGroupDeviceCreateInfo-physicalDeviceCount-00377", "If physicalDeviceCount is not 0, the physicalDevice parameter of vkCreateDevice must be an element of pPhysicalDevices", "1.3-extensions"},
    {"VUID-VkDeviceGroupDeviceCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentCapabilitiesKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentCapabilitiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-mode-01298", "If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-mode-01299", "If mode is VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR, then each element of pDeviceMasks must have exactly one bit set, and some physical device in the logical device must include that bit in its VkDeviceGroupPresentCapabilitiesKHR::presentMask", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-mode-01300", "If mode is VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR, then each element of pDeviceMasks must have a value for which all set bits are set in one of the elements of VkDeviceGroupPresentCapabilitiesKHR::presentMask", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-mode-01301", "If mode is VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR, then for each bit set in each element of pDeviceMasks, the corresponding element of VkDeviceGroupPresentCapabilitiesKHR::presentMask must be non-zero", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-mode-01303", "mode must have exactly one bit set, and that bit must have been included in VkDeviceGroupSwapchainCreateInfoKHR::modes", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-mode-parameter", "mode must be a valid VkDeviceGroupPresentModeFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-01302", "The value of each element of pDeviceMasks must be equal to the device mask passed in VkAcquireNextImageInfoKHR::deviceMask when the image index was last acquired", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-pDeviceMasks-parameter", "If swapchainCount is not 0, pDeviceMasks must be a valid pointer to an array of swapchainCount uint32_t values", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkDeviceGroupPresentInfoKHR-swapchainCount-01297", "swapchainCount must equal 0 or VkPresentInfoKHR::swapchainCount", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00905", "deviceMask must be a valid device mask value", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00906", "deviceMask must not be zero", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-deviceMask-00907", "deviceMask must be a subset of the command buffer's initial device mask", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-deviceRenderAreaCount-00908", "deviceRenderAreaCount must either be zero or equal to the number of physical devices in the logical device", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06166", "The offset.x member of any element of pDeviceRenderAreas must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06167", "The offset.y member of any element of pDeviceRenderAreas must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06168", "The sum of the offset.x and extent.width members of any element of pDeviceRenderAreas must be less than or equal to maxFramebufferWidth", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06169", "The sum of the offset.y and extent.height members of any element of pDeviceRenderAreas must be less than or equal to maxFramebufferHeight", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-pDeviceRenderAreas-parameter", "If deviceRenderAreaCount is not 0, pDeviceRenderAreas must be a valid pointer to an array of deviceRenderAreaCount VkRect2D structures", "1.3-extensions"},
    {"VUID-VkDeviceGroupRenderPassBeginInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-commandBufferCount-00083", "commandBufferCount must equal VkSubmitInfo::commandBufferCount", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-00086", "All elements of pCommandBufferDeviceMasks must be valid device masks", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-pCommandBufferDeviceMasks-parameter", "If commandBufferCount is not 0, pCommandBufferDeviceMasks must be a valid pointer to an array of commandBufferCount uint32_t values", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-pSignalSemaphoreDeviceIndices-parameter", "If signalSemaphoreCount is not 0, pSignalSemaphoreDeviceIndices must be a valid pointer to an array of signalSemaphoreCount uint32_t values", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-00085", "All elements of pWaitSemaphoreDeviceIndices and pSignalSemaphoreDeviceIndices must be valid device indices", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-pWaitSemaphoreDeviceIndices-parameter", "If waitSemaphoreCount is not 0, pWaitSemaphoreDeviceIndices must be a valid pointer to an array of waitSemaphoreCount uint32_t values", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-signalSemaphoreCount-00084", "signalSemaphoreCount must equal VkSubmitInfo::signalSemaphoreCount", "1.3-extensions"},
    {"VUID-VkDeviceGroupSubmitInfo-waitSemaphoreCount-00082", "waitSemaphoreCount must equal VkSubmitInfo::waitSemaphoreCount", "1.3-extensions"},
    {"VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-parameter", "modes must be a valid combination of VkDeviceGroupPresentModeFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkDeviceGroupSwapchainCreateInfoKHR-modes-requiredbitmask", "modes must not be 0", "1.3-extensions"},
    {"VUID-VkDeviceGroupSwapchainCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06776", "The pCreateInfo::pNext chain must not contain a VkImageDrmFormatModifierExplicitCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkImageCreateInfo structure", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirements-pNext-06996", "Applications also must not call vkGetDeviceImageMemoryRequirements with a VkImageCreateInfo whose pNext chain includes a VkExternalFormatANDROID structure with non-zero externalFormat.", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirements-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirements-planeAspect-parameter", "If planeAspect is not 0, planeAspect must be a valid VkImageAspectFlagBits value", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirements-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirementsKHR-pCreateInfo-06416", "The pCreateInfo::pNext chain must not contain a VkImageSwapchainCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirementsKHR-pCreateInfo-06417", "If pCreateInfo::format specifies a multi-planar format and pCreateInfo::flags has VK_IMAGE_CREATE_DISJOINT_BIT set then planeAspect must not be VK_IMAGE_ASPECT_NONE_KHR", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirementsKHR-pCreateInfo-06419", "If pCreateInfo::flags has VK_IMAGE_CREATE_DISJOINT_BIT set and if the pCreateInfo::tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image (that is, for a two-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT, and for a three-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT)", "1.3-extensions"},
    {"VUID-VkDeviceImageMemoryRequirementsKHR-pCreateInfo-06420", "If pCreateInfo::tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image (that is, aspectMask must specify a plane index that is less than the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with the image's format and VkImageDrmFormatModifierPropertiesEXT::drmFormatModifier)", "1.3-extensions"},
    {"VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-memory-03336", "memory must have been allocated with VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT", "1.3-extensions"},
    {"VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO", "1.3-extensions"},
    {"VUID-VkDeviceMemoryOverallocationCreateInfoAMD-overallocationBehavior-parameter", "overallocationBehavior must be a valid VkMemoryOverallocationBehaviorAMD value", "1.3-extensions"},
    {"VUID-VkDeviceMemoryOverallocationCreateInfoAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD", "1.3-extensions"},
    {"VUID-VkDeviceMemoryReportCallbackDataEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceMemoryReportCallbackDataEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT", "1.3-extensions"},
    {"VUID-VkDevicePrivateDataCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-flags-02861", "If the protectedMemory feature is not enabled, the VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT bit of flags must not be set", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-flags-06449", "If flags includes VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, queueFamilyIndex must be the index of a queue family that includes the VK_QUEUE_PROTECTED_BIT capability", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-flags-parameter", "flags must be a valid combination of VkDeviceQueueCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkDeviceQueueGlobalPriorityCreateInfoKHR", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383", "Each element of pQueuePriorities must be between 0.0 and 1.0 inclusive", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter", "pQueuePriorities must be a valid pointer to an array of queueCount float values", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-queueCount-00382", "queueCount must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex]", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-queueCount-arraylength", "queueCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkDeviceQueueCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkDeviceQueueGlobalPriorityCreateInfoKHR-globalPriority-parameter", "globalPriority must be a valid VkQueueGlobalPriorityKHR value", "1.3-extensions"},
    {"VUID-VkDeviceQueueGlobalPriorityCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkDeviceQueueInfo2-flags-06225", "flags must be equal to VkDeviceQueueCreateInfo::flags for a VkDeviceQueueCreateInfo structure for the queue family indicated by queueFamilyIndex when device was created", "1.3-extensions"},
    {"VUID-VkDeviceQueueInfo2-flags-parameter", "flags must be a valid combination of VkDeviceQueueCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkDeviceQueueInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDeviceQueueInfo2-queueFamilyIndex-01842", "queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure", "1.3-extensions"},
    {"VUID-VkDeviceQueueInfo2-queueIndex-01843", "queueIndex must be less than VkDeviceQueueCreateInfo::queueCount for the corresponding queue family and flags indicated by queueFamilyIndex and flags when device was created", "1.3-extensions"},
    {"VUID-VkDeviceQueueInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2", "1.3-extensions"},
    {"VUID-VkDirectFBSurfaceCreateInfoEXT-dfb-04117", "dfb must point to a valid DirectFB IDirectFB", "1.3-extensions"},
    {"VUID-VkDirectFBSurfaceCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDirectFBSurfaceCreateInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDirectFBSurfaceCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDirectFBSurfaceCreateInfoEXT-surface-04118", "surface must point to a valid DirectFB IDirectFBSurface", "1.3-extensions"},
    {"VUID-VkDispatchIndirectCommand-x-00417", "x must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-VkDispatchIndirectCommand-y-00418", "y must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-VkDispatchIndirectCommand-z-00419", "z must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-VkDisplayEventInfoEXT-displayEvent-parameter", "displayEvent must be a valid VkDisplayEventTypeEXT value", "1.3-extensions"},
    {"VUID-VkDisplayEventInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayEventInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDisplayModeCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDisplayModeCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayModeCreateInfoKHR-parameters-parameter", "parameters must be a valid VkDisplayModeParametersKHR structure", "1.3-extensions"},
    {"VUID-VkDisplayModeCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkDisplayModeParametersKHR-height-01991", "The height member of visibleRegion must be greater than 0", "1.3-extensions"},
    {"VUID-VkDisplayModeParametersKHR-refreshRate-01992", "refreshRate must be greater than 0", "1.3-extensions"},
    {"VUID-VkDisplayModeParametersKHR-width-01990", "The width member of visibleRegion must be greater than 0", "1.3-extensions"},
    {"VUID-VkDisplayModeProperties2KHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayModeProperties2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR", "1.3-extensions"},
    {"VUID-VkDisplayNativeHdrSurfaceCapabilitiesAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD", "1.3-extensions"},
    {"VUID-VkDisplayPlaneCapabilities2KHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayPlaneCapabilities2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR", "1.3-extensions"},
    {"VUID-VkDisplayPlaneInfo2KHR-mode-parameter", "mode must be a valid VkDisplayModeKHR handle", "1.3-extensions"},
    {"VUID-VkDisplayPlaneInfo2KHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayPlaneInfo2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR", "1.3-extensions"},
    {"VUID-VkDisplayPlaneProperties2KHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayPlaneProperties2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR", "1.3-extensions"},
    {"VUID-VkDisplayPowerInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayPowerInfoEXT-powerState-parameter", "powerState must be a valid VkDisplayPowerStateEXT value", "1.3-extensions"},
    {"VUID-VkDisplayPowerInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkDisplayPresentInfoKHR-dstRect-01258", "dstRect must specify a rectangular region that is a subset of the visibleRegion parameter of the display mode the swapchain being presented uses", "1.3-extensions"},
    {"VUID-VkDisplayPresentInfoKHR-persistentContent-01259", "If the persistentContent member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display the present operation targets is VK_FALSE, then persistent must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkDisplayPresentInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkDisplayPresentInfoKHR-srcRect-01257", "srcRect must specify a rectangular region that is a subset of the image being presented", "1.3-extensions"},
    {"VUID-VkDisplayProperties2KHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplayProperties2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254", "If alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then globalAlpha must be between 0 and 1, inclusive", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255", "alphaMode must be one of the bits present in the supportedAlpha member of VkDisplayPlaneCapabilitiesKHR for the display plane corresponding to displayMode", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-parameter", "alphaMode must be a valid VkDisplayPlaneAlphaFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-displayMode-parameter", "displayMode must be a valid VkDisplayModeKHR handle", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252", "planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-planeReorderPossible-01253", "If the planeReorderPossible member of the VkDisplayPropertiesKHR structure returned by vkGetPhysicalDeviceDisplayPropertiesKHR for the display corresponding to displayMode is VK_TRUE then planeStackIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR; otherwise planeStackIndex must equal the currentStackIndex member of VkDisplayPlanePropertiesKHR returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR for the display plane corresponding to displayMode", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-transform-06740", "transform must be one of the bits present in the supportedTransforms member of VkDisplayPropertiesKHR for the display corresponding to displayMode", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-transform-parameter", "transform must be a valid VkSurfaceTransformFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkDisplaySurfaceCreateInfoKHR-width-01256", "The width and height members of imageExtent must be less than or equal to VkPhysicalDeviceLimits::maxImageDimension2D", "1.3-extensions"},
    {"VUID-VkDrawIndexedIndirectCommand-None-00552", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-VkDrawIndexedIndirectCommand-firstInstance-00554", "If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0", "1.3-extensions"},
    {"VUID-VkDrawIndexedIndirectCommand-indexSize-00553", "(indexSize {times} (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer", "1.3-extensions"},
    {"VUID-VkDrawIndirectCommand-None-00500", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-VkDrawIndirectCommand-firstInstance-00501", "If the drawIndirectFirstInstance feature is not enabled, firstInstance must be 0", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07322", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, groupCountX must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07323", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, groupCountY must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07324", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07325", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, The product of groupCountX, groupCountY and groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupTotalCount", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07326", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, groupCountX must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07327", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, groupCountY must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07328", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandEXT-TaskEXT-07329", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, The product of groupCountX, groupCountY and groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupTotalCount", "1.3-extensions"},
    {"VUID-VkDrawMeshTasksIndirectCommandNV-taskCount-02175", "taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount", "1.3-extensions"},
    {"VUID-VkDrmFormatModifierPropertiesList2EXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT", "1.3-extensions"},
    {"VUID-VkDrmFormatModifierPropertiesListEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT", "1.3-extensions"},
    {"VUID-VkEventCreateInfo-flags-parameter", "flags must be a valid combination of VkEventCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkEventCreateInfo-pNext-06790", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkEventCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportMetalObjectCreateInfoEXT or VkImportMetalSharedEventInfoEXT", "1.3-extensions"},
    {"VUID-VkEventCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkEventCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkExportFenceCreateInfo-handleTypes-01446", "The bits in handleTypes must be supported and compatible, as reported by VkExternalFenceProperties", "1.3-extensions"},
    {"VUID-VkExportFenceCreateInfo-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalFenceHandleTypeFlagBits values", "1.3-extensions"},
    {"VUID-VkExportFenceCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkExportFenceWin32HandleInfoKHR-handleTypes-01447", "If VkExportFenceCreateInfo::handleTypes does not include VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, a VkExportFenceWin32HandleInfoKHR structure must not be included in the pNext chain of VkFenceCreateInfo", "1.3-extensions"},
    {"VUID-VkExportFenceWin32HandleInfoKHR-pAttributes-parameter", "If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value", "1.3-extensions"},
    {"VUID-VkExportFenceWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkExportMemoryAllocateInfo-handleTypes-00656", "The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties", "1.3-extensions"},
    {"VUID-VkExportMemoryAllocateInfo-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values", "1.3-extensions"},
    {"VUID-VkExportMemoryAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkExportMemoryAllocateInfoNV-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkExportMemoryAllocateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkExportMemoryWin32HandleInfoKHR-handleTypes-00657", "If VkExportMemoryAllocateInfo::handleTypes does not include VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, a VkExportMemoryWin32HandleInfoKHR structure must not be included in the pNext chain of VkMemoryAllocateInfo", "1.3-extensions"},
    {"VUID-VkExportMemoryWin32HandleInfoKHR-pAttributes-parameter", "If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value", "1.3-extensions"},
    {"VUID-VkExportMemoryWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkExportMemoryWin32HandleInfoNV-pAttributes-parameter", "If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value", "1.3-extensions"},
    {"VUID-VkExportMemoryWin32HandleInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV", "1.3-extensions"},
    {"VUID-VkExportMetalBufferInfoEXT-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkExportMetalBufferInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalCommandQueueInfoEXT-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-VkExportMetalCommandQueueInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalDeviceInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalIOSurfaceInfoEXT-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkExportMetalIOSurfaceInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalObjectCreateInfoEXT-exportObjectType-parameter", "If exportObjectType is not 0, exportObjectType must be a valid VkExportMetalObjectTypeFlagBitsEXT value", "1.3-extensions"},
    {"VUID-VkExportMetalObjectCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06791", "If the pNext chain includes a VkExportMetalDeviceInfoEXT structure, the VkInstance must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkInstanceCreateInfo structure in the vkCreateInstance command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06792", "If the pNext chain includes a VkExportMetalCommandQueueInfoEXT structure, the VkInstance must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkInstanceCreateInfo structure in the vkCreateInstance command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06793", "If the pNext chain includes a VkExportMetalBufferInfoEXT structure, the VkDeviceMemory in its memory member must have been allocated with VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkMemoryAllocateInfo structure in the vkAllocateMemory command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06794", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, exactly one of its image, imageView, or bufferView members must not be VK_NULL_HANDLE.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06795", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and its image member is not VK_NULL_HANDLE, the VkImage in its image member must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkImageCreateInfo structure in the vkCreateImage command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06796", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and its imageView member is not VK_NULL_HANDLE, the VkImageView in its imageView member must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkImageViewCreateInfo structure in the vkCreateImageView command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06797", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and its bufferView member is not VK_NULL_HANDLE, the VkBufferView in its bufferView member must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkBufferViewCreateInfo structure in the vkCreateBufferView command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06798", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and if either its image or imageView member is not VK_NULL_HANDLE, then plane must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06799", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and if the VkImage in its image member does not have a multi-planar format, then its plane member must be VK_IMAGE_ASPECT_PLANE_0_BIT.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06800", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and if the VkImage in its image member has a multi-planar format with only two planes, then its plane member must not be VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06801", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and if the VkImageView in its imageView member does not have a multi-planar format, then its plane member must be VK_IMAGE_ASPECT_PLANE_0_BIT.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06802", "If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and if the VkImageView in its imageView member has a multi-planar format with only two planes, then its plane member must not be VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06803", "If the pNext chain includes a VkExportMetalIOSurfaceInfoEXT structure, the VkImage in its image member must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkImageCreateInfo structure in the vkCreateImage command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06804", "If the pNext chain includes a VkExportMetalSharedEventInfoEXT structure, exactly one of its semaphore or event members must not be VK_NULL_HANDLE.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06805", "If the pNext chain includes a VkExportMetalSharedEventInfoEXT structure, and its semaphore member is not VK_NULL_HANDLE, the VkSemaphore in its semaphore member must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkSemaphoreCreateInfo structure in the vkCreateSemaphore command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-06806", "If the pNext chain includes a VkExportMetalSharedEventInfoEXT structure, and its event member is not VK_NULL_HANDLE, the VkEvent in its event member must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkEventCreateInfo structure in the vkCreateEvent command.", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportMetalBufferInfoEXT, VkExportMetalCommandQueueInfoEXT, VkExportMetalDeviceInfoEXT, VkExportMetalIOSurfaceInfoEXT, VkExportMetalSharedEventInfoEXT, or VkExportMetalTextureInfoEXT", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalObjectsInfoEXT-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalBufferInfoEXT, VkExportMetalCommandQueueInfoEXT, VkExportMetalIOSurfaceInfoEXT, VkExportMetalSharedEventInfoEXT, or VkExportMetalTextureInfoEXT", "1.3-extensions"},
    {"VUID-VkExportMetalSharedEventInfoEXT-commonparent", "Both of event, and semaphore that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkExportMetalSharedEventInfoEXT-event-parameter", "If event is not VK_NULL_HANDLE, event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-VkExportMetalSharedEventInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportMetalSharedEventInfoEXT-semaphore-parameter", "If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkExportMetalTextureInfoEXT-bufferView-parameter", "If bufferView is not VK_NULL_HANDLE, bufferView must be a valid VkBufferView handle", "1.3-extensions"},
    {"VUID-VkExportMetalTextureInfoEXT-commonparent", "Each of bufferView, image, and imageView that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkExportMetalTextureInfoEXT-image-parameter", "If image is not VK_NULL_HANDLE, image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkExportMetalTextureInfoEXT-imageView-parameter", "If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkExportMetalTextureInfoEXT-plane-parameter", "plane must be a valid VkImageAspectFlagBits value", "1.3-extensions"},
    {"VUID-VkExportMetalTextureInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkExportSemaphoreCreateInfo-handleTypes-01124", "The bits in handleTypes must be supported and compatible, as reported by VkExternalSemaphoreProperties", "1.3-extensions"},
    {"VUID-VkExportSemaphoreCreateInfo-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalSemaphoreHandleTypeFlagBits values", "1.3-extensions"},
    {"VUID-VkExportSemaphoreCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkExportSemaphoreWin32HandleInfoKHR-handleTypes-01125", "If VkExportSemaphoreCreateInfo::handleTypes does not include VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, VkExportSemaphoreWin32HandleInfoKHR must not be included in the pNext chain of VkSemaphoreCreateInfo", "1.3-extensions"},
    {"VUID-VkExportSemaphoreWin32HandleInfoKHR-pAttributes-parameter", "If pAttributes is not NULL, pAttributes must be a valid pointer to a valid SECURITY_ATTRIBUTES value", "1.3-extensions"},
    {"VUID-VkExportSemaphoreWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkExternalBufferProperties-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkExternalBufferProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES", "1.3-extensions"},
    {"VUID-VkExternalFenceProperties-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkExternalFenceProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES", "1.3-extensions"},
    {"VUID-VkExternalFormatANDROID-externalFormat-01894", "externalFormat must be 0 or a value returned in the externalFormat member of VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call to vkGetAndroidHardwareBufferPropertiesANDROID", "1.3-extensions"},
    {"VUID-VkExternalFormatANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID", "1.3-extensions"},
    {"VUID-VkExternalImageFormatProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES", "1.3-extensions"},
    {"VUID-VkExternalMemoryBufferCreateInfo-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values", "1.3-extensions"},
    {"VUID-VkExternalMemoryBufferCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkExternalMemoryImageCreateInfo-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBits values", "1.3-extensions"},
    {"VUID-VkExternalMemoryImageCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkExternalMemoryImageCreateInfoNV-handleTypes-parameter", "handleTypes must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkExternalMemoryImageCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkExternalSemaphoreProperties-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkExternalSemaphoreProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES", "1.3-extensions"},
    {"VUID-VkFenceCreateInfo-flags-parameter", "flags must be a valid combination of VkFenceCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkFenceCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportFenceCreateInfo or VkExportFenceWin32HandleInfoKHR", "1.3-extensions"},
    {"VUID-VkFenceCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkFenceCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-fence-01455", "fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-fence-parameter", "fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-handleType-01453", "handleType must have been included in VkExportFenceCreateInfo::handleTypes when fence's current payload was created", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-handleType-01454", "If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-handleType-01456", "handleType must be defined as a POSIX file descriptor handle", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-handleType-parameter", "handleType must be a valid VkExternalFenceHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkFenceGetFdInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-fence-01450", "fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-fence-parameter", "fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-handleType-01448", "handleType must have been included in VkExportFenceCreateInfo::handleTypes when the fence's current payload was created", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-handleType-01449", "If handleType is defined as an NT handle, vkGetFenceWin32HandleKHR must be called no more than once for each valid unique combination of fence and handleType", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-handleType-01451", "If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-handleType-01452", "handleType must be defined as an NT handle or a global share handle", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter", "handleType must be a valid VkExternalFenceHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkFenceGetWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-pNext-02627", "If the pNext chain of the VkImageFormatProperties2 structure includes a VkFilterCubicImageViewImageFormatPropertiesEXT structure, the pNext chain of the VkPhysicalDeviceImageFormatInfo2 structure must include a VkPhysicalDeviceImageViewImageFormatInfoEXT structure with an imageViewType that is compatible with imageType", "1.3-extensions"},
    {"VUID-VkFilterCubicImageViewImageFormatPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkFormatProperties2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDrmFormatModifierPropertiesList2EXT, VkDrmFormatModifierPropertiesListEXT, VkFormatProperties3, or VkSubpassResolvePerformanceQueryEXT", "1.3-extensions"},
    {"VUID-VkFormatProperties2-sType-sType", "sType must be VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2", "1.3-extensions"},
    {"VUID-VkFormatProperties2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkFormatProperties3-sType-sType", "sType must be VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04524", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, its layout member must be equal to VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04525", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.width must be a power of two value", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04526", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.width must be less than or equal to maxFragmentShadingRateAttachmentTexelSize.width", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04527", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.width must be greater than or equal to minFragmentShadingRateAttachmentTexelSize.width", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04528", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.height must be a power of two value", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04529", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.height must be less than or equal to maxFragmentShadingRateAttachmentTexelSize.height", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04530", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.height must be greater than or equal to minFragmentShadingRateAttachmentTexelSize.height", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04531", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, the quotient of shadingRateAttachmentTexelSize.width and shadingRateAttachmentTexelSize.height must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04532", "If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, the quotient of shadingRateAttachmentTexelSize.height and shadingRateAttachmentTexelSize.width must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-parameter", "If pFragmentShadingRateAttachment is not NULL, pFragmentShadingRateAttachment must be a valid pointer to a valid VkAttachmentReference2 structure", "1.3-extensions"},
    {"VUID-VkFragmentShadingRateAttachmentInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentImageInfo-flags-parameter", "flags must be a valid combination of VkImageCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentImageInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentImageInfo-pViewFormats-parameter", "If viewFormatCount is not 0, pViewFormats must be a valid pointer to an array of viewFormatCount valid VkFormat values", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentImageInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentImageInfo-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentImageInfo-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentsCreateInfo-pAttachmentImageInfos-parameter", "If attachmentImageInfoCount is not 0, pAttachmentImageInfos must be a valid pointer to an array of attachmentImageInfoCount valid VkFramebufferAttachmentImageInfo structures", "1.3-extensions"},
    {"VUID-VkFramebufferAttachmentsCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-attachmentCount-00876", "attachmentCount must be equal to the attachment count specified in renderPass", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-commonparent", "Both of renderPass, and the elements of pAttachments that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-02778", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT and attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkImageView handles", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03189", "If the imagelessFramebuffer feature is not enabled, flags must not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03190", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the pNext chain must include a VkFramebufferAttachmentsCreateInfo structure", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03191", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the attachmentImageInfoCount member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain must be equal to either zero or attachmentCount", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03196", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the width member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is referenced by VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment in renderPass must be greater than or equal to the ceiling of width/maxFragmentDensityTexelSize.width", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03197", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the height member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that is referenced by VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment in renderPass must be greater than or equal to the ceiling of height/maxFragmentDensityTexelSize.height", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03201", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the usage member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that refers to an attachment used as a color attachment or resolve attachment by renderPass must include VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03202", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the usage member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that refers to an attachment used as a depth/stencil attachment by renderPass must include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03203", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the usage member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that refers to an attachment used as a depth/stencil resolve attachment by renderPass must include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03204", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the usage member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that refers to an attachment used as an input attachment by renderPass must include VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-03205", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, at least one element of the pViewFormats member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain must be equal to the corresponding value of VkAttachmentDescription::format used to create renderPass", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04113", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with VkImageViewCreateInfo::viewType not equal to VK_IMAGE_VIEW_TYPE_3D", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04533", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have been created with a VkImageCreateInfo::extent.width greater than or equal to width", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04534", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have been created with a VkImageCreateInfo::extent.height greater than or equal to height", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04535", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have been created with a VkImageViewCreateInfo::subresourceRange.layerCount greater than or equal to layers", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04537", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and renderPass was specified with non-zero view masks, each element of pAttachments that is used as a fragment shading rate attachment by renderPass must have a layerCount that is either 1, or greater than the index of the most significant bit set in any of those view masks", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04538", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and renderPass was not specified with non-zero view masks, each element of pAttachments that is used as a fragment shading rate attachment by renderPass must have a layerCount that is either 1, or greater than layers", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04539", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is used as a fragment shading rate attachment must have a width at least as large as {lceil}width / texelWidth{rceil}, where texelWidth is the largest value of shadingRateAttachmentTexelSize.width in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04540", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is used as a fragment shading rate attachment must have a height at least as large as {lceil}height / texelHeight{rceil}, where texelHeight is the largest value of shadingRateAttachmentTexelSize.height in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04541", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the width member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as an input, color, resolve or depth/stencil attachment in renderPass must be greater than or equal to width", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04542", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the height member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as an input, color, resolve or depth/stencil attachment in renderPass must be greater than or equal to height", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04543", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the width member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be greater than or equal to {lceil}width / texelWidth{rceil}, where texelWidth is the largest value of shadingRateAttachmentTexelSize.width in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04544", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the height member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be greater than or equal to {lceil}height / texelHeight{rceil}, where texelHeight is the largest value of shadingRateAttachmentTexelSize.height in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04545", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be either 1, or greater than or equal to layers", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04547", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain used as an input, color, resolve, or depth/stencil attachment in pRenderPass must be greater than or equal to layers", "default"},
    {"VUID-VkFramebufferCreateInfo-flags-04548", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as a fragment shading rate attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04549", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the usage member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that refers to an attachment used as a fragment shading rate attachment by renderPass must include VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-04587", "If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT and renderPass was specified with non-zero view masks, each element of pAttachments that is used as a fragment shading rate attachment by renderPass must have a layerCount that is either 1, or greater than the index of the most significant bit set in any of those view masks", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-flags-parameter", "flags must be a valid combination of VkFramebufferCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-height-00887", "height must be greater than 0", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-height-00888", "height must be less than or equal to maxFramebufferHeight", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-layers-00889", "layers must be greater than 0", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-layers-00890", "layers must be less than or equal to maxFramebufferLayers", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00877", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as a color attachment or resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00879", "If renderpass is not VK_NULL_HANDLE, flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00880", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with a VkFormat value that matches the VkFormat specified by the corresponding VkAttachmentDescription in renderPass", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00881", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with a samples value that matches the samples value specified by the corresponding VkAttachmentDescription in renderPass", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00883", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must only specify a single mip level", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00884", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with the identity swizzle", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-00891", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is a 2D or 2D array image view taken from a 3D image must not be a depth/stencil format", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-02552", "Each element of pAttachments that is used as a fragment density map attachment by renderPass must not have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-02555", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is referenced by fragmentDensityMapAttachment must have a width at least as large as the ceiling of width/maxFragmentDensityTexelSize.width", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-02556", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is referenced by fragmentDensityMapAttachment must have a height at least as large as the ceiling of height/maxFragmentDensityTexelSize.height", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-02633", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as a depth/stencil attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-02634", "If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as a depth/stencil resolve attachment by renderPass must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-pAttachments-02744", "Each element of pAttachments that is referenced by fragmentDensityMapAttachment must have a layerCount equal to 1", "default"},
    {"VUID-VkFramebufferCreateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkFramebufferAttachmentsCreateInfo", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-02531", "If renderPass was specified with non-zero view masks, layers must be 1", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-02553", "If renderPass has a fragment density map attachment and the fragmentDensityMapNonSubsampledImages feature is not enabled, each element of pAttachments must have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT unless that element is the fragment density map attachment", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-02746", "If renderPass was specified with non-zero view masks, each element of pAttachments that is referenced by fragmentDensityMapAttachment must have a layerCount equal to 1 or greater than the index of the most significant bit set in any of those view masks", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-02747", "If renderPass was not specified with non-zero view masks, each element of pAttachments that is referenced by fragmentDensityMapAttachment must have a layerCount equal to 1", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-03198", "If multiview is enabled for renderPass and flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain used as an input, color, resolve, or depth/stencil attachment in renderPass must be greater than the maximum bit index set in the view mask in the subpasses in which it is used in renderPass", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-04536", "If renderPass was specified with non-zero view masks, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have a layerCount greater than the index of the most significant bit set in any of those view masks", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-04546", "If multiview is not enabled for renderPass and flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain used as an input, color, resolve, or depth/stencil attachment in renderPass must be greater than or equal to layers", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-06502", "If renderPass was created with fragment density map offsets other than (0,0), each element of pAttachments must have been created with a flags value including VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM.", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-renderPass-parameter", "renderPass must be a valid VkRenderPass handle", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-samples-06881", "If multisampled-render-to-single-sampled is enabled for any subpass, all color, depth/stencil and input attachments used in that subpass which have VkAttachmentDescription::samples or VkAttachmentDescription2::samples equal to VK_SAMPLE_COUNT_1_BIT must have been created with VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT in their VkImageCreateInfo::flags.", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-samples-07009", "If multisampled-render-to-single-sampled is enabled for any subpass, all color, depth/stencil and input attachments used in that subpass which have VkAttachmentDescription::samples or VkAttachmentDescription2::samples equal to VK_SAMPLE_COUNT_1_BIT must have a format that supports the sample count specified in VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-width-00885", "width must be greater than 0", "1.3-extensions"},
    {"VUID-VkFramebufferCreateInfo-width-00886", "width must be less than or equal to maxFramebufferWidth", "1.3-extensions"},
    {"VUID-VkFramebufferMixedSamplesCombinationNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkFramebufferMixedSamplesCombinationNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-commonparent", "Each of indirectCommandsLayout, pipeline, preprocessBuffer, sequencesCountBuffer, and sequencesIndexBuffer that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02913", "If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the pipeline must have been created with multiple shader groups", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02914", "If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the pipeline must have been created with VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set in VkGraphicsPipelineCreateInfo::flags", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02915", "If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, then the pipeline`s VkPipelineLayout must match the VkIndirectCommandsLayoutTokenNV::pushconstantPipelineLayout", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-07078", "If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV, then the pipeline must contain a shader stage using the MeshNV {ExecutionModel}.", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-07079", "If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV, then the pipeline must contain a shader stage using the MeshEXT {ExecutionModel}.", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-parameter", "indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNV handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-pStreams-parameter", "pStreams must be a valid pointer to an array of streamCount valid VkIndirectCommandsStreamNV structures", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-pipeline-02912", "The provided pipeline must match the pipeline bound at execution time", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-02918", "preprocessBuffer must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set in its usage flag", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-02971", "If preprocessBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-parameter", "preprocessBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-preprocessOffset-02919", "preprocessOffset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minIndirectCommandsBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-preprocessSize-02920", "preprocessSize must be at least equal to the memory requirement`s size returned by vkGetGeneratedCommandsMemoryRequirementsNV using the matching inputs (indirectCommandsLayout, ...) as within this structure", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesCount-02917", "sequencesCount must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectSequenceCount and VkGeneratedCommandsMemoryRequirementsInfoNV::maxSequencesCount that was used to determine the preprocessSize", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02921", "sequencesCountBuffer can be set if the actual used count of sequences is sourced from the provided buffer. In that case the sequencesCount serves as upper bound", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02922", "If sequencesCountBuffer is not VK_NULL_HANDLE, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02923", "If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountOffset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minSequencesCountBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02972", "If sequencesCountBuffer is not VK_NULL_HANDLE and is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-parameter", "If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02924", "If indirectCommandsLayout's VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV is set, sequencesIndexBuffer must be set otherwise it must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02925", "If sequencesIndexBuffer is not VK_NULL_HANDLE, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02926", "If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexOffset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minSequencesIndexBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02973", "If sequencesIndexBuffer is not VK_NULL_HANDLE and is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-parameter", "If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-streamCount-02916", "streamCount must match the indirectCommandsLayout's streamCount", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength", "streamCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-commonparent", "Both of indirectCommandsLayout, and pipeline must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-indirectCommandsLayout-parameter", "indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNV handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-maxSequencesCount-02907", "maxSequencesCount must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectSequenceCount", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV", "1.3-extensions"},
    {"VUID-VkGeometryAABBNV-aabbData-parameter", "If aabbData is not VK_NULL_HANDLE, aabbData must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeometryAABBNV-offset-02439", "offset must be less than the size of aabbData", "1.3-extensions"},
    {"VUID-VkGeometryAABBNV-offset-02440", "offset must be a multiple of 8", "1.3-extensions"},
    {"VUID-VkGeometryAABBNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkGeometryAABBNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV", "1.3-extensions"},
    {"VUID-VkGeometryAABBNV-stride-02441", "stride must be a multiple of 8", "1.3-extensions"},
    {"VUID-VkGeometryDataNV-aabbs-parameter", "aabbs must be a valid VkGeometryAABBNV structure", "1.3-extensions"},
    {"VUID-VkGeometryDataNV-triangles-parameter", "triangles must be a valid VkGeometryTrianglesNV structure", "1.3-extensions"},
    {"VUID-VkGeometryNV-flags-parameter", "flags must be a valid combination of VkGeometryFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkGeometryNV-geometry-parameter", "geometry must be a valid VkGeometryDataNV structure", "1.3-extensions"},
    {"VUID-VkGeometryNV-geometryType-03503", "geometryType must be VK_GEOMETRY_TYPE_TRIANGLES_NV or VK_GEOMETRY_TYPE_AABBS_NV", "1.3-extensions"},
    {"VUID-VkGeometryNV-geometryType-parameter", "geometryType must be a valid VkGeometryTypeKHR value", "1.3-extensions"},
    {"VUID-VkGeometryNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkGeometryNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GEOMETRY_NV", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-commonparent", "Each of indexData, transformData, and vertexData that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexCount-02436", "indexCount must be 0 if indexType is VK_INDEX_TYPE_NONE_NV", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexData-02434", "indexData must be VK_NULL_HANDLE if indexType is VK_INDEX_TYPE_NONE_NV", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexData-02435", "indexData must be a valid VkBuffer handle if indexType is not VK_INDEX_TYPE_NONE_NV", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexData-parameter", "If indexData is not VK_NULL_HANDLE, indexData must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexOffset-02431", "indexOffset must be less than the size of indexData", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexOffset-02432", "indexOffset must be a multiple of the element size of indexType", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexType-02433", "indexType must be VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_NV", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-indexType-parameter", "indexType must be a valid VkIndexType value", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-transformData-parameter", "If transformData is not VK_NULL_HANDLE, transformData must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-transformOffset-02437", "transformOffset must be less than the size of transformData", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-transformOffset-02438", "transformOffset must be a multiple of 16", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-vertexData-parameter", "If vertexData is not VK_NULL_HANDLE, vertexData must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-vertexFormat-02430", "vertexFormat must be one of VK_FORMAT_R32G32B32_SFLOAT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16B16_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16_SNORM, or VK_FORMAT_R16G16B16_SNORM", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-vertexFormat-parameter", "vertexFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-vertexOffset-02428", "vertexOffset must be less than the size of vertexData", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-vertexOffset-02429", "vertexOffset must be a multiple of the component size of vertexFormat", "1.3-extensions"},
    {"VUID-VkGeometryTrianglesNV-vertexStride-03818", "vertexStride must be less than or equal to 232-1", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-Input-06632", "If the pipeline is being created with fragment shader state with a fragment shader that either enables sample shading or decorates any variable in the Input storage class with Sample, then pMultisampleState must not be NULL", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-None-02322", "If the pipeline is being created with pre-rasterization shader state, and there are any mesh shader stages in the pipeline there must not be any shader stage in the pipeline with a Xfb execution mode", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-None-04574", "If the pipeline is being created with fragment shader state, and the supersampleFragmentShadingRates feature is not enabled, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::shadingRate must not be equal to VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV, VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV, VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV, or VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-None-04575", "If the pipeline is being created with fragment shader state, and the noInvocationFragmentShadingRates feature is not enabled, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::shadingRate must not be equal to VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-None-04889", "If the pipeline is being created with pre-rasterization shader state and fragment shader state, the fragment shader and last pre-rasterization shader stage and any relevant state must adhere to the pipeline linking rules described in the Shader Interfaces chapter", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-None-06569", "If the pipeline is being created with  fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::shadingRateType must be a valid VkFragmentShadingRateTypeNV value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-None-06573", "The pipeline must be created with a complete set of state", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-PrimitiveId-06264", "If the pipeline is being created with pre-rasterization shader state, it includes a mesh shader and the fragment shader code reads from an input variable that is decorated with PrimitiveId, then the mesh shader code must write to a matching output variable, decorated with PrimitiveId, in all execution paths", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-TaskNV-07063", "The shader stages for VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT must use either the TaskNV and MeshNV {ExecutionModel} or the TaskEXT and MeshEXT {ExecutionModel}, but must not use both", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-commonparent", "Each of basePipelineHandle, layout, and renderPass that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06759", "If conservativePointAndLineRasterization is not supported; the pipeline is being created with vertex input state and pre-rasterization shader state; the pipeline does not include a geometry shader; and the value of VkPipelineInputAssemblyStateCreateInfo::topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, or VK_PRIMITIVE_TOPOLOGY_LINE_STRIP, then VkPipelineRasterizationConservativeStateCreateInfoEXT::conservativeRasterizationMode must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06760", "If conservativePointAndLineRasterization is not supported, the pipeline is being created with pre-rasterization shader state, and the pipeline includes a geometry shader with either the OutputPoints or OutputLineStrip execution modes, VkPipelineRasterizationConservativeStateCreateInfoEXT::conservativeRasterizationMode must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06761", "If conservativePointAndLineRasterization is not supported, the pipeline is being created with pre-rasterization shader state, and the pipeline includes a mesh shader with either the OutputPoints or OutputLinesNV execution modes, VkPipelineRasterizationConservativeStateCreateInfoEXT::conservativeRasterizationMode must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-coverageReductionMode-02722", "If the pipeline is being created with fragment output interface state, and the VK_NV_coverage_reduction_mode extension is enabled, the coverage reduction mode specified by VkPipelineCoverageReductionStateCreateInfoNV::coverageReductionMode, the rasterizationSamples member of pMultisampleState and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-depthStencilAttachmentSamples-06593", "If the fragment output interface state and the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV is not 0, it must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576", "If the dynamicRendering feature is not enabled and the pipeline is being created with pre-rasterization shader state, fragment shader state, or fragment output interface state, renderPass must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3AlphaToCoverageEnable-07375", "If the extendedDynamicState3AlphaToCoverageEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3AlphaToOneEnable-07376", "If the extendedDynamicState3AlphaToOneEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorBlendAdvanced-07386", "If the extendedDynamicState3ColorBlendAdvanced feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorBlendEnable-07378", "If the extendedDynamicState3ColorBlendEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorBlendEquation-07379", "If the extendedDynamicState3ColorBlendEquation feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ColorWriteMask-07380", "If the extendedDynamicState3ColorWriteMask feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ConservativeRasterizationMode-07382", "If the extendedDynamicState3ConservativeRasterizationMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationMode-07395", "If the extendedDynamicState3CoverageModulationMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTable-07397", "If the extendedDynamicState3CoverageModulationTable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTableEnable-07396", "If the extendedDynamicState3CoverageModulationTableEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageReductionMode-07398", "If the extendedDynamicState3CoverageReductionMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorEnable-07393", "If the extendedDynamicState3CoverageToColorEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorLocation-07394", "If the extendedDynamicState3CoverageToColorLocation feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClampEnable-07371", "If the extendedDynamicState3DepthClampEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClipEnable-07384", "If the extendedDynamicState3DepthClipEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClipNegativeOneToOne-07390", "If the extendedDynamicState3DepthClipNegativeOneToOne feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ExtraPrimitiveOverestimationSize-07383", "If the extendedDynamicState3ExtraPrimitiveOverestimationSize feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LineRasterizationMode-07388", "If the extendedDynamicState3LineRasterizationMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LineStippleEnable-07389", "If the extendedDynamicState3LineStippleEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LogicOpEnable-07377", "If the extendedDynamicState3LogicOpEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3PolygonMode-07372", "If the extendedDynamicState3PolygonMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_POLYGON_MODE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ProvokingVertexMode-07387", "If the extendedDynamicState3ProvokingVertexMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationSamples-07373", "If the extendedDynamicState3RasterizationSamples feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationStream-07381", "If the extendedDynamicState3RasterizationStream feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RepresentativeFragmentTestEnable-07399", "If the extendedDynamicState3RepresentativeFragmentTestEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3SampleLocationsEnable-07385", "If the extendedDynamicState3SampleLocationsEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3SampleMask-07374", "If the extendedDynamicState3SampleMask feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_SAMPLE_MASK_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ShadingRateImageEnable-07400", "If the extendedDynamicState3ShadingRateImageEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3TessellationDomainOrigin-07370", "If the extendedDynamicState3TessellationDomainOrigin feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ViewportSwizzle-07392", "If the extendedDynamicState3ViewportSwizzle feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ViewportWScalingEnable-07391", "If the extendedDynamicState3ViewportWScalingEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-00722", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a graphics VkPipeline", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-00723", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-00724", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-00725", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-00764", "flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-02877", "If flags includes VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then the deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-02966", "If the pipeline is being created with pre-rasterization shader state and flags includes VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then all stages must not specify Xfb execution mode", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03371", "flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03372", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03373", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03374", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03375", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03376", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03377", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-03577", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-04901", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, then the subpass must be the last subpass in a subpass dependency chain", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-04902", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if pResolveAttachments is not NULL, then each resolve attachment must be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-04947", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06482", "If the pipeline is being created with fragment output interface state and the flags member of VkPipelineColorBlendStateCreateInfo includes VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT, renderpass must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06483", "If the pipeline is being created with fragment output interface state and the flags member of VkPipelineDepthStencilStateCreateInfo includes VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT or VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT, renderpass must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06484", "If the pipeline is being created with fragment output interface state and the flags member of VkPipelineColorBlendStateCreateInfo includes VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT subpass must have been created with VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06485", "If the pipeline is being created with fragment output interface state and the flags member of VkPipelineDepthStencilStateCreateInfo includes VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT, subpass must have been created with VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06486", "If the pipeline is being created with fragment output interface state and the flags member of VkPipelineDepthStencilStateCreateInfo includes VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT, subpass must have been created with VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06591", "If pStages includes a fragment shader stage, and the fragment shader declares the EarlyFragmentTests execution mode, the flags member of VkPipelineDepthStencilStateCreateInfo must not include VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT or VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06596", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other flag, the value of VkMultiviewPerViewAttributesInfoNVX::perViewAttributes specified in both this pipeline and the library must be equal", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06598", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other flag, the value of VkMultiviewPerViewAttributesInfoNVX::perViewAttributesPositionXOnly specified in both this pipeline and the library must be equal", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06608", "If the pipeline is being created with all possible state subsets, flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06609", "If flags includes VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, pipeline libraries included via VkPipelineLibraryCreateInfoKHR must have been created with VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06610", "If flags includes VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT, pipeline libraries included via VkPipelineLibraryCreateInfoKHR must have been created with VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06612", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other flag, and layout was not created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the layout used by this pipeline and the library must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06614", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other subset, and layout was created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the layout used by the library must also have been created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06616", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other subset, and layout was created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, elements of the pSetLayouts array which layout was created with that are not VK_NULL_HANDLE must be identically defined to the element at the same index of pSetLayouts used to create the library's layout", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06618", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other flag, any descriptor set layout N specified by layout in both this pipeline and the library which include bindings accessed by shader stages in each must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06620", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other flag, push constants specified in layout in both this pipeline and the library which are available to shader stages in each must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06626", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, and renderPass is VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::viewMask used by this pipeline and that specified by the library must be identical", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06633", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a pMultisampleState that was not NULL, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, pMultisampleState must be identically defined to that used to create the library", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06637", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, pMultisampleState->sampleShading is VK_TRUE, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the pMultisampleState used to create that library must be identically defined pMultisampleState", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06638", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other flag, values specified in VkPipelineFragmentShadingRateStateCreateInfoKHR for both this pipeline and that library must be identical", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06640", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06641", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06642", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06643", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06644", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, stageCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06645", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags is non-zero, if flags includes VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, any libraries must have also been created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06679", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other subset, and any element of the pSetLayouts array which layout was created with was VK_NULL_HANDLE, then the corresponding element of the pSetLayouts array used to create the library's layout must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06680", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other subset, and any element of the pSetLayouts array used to create the library's layout was VK_NULL_HANDLE, then the corresponding element of the pSetLayouts array used to create this pipeline's layout must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06682", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes both VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, layout must have been created with no elements of the pSetLayouts array set to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06683", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and pRasterizationState->rasterizerDiscardEnable is VK_TRUE, layout must have been created with no elements of the pSetLayouts array set to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06684", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, the value of subpass must be equal to that used to create the library", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06729", "If flags includes VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline includes a complete set of state specified entirely by libraries, and each library was created with a VkPipelineLayout created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then layout must be a valid VkPipelineLayout that is compatible with the union of the libraries' pipeline layouts other than the inclusion/exclusion of VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06730", "If flags does not include VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline includes a complete set of state specified entirely by libraries, and each library was created with a VkPipelineLayout created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then layout must be a valid VkPipelineLayout that is compatible with the union of the libraries' pipeline layouts", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06756", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other subset, and any element of the pSetLayouts array which layout was created with was VK_NULL_HANDLE, then the corresponding element of the pSetLayouts array used to create the library's layout must not have shader bindings for shaders in the other subset", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-06757", "If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes only one of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes the other subset, and any element of the pSetLayouts array used to create the library's layout was VK_NULL_HANDLE, then the corresponding element of the pSetLayouts array used to create this pipeline's layout must not have shader bindings for shaders in the other subset", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-07369", "flags must not include both VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT and VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-07401", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506", "If the pipeline is being created with pre-rasterization shader state or fragment shader state, the fragmentShadingRateNonTrivialCombinerOps limit is not supported, and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, elements of VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04573", "If the pipeline is being created with fragment shader state, and the fragmentShadingRateNonTrivialCombinerOps limit is not supported and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, elements of VkPipelineFragmentShadingRateEnumStateCreateInfoNV::combinerOps must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-geometryStreams-02321", "If the pipeline is being created with pre-rasterization shader state, and the last pre-rasterization shader stage is a geometry shader, and that geometry shader uses the GeometryStreams capability, then VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams feature must be enabled", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606", "If the graphicsPipelineLibrary feature is not enabled, flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06607", "If the graphicsPipelineLibrary feature is not enabled, the pipeline must be created with a complete set of state", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-layout-00756", "layout must be consistent with all shaders specified in pStages", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-layout-01688", "The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-layout-06602", "layout must be a valid VkPipelineLayout handle", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-libraryCount-06648", "If the pipeline is not created with a complete set of state, or VkPipelineLibraryCreateInfoKHR::libraryCount is not 0, VkGraphicsPipelineShaderGroupsCreateInfoNV::groupCount and VkGraphicsPipelineShaderGroupsCreateInfoNV::pipelineCount must be 0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-libraryCount-06649", "If the pipeline is created with a complete set of state, VkPipelineLibraryCreateInfoKHR::libraryCount is 0, and the pNext chain includes an instance of VkGraphicsPipelineShaderGroupsCreateInfoNV, VkGraphicsPipelineShaderGroupsCreateInfoNV::groupCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766", "If the pipeline is being created with pre-rasterization shader state and at least one of fragment output interface state or fragment shader state, and pMultisampleState is not NULL, the lineRasterizationMode member of a VkPipelineRasterizationLineStateCreateInfoEXT structure included in the pNext chain of pRasterizationState is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT or VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the alphaToCoverageEnable, alphaToOneEnable, and sampleShadingEnable members of pMultisampleState must all be VK_FALSE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-multisampledRenderToSingleSampled-06853", "If the pipeline is being created with fragment output interface state, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must be the same as the sample count for those subpass attachments", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-multiview-06577", "If the multiview feature is not enabled, the pipeline is being created with pre-rasterization shader state, fragment shader state, or fragment output interface state, and renderPass is VK_NULL_HANDLE, VkPipelineRenderingCreateInfo::viewMask must be 0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pColorAttachmentSamples-06592", "If the fragment output interface state, elements of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV must be valid VkSampleCountFlagBits values", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04494", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width must be greater than or equal to 1", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04495", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must be greater than or equal to 1", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04496", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width must be a power-of-two value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04497", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must be a power-of-two value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04498", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width must be less than or equal to 4", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04499", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must be less than or equal to 4", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the pipelineFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width and VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must both be equal to 1", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04501", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the primitiveFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[0] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04502", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the attachmentFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[1] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04569", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the fragmentShadingRateEnums feature is not enabled, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::shadingRateType must be equal to VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04570", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the pipelineFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::shadingRate must be equal to VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04571", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the primitiveFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::combinerOps[0] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04572", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the attachmentFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::combinerOps[1] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06567", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[0] must be a valid VkFragmentShadingRateCombinerOpKHR value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06568", "If the pipeline is being created with pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[1] must be a valid VkFragmentShadingRateCombinerOpKHR value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06570", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::shadingRate must be a valid VkFragmentShadingRateNV value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06571", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::combinerOps[0] must be a valid VkFragmentShadingRateCombinerOpKHR value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06572", "If the pipeline is being created with fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateEnumStateCreateInfoNV::combinerOps[1] must be a valid VkFragmentShadingRateCombinerOpKHR value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter", "If pDynamicState is not NULL, pDynamicState must be a valid pointer to a valid VkPipelineDynamicStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00747", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT, the pViewports member of pViewportState must be a valid pointer to an array of pViewportState->viewportCount valid VkViewport structures", "1.2-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00748", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SCISSOR, the pScissors member of pViewportState must be a valid pointer to an array of pViewportState->scissorCount VkRect2D structures", "1.2-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749", "If the pipeline is being created with pre-rasterization shader state, and the wideLines feature is not enabled, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_WIDTH, the lineWidth member of pRasterizationState must be 1.0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754", "If the pipeline is being created with pre-rasterization shader state, the depthBiasClamp feature is not enabled, no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BIAS, and the depthBiasEnable member of pRasterizationState is VK_TRUE, the depthBiasClamp member of pRasterizationState must be 0.0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00755", "If the pipeline is being created with fragment shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01521", "If the pipeline is being created with fragment shader state or fragment output interface state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure included in the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.width must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01522", "If the pipeline is being created with fragment shader state or fragment output interface state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure included in the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationGridSize.height must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01523", "If the pipeline is being created with fragment shader state or fragment output interface state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure included in the pNext chain of pMultisampleState is VK_TRUE, sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-01715", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV, and the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure, included in the pNext chain of pViewportState, is VK_TRUE, the pViewportWScalings member of the VkPipelineViewportWScalingStateCreateInfoNV must be a pointer to an array of VkPipelineViewportWScalingStateCreateInfoNV::viewportCount valid VkViewportWScalingNV structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510", "If the pipeline is being created with fragment shader state, and the VK_EXT_depth_range_unrestricted extension is not enabled and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03378", "If the extendedDynamicState feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_CULL_MODE, VK_DYNAMIC_STATE_FRONT_FACE, VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY, VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT, VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT, VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE, VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE, or VK_DYNAMIC_STATE_STENCIL_OP", "1.2-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03379", "If the pipeline is being created with pre-rasterization shader state, and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in the pDynamicStates array then viewportCount must be zero", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03380", "If the pipeline is being created with pre-rasterization shader state, and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in the pDynamicStates array then scissorCount must be zero", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03578", "All elements of the pDynamicStates member of pDynamicState must not be VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04056", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV, and if pViewportState->pNext chain includes a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure, and if its exclusiveScissorCount member is not 0, then its pExclusiveScissors member must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04057", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV, and if pViewportState->pNext chain includes a VkPipelineViewportShadingRateImageStateCreateInfoNV structure, then its pShadingRatePalettes member must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04058", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT, and if pNext chain includes a VkPipelineDiscardRectangleStateCreateInfoEXT structure, and if its discardRectangleCount member is not 0, then its pDiscardRectangles member must be a valid pointer to an array of discardRectangleCount VkRect2D structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04130", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_VIEWPORT or VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT, the pViewports member of pViewportState must be a valid pointer to an array of pViewportState->viewportCount valid VkViewport structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04131", "If the pipeline is being created with pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_SCISSOR or VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT, the pScissors member of pViewportState must be a valid pointer to an array of pViewportState->scissorCount VkRect2D structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04132", "If the pipeline is being created with pre-rasterization shader state, and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in the pDynamicStates array then VK_DYNAMIC_STATE_VIEWPORT must not be present", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04133", "If the pipeline is being created with pre-rasterization shader state, and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in the pDynamicStates array then VK_DYNAMIC_STATE_SCISSOR must not be present", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04800", "If the colorWriteEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04807", "If the pipeline is being created with pre-rasterization shader state and the vertexInputDynamicState feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VERTEX_INPUT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04868", "If the extendedDynamicState2 feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE, VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE", "1.2-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04869", "If the extendedDynamicState2LogicOp feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_LOGIC_OP_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04870", "If the extendedDynamicState2PatchControlPoints feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07065", "If the pipeline is being created with pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY, or VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07066", "If the pipeline is being created with pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07067", "If the pipeline is being created with pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VERTEX_INPUT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06597", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the value of VkMultiviewPerViewAttributesInfoNVX::perViewAttributes specified in both libraries must be equal", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06599", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the value of VkMultiviewPerViewAttributesInfoNVX::perViewAttributesPositionXOnly specified in both libraries must be equal", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06611", "Any pipeline libraries included via VkPipelineLibraryCreateInfoKHR::pLibraries must not include any state subset already defined by this structure or defined by any other pipeline library in VkPipelineLibraryCreateInfoKHR::pLibraries", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06613", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the layout specified by either library was not created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the layout used by each library must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06615", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the layout specified by either library was created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then the layout used by both libraries must have been created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06617", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and the layout specified by either library was created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, elements of the pSetLayouts array which either layout was created with that are not VK_NULL_HANDLE must be identically defined to the element at the same index of pSetLayouts used to create the other library's layout", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06619", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, any descriptor set layout N specified by layout in both libraries which include bindings accessed by shader stages in each must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06621", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, push constants specified in layout in both this pipeline and the library which are available to shader stages in each must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06623", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and another element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, the value of subpass used to create each library must be identical", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06627", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, another element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, and renderPass was VK_NULL_HANDLE for both libraries, the value of VkPipelineRenderingCreateInfo::viewMask set by each library must be identical", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06628", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and another element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, the renderPass objects used to create each library must be compatible or all equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06634", "If an element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a pMultisampleState that was not NULL, and if VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, pMultisampleState must be identically defined to that used to create the library", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06635", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT with a pMultisampleState that was not NULL, and if a different element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, the pMultisampleState used to create each library must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06636", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT and a value of pMultisampleState->sampleShading equal VK_TRUE, and if a different element of VkPipelineLibraryCreateInfoKHR::pLibraries was created with VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, the pMultisampleState used to create each library must be identically defined", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06639", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, values specified in VkPipelineFragmentShadingRateStateCreateInfoKHR for both this pipeline and that library must be identical", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06646", "If VkPipelineLibraryCreateInfoKHR::pLibraries includes more than one library, and any library was created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, all libraries must have also been created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06647", "If VkPipelineLibraryCreateInfoKHR::pLibraries includes at least one library, VkGraphicsPipelineLibraryCreateInfoEXT::flags is non-zero, and any library was created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, flags must include VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06681", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and any element of the pSetLayouts array used to create each library's layout was VK_NULL_HANDLE, then the corresponding element of the pSetLayouts array used to create the other library's layout must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06758", "If one element of VkPipelineLibraryCreateInfoKHR::pLibraries includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and another element includes VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, and any element of the pSetLayouts array used to create each library's layout was VK_NULL_HANDLE, then the corresponding element of the pSetLayouts array used to create the other library's layout must not have shader bindings for shaders in the other subset", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-06629", "If the pipeline is being created with fragment shader state pMultisampleState must be NULL or a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-06630", "If the pipeline is being created with fragment shader state pMultisampleState must not be NULL", "default"},
    {"VUID-VkGraphicsPipelineCreateInfo-pNext-06605", "If the pNext chain includes an instance of VkGraphicsPipelineShaderGroupsCreateInfoNV, its groupCount member must be greater than 0", "default"},
    {"VUID-VkGraphicsPipelineCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAttachmentSampleCountInfoAMD, VkGraphicsPipelineLibraryCreateInfoEXT, VkGraphicsPipelineShaderGroupsCreateInfoNV, VkMultiviewPerViewAttributesInfoNVX, VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreationFeedbackCreateInfo, VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineFragmentShadingRateEnumStateCreateInfoNV, VkPipelineFragmentShadingRateStateCreateInfoKHR, VkPipelineLibraryCreateInfoKHR, VkPipelineRenderingCreateInfo, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, or VkPipelineRobustnessCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-06601", "pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00729", "If the pipeline is being created with pre-rasterization shader state and pStages includes a tessellation control shader stage, it must include a tessellation evaluation shader stage", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00730", "If the pipeline is being created with pre-rasterization shader state and pStages includes a tessellation evaluation shader stage, it must include a tessellation control shader stage", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00731", "If the pipeline is being created with pre-rasterization shader state and pStages includes a tessellation control shader stage and a tessellation evaluation shader stage, pTessellationState must be a valid pointer to a valid VkPipelineTessellationStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00732", "If the pipeline is being created with pre-rasterization shader state and pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction specifying the type of subdivision in the pipeline", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00733", "If the pipeline is being created with pre-rasterization shader state and pStages includes tessellation shader stages, and the shader code of both stages contain an OpExecutionMode instruction specifying the type of subdivision in the pipeline, they must both specify the same subdivision mode", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00734", "If the pipeline is being created with pre-rasterization shader state and pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction specifying the output patch size in the pipeline", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00735", "If the pipeline is being created with pre-rasterization shader state and pStages includes tessellation shader stages, and the shader code of both contain an OpExecutionMode instruction specifying the out patch size in the pipeline, they must both specify the same patch size", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00736", "If the pipeline is being created with pre-rasterization shader state and pStages includes tessellation shader stages, the topology member of pInputAssembly must be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00738", "If the pipeline is being created with pre-rasterization shader state and pStages includes a geometry shader stage, and does not include any tessellation shader stages, its shader code must contain an OpExecutionMode instruction specifying an input primitive type that is compatible with the primitive topology specified in pInputAssembly", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00739", "If the pipeline is being created with pre-rasterization shader state and pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must contain an OpExecutionMode instruction specifying an input primitive type that is compatible with the primitive topology that is output by the tessellation stages", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00740", "If the pipeline is being created with pre-rasterization shader state and fragment shader state, it includes both a fragment shader and a geometry shader, and the fragment shader code reads from an input variable that is decorated with PrimitiveId, then the geometry shader code must write to a matching output variable, decorated with PrimitiveId, in all execution paths", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-00742", "If the pipeline is being created with pre-rasterization shader state and multiple pre-rasterization shader stages are included in pStages, the shader code for the entry points identified by those pStages and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-01565", "If the pipeline is being created with fragment shader state and an input attachment was referenced by an aspectMask at renderPass creation time, the fragment shader must only read from the aspects that were specified for that input attachment", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-02095", "If the pipeline is being created with pre-rasterization shader state the geometric shader stages provided in pStages must be either from the mesh shading pipeline (stage is VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT) or from the primitive shading pipeline (stage is VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOMETRY_BIT)", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-02097", "If the pipeline is being created with vertex input state, pVertexInputState must be a valid pointer to a valid VkPipelineVertexInputStateCreateInfo structure", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-02098", "If the pipeline is being created with vertex input state, pInputAssemblyState must be a valid pointer to a valid VkPipelineInputAssemblyStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-02317", "If the pipeline is being created with pre-rasterization shader state, the Xfb execution mode can be specified by no more than one shader stage in pStages", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-02318", "If the pipeline is being created with pre-rasterization shader state, and any shader stage in pStages specifies Xfb execution mode it must be the last pre-rasterization shader stage", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-06600", "pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-06894", "If the pipeline is being created with pre-rasterization shader state but not fragment shader state, elements of pStages must not have stage set to VK_SHADER_STAGE_FRAGMENT_BIT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-06895", "If the pipeline is being created with fragment shader state but not pre-rasterization shader state, elements of pStages must not have stage set to a shader stage which participates in pre-rasterization", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pStages-06896", "If the pipeline is being created with pre-rasterization shader state, all elements of pStages must have a stage set to a shader stage which participates in fragment shader state or pre-rasterization shader state", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-04910", "If the pipeline is being created with vertex input state, and VK_DYNAMIC_STATE_VERTEX_INPUT_EXT is not set, pVertexInputState must be a valid pointer to a valid VkPipelineVertexInputStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pViewportState-04892", "If the pipeline is being created with pre-rasterization shader state, and the graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled, pViewportState must be a valid pointer to a valid VkPipelineViewportStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pipelineCreationCacheControl-02878", "If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pipelineProtectedAccess-07368", "If the pipelineProtectedAccess feature is not enabled, flags must not include VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT or VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-pipelineStageCreationFeedbackCount-06594", "If VkPipelineCreationFeedbackCreateInfo::pipelineStageCreationFeedbackCount is not 0, it must be equal to stageCount", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04503", "If the pipeline is being created with pre-rasterization shader state and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is not included in pDynamicState->pDynamicStates, and VkPipelineViewportStateCreateInfo::viewportCount is greater than 1, entry points specified in pStages must not write to the PrimitiveShadingRateKHR built-in", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04504", "If the pipeline is being created with pre-rasterization shader state and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, and entry points specified in pStages write to the ViewportIndex built-in, they must not also write to the PrimitiveShadingRateKHR built-in", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04505", "If the pipeline is being created with pre-rasterization shader state and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, and entry points specified in pStages write to the ViewportMaskNV built-in, they must not also write to the PrimitiveShadingRateKHR built-in", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-rasterizationSamples-04899", "If the pipeline is being created with fragment shader state, and the VK_QCOM_render_pass_shader_resolve extension is enabled, and if subpass has any input attachments, and if the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the sample count of the input attachments must equal rasterizationSamples", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02319", "If the pipeline is being created with pre-rasterization shader state, and a VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream value other than zero is specified, all variables in the output interface of the entry point being compiled decorated with Position, PointSize, ClipDistance, or CullDistance must be decorated with identical Stream values that match the rasterizationStream", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-rasterizationStream-02320", "If the pipeline is being created with pre-rasterization shader state, and VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream is zero, or not specified, all variables in the output interface of the entry point being compiled decorated with Position, PointSize, ClipDistance, or CullDistance must be decorated with a Stream value of zero, or must not specify the Stream decoration", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00750", "If the pipeline is being created with pre-rasterization shader state, and the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, pViewportState must be a valid pointer to a valid VkPipelineViewportStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-00751", "If the pipeline is being created with fragment output interface state, pMultisampleState must be a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038", "If renderPass is not VK_NULL_HANDLE and the pipeline is being created with fragment shader state the fragment shader must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06041", "If renderPass is not VK_NULL_HANDLE, and the pipeline is being created with fragment output interface state, then for each color attachment in the subpass, if the potential format features of the format of the corresponding attachment description do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06042", "If renderPass is not VK_NULL_HANDLE, and the pipeline is being created with fragment output interface state, and the subpass uses color attachments, the attachmentCount member of pColorBlendState must be equal to the colorAttachmentCount used to create subpass", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06043", "If renderPass is not VK_NULL_HANDLE, the pipeline is being created with fragment shader state, and subpass uses a depth/stencil attachment, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06044", "If renderPass is not VK_NULL_HANDLE, the pipeline is being created with fragment output interface state, and subpass uses color attachments, pColorBlendState must be a valid pointer to a valid VkPipelineColorBlendStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06046", "If renderPass is a valid renderPass, subpass must be a valid subpass within renderPass", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06047", "If renderPass is a valid renderPass, the pipeline is being created with pre-rasterization shader state, and the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewTessellationShader is not enabled, then pStages must not include tessellation shaders", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06048", "If renderPass is a valid renderPass, the pipeline is being created with pre-rasterization shader state, and the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewGeometryShader is not enabled, then pStages must not include a geometry shader", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06049", "If renderPass is a valid renderPass, the pipeline is being created with pre-rasterization shader state, and the renderPass has multiview enabled and subpass has more than one bit set in the view mask, shaders in the pipeline must not write to the Layer built-in output", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06050", "If renderPass is a valid renderPass and the pipeline is being created with pre-rasterization shader state, and the renderPass has multiview enabled, then all shaders must not include variables decorated with the Layer built-in decoration in their interfaces", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06053", "If renderPass is VK_NULL_HANDLE, the pipeline is being created with fragment shader state and fragment output interface state, and either of VkPipelineRenderingCreateInfo::depthAttachmentFormat or VkPipelineRenderingCreateInfo::stencilAttachmentFormat are not VK_FORMAT_UNDEFINED, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06054", "If renderPass is VK_NULL_HANDLE, the pipeline is being created with fragment output interface state, and VkPipelineRenderingCreateInfo::colorAttachmentCount is not equal to 0, pColorBlendState must be a valid pointer to a valid VkPipelineColorBlendStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06055", "If renderPass is VK_NULL_HANDLE and the pipeline is being created with fragment output interface state, pColorBlendState->attachmentCount must be equal to VkPipelineRenderingCreateInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06056", "If renderPass is VK_NULL_HANDLE and the pipeline is being created with fragment shader state the fragment shader must not read from any input attachment", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06057", "If renderPass is VK_NULL_HANDLE, the pipeline is being created with pre-rasterization shader state, the viewMask member of a VkPipelineRenderingCreateInfo structure included in the pNext chain is not 0, and the multiviewTessellationShader feature is not enabled, then pStages must not include tessellation shaders", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06058", "If renderPass is VK_NULL_HANDLE, the pipeline is being created with pre-rasterization shader state, the viewMask member of a VkPipelineRenderingCreateInfo structure included in the pNext chain is not 0, and the multiviewGeometryShader feature is not enabled, then pStages must not include a geometry shader", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06059", "If renderPass is VK_NULL_HANDLE, the pipeline is being created with pre-rasterization shader state, and the viewMask member of a VkPipelineRenderingCreateInfo structure included in the pNext chain is not 0, shaders in pStages must not include variables decorated with the Layer built-in decoration in their interfaces", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06061", "If the pipeline is being created with fragment shader state and renderPass is VK_NULL_HANDLE, fragment shaders in pStages must not include the InputAttachment capability", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06062", "If the pipeline is being created with fragment output interface state and renderPass is VK_NULL_HANDLE, for each color attachment format defined by the pColorAttachmentFormats member of VkPipelineRenderingCreateInfo, if its potential format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06063", "If the pipeline is being created with fragment output interface state and renderPass is VK_NULL_HANDLE, if the pNext chain includes VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV, the colorAttachmentCount member of that structure must be equal to the value of VkPipelineRenderingCreateInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06574", "If the pipeline is being created with pre-rasterization shader state, fragment shader state, or fragment output interface state, renderPass must be a valid render pass object", "1.2"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06575", "If the pipeline is being created with pre-rasterization shader state, fragment shader state, or fragment output interface state, renderPass must be VK_NULL_HANDLE or a valid render pass object", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06578", "If the pipeline is being created with pre-rasterization shader state, fragment shader state, or fragment output interface state, and renderPass is VK_NULL_HANDLE, the index of the most significant bit in VkPipelineRenderingCreateInfo::viewMask must be less than maxMultiviewViewCount", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06579", "If the pipeline is being created with fragment output interface state, and renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::colorAttachmentCount is not 0, VkPipelineRenderingCreateInfo::pColorAttachmentFormats must be a valid pointer to an array of colorAttachmentCount valid VkFormat values", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06580", "If the pipeline is being created with fragment output interface state, and renderPass is VK_NULL_HANDLE, each element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06581", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, and any element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats is not VK_FORMAT_UNDEFINED, that format must be a format with potential format features that include VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06582", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, and any element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats is not VK_FORMAT_UNDEFINED, that format must be a format with potential format features that include VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06583", "If the pipeline is being created with fragment output interface state, and renderPass is VK_NULL_HANDLE, VkPipelineRenderingCreateInfo::depthAttachmentFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06584", "If the pipeline is being created with fragment output interface state, and renderPass is VK_NULL_HANDLE, VkPipelineRenderingCreateInfo::stencilAttachmentFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06585", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::depthAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06586", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06587", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::depthAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format that includes a depth aspect", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06588", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format that includes a stencil aspect", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06589", "If the pipeline is being created with fragment output interface state, renderPass is VK_NULL_HANDLE, VkPipelineRenderingCreateInfo::depthAttachmentFormat is not VK_FORMAT_UNDEFINED, and VkPipelineRenderingCreateInfo::stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, depthAttachmentFormat must equal stencilAttachmentFormat", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06590", "If renderPass is VK_NULL_HANDLE and the pipeline is being created with fragment shader state but not fragment output interface state, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06595", "If renderPass is VK_NULL_HANDLE, the pipeline is being created with pre-rasterization shader state or fragment shader state, and VkMultiviewPerViewAttributesInfoNVX::perViewAttributesPositionXOnly is VK_TRUE then VkMultiviewPerViewAttributesInfoNVX::perViewAttributes must also be VK_TRUE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06603", "If renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-06854", "If renderPass is not VK_NULL_HANDLE, the VK_EXT_multisampled_render_to_single_sampled extension is enabled, and subpass has a VkMultisampledRenderToSingleSampledInfoEXT structure included in the VkSubpassDescription2::pNext chain with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then the rasterizationSamples member of pMultisampleState must be equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples.", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderPass-07064", "If renderPass is a valid renderPass, the pipeline is being created with pre-rasterization shader state, and the renderPass has multiview enabled and subpass has more than one bit set in the view mask and multiviewMeshShader is not enabled, then pStages must not include a mesh shader", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderpass-06624", "If renderpass is not VK_NULL_HANDLE, VkGraphicsPipelineLibraryCreateInfoEXT::flags includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, renderPass must be compatible with that used to create the library", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderpass-06625", "If renderpass is VK_NULL_HANDLE, VkGraphicsPipelineLibraryCreateInfoEXT::flags includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, the value of renderPass used to create that library must also be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-renderpass-06631", "If the pipeline is being created with fragment shader state and renderpass is not VK_NULL_HANDLE, then pMultisampleState must not be NULL", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-sampleLocationsEnable-01524", "If the pipeline is being created with fragment shader state, and the sampleLocationsEnable member of a VkPipelineSampleLocationsStateCreateInfoEXT structure included in the pNext chain of pMultisampleState is VK_TRUE, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-sampleShadingEnable-04900", "If the pipeline is being created with fragment shader state, and the VK_QCOM_render_pass_shader_resolve extension is enabled, and if the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then sampleShadingEnable must be false", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-stage-00727", "If the pipeline is being created with pre-rasterization shader state the stage member of one element of pStages must be VK_SHADER_STAGE_VERTEX_BIT", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-stage-02096", "If the pipeline is being created with pre-rasterization shader state the stage member of one element of pStages must be either VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-stage-06897", "If the pipeline is being created with fragment shader state and/or pre-rasterization shader state, any value of stage must not be set in more than one element of pStages", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-stageCount-06604", "stageCount must be greater than 0", "1.3-khr-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-stippledLineEnable-02767", "If the pipeline is being created with pre-rasterization shader state, the stippledLineEnable member of VkPipelineRasterizationLineStateCreateInfoEXT is VK_TRUE, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_STIPPLE_EXT, then the lineStippleFactor member of VkPipelineRasterizationLineStateCreateInfoEXT must be in the range [1,256]", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-subpass-00758", "If the pipeline is being created with fragment output interface state, and subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-subpass-01411", "If the pipeline is being created with fragment output interface state, and the VK_NV_framebuffer_mixed_samples extension is enabled, and if subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled, then the rasterizationSamples member of pMultisampleState must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-subpass-01412", "If the pipeline is being created with fragment output interface state, and the VK_NV_framebuffer_mixed_samples extension is enabled, and if subpass has any color attachments, then the rasterizationSamples member of pMultisampleState must be greater than or equal to the sample count for those subpass attachments", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-subpass-01505", "If the pipeline is being created with fragment output interface state, and the VK_AMD_mixed_attachment_samples extension is enabled, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must equal the maximum of the sample counts of those subpass attachments", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineCreateInfo-topology-00737", "If the pipeline is being created with pre-rasterization shader state and the topology member of pInputAssembly is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, pStages must include tessellation shader stages", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-parameter", "flags must be a valid combination of VkGraphicsPipelineLibraryFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineLibraryCreateInfoEXT-flags-requiredbitmask", "flags must not be 0", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineLibraryCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-deviceGeneratedCommands-02887", "The deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-groupCount-02879", "groupCount must be at least 1 and as maximum VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxGraphicsShaderGroupCount", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-groupCount-02880", "The sum of groupCount including those groups added from referenced pPipelines must also be as maximum VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxGraphicsShaderGroupCount", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02881", "The state of the first element of pGroups must match its equivalent within the parent's VkGraphicsPipelineCreateInfo", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02882", "Each element of pGroups must in combination with the rest of the pipeline state yield a valid state configuration", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02883", "All elements of pGroups must use the same shader stage combinations", "default"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02884", "All elements of pGroups must use the same shader stage combinations unless any mesh shader stage is used, then either combination of task and mesh or just mesh shader is valid", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-02885", "Mesh and regular primitive shading stages cannot be mixed across pGroups", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pGroups-parameter", "If groupCount is not 0, pGroups must be a valid pointer to an array of groupCount valid VkGraphicsShaderGroupCreateInfoNV structures", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-02886", "Each element of pPipelines must have been created with identical state to the pipeline currently created except the state that can be overridden by VkGraphicsShaderGroupCreateInfoNV", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-pPipelines-parameter", "If pipelineCount is not 0, pPipelines must be a valid pointer to an array of pipelineCount valid VkPipeline handles", "1.3-extensions"},
    {"VUID-VkGraphicsPipelineShaderGroupsCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-02889", "For pStages, the same restrictions as in VkGraphicsPipelineCreateInfo::pStages apply", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-pStages-parameter", "pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-pTessellationState-02891", "For pTessellationState, the same restrictions as in VkGraphicsPipelineCreateInfo::pTessellationState apply", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-pVertexInputState-02890", "For pVertexInputState, the same restrictions as in VkGraphicsPipelineCreateInfo::pVertexInputState apply", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-02888", "For stageCount, the same restrictions as in VkGraphicsPipelineCreateInfo::stageCount apply", "1.3-extensions"},
    {"VUID-VkGraphicsShaderGroupCreateInfoNV-stageCount-arraylength", "stageCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkHdrMetadataEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkHdrMetadataEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_HDR_METADATA_EXT", "1.3-extensions"},
    {"VUID-VkHeadlessSurfaceCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkHeadlessSurfaceCreateInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkHeadlessSurfaceCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkIOSSurfaceCreateInfoMVK-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkIOSSurfaceCreateInfoMVK-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkIOSSurfaceCreateInfoMVK-pView-01316", "If pView is a UIView object, it must be a valid UIView, must be backed by a CALayer object of type CAMetalLayer, and vkCreateIOSSurfaceMVK must be called on the main thread", "1.3-extensions"},
    {"VUID-VkIOSSurfaceCreateInfoMVK-pView-04143", "If pView is a CAMetalLayer object, it must be a valid CAMetalLayer", "1.3-extensions"},
    {"VUID-VkIOSSurfaceCreateInfoMVK-sType-sType", "sType must be VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK", "1.3-extensions"},
    {"VUID-VkImageBlit-aspectMask-00238", "The aspectMask member of srcSubresource and dstSubresource must match", "1.3-extensions"},
    {"VUID-VkImageBlit-dstSubresource-parameter", "dstSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageBlit-layerCount-00239", "The layerCount member of srcSubresource and dstSubresource must match", "1.3-extensions"},
    {"VUID-VkImageBlit-srcSubresource-parameter", "srcSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageBlit2-aspectMask-00238", "The aspectMask member of srcSubresource and dstSubresource must match", "1.3-extensions"},
    {"VUID-VkImageBlit2-dstSubresource-parameter", "dstSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageBlit2-layerCount-00239", "The layerCount member of srcSubresource and dstSubresource must match", "1.3-extensions"},
    {"VUID-VkImageBlit2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkCopyCommandTransformInfoQCOM", "1.3-extensions"},
    {"VUID-VkImageBlit2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_BLIT_2", "1.3-extensions"},
    {"VUID-VkImageBlit2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkImageBlit2-srcSubresource-parameter", "srcSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageCompressionControlEXT-flags-06747", "flags must be one of VK_IMAGE_COMPRESSION_DEFAULT_EXT, VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT, VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, or VK_IMAGE_COMPRESSION_DISABLED_EXT", "1.3-extensions"},
    {"VUID-VkImageCompressionControlEXT-flags-06748", "If flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, pFixedRateFlags must not be NULL", "1.3-extensions"},
    {"VUID-VkImageCompressionControlEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT", "1.3-extensions"},
    {"VUID-VkImageCompressionPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-attachmentFragmentShadingRate-06401", "If the attachmentFragmentShadingRate feature is enabled, and pFormatConstraints::imageCreateInfo::usage contains VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, then pFormatConstraints::requiredFormatFeatures must contain VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-bufferCollectionConstraints-parameter", "bufferCollectionConstraints must be a valid VkBufferCollectionConstraintsInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-flags-parameter", "flags must be a valid combination of VkImageConstraintsInfoFlagBitsFUCHSIA values", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-formatConstraintsCount-arraylength", "formatConstraintsCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06395", "All elements of pFormatConstraints must have at least one bit set in its VkImageFormatConstraintsInfoFUCHSIA::requiredFormatFeatures", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06396", "If pFormatConstraints::imageCreateInfo::usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then pFormatConstraints::requiredFormatFeatures must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06397", "If pFormatConstraints::imageCreateInfo::usage contains VK_IMAGE_USAGE_STORAGE_BIT, then pFormatConstraints::requiredFormatFeatures must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06398", "If pFormatConstraints::imageCreateInfo::usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then pFormatConstraints::requiredFormatFeatures must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06399", "If pFormatConstraints::imageCreateInfo::usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then pFormatConstraints::requiredFormatFeatures must contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-06400", "If pFormatConstraints::imageCreateInfo::usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, then pFormatConstraints::requiredFormatFeatures must contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pFormatConstraints-parameter", "pFormatConstraints must be a valid pointer to an array of formatConstraintsCount valid VkImageFormatConstraintsInfoFUCHSIA structures", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageConstraintsInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImageCopy-aspectMask-00137", "The aspectMask member of srcSubresource and dstSubresource must match", "1.0"},
    {"VUID-VkImageCopy-dstSubresource-parameter", "dstSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageCopy-extent-00140", "The number of slices of the extent (for 3D) or layers of the srcSubresource (for non-3D) must match the number of slices of the extent (for 3D) or layers of the dstSubresource (for non-3D)", "1.3-extensions"},
    {"VUID-VkImageCopy-extent-06668", "extent.width must not be 0", "1.3-extensions"},
    {"VUID-VkImageCopy-extent-06669", "extent.height must not be 0", "1.3-extensions"},
    {"VUID-VkImageCopy-extent-06670", "extent.depth must not be 0", "1.3-extensions"},
    {"VUID-VkImageCopy-layerCount-00138", "The layerCount member of srcSubresource and dstSubresource must match", "1.0"},
    {"VUID-VkImageCopy-srcSubresource-parameter", "srcSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageCopy2-aspectMask-00137", "The aspectMask member of srcSubresource and dstSubresource must match", "default"},
    {"VUID-VkImageCopy2-dstSubresource-parameter", "dstSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageCopy2-extent-00140", "The number of slices of the extent (for 3D) or layers of the srcSubresource (for non-3D) must match the number of slices of the extent (for 3D) or layers of the dstSubresource (for non-3D)", "1.3-extensions"},
    {"VUID-VkImageCopy2-extent-06668", "extent.width must not be 0", "1.3-extensions"},
    {"VUID-VkImageCopy2-extent-06669", "extent.height must not be 0", "1.3-extensions"},
    {"VUID-VkImageCopy2-extent-06670", "extent.depth must not be 0", "1.3-extensions"},
    {"VUID-VkImageCopy2-layerCount-00138", "The layerCount member of srcSubresource and dstSubresource must match", "default"},
    {"VUID-VkImageCopy2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageCopy2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_COPY_2", "1.3-extensions"},
    {"VUID-VkImageCopy2-srcSubresource-parameter", "srcSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-Format-02536", "If Format is a depth-stencil format and the pNext chain includes a VkImageStencilUsageCreateInfo structure with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-None-01891", "If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_CREATE_PROTECTED_BIT must not also be set", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-None-01925", "If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must not also be set", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-arrayLayers-00948", "arrayLayers must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-arrayLayers-02256", "arrayLayers must be less than or equal to imageCreateMaxArrayLayers (as defined in Image Creation Limits)", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-extent-00944", "extent.width must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-extent-00945", "extent.height must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-extent-00946", "extent.depth must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-extent-02252", "extent.width must be less than or equal to imageCreateMaxExtent.width (as defined in Image Creation Limits)", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-extent-02253", "extent.height must be less than or equal to imageCreateMaxExtent.height (as defined in Image Creation Limits)", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-extent-02254", "extent.depth must be less than or equal to imageCreateMaxExtent.depth (as defined in Image Creation Limits)", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-00949", "If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-00950", "If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_3D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-00969", "If the sparseBinding feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-00987", "If flags contains VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-01533", "If flags contains VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT format must be a depth or depth/stencil format", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-01572", "If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then format must be a compressed image format", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-01573", "If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-01890", "If the protectedMemory feature is not enabled, flags must not contain VK_IMAGE_CREATE_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-01924", "If the sparseResidencyAliased feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02050", "If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, imageType must be VK_IMAGE_TYPE_2D or VK_IMAGE_TYPE_3D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02051", "If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, it must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and the format must not be a depth/stencil format", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02052", "If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_2D, extent.width and extent.height must be greater than 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02053", "If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_3D, extent.width, extent.height, and extent.depth must be greater than 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02259", "If flags contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, then mipLevels must be one, arrayLayers must be one, imageType must be VK_IMAGE_TYPE_2D. and imageCreateMaybeLinear (as defined in Image Creation Limits) must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02557", "If flags contains VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02565", "If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, tiling must be VK_IMAGE_TILING_OPTIMAL", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02566", "If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02567", "If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-02568", "If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, mipLevels must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-04738", "If flags does not contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT and the pNext chain includes a VkImageFormatListCreateInfo structure, then VkImageFormatListCreateInfo::viewFormatCount must be 0 or 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-06883", "If flags contains VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT, samples must be VK_SAMPLE_COUNT_1_BIT.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-flags-parameter", "flags must be a valid combination of VkImageCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-00943", "format must not be VK_FORMAT_UNDEFINED", "1.3-khr-extensions"},
    {"VUID-VkImageCreateInfo-format-01577", "If format is not a multi-planar format, and flags does not include VK_IMAGE_CREATE_ALIAS_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-02537", "If format is a depth-stencil format and the pNext chain includes a VkImageStencilUsageCreateInfo structure with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-02538", "If the shaderStorageImageMultisample feature is not enabled, format is a depth-stencil format and the pNext chain includes a VkImageStencilUsageCreateInfo structure with its stencilUsage including VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-02795", "If format is a depth-stencil format, usage includes VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-02796", "If format is a depth-stencil format, usage does not include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also not include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-02797", "If format is a depth-stencil format, usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-02798", "If format is a depth-stencil format, usage does not include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also not include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-04712", "If format has a _422 or _420 suffix, width must be a multiple of 2", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-04713", "If format has a _420 suffix, height must be a multiple of 2", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-06410", "If the image format is one of the formats that require a sampler {YCbCr} conversion, mipLevels must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-06411", "If the image format is one of the formats that require a sampler {YCbCr} conversion, samples must be VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-06412", "If the image format is one of the formats that require a sampler {YCbCr} conversion, imageType must be VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-fragmentDensityMapOffset-06514", "If the fragmentDensityMapOffset feature is not enabled and usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.width must be less than or equal to the ceiling of maxFramebufferWidth/minFragmentDensityTexelSize.width", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-fragmentDensityMapOffset-06515", "If the fragmentDensityMapOffset feature is not enabled and usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.height must be less than or equal to the ceiling of maxFramebufferHeight/minFragmentDensityTexelSize.height", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageCreateFormatFeatures-02260", "If format is a multi-planar format, and if imageCreateFormatFeatures (as defined in Image Creation Limits) does not contain VK_FORMAT_FEATURE_DISJOINT_BIT, then flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251", "Each of the following values (as described in Image Creation Limits) must not be undefined : imageCreateMaxMipLevels, imageCreateMaxArrayLayers, imageCreateMaxExtent, and imageCreateSampleCounts", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00954", "If imageType is VK_IMAGE_TYPE_2D and flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be equal and arrayLayers must be greater than or equal to 6", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00956", "If imageType is VK_IMAGE_TYPE_1D, both extent.height and extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00957", "If imageType is VK_IMAGE_TYPE_2D, extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00961", "If imageType is VK_IMAGE_TYPE_3D, arrayLayers must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00970", "If imageType is VK_IMAGE_TYPE_1D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00971", "If the sparseResidencyImage2D feature is not enabled, and imageType is VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00972", "If the sparseResidencyImage3D feature is not enabled, and imageType is VK_IMAGE_TYPE_3D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00973", "If the sparseResidency2Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_2_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00974", "If the sparseResidency4Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_4_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00975", "If the sparseResidency8Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_8_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-00976", "If the sparseResidency16Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_16_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-02082", "If usage includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, imageType must be VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageType-parameter", "imageType must be a valid VkImageType value", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-imageView2DOn3DImage-04459", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::imageView2DOn3DImage is VK_FALSE, flags must not contain VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-initialLayout-00993", "initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-initialLayout-parameter", "initialLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-mipLevels-00947", "mipLevels must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-mipLevels-00958", "mipLevels must be less than or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-mipLevels-02255", "mipLevels must be less than or equal to imageCreateMaxMipLevels (as defined in Image Creation Limits)", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-multisampleArrayImage-04460", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::multisampleArrayImage is VK_FALSE, and samples is not VK_SAMPLE_COUNT_1_BIT, then arrayLayers must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-multisampledRenderToSingleSampled-06882", "If the multisampledRenderToSingleSampled feature is not enabled, flags must not contain VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-00988", "If the pNext chain includes a VkExternalMemoryImageCreateInfoNV structure, it must not contain a VkExternalMemoryImageCreateInfo structure", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-00990", "If the pNext chain includes a VkExternalMemoryImageCreateInfo structure, its handleTypes member must only contain bits that are also in VkExternalImageFormatProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceImageFormatProperties2 with format, imageType, tiling, usage, and flags equal to those in this structure, and with a VkPhysicalDeviceExternalImageFormatInfo structure included in the pNext chain, with a handleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfo::handleTypes", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-00991", "If the pNext chain includes a VkExternalMemoryImageCreateInfoNV structure, its handleTypes member must only contain bits that are also in VkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNV with format, imageType, tiling, usage, and flags equal to those in this structure, and with externalHandleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfoNV::handleTypes", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-01443", "If the pNext chain includes a VkExternalMemoryImageCreateInfo or VkExternalMemoryImageCreateInfoNV structure whose handleTypes member is not 0, initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-01974", "If the pNext chain includes a VkExternalFormatANDROID structure, and its externalFormat member is non-zero the format must be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-01975", "If the pNext chain does not include a VkExternalFormatANDROID structure, or does and its externalFormat member is 0, the format must not be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-02262", "If the pNext chain includes a VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT structure, then tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-02393", "If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, imageType must be VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-02394", "If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, mipLevels must either be 1 or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-02396", "If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, flags must not include VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-02397", "If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, usage must not include any usages except VK_IMAGE_USAGE_SAMPLED_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-02398", "If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, tiling must be VK_IMAGE_TILING_OPTIMAL", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06390", "If the VkImage is to be used to import memory from a VkBufferCollectionFUCHSIA, a VkBufferCollectionImageCreateInfoFUCHSIA structure must be chained to pNext.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06722", "If a VkImageFormatListCreateInfo structure was included in the pNext chain and VkImageFormatListCreateInfo::viewFormatCount is not zero, then each format in VkImageFormatListCreateInfo::pViewFormats must either be compatible with the format as described in the compatibility table or, if flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, be an uncompressed format that is size-compatible with format", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06743", "If the pNext chain includes a VkImageCompressionControlEXT structure, format is a multi-planar format, and VkImageCompressionControlEXT::flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then VkImageCompressionControlEXT::compressionControlPlaneCount must be equal to the number of planes in format", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06744", "If the pNext chain includes a VkImageCompressionControlEXT structure, format is not a multi-planar format, and VkImageCompressionControlEXT::flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then VkImageCompressionControlEXT::compressionControlPlaneCount must be 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06745", "If the pNext chain includes a VkImageCompressionControlEXT structure, and VkImageCompressionControlEXT::flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then VkImageCompressionControlEXT::compressionControlPlaneCount must be 1", "default"},
    {"VUID-VkImageCreateInfo-pNext-06746", "If the pNext chain includes a VkImageCompressionControlEXT structure, it must not contain a VkImageDrmFormatModifierExplicitCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06783", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be either VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT or VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06784", "If the pNext chain includes a VkImportMetalTextureInfoEXT structure its plane member must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06785", "If the pNext chain includes a VkImportMetalTextureInfoEXT structure and the image does not have a multi-planar format, then VkImportMetalTextureInfoEXT::plane must be VK_IMAGE_ASPECT_PLANE_0_BIT.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06786", "If the pNext chain includes a VkImportMetalTextureInfoEXT structure and the image has a multi-planar format with only two planes, then VkImportMetalTextureInfoEXT::plane must not be VK_IMAGE_ASPECT_PLANE_2_BIT.", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-06811", "If the pNext chain includes a VkVideoProfileListInfoKHR structure then supportedVideoFormat must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkBufferCollectionImageCreateInfoFUCHSIA, VkDedicatedAllocationImageCreateInfoNV, VkExportMetalObjectCreateInfoEXT, VkExternalFormatANDROID, VkExternalMemoryImageCreateInfo, VkExternalMemoryImageCreateInfoNV, VkImageCompressionControlEXT, VkImageDrmFormatModifierExplicitCreateInfoEXT, VkImageDrmFormatModifierListCreateInfoEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkImageSwapchainCreateInfoKHR, VkImportMetalIOSurfaceInfoEXT, VkImportMetalTextureInfoEXT, VkOpticalFlowImageFormatInfoNV, or VkVideoProfileListInfoKHR", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-physicalDeviceCount-01421", "If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalObjectCreateInfoEXT or VkImportMetalTextureInfoEXT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-samples-02083", "If usage includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, samples must be VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-samples-02257", "If samples is not VK_SAMPLE_COUNT_1_BIT, then imageType must be VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, mipLevels must be equal to 1, and imageCreateMaybeLinear (as defined in Image Creation Limits) must be VK_FALSE,", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-samples-02258", "samples must be a bit value that is set in imageCreateSampleCounts (as defined in Image Creation Limits)", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-samples-02558", "If samples is not VK_SAMPLE_COUNT_1_BIT, usage must not contain VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-sharingMode-00941", "If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-sharingMode-00942", "If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-sharingMode-01392", "If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device", "1.0"},
    {"VUID-VkImageCreateInfo-sharingMode-01420", "If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-sharingMode-parameter", "sharingMode must be a valid VkSharingMode value", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-tiling-02084", "If usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, tiling must be VK_IMAGE_TILING_OPTIMAL", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-tiling-02261", "If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pNext chain must include exactly one of VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT structures", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-tiling-02353", "If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must include a VkImageFormatListCreateInfo structure with non-zero viewFormatCount", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-tiling-04121", "If tiling is VK_IMAGE_TILING_LINEAR, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-tiling-parameter", "tiling must be a valid VkImageTiling value", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-00963", "If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-00964", "If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-00965", "If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-00966", "If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, usage must also contain at least one of VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-00968", "If the shaderStorageImageMultisample feature is not enabled, and usage contains VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-02559", "If usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.width must be less than or equal to the ceiling of maxFramebufferWidth/minFragmentDensityTexelSize.width", "default"},
    {"VUID-VkImageCreateInfo-usage-02560", "If usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.height must be less than or equal to the ceiling of maxFramebufferHeight/minFragmentDensityTexelSize.height", "default"},
    {"VUID-VkImageCreateInfo-usage-04815", "If usage includes VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, then the pNext chain must include a valid VkVideoProfileListInfoKHR structure with profileCount greater than 0 and pProfiles including at least one VkVideoProfileInfoKHR::videoCodecOperation specifying a decode operation", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-04816", "If usage includes VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR, VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, then the pNext chain must include a valid VkVideoProfileListInfoKHR structure with profileCount greater than 0 and pProfiles including at least one VkVideoProfileInfoKHR::videoCodecOperation specifying an encode operation", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-04992", "If usage includes VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI, tiling must be VK_IMAGE_TILING_LINEAR", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkImageCreateInfo-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-arrayPitch-02268", "For each element of pPlaneLayouts, arrayPitch must be 0 if VkImageCreateInfo::arrayLayers is 1", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-depthPitch-02269", "For each element of pPlaneLayouts, depthPitch must be 0 if VkImageCreateInfo::extent.depth is 1", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifier-02264", "drmFormatModifier must be compatible with the parameters in VkImageCreateInfo and its pNext chain, as determined by querying VkPhysicalDeviceImageFormatInfo2 extended with VkPhysicalDeviceImageDrmFormatModifierInfoEXT", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-drmFormatModifierPlaneCount-02265", "drmFormatModifierPlaneCount must be equal to the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with VkImageCreateInfo::format and drmFormatModifier, as found by querying VkDrmFormatModifierPropertiesListEXT", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-pPlaneLayouts-parameter", "If drmFormatModifierPlaneCount is not 0, pPlaneLayouts must be a valid pointer to an array of drmFormatModifierPlaneCount VkSubresourceLayout structures", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-size-02267", "For each element of pPlaneLayouts, size must be 0", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierListCreateInfoEXT-drmFormatModifierCount-arraylength", "drmFormatModifierCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-02263", "Each modifier in pDrmFormatModifiers must be compatible with the parameters in VkImageCreateInfo and its pNext chain, as determined by querying VkPhysicalDeviceImageFormatInfo2 extended with VkPhysicalDeviceImageDrmFormatModifierInfoEXT", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierListCreateInfoEXT-pDrmFormatModifiers-parameter", "pDrmFormatModifiers must be a valid pointer to an array of drmFormatModifierCount uint64_t values", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierListCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierPropertiesEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageDrmFormatModifierPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-colorSpaceCount-arraylength", "colorSpaceCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-imageCreateInfo-parameter", "imageCreateInfo must be a valid VkImageCreateInfo structure", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-pColorSpaces-parameter", "pColorSpaces must be a valid pointer to an array of colorSpaceCount valid VkSysmemColorSpaceFUCHSIA structures", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-parameter", "requiredFormatFeatures must be a valid combination of VkFormatFeatureFlagBits values", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-requiredFormatFeatures-requiredbitmask", "requiredFormatFeatures must not be 0", "1.3-extensions"},
    {"VUID-VkImageFormatConstraintsInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImageFormatListCreateInfo-pViewFormats-parameter", "If viewFormatCount is not 0, pViewFormats must be a valid pointer to an array of viewFormatCount valid VkFormat values", "1.3-extensions"},
    {"VUID-VkImageFormatListCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkImageFormatProperties2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAndroidHardwareBufferUsageANDROID, VkExternalImageFormatProperties, VkFilterCubicImageViewImageFormatPropertiesEXT, VkImageCompressionPropertiesEXT, VkSamplerYcbcrConversionImageFormatProperties, or VkTextureLODGatherFormatPropertiesAMD", "1.3-extensions"},
    {"VUID-VkImageFormatProperties2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2", "1.3-extensions"},
    {"VUID-VkImageFormatProperties2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-attachmentFeedbackLoopLayout-07313", "If the attachmentFeedbackLoopLayout feature is not enabled, newLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-01207", "If image has a depth/stencil format with both depth and stencil components, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT", "1.1"},
    {"VUID-VkImageMemoryBarrier-image-01671", "If image has a single-plane color format or is not disjoint, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-01672", "If image has a multi-planar format and the image is disjoint, then the aspectMask member of subresourceRange must include either at least one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and VK_IMAGE_ASPECT_PLANE_2_BIT; or must include VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-01673", "If image has a multi-planar format with only two planes, then the aspectMask member of subresourceRange must not include VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-01932", "If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-02902", "If image has a color format, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT", "1.0"},
    {"VUID-VkImageMemoryBarrier-image-03319", "If image has a depth/stencil format with both depth and stencil and the separateDepthStencilLayouts feature is enabled, then the aspectMask member of subresourceRange must include either or both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-03320", "If image has a depth/stencil format with both depth and stencil and the separateDepthStencilLayouts feature is not enabled, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-04069", "If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must be valid queue families", "1.0"},
    {"VUID-VkImageMemoryBarrier-image-04071", "If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is one of the special queue family values reserved for external memory transfers, the other must be VK_QUEUE_FAMILY_IGNORED", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-04072", "If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-newLayout-01198", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, newLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-newLayout-parameter", "newLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01197", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, oldLayout must be VK_IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources affected by the barrier", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01208", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01209", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01210", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01211", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01212", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01213", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01658", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-01659", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-02088", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR then image must have been created with VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR set", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-oldLayout-parameter", "oldLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkSampleLocationsInfoEXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-03938", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL, image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-03939", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL, image must have been created with at least one of VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-04065", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL then image must have been created with at least one of VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-04066", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-04067", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with at least one of VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-04068", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-04070", "If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, at least one must not be a special queue family reserved for external memory ownership transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-srcQueueFamilyIndex-07006", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT then image must have been created with either the VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bits, and the VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT or VK_IMAGE_USAGE_SAMPLED_BIT usage bits, and the VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT usage bit.", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-subresourceRange-01486", "subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-subresourceRange-01488", "subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-subresourceRange-01724", "If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-subresourceRange-01725", "If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-subresourceRange-parameter", "subresourceRange must be a valid VkImageSubresourceRange structure", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-synchronization2-03856", "If the synchronization2 feature is not enabled, and image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex must both be VK_QUEUE_FAMILY_IGNORED", "1.0"},
    {"VUID-VkImageMemoryBarrier-synchronization2-03857", "If the synchronization2 feature is not enabled, and image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, at least one of srcQueueFamilyIndex and dstQueueFamilyIndex must be VK_QUEUE_FAMILY_IGNORED", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier-synchronization2-06911", "If the synchronization2 feature is not enabled, layout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-attachmentFeedbackLoopLayout-07313", "If the attachmentFeedbackLoopLayout feature is not enabled, newLayout must not be VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03900", "If pname:dstAccessMask includes VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03901", "If pname:dstAccessMask includes VK_ACCESS_2_INDEX_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03902", "If pname:dstAccessMask includes VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03903", "If pname:dstAccessMask includes VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03904", "If pname:dstAccessMask includes VK_ACCESS_2_UNIFORM_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03905", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_SAMPLED_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03906", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_STORAGE_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03907", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03908", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-khr-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03909", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03910", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03911", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03912", "If pname:dstAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03913", "If pname:dstAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03914", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03915", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFER_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_CLEAR_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03916", "If pname:dstAccessMask includes VK_ACCESS_2_HOST_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03917", "If pname:dstAccessMask includes VK_ACCESS_2_HOST_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03918", "If pname:dstAccessMask includes VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03919", "If pname:dstAccessMask includes VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03920", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03922", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03923", "If pname:dstAccessMask includes VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03924", "If pname:dstAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03925", "If pname:dstAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03926", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03927", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-03928", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-04747", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-04858", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-04859", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-04860", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-04861", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-04994", "If pname:dstAccessMask includes VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI, pname:dstStageMask must include VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-06254", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "default"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-06255", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-06256", "If the rayQuery feature is not enabled and pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-06257", "If the rayQuery feature is not enabled and pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-07272", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT or VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-07454", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-07455", "If pname:dstAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-07456", "If pname:dstAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-07457", "If pname:dstAccessMask includes VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-07458", "If pname:dstAccessMask includes VK_ACCESS_2_MICROMAP_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstAccessMask-parameter", "dstAccessMask must be a valid combination of VkAccessFlagBits2 values", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03929", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03930", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03931", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03933", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03934", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-03935", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-04956", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-04957", "If the subpassShading feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-04995", "If the invocationMask feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-01207", "If image has a depth/stencil format with both depth and stencil components, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT", "default"},
    {"VUID-VkImageMemoryBarrier2-image-01671", "If image has a single-plane color format or is not disjoint, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-01672", "If image has a multi-planar format and the image is disjoint, then the aspectMask member of subresourceRange must include either at least one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, and VK_IMAGE_ASPECT_PLANE_2_BIT; or must include VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-01673", "If image has a multi-planar format with only two planes, then the aspectMask member of subresourceRange must not include VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-01932", "If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-02902", "If image has a color format, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT", "default"},
    {"VUID-VkImageMemoryBarrier2-image-03319", "If image has a depth/stencil format with both depth and stencil and the separateDepthStencilLayouts feature is enabled, then the aspectMask member of subresourceRange must include either or both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-03320", "If image has a depth/stencil format with both depth and stencil and the separateDepthStencilLayouts feature is not enabled, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-04069", "If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must be valid queue families", "default"},
    {"VUID-VkImageMemoryBarrier2-image-04071", "If image was created with a sharing mode of VK_SHARING_MODE_CONCURRENT, srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, and one of srcQueueFamilyIndex and dstQueueFamilyIndex is one of the special queue family values reserved for external memory transfers, the other must be VK_QUEUE_FAMILY_IGNORED", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-04072", "If image was created with a sharing mode of VK_SHARING_MODE_EXCLUSIVE, and srcQueueFamilyIndex and dstQueueFamilyIndex are not equal, srcQueueFamilyIndex and dstQueueFamilyIndex must both be valid queue families, or one of the special queue family values reserved for external memory transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-newLayout-01198", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, newLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-newLayout-parameter", "newLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01197", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, oldLayout must be VK_IMAGE_LAYOUT_UNDEFINED or the current layout of the image subresources affected by the barrier", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01208", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01209", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01210", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01211", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01212", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01213", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01658", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-01659", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-02088", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR then image must have been created with VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR set", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-oldLayout-parameter", "oldLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkSampleLocationsInfoEXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03900", "If pname:srcAccessMask includes VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03901", "If pname:srcAccessMask includes VK_ACCESS_2_INDEX_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03902", "If pname:srcAccessMask includes VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03903", "If pname:srcAccessMask includes VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03904", "If pname:srcAccessMask includes VK_ACCESS_2_UNIFORM_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03905", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_SAMPLED_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03906", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_STORAGE_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03907", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03908", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-khr-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03909", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03910", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03911", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03912", "If pname:srcAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03913", "If pname:srcAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03914", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03915", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFER_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_CLEAR_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03916", "If pname:srcAccessMask includes VK_ACCESS_2_HOST_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03917", "If pname:srcAccessMask includes VK_ACCESS_2_HOST_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03918", "If pname:srcAccessMask includes VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03919", "If pname:srcAccessMask includes VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03920", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03922", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03923", "If pname:srcAccessMask includes VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03924", "If pname:srcAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03925", "If pname:srcAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03926", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03927", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-03928", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-04747", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-04858", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-04859", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-04860", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-04861", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-04994", "If pname:srcAccessMask includes VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI, pname:srcStageMask must include VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-06254", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "default"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-06255", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-06256", "If the rayQuery feature is not enabled and pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-06257", "If the rayQuery feature is not enabled and pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-07272", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT or VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-07454", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-07455", "If pname:srcAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-07456", "If pname:srcAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-07457", "If pname:srcAccessMask includes VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-07458", "If pname:srcAccessMask includes VK_ACCESS_2_MICROMAP_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcAccessMask-parameter", "srcAccessMask must be a valid combination of VkAccessFlagBits2 values", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-03938", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL, image must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-03939", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL, image must have been created with at least one of VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-04065", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL then image must have been created with at least one of VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-04066", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-04067", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL then image must have been created with at least one of VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_SAMPLED_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-04068", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL then image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT set", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-04070", "If srcQueueFamilyIndex is not equal to dstQueueFamilyIndex, at least one must not be a special queue family reserved for external memory ownership transfers, as described in Queue Family Ownership Transfer", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcQueueFamilyIndex-07006", "If srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, and oldLayout or newLayout is VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT then image must have been created with either the VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT usage bits, and the VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT or VK_IMAGE_USAGE_SAMPLED_BIT usage bits, and the VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT usage bit.", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03854", "If either srcStageMask or dstStageMask includes VK_PIPELINE_STAGE_2_HOST_BIT, srcQueueFamilyIndex and dstQueueFamilyIndex must be equal", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03855", "If srcStageMask includes VK_PIPELINE_STAGE_2_HOST_BIT, and srcQueueFamilyIndex and dstQueueFamilyIndex define a queue family ownership transfer or oldLayout and newLayout define an image layout transition, oldLayout must be one of VK_IMAGE_LAYOUT_PREINITIALIZED, VK_IMAGE_LAYOUT_UNDEFINED, or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03929", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03930", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03931", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03933", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03934", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-03935", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-04956", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-04957", "If the subpassShading feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-04995", "If the invocationMask feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-subresourceRange-01486", "subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-subresourceRange-01488", "subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-subresourceRange-01724", "If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-subresourceRange-01725", "If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-subresourceRange-parameter", "subresourceRange must be a valid VkImageSubresourceRange structure", "1.3-extensions"},
    {"VUID-VkImageMemoryBarrier2-synchronization2-06911", "If the synchronization2 feature is not enabled, layout must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR or VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-01589", "If image was created with a multi-planar format and the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-01590", "If image was not created with the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must not be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-01591", "If image was created with a single-plane format, there must not be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure", "1.3-khr-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-01897", "If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-02279", "If image was created with VK_IMAGE_CREATE_DISJOINT_BIT and with VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-02280", "If image was created with a single-plane format and with any tiling other than VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must not be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkImagePlaneMemoryRequirementsInfo", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2", "1.3-extensions"},
    {"VUID-VkImageMemoryRequirementsInfo2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-imagePipeHandle-04863", "imagePipeHandle must be a valid zx_handle_t", "1.3-extensions"},
    {"VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImagePipeSurfaceCreateInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-02281", "If the image's tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid format plane for the image (that is, for a two-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT, and for a three-plane image planeAspect must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT)", "1.3-extensions"},
    {"VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-02282", "If the image's tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image (that is, aspectMask must specify a plane index that is less than the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with the image's format and VkImageDrmFormatModifierPropertiesEXT::drmFormatModifier)", "1.3-extensions"},
    {"VUID-VkImagePlaneMemoryRequirementsInfo-planeAspect-parameter", "planeAspect must be a valid VkImageAspectFlagBits value", "1.3-extensions"},
    {"VUID-VkImagePlaneMemoryRequirementsInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO", "1.3-extensions"},
    {"VUID-VkImageResolve-aspectMask-00266", "The aspectMask member of srcSubresource and dstSubresource must only contain VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageResolve-dstSubresource-parameter", "dstSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageResolve-layerCount-00267", "The layerCount member of srcSubresource and dstSubresource must match", "1.3-extensions"},
    {"VUID-VkImageResolve-srcSubresource-parameter", "srcSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageResolve2-aspectMask-00266", "The aspectMask member of srcSubresource and dstSubresource must only contain VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageResolve2-dstSubresource-parameter", "dstSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageResolve2-layerCount-00267", "The layerCount member of srcSubresource and dstSubresource must match", "1.3-extensions"},
    {"VUID-VkImageResolve2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageResolve2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2", "1.3-extensions"},
    {"VUID-VkImageResolve2-srcSubresource-parameter", "srcSubresource must be a valid VkImageSubresourceLayers structure", "1.3-extensions"},
    {"VUID-VkImageSparseMemoryRequirementsInfo2-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkImageSparseMemoryRequirementsInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageSparseMemoryRequirementsInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2", "1.3-extensions"},
    {"VUID-VkImageStencilUsageCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkImageStencilUsageCreateInfo-stencilUsage-02539", "If stencilUsage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, it must not include bits other than VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageStencilUsageCreateInfo-stencilUsage-parameter", "stencilUsage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkImageStencilUsageCreateInfo-stencilUsage-requiredbitmask", "stencilUsage must not be 0", "1.3-extensions"},
    {"VUID-VkImageSubresource-aspectMask-parameter", "aspectMask must be a valid combination of VkImageAspectFlagBits values", "1.3-extensions"},
    {"VUID-VkImageSubresource-aspectMask-requiredbitmask", "aspectMask must not be 0", "1.3-extensions"},
    {"VUID-VkImageSubresource2EXT-imageSubresource-parameter", "imageSubresource must be a valid VkImageSubresource structure", "1.3-extensions"},
    {"VUID-VkImageSubresource2EXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageSubresource2EXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT", "1.3-extensions"},
    {"VUID-VkImageSubresourceLayers-aspectMask-00167", "If aspectMask contains VK_IMAGE_ASPECT_COLOR_BIT, it must not contain either of VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-VkImageSubresourceLayers-aspectMask-00168", "aspectMask must not contain VK_IMAGE_ASPECT_METADATA_BIT", "1.3-extensions"},
    {"VUID-VkImageSubresourceLayers-aspectMask-02247", "aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT for any index i", "1.3-extensions"},
    {"VUID-VkImageSubresourceLayers-aspectMask-parameter", "aspectMask must be a valid combination of VkImageAspectFlagBits values", "1.3-extensions"},
    {"VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask", "aspectMask must not be 0", "1.3-extensions"},
    {"VUID-VkImageSubresourceLayers-layerCount-01700", "layerCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageSubresourceRange-aspectMask-01670", "If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, then it must not include any of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-VkImageSubresourceRange-aspectMask-02278", "aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT for any index i", "1.3-extensions"},
    {"VUID-VkImageSubresourceRange-aspectMask-parameter", "aspectMask must be a valid combination of VkImageAspectFlagBits values", "1.3-extensions"},
    {"VUID-VkImageSubresourceRange-aspectMask-requiredbitmask", "aspectMask must not be 0", "1.3-extensions"},
    {"VUID-VkImageSubresourceRange-layerCount-01721", "If layerCount is not VK_REMAINING_ARRAY_LAYERS, it must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageSubresourceRange-levelCount-01720", "If levelCount is not VK_REMAINING_MIP_LEVELS, it must be greater than 0", "1.3-extensions"},
    {"VUID-VkImageSwapchainCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImageSwapchainCreateInfoKHR-swapchain-00995", "If swapchain is not VK_NULL_HANDLE, the fields of VkImageCreateInfo must match the implied image creation parameters of the swapchain", "1.3-extensions"},
    {"VUID-VkImageSwapchainCreateInfoKHR-swapchain-parameter", "If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02230", "decodeMode must be one of VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, or VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", "1.3-extensions"},
    {"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02231", "If the decodeModeSharedExponent feature is not enabled, decodeMode must not be VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", "1.3-extensions"},
    {"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02232", "If decodeMode is VK_FORMAT_R8G8B8A8_UNORM the image view must not include blocks using any of the ASTC HDR modes", "1.3-extensions"},
    {"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-parameter", "decodeMode must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkImageViewASTCDecodeModeEXT-format-04084", "format of the image view must be one of the ASTC Compressed Image Formats", "1.3-extensions"},
    {"VUID-VkImageViewASTCDecodeModeEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT", "1.3-extensions"},
    {"VUID-VkImageViewAddressPropertiesNVX-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageViewAddressPropertiesNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-None-02273", "The format features of the resultant image view must contain at least one bit", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-components-parameter", "components must be a valid VkComponentMapping structure", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-flags-02572", "If the fragmentDensityMapDynamic feature is not enabled, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-flags-03567", "If the fragmentDensityMapDeferred feature is not enabled, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-flags-03568", "If flags contains VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-flags-04116", "If flags does not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT and image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, its flags must not contain any of VK_IMAGE_CREATE_PROTECTED_BIT, VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-flags-parameter", "flags must be a valid combination of VkImageViewCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-format-04714", "If format has a _422 or _420 suffix then image must have been created with a width that is a multiple of 2", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-format-04715", "If format has a _420 suffix then image must have been created with a height that is a multiple of 2", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-format-06415", "If the image view requires a sampler {YCbCr} conversion and usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then the pNext chain must include a VkSamplerYcbcrConversionInfo structure with a conversion value other than VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01003", "If image was not created with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then viewType must not be VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01018", "If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes", "1.0"},
    {"VUID-VkImageViewCreateInfo-image-01019", "If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, format must be identical to the format used to create image", "1.0"},
    {"VUID-VkImageViewCreateInfo-image-01020", "If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01482", "If image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-khr-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01583", "If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with, or must be an uncompressed format that is size-compatible with, the format used to create image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01586", "If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the format of the image is a multi-planar format, and if subresourceRange.aspectMask is one of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT, then format must be compatible with the VkFormat for the plane of the image format indicated by subresourceRange.aspectMask, as defined in Compatible formats of planes of multi-planar formats", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01759", "If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with the format used to create image, as defined in Format Compatibility Classes", "default"},
    {"VUID-VkImageViewCreateInfo-image-01760", "If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes", "default"},
    {"VUID-VkImageViewCreateInfo-image-01761", "If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, but without the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, and if the format of the image is not a multi-planar format, format must be compatible with the format used to create image, as defined in Format Compatibility Classes", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-01762", "If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, or if the format of the image is a multi-planar format and if subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT, format must be identical to the format used to create image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02086", "If image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02087", "If the shadingRateImage feature is enabled, and If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must be VK_FORMAT_R8_UINT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02399", "If image has an external format, format must be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02400", "If image has an external format, the pNext chain must include a VkSamplerYcbcrConversionInfo structure with a conversion object created with the same external format as image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02401", "If image has an external format, all members of components must be the identity swizzle", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02571", "If image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, subresourceRange.levelCount must be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-02724", "If image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange.baseArrayLayer must be less than the depth computed from baseMipLevel and extent.depth specified in VkImageCreateInfo when image was created, according to the formula defined in Image Miplevel Sizing", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-03569", "If image was created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT and usage containing VK_IMAGE_USAGE_SAMPLED_BIT, subresourceRange.layerCount must be less than or equal to VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::maxSubsampledArrayLayers", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-04441", "image must have been created with a usage value containing at least one of the usages defined in the valid image usage list for image views", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-04817", "If image was created with usage containing VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR, VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, then the viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY and all members of components must have the identity swizzle", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-04818", "If image was created with usage containing VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR, VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, then the viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY and all members of components must have the identity swizzle", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-04970", "If image was created with VK_IMAGE_TYPE_3D and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY then subresourceRange.levelCount must be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-04971", "If image was created with VK_IMAGE_TYPE_3D and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY then VkImageCreateInfo::flags must not contain any of VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, and VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-04972", "If image was created with a samples value not equal to VK_SAMPLE_COUNT_1_BIT then viewType must be either VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-06723", "If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then viewType must not be VK_IMAGE_VIEW_TYPE_2D_ARRAY", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-06724", "If image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-06727", "If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set then viewType must not be VK_IMAGE_VIEW_TYPE_2D", "1.3-khr-extensions"},
    {"VUID-VkImageViewCreateInfo-image-06728", "If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, then viewType must not be VK_IMAGE_VIEW_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-07072", "If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag and format is a non-compressed format, the levelCount and layerCount members of subresourceRange must both be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-imageViewFormatReinterpretation-04466", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::imageViewFormatReinterpretation is VK_FALSE, the VkFormat in format must not contain a different number of components, or a different number of bits in each component, than the format of the VkImage in image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-imageViewFormatSwizzle-04465", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::imageViewFormatSwizzle is VK_FALSE, all elements of components must have the identity swizzle", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-imageViewType-04973", "If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, then subresourceRange.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-imageViewType-04974", "If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, then the remaining number of layers must be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-invocationMask-04993", "If the invocationMask feature is enabled, and if image was created with usage containing VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI, format must be VK_FORMAT_R8_UINT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-01585", "If a VkImageFormatListCreateInfo structure was included in the pNext chain of the VkImageCreateInfo structure used when creating image and VkImageFormatListCreateInfo::viewFormatCount is not zero then format must be one of the formats in VkImageFormatListCreateInfo::pViewFormats", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-01970", "If the pNext chain includes a VkSamplerYcbcrConversionInfo structure with a conversion value other than VK_NULL_HANDLE, all members of components must have the identity swizzle", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-02661", "If the pNext chain includes a VkImageViewUsageCreateInfo structure, its usage member must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image", "1.1-khr-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-02662", "If the pNext chain includes a VkImageViewUsageCreateInfo structure, and image was not created with a VkImageStencilUsageCreateInfo structure included in the pNext chain of VkImageCreateInfo, its usage member must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-02663", "If the pNext chain includes a VkImageViewUsageCreateInfo structure, image was created with a VkImageStencilUsageCreateInfo structure included in the pNext chain of VkImageCreateInfo, and subresourceRange.aspectMask includes VK_IMAGE_ASPECT_STENCIL_BIT, the usage member of the VkImageViewUsageCreateInfo structure must not include any bits that were not set in the usage member of the VkImageStencilUsageCreateInfo structure used to create image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-02664", "If the pNext chain includes a VkImageViewUsageCreateInfo structure, image was created with a VkImageStencilUsageCreateInfo structure included in the pNext chain of VkImageCreateInfo, and subresourceRange.aspectMask includes bits other than VK_IMAGE_ASPECT_STENCIL_BIT, the usage member of the VkImageViewUsageCreateInfo structure must not include any bits that were not set in the usage member of the VkImageCreateInfo structure used to create image", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06658", "If the pNext chain includes a VkSamplerYcbcrConversionInfo structure with a conversion value other than VK_NULL_HANDLE, format must be the same used in VkSamplerYcbcrConversionCreateInfo::format", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06787", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06944", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then textureSampleWeighted feature must be enabled", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06945", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then image must have been created with usage containing VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06946", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then components must be VK_COMPONENT_SWIZZLE_IDENTITY for all components", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06947", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then subresourceRange.aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06948", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then subresourceRange.levelCount must be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06949", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then viewType must be VK_IMAGE_VIEW_TYPE_1D_ARRAY or VK_IMAGE_VIEW_TYPE_2D_ARRAY", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06950", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and if viewType is VK_IMAGE_VIEW_TYPE_1D_ARRAY, then image must have been created with imageType VK_IMAGE_TYPE_1D", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06951", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_1D_ARRAY, then subresourceRange.layerCount must be equal to 2.", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06952", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_1D_ARRAY, then image must have been created with width equal to or greater than \\((numPhases \\times \\mathbin{max}\\left( \\mathbin{align}\\left(filterSize.width,4\\right), filterSize.height\\right))\\)", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06953", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and if viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then image must have been created with imageType VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06954", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then subresourceRange.layerCount must be equal or greater than numPhases", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06955", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then image must have been created with width equal to or greater than filterSize.width", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06956", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then image must have been created with height equal to or greater than filterSize.height", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-06957", "If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure then VkImageViewSampleWeightCreateInfoQCOM::filterSize.height must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.height", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportMetalObjectCreateInfoEXT, VkImageViewASTCDecodeModeEXT, VkImageViewMinLodCreateInfoEXT, VkImageViewSampleWeightCreateInfoQCOM, VkImageViewUsageCreateInfo, or VkSamplerYcbcrConversionInfo", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-subResourceRange-01021", "viewType must be compatible with the type of image as shown in the view type compatibility table", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-01478", "subresourceRange.baseMipLevel must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-01480", "subresourceRange.baseArrayLayer must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.0"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-01483", "If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange.layerCount must be non-zero and subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-khr-extensions"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-01718", "If subresourceRange.levelCount is not VK_REMAINING_MIP_LEVELS, subresourceRange.baseMipLevel + subresourceRange.levelCount must be less than or equal to the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-01719", "If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created", "1.0"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-02725", "If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, image is a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT set, and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange.layerCount must be non-zero and subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the depth computed from baseMipLevel and extent.depth specified in VkImageCreateInfo when image was created, according to the formula defined in Image Miplevel Sizing", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-06725", "If subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, image is not a 3D image created with VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, or viewType is not VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY, subresourceRange.layerCount must be non-zero and subresourceRange.baseArrayLayer + subresourceRange.layerCount must be less than or equal to the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-subresourceRange-parameter", "subresourceRange must be a valid VkImageSubresourceRange structure", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-02274", "If usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then the format features of the resultant image view must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-02275", "If usage contains VK_IMAGE_USAGE_STORAGE_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-02276", "If usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-02277", "If usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-02652", "If usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, then the image view's format features must contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-04550", "If the attachmentFragmentShadingRate feature is enabled, and the usage for the image view includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, then the image view's format features must contain VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-04551", "If the attachmentFragmentShadingRate feature is enabled, the usage for the image view includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, and layeredShadingRateAttachments is VK_FALSE, subresourceRange.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-06516", "If usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV, if the image is created with VK_IMAGE_TILING_LINEAR and the linearColorAttachment feature is enabled", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-usage-06517", "If usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV, if the image is created with VK_IMAGE_TILING_LINEAR and the linearColorAttachment feature is enabled", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-viewType-01004", "If the imageCubeArray feature is not enabled, viewType must not be VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-viewType-02960", "If viewType is VK_IMAGE_VIEW_TYPE_CUBE and subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.layerCount must be 6", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-viewType-02961", "If viewType is VK_IMAGE_VIEW_TYPE_CUBE_ARRAY and subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.layerCount must be a multiple of 6", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-viewType-02962", "If viewType is VK_IMAGE_VIEW_TYPE_CUBE and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, the remaining number of layers must be 6", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-viewType-02963", "If viewType is VK_IMAGE_VIEW_TYPE_CUBE_ARRAY and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, the remaining number of layers must be a multiple of 6", "1.3-extensions"},
    {"VUID-VkImageViewCreateInfo-viewType-parameter", "viewType must be a valid VkImageViewType value", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-commonparent", "Both of imageView, and sampler that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-descriptorType-02654", "descriptorType must be VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-descriptorType-parameter", "descriptorType must be a valid VkDescriptorType value", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-imageView-02656", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the image that imageView was created from must have been created with the VK_IMAGE_USAGE_SAMPLED_BIT usage bit set", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-imageView-02657", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the image that imageView was created from must have been created with the VK_IMAGE_USAGE_STORAGE_BIT usage bit set", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-imageView-parameter", "imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-sampler-02655", "sampler must be a valid VkSampler if descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER", "1.3-extensions"},
    {"VUID-VkImageViewHandleInfoNVX-sampler-parameter", "If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle", "1.3-extensions"},
    {"VUID-VkImageViewMinLodCreateInfoEXT-minLod-06455", "If the minLod feature is not enabled, minLod must be 0.0.", "1.3-extensions"},
    {"VUID-VkImageViewMinLodCreateInfoEXT-minLod-06456", "minLod must be less or equal to the index of the last mipmap level accessible to the view.", "1.3-extensions"},
    {"VUID-VkImageViewMinLodCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06960", "filterCenter.x must be less than or equal to (filterSize.width - 1)", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06961", "filterCenter.y must be less than or equal to (filterSize.height - 1)", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06958", "filterSize.width must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.width", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06959", "filterSize.height must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.height", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06962", "numPhases must be a power of two squared value (i.e., 1, 4, 16, 64, 256, etc.)", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06963", "numPhases must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterPhases", "1.3-extensions"},
    {"VUID-VkImageViewSampleWeightCreateInfoQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM", "1.3-extensions"},
    {"VUID-VkImageViewUsageCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkImageViewUsageCreateInfo-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkImageViewUsageCreateInfo-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01880", "If buffer is not NULL, Android hardware buffers must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties", "1.3-extensions"},
    {"VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01881", "If buffer is not NULL, it must be a valid Android hardware buffer object with AHardwareBuffer_Desc::usage compatible with Vulkan as described in Android Hardware Buffers", "1.3-extensions"},
    {"VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-parameter", "buffer must be a valid pointer to an AHardwareBuffer value", "1.3-extensions"},
    {"VUID-VkImportAndroidHardwareBufferInfoANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-fd-01541", "fd must obey any requirements listed for handleType in external fence handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-fence-parameter", "fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-flags-parameter", "flags must be a valid combination of VkFenceImportFlagBits values", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-handleType-01464", "handleType must be a value included in the Handle Types Supported by VkImportFenceFdInfoKHR table", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-handleType-07306", "If handleType refers to a handle type with copy payload transference semantics, flags must contain VK_FENCE_IMPORT_TEMPORARY_BIT", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-handleType-parameter", "handleType must be a valid VkExternalFenceHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImportFenceFdInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-fence-parameter", "fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-flags-parameter", "flags must be a valid combination of VkFenceImportFlagBits values", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-handle-01462", "If handle is not NULL, name must be NULL", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-handle-01539", "If handle is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01457", "handleType must be a value included in the Handle Types Supported by VkImportFenceWin32HandleInfoKHR table", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01459", "If handleType is not VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, name must be NULL", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01460", "If handle is NULL, name must name a valid synchronization primitive of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01461", "If name is NULL, handle must be a valid handle of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-name-01540", "If name is not NULL, it must obey any requirements listed for handleType in external fence handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImportFenceWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImportMemoryBufferCollectionFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-VkImportMemoryBufferCollectionFUCHSIA-index-06406", "index must be less than the value retrieved as VkBufferCollectionPropertiesFUCHSIA:bufferCount", "1.3-extensions"},
    {"VUID-VkImportMemoryBufferCollectionFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-fd-00668", "The memory from which fd was exported must have been created on the same underlying physical device as device", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-fd-01520", "fd must obey any requirements listed for handleType in external memory handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-fd-01746", "The memory represented by fd must have been created from a physical device and driver that is compatible with device and handleType, as described in External memory handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-handleType-00667", "If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-handleType-00669", "If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-handleType-00670", "If handleType is not 0, fd must be a valid handle of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-handleType-parameter", "If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportMemoryFdInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-handleType-01747", "If handleType is not 0, it must be supported for import, as reported in VkExternalMemoryProperties", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-handleType-01748", "If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-handleType-01750", "If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-handleType-01751", "If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to allocationSize number of bytes of host mapped foreign memory, where allocationSize is the member of the VkMemoryAllocateInfo structure this structure is chained to", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-01749", "pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment", "1.3-extensions"},
    {"VUID-VkImportMemoryHostPointerInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handle-00659", "The memory from which handle was exported, or the memory named by name must have been created on the same underlying physical device as device", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handle-01441", "if handle is not NULL, name must be NULL", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handle-01518", "If handle is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00658", "If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00660", "If handleType is not 0, it must be defined as an NT handle or a global share handle", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00661", "If handleType is not 0 and name is NULL, handle must be a valid handle of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-01439", "If handleType is not VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, name must be NULL", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-01440", "If handleType is not 0 and handle is NULL, name must name a valid memory resource of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-parameter", "If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-name-01519", "If name is not NULL, it must obey any requirements listed for handleType in external memory handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoNV-handle-01328", "handle must be a valid handle to memory, obtained as specified by handleType", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoNV-handleType-01327", "handleType must not have more than one bit set", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoNV-handleType-parameter", "handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkImportMemoryWin32HandleInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV", "1.3-extensions"},
    {"VUID-VkImportMemoryZirconHandleInfoFUCHSIA-handle-04772", "handle must be a valid VMO handle", "1.3-extensions"},
    {"VUID-VkImportMemoryZirconHandleInfoFUCHSIA-handleType-04771", "handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImportMemoryZirconHandleInfoFUCHSIA-handleType-parameter", "If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportMemoryZirconHandleInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImportMetalBufferInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImportMetalIOSurfaceInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImportMetalSharedEventInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImportMetalTextureInfoEXT-plane-parameter", "plane must be a valid VkImageAspectFlagBits value", "1.3-extensions"},
    {"VUID-VkImportMetalTextureInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-fd-01544", "fd must obey any requirements listed for handleType in external semaphore handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-flags-03323", "If flags contains VK_SEMAPHORE_IMPORT_TEMPORARY_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field of the semaphore from which fd was exported must not be VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-flags-parameter", "flags must be a valid combination of VkSemaphoreImportFlagBits values", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-handleType-01143", "handleType must be a value included in the Handle Types Supported by VkImportSemaphoreFdInfoKHR table", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-handleType-03263", "If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT, the VkSemaphoreCreateInfo::flags field must match that of the semaphore from which fd was exported", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-handleType-03264", "If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field must match that of the semaphore from which fd was exported", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-handleType-07307", "If handleType refers to a handle type with copy payload transference semantics, flags must contain VK_SEMAPHORE_IMPORT_TEMPORARY_BIT", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-handleType-parameter", "handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImportSemaphoreFdInfoKHR-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-03322", "If flags contains VK_SEMAPHORE_IMPORT_TEMPORARY_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field of the semaphore from which handle or name was exported must not be VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-parameter", "flags must be a valid combination of VkSemaphoreImportFlagBits values", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01469", "If handle is not NULL, name must be NULL", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01542", "If handle is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01140", "handleType must be a value included in the Handle Types Supported by VkImportSemaphoreWin32HandleInfoKHR table", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01466", "If handleType is not VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, name must be NULL", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01467", "If handle is NULL, name must name a valid synchronization primitive of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01468", "If name is NULL, handle must be a valid handle of the type specified by handleType", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-03261", "If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, the VkSemaphoreCreateInfo::flags field must match that of the semaphore from which handle or name was exported", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-03262", "If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field must match that of the semaphore from which handle or name was exported", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-name-01543", "If name is not NULL, it must obey any requirements listed for handleType in external semaphore handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkImportSemaphoreWin32HandleInfoKHR-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-flags-parameter", "flags must be a valid combination of VkSemaphoreImportFlagBits values", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-04765", "handleType must be a value included in the Handle Types Supported by VkImportSemaphoreZirconHandleInfoFUCHSIA table", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-handleType-parameter", "handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-semaphoreType-04768", "The VkSemaphoreTypeCreateInfo::semaphoreType field must not be VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-zirconHandle-04766", "zirconHandle must obey any requirements listed for handleType in external semaphore handle types compatibility", "1.3-extensions"},
    {"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-zirconHandle-04767", "zirconHandle must have ZX_RIGHTS_BASIC and ZX_RIGHTS_SIGNAL rights", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-flags-parameter", "flags must be a valid combination of VkIndirectCommandsLayoutUsageFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pStreamStrides-02937", "each element of pStreamStrides must be greater than `0`and less than or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectCommandsStreamStride. Furthermore the alignment of each token input must be ensured", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pStreamStrides-parameter", "pStreamStrides must be a valid pointer to an array of streamCount uint32_t values", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02932", "If pTokens contains an entry of VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV it must be the first element of the array and there must be only a single element of such token type", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02933", "If pTokens contains an entry of VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV there must be only a single element of such token type", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02934", "All state tokens in pTokens must occur before any work provoking tokens (VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV, VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV)", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-02935", "The content of pTokens must include one single work provoking token that is compatible with the pipelineBindPoint", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pTokens-parameter", "pTokens must be a valid pointer to an array of tokenCount valid VkIndirectCommandsLayoutTokenNV structures", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-02930", "The pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-streamCount-02936", "streamCount must be greater than 0 and less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectCommandsStreamCount", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-streamCount-arraylength", "streamCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-tokenCount-02931", "tokenCount must be greater than 0 and less than or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectCommandsTokenCount", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutCreateInfoNV-tokenCount-arraylength", "tokenCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-indirectStateFlags-parameter", "indirectStateFlags must be a valid combination of VkIndirectStateFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-offset-02952", "offset must be less than or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectCommandsTokenOffset", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-offset-06888", "offset must be aligned to the scalar alignment of tokenType or minIndirectCommandsBufferOffsetAlignment, whichever is lower", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypeValues-parameter", "If indexTypeCount is not 0, pIndexTypeValues must be a valid pointer to an array of indexTypeCount uint32_t values", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-pIndexTypes-parameter", "If indexTypeCount is not 0, pIndexTypes must be a valid pointer to an array of indexTypeCount valid VkIndexType values", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-pushconstantPipelineLayout-parameter", "If pushconstantPipelineLayout is not VK_NULL_HANDLE, pushconstantPipelineLayout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-pushconstantShaderStageFlags-parameter", "pushconstantShaderStageFlags must be a valid combination of VkShaderStageFlagBits values", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-stream-02951", "stream must be smaller than VkIndirectCommandsLayoutCreateInfoNV::streamCount", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02976", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV, vertexBindingUnit must stay within device supported limits for the appropriate commands", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02977", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, pushconstantPipelineLayout must be valid", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02978", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, pushconstantOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02979", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, pushconstantSize must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02980", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, pushconstantOffset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02981", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, pushconstantSize must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus pushconstantOffset", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02982", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, for each byte in the range specified by pushconstantOffset and pushconstantSize and for each shader stage in pushconstantShaderStageFlags, there must be a push constant range in pushconstantPipelineLayout that includes that byte and that stage", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02983", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, for each byte in the range specified by pushconstantOffset and pushconstantSize and for each push constant range that overlaps that byte, pushconstantShaderStageFlags must include all stages in that push constant range's VkPushConstantRange::stageFlags", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-02984", "If tokenType is VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV, indirectStateFlags must not be 0", "1.3-extensions"},
    {"VUID-VkIndirectCommandsLayoutTokenNV-tokenType-parameter", "tokenType must be a valid VkIndirectCommandsTokenTypeNV value", "1.3-extensions"},
    {"VUID-VkIndirectCommandsStreamNV-buffer-02942", "The buffer's usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-VkIndirectCommandsStreamNV-buffer-02975", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkIndirectCommandsStreamNV-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkIndirectCommandsStreamNV-offset-02943", "The offset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minIndirectCommandsBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkInitializePerformanceApiInfoINTEL-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkInitializePerformanceApiInfoINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL", "1.3-extensions"},
    {"VUID-VkInputAttachmentAspectReference-aspectMask-01964", "aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT", "1.3-extensions"},
    {"VUID-VkInputAttachmentAspectReference-aspectMask-02250", "aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT for any index i", "1.3-extensions"},
    {"VUID-VkInputAttachmentAspectReference-aspectMask-parameter", "aspectMask must be a valid combination of VkImageAspectFlagBits values", "1.3-extensions"},
    {"VUID-VkInputAttachmentAspectReference-aspectMask-requiredbitmask", "aspectMask must not be 0", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-flags-06559", "If flags has the VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR bit set, the list of enabled extensions in ppEnabledExtensionNames must contain VK_KHR_portability_enumeration", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-flags-parameter", "flags must be a valid combination of VkInstanceCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-pApplicationInfo-parameter", "If pApplicationInfo is not NULL, pApplicationInfo must be a valid pointer to a valid VkApplicationInfo structure", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-pNext-04925", "If the pNext chain of VkInstanceCreateInfo includes a VkDebugReportCallbackCreateInfoEXT structure, the list of enabled extensions in ppEnabledExtensionNames must contain VK_EXT_debug_report", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-pNext-04926", "If the pNext chain of VkInstanceCreateInfo includes a VkDebugUtilsMessengerCreateInfoEXT structure, the list of enabled extensions in ppEnabledExtensionNames must contain VK_EXT_debug_utils", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-pNext-06779", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be either VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT or VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDebugReportCallbackCreateInfoEXT, VkDebugUtilsMessengerCreateInfoEXT, VkExportMetalObjectCreateInfoEXT, VkValidationFeaturesEXT, or VkValidationFlagsEXT", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter", "If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter", "If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkInstanceCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkDebugUtilsMessengerCreateInfoEXT or VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkMacOSSurfaceCreateInfoMVK-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkMacOSSurfaceCreateInfoMVK-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMacOSSurfaceCreateInfoMVK-pView-01317", "If pView is an NSView object, it must be a valid NSView, must be backed by a CALayer object of type CAMetalLayer, and vkCreateMacOSSurfaceMVK must be called on the main thread", "1.3-extensions"},
    {"VUID-VkMacOSSurfaceCreateInfoMVK-pView-04144", "If pView is a CAMetalLayer object, it must be a valid CAMetalLayer", "1.3-extensions"},
    {"VUID-VkMacOSSurfaceCreateInfoMVK-sType-sType", "sType must be VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-memory-00684", "memory must be currently host mapped", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-offset-00687", "offset must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-sType-sType", "sType must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-size-00685", "If size is not equal to VK_WHOLE_SIZE, offset and size must specify a range contained within the currently mapped range of memory", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-size-00686", "If size is equal to VK_WHOLE_SIZE, offset must be within the currently mapped range of memory", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-size-01389", "If size is equal to VK_WHOLE_SIZE, the end of the current mapping of memory must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize bytes from the beginning of the memory object, or be equal to the end of the memory object", "1.3-extensions"},
    {"VUID-VkMappedMemoryRange-size-01390", "If size is not equal to VK_WHOLE_SIZE, size must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize, or offset plus size must equal the size of memory", "1.3-extensions"},
    {"VUID-VkMemoryAllocateFlagsInfo-deviceMask-00675", "If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must be a valid device mask", "1.3-extensions"},
    {"VUID-VkMemoryAllocateFlagsInfo-deviceMask-00676", "If VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT is set, deviceMask must not be zero", "1.3-extensions"},
    {"VUID-VkMemoryAllocateFlagsInfo-flags-parameter", "flags must be a valid combination of VkMemoryAllocateFlagBits values", "1.3-extensions"},
    {"VUID-VkMemoryAllocateFlagsInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-None-00643", "If the parameters define an import operation and the external handle specified was created by the Vulkan API, the device mask specified by VkMemoryAllocateFlagsInfo must match the mask specified when the payload being imported was allocated", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-None-00644", "If the parameters define an import operation and the external handle specified was created by the Vulkan API, the list of physical devices that comprise the logical device passed to vkAllocateMemory must match the list of physical devices that comprise the logical device on which the payload was originally allocated", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-None-04749", "If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA, the value of memoryTypeIndex must be an index identifying a memory type from the memoryTypeBits field of the VkMemoryZirconHandlePropertiesFUCHSIA structure populated by a call to vkGetMemoryZirconHandlePropertiesFUCHSIA", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-None-06657", "The parameters must not define more than one import operation", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-00638", "allocationSize must be greater than 0", "1.3-khr-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-00647", "If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, allocationSize must match the size specified when creating the Direct3D 12 heap from which the payload was extracted", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-01742", "If the parameters define an import operation, the external handle specified was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, then the values of allocationSize and memoryTypeIndex must match those specified when the payload being imported was created", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-01743", "If the parameters define an import operation, the external handle was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, then the values of allocationSize and memoryTypeIndex must match those specified when the payload being imported was created", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-01745", "If the parameters define an import operation and the external handle is a host pointer, allocationSize must be an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-02383", "If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, allocationSize must be the size returned by vkGetAndroidHardwareBufferPropertiesANDROID for the Android hardware buffer", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-04750", "If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA, the value of allocationSize must be greater than 0 and must be less than or equal to the size of the VMO as determined by zx_vmo_get_size(handle) where handle is the VMO handle to the imported external memory", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-allocationSize-06382", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA, allocationSize must match VkMemoryRequirements::size value retrieved by vkGetImageMemoryRequirements or vkGetBufferMemoryRequirements for image-based or buffer-based collections respectively", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-buffer-06380", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA, and VkMemoryDedicatedAllocateInfo::buffer is present and non-NULL, VkImportMemoryBufferCollectionFUCHSIA::collection and VkImportMemoryBufferCollectionFUCHSIA::index must match VkBufferCollectionBufferCreateInfoFUCHSIA::collection and VkBufferCollectionBufferCreateInfoFUCHSIA::index, respectively, of the VkBufferCollectionBufferCreateInfoFUCHSIA structure used to create the VkMemoryDedicatedAllocateInfo::buffer", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-buffer-06385", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA and VkMemoryDedicatedAllocateInfo::buffer is not VK_NULL_HANDLE, the buffer must be created with a VkBufferCollectionBufferCreateInfoFUCHSIA structure chained to its VkBufferCreateInfo::pNext pointer", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-flags-03330", "If VkMemoryAllocateFlagsInfo::flags includes VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, the bufferDeviceAddressCaptureReplay feature must be enabled", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-flags-03331", "If VkMemoryAllocateFlagsInfo::flags includes VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT, the bufferDeviceAddress feature must be enabled", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-image-06381", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA, and VkMemoryDedicatedAllocateInfo::image is present and non-NULL, VkImportMemoryBufferCollectionFUCHSIA::collection and VkImportMemoryBufferCollectionFUCHSIA::index must match VkBufferCollectionImageCreateInfoFUCHSIA::collection and VkBufferCollectionImageCreateInfoFUCHSIA::index, respectively, of the VkBufferCollectionImageCreateInfoFUCHSIA structure used to create the VkMemoryDedicatedAllocateInfo::image", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-image-06384", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA and VkMemoryDedicatedAllocateInfo::image is not VK_NULL_HANDLE, the image must be created with a VkBufferCollectionImageCreateInfoFUCHSIA structure chained to its VkImageCreateInfo::pNext pointer", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-memoryTypeIndex-00645", "If the parameters define an import operation and the external handle is an NT handle or a global share handle created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryWin32HandlePropertiesKHR", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-memoryTypeIndex-00648", "If the parameters define an import operation and the external handle is a POSIX file descriptor created outside of the Vulkan API, the value of memoryTypeIndex must be one of those returned by vkGetMemoryFdPropertiesKHR", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-memoryTypeIndex-01744", "If the parameters define an import operation and the external handle is a host pointer, the value of memoryTypeIndex must be one of those returned by vkGetMemoryHostPointerPropertiesEXT", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-memoryTypeIndex-01872", "If the protectedMemory feature is not enabled, the VkMemoryAllocateInfo::memoryTypeIndex must not indicate a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-memoryTypeIndex-02385", "If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, memoryTypeIndex must be one of those returned by vkGetAndroidHardwareBufferPropertiesANDROID for the Android hardware buffer", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-memoryTypeIndex-06386", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA, memoryTypeIndex must be from VkBufferCollectionPropertiesFUCHSIA as retrieved by vkGetBufferCollectionPropertiesFUCHSIA.", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-opaqueCaptureAddress-03329", "If VkMemoryOpaqueCaptureAddressAllocateInfo::opaqueCaptureAddress is not zero, VkMemoryAllocateFlagsInfo::flags must include VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-opaqueCaptureAddress-03333", "If the parameters define an import operation, VkMemoryOpaqueCaptureAddressAllocateInfo::opaqueCaptureAddress must be zero", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-00639", "If the pNext chain includes a VkExportMemoryAllocateInfo structure, and any of the handle types specified in VkExportMemoryAllocateInfo::handleTypes require a dedicated allocation, as reported by vkGetPhysicalDeviceImageFormatProperties2 in VkExternalImageFormatProperties::externalMemoryProperties.externalMemoryFeatures or VkExternalBufferProperties::externalMemoryProperties.externalMemoryFeatures, the pNext chain must include a VkMemoryDedicatedAllocateInfo or VkDedicatedAllocationMemoryAllocateInfoNV structure with either its image or buffer member set to a value other than VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-00640", "If the pNext chain includes a VkExportMemoryAllocateInfo structure, it must not include a VkExportMemoryAllocateInfoNV or VkExportMemoryWin32HandleInfoNV structure", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-00641", "If the pNext chain includes a VkImportMemoryWin32HandleInfoKHR structure, it must not include a VkImportMemoryWin32HandleInfoNV structure", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-01874", "If the parameters do not define an import operation, and the pNext chain includes a VkExportMemoryAllocateInfo structure with VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID included in its handleTypes member, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image not equal to VK_NULL_HANDLE, then allocationSize must be 0, otherwise allocationSize must be greater than 0", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02384", "If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, and the pNext chain does not include a VkMemoryDedicatedAllocateInfo structure or VkMemoryDedicatedAllocateInfo::image is VK_NULL_HANDLE, the Android hardware buffer must have a AHardwareBuffer_Desc::format of AHARDWAREBUFFER_FORMAT_BLOB and a AHardwareBuffer_Desc::usage that includes AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02386", "If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the Android hardware buffer's AHardwareBuffer::usage must include at least one of AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER, AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE or AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02387", "If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the format of image must be VK_FORMAT_UNDEFINED or the format returned by vkGetAndroidHardwareBufferPropertiesANDROID in VkAndroidHardwareBufferFormatPropertiesANDROID::format for the Android hardware buffer", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02388", "If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image that is not VK_NULL_HANDLE, the width, height, and array layer dimensions of image and the Android hardware buffer's AHardwareBuffer_Desc must be identical", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02389", "If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image that is not VK_NULL_HANDLE, and the Android hardware buffer's AHardwareBuffer::usage includes AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have a complete mipmap chain", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02390", "If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image that is not VK_NULL_HANDLE, each bit set in the usage of image must be listed in AHardwareBuffer Usage Equivalence, and if there is a corresponding AHARDWAREBUFFER_USAGE bit listed that bit must be included in the Android hardware buffer's AHardwareBuffer_Desc::usage", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02586", "If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image that is not VK_NULL_HANDLE, and the Android hardware buffer's AHardwareBuffer::usage does not include AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have exactly one mipmap level", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02805", "If the parameters define an import operation and the external handle is a host pointer, the pNext chain must not include a VkDedicatedAllocationMemoryAllocateInfoNV structure with either its image or buffer field set to a value other than VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-02806", "If the parameters define an import operation and the external handle is a host pointer, the pNext chain must not include a VkMemoryDedicatedAllocateInfo structure with either its image or buffer field set to a value other than VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-03332", "If the pNext chain includes a VkImportMemoryHostPointerInfoEXT structure, VkMemoryOpaqueCaptureAddressAllocateInfo::opaqueCaptureAddress must be zero", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-06383", "If the parameters define an import operation from an VkBufferCollectionFUCHSIA, the pNext chain must include a VkMemoryDedicatedAllocateInfo structure with either its image or buffer field set to a value other than VK_NULL_HANDLE.", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-06780", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDedicatedAllocationMemoryAllocateInfoNV, VkExportMemoryAllocateInfo, VkExportMemoryAllocateInfoNV, VkExportMemoryWin32HandleInfoKHR, VkExportMemoryWin32HandleInfoNV, VkExportMetalObjectCreateInfoEXT, VkImportAndroidHardwareBufferInfoANDROID, VkImportMemoryBufferCollectionFUCHSIA, VkImportMemoryFdInfoKHR, VkImportMemoryHostPointerInfoEXT, VkImportMemoryWin32HandleInfoKHR, VkImportMemoryWin32HandleInfoNV, VkImportMemoryZirconHandleInfoFUCHSIA, VkImportMetalBufferInfoEXT, VkMemoryAllocateFlagsInfo, VkMemoryDedicatedAllocateInfo, VkMemoryOpaqueCaptureAddressAllocateInfo, or VkMemoryPriorityAllocateInfoEXT", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkMemoryAllocateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier-dstAccessMask-parameter", "dstAccessMask must be a valid combination of VkAccessFlagBits values", "1.3-extensions"},
    {"VUID-VkMemoryBarrier-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryBarrier-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_BARRIER", "1.3-extensions"},
    {"VUID-VkMemoryBarrier-srcAccessMask-parameter", "srcAccessMask must be a valid combination of VkAccessFlagBits values", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03900", "If pname:dstAccessMask includes VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03901", "If pname:dstAccessMask includes VK_ACCESS_2_INDEX_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03902", "If pname:dstAccessMask includes VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03903", "If pname:dstAccessMask includes VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03904", "If pname:dstAccessMask includes VK_ACCESS_2_UNIFORM_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03905", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_SAMPLED_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03906", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_STORAGE_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03907", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03908", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-khr-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03909", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03910", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03911", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03912", "If pname:dstAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03913", "If pname:dstAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03914", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03915", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFER_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_CLEAR_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03916", "If pname:dstAccessMask includes VK_ACCESS_2_HOST_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03917", "If pname:dstAccessMask includes VK_ACCESS_2_HOST_WRITE_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03918", "If pname:dstAccessMask includes VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03919", "If pname:dstAccessMask includes VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03920", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03922", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03923", "If pname:dstAccessMask includes VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03924", "If pname:dstAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03925", "If pname:dstAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03926", "If pname:dstAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03927", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-03928", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-04747", "If pname:dstAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-04858", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-04859", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-04860", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-04861", "If pname:dstAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-04994", "If pname:dstAccessMask includes VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI, pname:dstStageMask must include VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-06254", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "default"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-06255", "If pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-06256", "If the rayQuery feature is not enabled and pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-06257", "If the rayQuery feature is not enabled and pname:dstAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:dstStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-07272", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT or VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-07454", "If pname:dstAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-07455", "If pname:dstAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-07456", "If pname:dstAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV, pname:dstStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-07457", "If pname:dstAccessMask includes VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-07458", "If pname:dstAccessMask includes VK_ACCESS_2_MICROMAP_READ_BIT_EXT, pname:dstStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstAccessMask-parameter", "dstAccessMask must be a valid combination of VkAccessFlagBits2 values", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03929", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03930", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03931", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03933", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03934", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-03935", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-04956", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkMemoryBarrier2-dstStageMask-04957", "If the subpassShading feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-04995", "If the invocationMask feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkMemoryBarrier2-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_BARRIER_2", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03900", "If pname:srcAccessMask includes VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03901", "If pname:srcAccessMask includes VK_ACCESS_2_INDEX_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03902", "If pname:srcAccessMask includes VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT, VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03903", "If pname:srcAccessMask includes VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03904", "If pname:srcAccessMask includes VK_ACCESS_2_UNIFORM_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03905", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_SAMPLED_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03906", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_STORAGE_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03907", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03908", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-khr-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03909", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03910", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03911", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03912", "If pname:srcAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03913", "If pname:srcAccessMask includes VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03914", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03915", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFER_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COPY_BIT, VK_PIPELINE_STAGE_2_BLIT_BIT, VK_PIPELINE_STAGE_2_RESOLVE_BIT, VK_PIPELINE_STAGE_2_CLEAR_BIT, VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03916", "If pname:srcAccessMask includes VK_ACCESS_2_HOST_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03917", "If pname:srcAccessMask includes VK_ACCESS_2_HOST_WRITE_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03918", "If pname:srcAccessMask includes VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03919", "If pname:srcAccessMask includes VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03920", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03922", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03923", "If pname:srcAccessMask includes VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03924", "If pname:srcAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03925", "If pname:srcAccessMask includes VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03926", "If pname:srcAccessMask includes VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03927", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-03928", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-04747", "If pname:srcAccessMask includes VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT, VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT, VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, or VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-04858", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-04859", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-04860", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-04861", "If pname:srcAccessMask includes VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-04994", "If pname:srcAccessMask includes VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI, pname:srcStageMask must include VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-06254", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "default"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-06255", "If pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-06256", "If the rayQuery feature is not enabled and pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages except VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-06257", "If the rayQuery feature is not enabled and pname:srcAccessMask includes VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR, pname:srcStageMask must not include any of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "default"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-07272", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT or VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-07454", "If pname:srcAccessMask includes VK_ACCESS_2_SHADER_READ_BIT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR, VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or one of the VK_PIPELINE_STAGE_*_SHADER_BIT stages", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-07455", "If pname:srcAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-07456", "If pname:srcAccessMask includes VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV, pname:srcStageMask must include VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-07457", "If pname:srcAccessMask includes VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-07458", "If pname:srcAccessMask includes VK_ACCESS_2_MICROMAP_READ_BIT_EXT, pname:srcStageMask must include VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT or VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcAccessMask-parameter", "srcAccessMask must be a valid combination of VkAccessFlagBits2 values", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03929", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03930", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03931", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03933", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03934", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-03935", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-04956", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkMemoryBarrier2-srcStageMask-04957", "If the subpassShading feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-04995", "If the invocationMask feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkMemoryBarrier2-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-01435", "If buffer is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer", "1.3-khr-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-01436", "If buffer is not VK_NULL_HANDLE, buffer must have been created without VK_BUFFER_CREATE_SPARSE_BINDING_BIT set in VkBufferCreateInfo::flags", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-01877", "If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-01879", "If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-02965", "If buffer is not VK_NULL_HANDLE and the memory is not an imported Android Hardware Buffer, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-04752", "If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-buffer-parameter", "If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-commonparent", "Both of buffer, and image that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-01432", "At least one of image and buffer must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-01433", "If image is not VK_NULL_HANDLE, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image", "1.3-khr-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-01434", "If image is not VK_NULL_HANDLE, image must have been created without VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in VkImageCreateInfo::flags", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-01797", "If image is not VK_NULL_HANDLE, image must not have been created with VK_IMAGE_CREATE_DISJOINT_BIT set in VkImageCreateInfo::flags", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-01876", "If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-01878", "If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-02964", "If image is not VK_NULL_HANDLE and the memory is not an imported Android Hardware Buffer, VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-04751", "If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-image-parameter", "If image is not VK_NULL_HANDLE, image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkMemoryDedicatedRequirements-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS", "1.3-extensions"},
    {"VUID-VkMemoryFdPropertiesKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryFdPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-handleTypes-01882", "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created", "1.3-extensions"},
    {"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-01883", "If the pNext chain of the VkMemoryAllocateInfo used to allocate memory included a VkMemoryDedicatedAllocateInfo with non-NULL image member, then that image must already be bound to memory", "1.3-extensions"},
    {"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID", "1.3-extensions"},
    {"VUID-VkMemoryGetFdInfoKHR-handleType-00671", "handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created", "1.3-extensions"},
    {"VUID-VkMemoryGetFdInfoKHR-handleType-00672", "handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMemoryGetFdInfoKHR-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkMemoryGetFdInfoKHR-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkMemoryGetFdInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryGetFdInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR", "1.3-extensions"},
    {"VUID-VkMemoryGetRemoteAddressInfoNV-handleType-04966", "handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created", "1.3-extensions"},
    {"VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkMemoryGetRemoteAddressInfoNV-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkMemoryGetRemoteAddressInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryGetRemoteAddressInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662", "handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00663", "If handleType is defined as an NT handle, vkGetMemoryWin32HandleKHR must be called no more than once for each valid unique combination of memory and handleType", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00664", "handleType must be defined as an NT handle or a global share handle", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryGetWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-04775", "handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA", "1.3-extensions"},
    {"VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-04776", "handleType must have been included in the handleTypes field of the VkExportMemoryAllocateInfo structure when the external memory was allocated", "1.3-extensions"},
    {"VUID-VkMemoryGetZirconHandleInfoFUCHSIA-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkMemoryGetZirconHandleInfoFUCHSIA-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkMemoryGetZirconHandleInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryGetZirconHandleInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkMemoryHostPointerPropertiesEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryHostPointerPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkMemoryOpaqueCaptureAddressAllocateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO", "1.3-extensions"},
    {"VUID-VkMemoryPriorityAllocateInfoEXT-priority-02602", "priority must be between 0 and 1, inclusive", "1.3-extensions"},
    {"VUID-VkMemoryPriorityAllocateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMemoryRequirements2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkMemoryDedicatedRequirements", "1.3-extensions"},
    {"VUID-VkMemoryRequirements2-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2", "1.3-extensions"},
    {"VUID-VkMemoryRequirements2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkMemoryWin32HandlePropertiesKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryWin32HandlePropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkMemoryZirconHandlePropertiesFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMemoryZirconHandlePropertiesFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA", "1.3-extensions"},
    {"VUID-VkMetalSurfaceCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkMetalSurfaceCreateInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMetalSurfaceCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-flags-parameter", "flags must be a valid combination of VkBuildMicromapFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-pUsageCounts-07516", "Only one of pUsageCounts or ppUsageCounts can be a valid pointer, the other must be NULL.", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-pUsageCounts-parameter", "If usageCountsCount is not 0, and pUsageCounts is not NULL, pUsageCounts must be a valid pointer to an array of usageCountsCount VkMicromapUsageEXT structures", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-ppUsageCounts-parameter", "If usageCountsCount is not 0, and ppUsageCounts is not NULL, ppUsageCounts must be a valid pointer to an array of usageCountsCount valid pointers to VkMicromapUsageEXT structures", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-type-07517", "If type is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT the format member of VkMicromapUsageEXT must be a valid value from VkOpacityMicromapFormatEXT", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-type-07518", "If type is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT the format member of VkMicromapTriangleEXT must be a valid value from VkOpacityMicromapFormatEXT", "1.3-extensions"},
    {"VUID-VkMicromapBuildInfoEXT-type-parameter", "type must be a valid VkMicromapTypeEXT value", "1.3-extensions"},
    {"VUID-VkMicromapBuildSizesInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMicromapBuildSizesInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-buffer-07435", "buffer must have been created with a usage value containing VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-buffer-07436", "buffer must not have been created with VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-createFlags-07434", "If createFlags includes VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT, VkPhysicalDeviceOpacityMicromapFeaturesEXT::micromapCaptureReplay must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-createFlags-parameter", "createFlags must be a valid combination of VkMicromapCreateFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-deviceAddress-07433", "If deviceAddress is not zero, createFlags must include VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-offset-07437", "The sum of offset and size must be less than the size of buffer", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-offset-07438", "offset must be a multiple of 256 bytes", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMicromapCreateInfoEXT-type-parameter", "type must be a valid VkMicromapTypeEXT value", "1.3-extensions"},
    {"VUID-VkMicromapTriangleEXT-format-07522", "If the VkMicromapTypeEXT of the micromap is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT then format must be VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT or VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT.", "1.3-extensions"},
    {"VUID-VkMicromapTriangleEXT-format-07523", "If the VkMicromapTypeEXT of the micromap is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT and format is VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT then subdivisionLevel must be less than or equal to maxOpacity2StateSubdivisionLevel of VkPhysicalDeviceOpacityMicromapPropertiesEXT", "1.3-extensions"},
    {"VUID-VkMicromapTriangleEXT-format-07524", "If the VkMicromapTypeEXT of the micromap is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT and format is VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT then subdivisionLevel must be less than or equal to maxOpacity4StateSubdivisionLevel of VkPhysicalDeviceOpacityMicromapPropertiesEXT", "1.3-extensions"},
    {"VUID-VkMicromapUsageEXT-format-07519", "If the VkMicromapTypeEXT of the micromap is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT then format must be VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT or VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT.", "1.3-extensions"},
    {"VUID-VkMicromapUsageEXT-format-07520", "If the VkMicromapTypeEXT of the micromap is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT and format is VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT then subdivisionLevel must be less than or equal to maxOpacity2StateSubdivisionLevel of VkPhysicalDeviceOpacityMicromapPropertiesEXT", "1.3-extensions"},
    {"VUID-VkMicromapUsageEXT-format-07521", "If the VkMicromapTypeEXT of the micromap is VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT and format is VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT then subdivisionLevel must be less than or equal to maxOpacity4StateSubdivisionLevel of VkPhysicalDeviceOpacityMicromapPropertiesEXT", "1.3-extensions"},
    {"VUID-VkMicromapVersionInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMicromapVersionInfoEXT-pVersionData-parameter", "pVersionData must be a valid pointer to an array of \\(2 \\times \\mathtt{VK\\_UUID\\_SIZE}\\) uint8_t values", "1.3-extensions"},
    {"VUID-VkMicromapVersionInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMultisamplePropertiesEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkMultisamplePropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkMultisampledRenderToSingleSampledInfoEXT-pNext-06880", "If added to the pNext chain of VkRenderingInfo, each imageView member of any element of VkRenderingInfo::pColorAttachments, VkRenderingInfo::pDepthAttachment, or VkRenderingInfo::pStencilAttachment that is not VK_NULL_HANDLE must have a format that supports the sample count specified in rasterizationSamples", "1.3-extensions"},
    {"VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-06878", "The value of rasterizationSamples must not be VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-parameter", "rasterizationSamples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkMultisampledRenderToSingleSampledInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMultiviewPerViewAttributesInfoNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeCreateInfoEXT-pMutableDescriptorTypeLists-parameter", "If mutableDescriptorTypeListCount is not 0, pMutableDescriptorTypeLists must be a valid pointer to an array of mutableDescriptorTypeListCount valid VkMutableDescriptorTypeListEXT structures", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-descriptorTypeCount-04597", "descriptorTypeCount must not be 0 if the corresponding binding is of VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-descriptorTypeCount-04599", "descriptorTypeCount must be 0 if the corresponding binding is not of VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04598", "pDescriptorTypes must be a valid pointer to an array of descriptorTypeCount valid, unique VkDescriptorType values if the given binding is of VK_DESCRIPTOR_TYPE_MUTABLE_EXT type", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04600", "pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_MUTABLE_EXT", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04601", "pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04602", "pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04603", "pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK", "1.3-extensions"},
    {"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-parameter", "If descriptorTypeCount is not 0, pDescriptorTypes must be a valid pointer to an array of descriptorTypeCount valid VkDescriptorType values", "1.3-extensions"},
    {"VUID-VkOpticalFlowExecuteInfoNV-flags-parameter", "flags must be a valid combination of VkOpticalFlowExecuteFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkOpticalFlowExecuteInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkOpticalFlowExecuteInfoNV-pRegions-parameter", "If regionCount is not 0, pRegions must be a valid pointer to an array of regionCount VkRect2D structures", "1.3-extensions"},
    {"VUID-VkOpticalFlowExecuteInfoNV-regionCount-07593", "regionCount must be 0 if VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV was not set for VkOpticalFlowSessionNV on which this command is operating.", "1.3-extensions"},
    {"VUID-VkOpticalFlowExecuteInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV", "1.3-extensions"},
    {"VUID-VkOpticalFlowImageFormatInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV", "1.3-extensions"},
    {"VUID-VkOpticalFlowImageFormatInfoNV-usage-parameter", "usage must be a valid combination of VkOpticalFlowUsageFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkOpticalFlowImageFormatInfoNV-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkOpticalFlowImageFormatPropertiesNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkOpticalFlowImageFormatPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-costFormat-07585", "costFormat must be one of the formats returned by vkGetPhysicalDeviceOpticalFlowImageFormatsNV for VK_OPTICAL_FLOW_USAGE_COST_BIT_NV if VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV is set in flags.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-costFormat-parameter", "If costFormat is not 0, costFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flags-07588", "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV must not be set in flags if VkPhysicalDeviceOpticalFlowPropertiesNV::hintSupported is VK_FALSE.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flags-07589", "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV must not be set in flags if VkPhysicalDeviceOpticalFlowPropertiesNV::costSupported is VK_FALSE.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flags-07590", "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV must not be set in flags if VkPhysicalDeviceOpticalFlowPropertiesNV::globalFlowSupported is VK_FALSE.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flags-07591", "VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV must not be set in flags if VkPhysicalDeviceOpticalFlowPropertiesNV::maxNumRegionsOfInterest is 0.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flags-07592", "VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV must not be set in flags if VkPhysicalDeviceOpticalFlowPropertiesNV::bidirectionalFlowSupported is VK_FALSE.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flags-parameter", "flags must be a valid combination of VkOpticalFlowSessionCreateFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flowVectorFormat-07584", "flowVectorFormat must be one of the formats returned by vkGetPhysicalDeviceOpticalFlowImageFormatsNV for VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-flowVectorFormat-parameter", "flowVectorFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-height-07582", "height must be greater than or equal to VkPhysicalDeviceOpticalFlowPropertiesNV::minHeight and less than or equal to VkPhysicalDeviceOpticalFlowPropertiesNV::maxHeight.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-hintGridSize-07587", "hintGridSize must be exactly one of the bits reported in VkPhysicalDeviceOpticalFlowPropertiesNV::supportedHintGridSizes if VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV is set in flags.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-hintGridSize-parameter", "hintGridSize must be a valid combination of VkOpticalFlowGridSizeFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-imageFormat-07583", "imageFormat must be one of the formats returned by vkGetPhysicalDeviceOpticalFlowImageFormatsNV for VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-imageFormat-parameter", "imageFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-07586", "outputGridSize must be exactly one of the bits reported in VkPhysicalDeviceOpticalFlowPropertiesNV::supportedOutputGridSizes.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-parameter", "outputGridSize must be a valid combination of VkOpticalFlowGridSizeFlagBitsNV values", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-outputGridSize-requiredbitmask", "outputGridSize must not be 0", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkOpticalFlowSessionCreatePrivateDataInfoNV", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-performanceLevel-parameter", "If performanceLevel is not 0, performanceLevel must be a valid VkOpticalFlowPerformanceLevelNV value", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreateInfoNV-width-07581", "width must be greater than or equal to VkPhysicalDeviceOpticalFlowPropertiesNV::minWidth and less than or equal to VkPhysicalDeviceOpticalFlowPropertiesNV::maxWidth.", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-pPrivateData-parameter", "pPrivateData must be a pointer value", "1.3-extensions"},
    {"VUID-VkOpticalFlowSessionCreatePrivateDataInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV", "1.3-extensions"},
    {"VUID-VkPerformanceConfigurationAcquireInfoINTEL-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPerformanceConfigurationAcquireInfoINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL", "1.3-extensions"},
    {"VUID-VkPerformanceConfigurationAcquireInfoINTEL-type-parameter", "type must be a valid VkPerformanceConfigurationTypeINTEL value", "1.3-extensions"},
    {"VUID-VkPerformanceCounterDescriptionKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPerformanceCounterDescriptionKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR", "1.3-extensions"},
    {"VUID-VkPerformanceCounterKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPerformanceCounterKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR", "1.3-extensions"},
    {"VUID-VkPerformanceMarkerInfoINTEL-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPerformanceMarkerInfoINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL", "1.3-extensions"},
    {"VUID-VkPerformanceOverrideInfoINTEL-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPerformanceOverrideInfoINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL", "1.3-extensions"},
    {"VUID-VkPerformanceOverrideInfoINTEL-type-parameter", "type must be a valid VkPerformanceOverrideTypeINTEL value", "1.3-extensions"},
    {"VUID-VkPerformanceQuerySubmitInfoKHR-counterPassIndex-03221", "counterPassIndex must be less than the number of counter passes required by any queries within the batch. The required number of counter passes for a performance query is obtained by calling vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", "1.3-extensions"},
    {"VUID-VkPerformanceQuerySubmitInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPerformanceStreamMarkerInfoINTEL-marker-02735", "The value written by the application into marker must only used the valid bits as reported by vkGetPerformanceParameterINTEL with the VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL", "1.3-extensions"},
    {"VUID-VkPerformanceStreamMarkerInfoINTEL-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPerformanceStreamMarkerInfoINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL", "1.3-extensions"},
    {"VUID-VkPerformanceValueINTEL-type-parameter", "type must be a valid VkPerformanceValueTypeINTEL value", "1.3-extensions"},
    {"VUID-VkPerformanceValueINTEL-valueString-parameter", "If type is VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL, the valueString member of data must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkPhysicalDevice16BitStorageFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDevice4444FormatsFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevice8BitStorageFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceASTCDecodeFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceAccelerationStructureFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceAccelerationStructurePropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceAddressBindingReportFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceBorderColorSwizzleFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceBufferDeviceAddressFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceBufferDeviceAddressFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCoherentMemoryFeaturesAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceColorWriteEnableFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceComputeShaderDerivativesFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceConditionalRenderingFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceConservativeRasterizationPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCooperativeMatrixFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCooperativeMatrixPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCornerSampledImageFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCoverageReductionModeFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCustomBorderColorFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceCustomBorderColorPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDepthClampZeroOneFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDepthClipControlFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDepthClipEnableFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDepthStencilResolveProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDescriptorIndexingFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDescriptorIndexingProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDeviceMemoryReportFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDiagnosticsConfigFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDiscardRectanglePropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDriverProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDrmPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceDynamicRenderingFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExclusiveScissorFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExtendedDynamicState2FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExtendedDynamicState3FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExtendedDynamicState3PropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExtendedDynamicStateFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalBufferInfo-flags-parameter", "flags must be a valid combination of VkBufferCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalBufferInfo-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalBufferInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalBufferInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalBufferInfo-usage-parameter", "usage must be a valid combination of VkBufferUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalBufferInfo-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalFenceInfo-handleType-parameter", "handleType must be a valid VkExternalFenceHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalFenceInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalFenceInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalImageFormatInfo-handleType-parameter", "If handleType is not 0, handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalImageFormatInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalMemoryHostPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalMemoryRDMAFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalSemaphoreInfo-handleType-parameter", "handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalSemaphoreInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkSemaphoreTypeCreateInfo", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceExternalSemaphoreInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFaultFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFeatures2-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFloatControlsProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentDensityMap2FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentDensityMap2PropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentDensityMapFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentDensityMapPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-maxFragmentShadingRateInvocationCount-parameter", "maxFragmentShadingRateInvocationCount must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRateFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRateKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRateKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceFragmentShadingRatePropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceGroupProperties-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceGroupProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceHostQueryResetFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceIDProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImage2DViewOf3DFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageCompressionControlFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02314", "If sharingMode is VK_SHARING_MODE_CONCURRENT, then pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02315", "If sharingMode is VK_SHARING_MODE_CONCURRENT, then queueFamilyIndexCount must be greater than 1", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02316", "If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than the pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-parameter", "sharingMode must be a valid VkSharingMode value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-flags-parameter", "flags must be a valid combination of VkImageCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkImageCompressionControlEXT, VkImageFormatListCreateInfo, VkImageStencilUsageCreateInfo, VkOpticalFlowImageFormatInfoNV, VkPhysicalDeviceExternalImageFormatInfo, VkPhysicalDeviceImageDrmFormatModifierInfoEXT, VkPhysicalDeviceImageViewImageFormatInfoEXT, or VkVideoProfileListInfoKHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02249", "tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT if and only if the pNext chain includes VkPhysicalDeviceImageDrmFormatModifierInfoEXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02313", "If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must include a VkImageFormatListCreateInfo structure with non-zero viewFormatCount", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-parameter", "tiling must be a valid VkImageTiling value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-type-parameter", "type must be a valid VkImageType value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageFormatInfo2-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageProcessingFeaturesQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageProcessingPropertiesQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageRobustnessFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-imageViewType-parameter", "imageViewType must be a valid VkImageViewType value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageViewImageFormatInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImageViewMinLodFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceImagelessFramebufferFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceIndexTypeUint8FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceInheritedViewportScissorFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceInlineUniformBlockFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceInlineUniformBlockProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceInvocationMaskFeaturesHUAWEI-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceLegacyDitheringFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceLineRasterizationFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceLineRasterizationPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceLinearColorAttachmentFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMaintenance3Properties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMaintenance4Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMaintenance4Properties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMemoryBudgetPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMemoryPriorityFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMemoryProperties2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkPhysicalDeviceMemoryBudgetPropertiesEXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMemoryProperties2-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMemoryProperties2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-multiviewMeshShader-07032", "If multiviewMeshShader is enabled then VkPhysicalDeviceMultiviewFeaturesKHR::multiview must also be enabled", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-primitiveFragmentShadingRateMeshShader-07033", "If primitiveFragmentShadingRateMeshShader is enabled then VkPhysicalDeviceFragmentShadingRateFeaturesKHR::primitiveFragmentShadingRate must also be enabled", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMeshShaderFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMeshShaderPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMeshShaderPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiDrawFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiDrawPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580", "If multiviewGeometryShader is enabled then multiview must also be enabled", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581", "If multiviewTessellationShader is enabled then multiview must also be enabled", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiviewFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMultiviewProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceOpacityMicromapFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceOpacityMicromapPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceOpticalFlowFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceOpticalFlowPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePCIBusInfoPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePerformanceQueryFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePerformanceQueryPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePipelineCreationCacheControlFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePipelinePropertiesFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePipelineProtectedAccessFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePipelineRobustnessFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePipelineRobustnessPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePointClippingProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePortabilitySubsetFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePortabilitySubsetPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePresentBarrierFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePresentIdFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePresentWaitFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePrivateDataFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProperties2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDrmPropertiesEXT, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRatePropertiesKHR, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, VkPhysicalDeviceIDProperties, VkPhysicalDeviceImageProcessingPropertiesQCOM, VkPhysicalDeviceInlineUniformBlockProperties, VkPhysicalDeviceLineRasterizationPropertiesEXT, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance4Properties, VkPhysicalDeviceMeshShaderPropertiesEXT, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiDrawPropertiesEXT, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceOpacityMicromapPropertiesEXT, VkPhysicalDeviceOpticalFlowPropertiesNV, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePerformanceQueryPropertiesKHR, VkPhysicalDevicePipelineRobustnessPropertiesEXT, VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePortabilitySubsetPropertiesKHR, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProvokingVertexPropertiesEXT, VkPhysicalDevicePushDescriptorPropertiesKHR, VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRobustness2PropertiesEXT, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderIntegerDotProductProperties, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSubgroupSizeControlProperties, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, VkPhysicalDeviceTexelBufferAlignmentProperties, VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan12Properties, or VkPhysicalDeviceVulkan13Properties", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProperties2-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProperties2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProtectedMemoryFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProtectedMemoryProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProvokingVertexFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceProvokingVertexPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDevicePushDescriptorPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayQueryFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayTracingMotionBlurFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03575", "If rayTracingPipelineShaderGroupHandleCaptureReplayMixed is VK_TRUE, rayTracingPipelineShaderGroupHandleCaptureReplay must also be VK_TRUE", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayTracingPipelineFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayTracingPipelinePropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRayTracingPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRobustness2FeaturesEXT-robustBufferAccess2-04000", "If robustBufferAccess2 is enabled then robustBufferAccess must also be enabled", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRobustness2FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceRobustness2PropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSampleLocationsPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSamplerFilterMinmaxProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSamplerYcbcrConversionFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceScalarBlockLayoutFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderAtomicFloatFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderAtomicInt64Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderClockFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderCoreProperties2AMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderCorePropertiesAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderDrawParametersFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderFloat16Int8Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderImageFootprintFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderIntegerDotProductFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderIntegerDotProductProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderSMBuiltinsFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderSMBuiltinsPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShaderTerminateInvocationFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShadingRateImageFeaturesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceShadingRateImagePropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-01095", "samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-tiling-parameter", "tiling must be a valid VkImageTiling value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-type-parameter", "type must be a valid VkImageType value", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSparseImageFormatInfo2-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSubgroupProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSubgroupSizeControlFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSubgroupSizeControlProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSubpassShadingFeaturesHUAWEI-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSubpassShadingPropertiesHUAWEI-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-02672", "If the pNext chain includes a VkSurfaceFullScreenExclusiveInfoEXT structure with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, a VkSurfaceFullScreenExclusiveWin32InfoEXT structure must be included in the pNext chain", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSurfaceFullScreenExclusiveInfoEXT or VkSurfaceFullScreenExclusiveWin32InfoEXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pSurfaceInfo-06526", "When passed as the pSurfaceInfo parameter of vkGetPhysicalDeviceSurfaceCapabilities2KHR, if the VK_GOOGLE_surfaceless_query extension is enabled and the pNext chain of the pSurfaceCapabilities parameter includes VkSurfaceProtectedCapabilitiesKHR, then surface can be VK_NULL_HANDLE. Otherwise, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pSurfaceInfo-06527", "When passed as the pSurfaceInfo parameter of vkGetPhysicalDeviceSurfaceFormats2KHR, if the VK_GOOGLE_surfaceless_query extension is enabled, then surface can be VK_NULL_HANDLE. Otherwise, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pSurfaceInfo-06528", "When passed as the pSurfaceInfo parameter of vkGetPhysicalDeviceSurfacePresentModes2EXT, if the VK_GOOGLE_surfaceless_query extension is enabled, then surface can be VK_NULL_HANDLE. Otherwise, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-surface-06529", "surface must be a valid VkSurfaceKHR handle", "default"},
    {"VUID-VkPhysicalDeviceSurfaceInfo2KHR-surface-parameter", "If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceSynchronization2Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTexelBufferAlignmentProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTextureCompressionASTCHDRFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTilePropertiesFeaturesQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTimelineSemaphoreFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTimelineSemaphoreProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceToolProperties-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceToolProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTransformFeedbackFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceTransformFeedbackPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceUniformBufferStandardLayoutFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVariablePointersFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431", "If variablePointers is enabled then variablePointersStorageBuffer must also be enabled", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-parameter", "imageUsage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVideoFormatInfoKHR-imageUsage-requiredbitmask", "imageUsage must not be 0", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVideoFormatInfoKHR-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkVideoProfileListInfoKHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVideoFormatInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkan11Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkan11Properties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkan12Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkan12Properties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkan13Features-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkan13Properties-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceVulkanMemoryModelFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceYcbcrImageArraysFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures-sType-sType", "sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineCacheCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-initialDataSize-00768", "If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetPipelineCacheData when pInitialData was originally retrieved", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-initialDataSize-00769", "If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetPipelineCacheData", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-pInitialData-parameter", "If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-pipelineCreationCacheControl-02892", "If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT", "1.3-extensions"},
    {"VUID-VkPipelineCacheCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineCacheHeaderVersionOne-headerSize-04967", "headerSize must be 32", "1.3-extensions"},
    {"VUID-VkPipelineCacheHeaderVersionOne-headerVersion-04968", "headerVersion must be VK_PIPELINE_CACHE_HEADER_VERSION_ONE", "1.3-extensions"},
    {"VUID-VkPipelineCacheHeaderVersionOne-headerVersion-parameter", "headerVersion must be a valid VkPipelineCacheHeaderVersion value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-01426", "If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-parameter", "blendOverlap must be a valid VkBlendOverlapEXT value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-dstPremultiplied-01425", "If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-srcPremultiplied-01424", "If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-advancedBlendAllOperations-01409", "If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendAllOperations is VK_FALSE, then colorBlendOp must not be VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01407", "If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and colorBlendOp is an advanced blend operation, then colorBlendOp must be the same for all attachments", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01408", "If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and alphaBlendOp is an advanced blend operation, then alphaBlendOp must be the same for all attachments", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter", "alphaBlendOp must be a valid VkBlendOp value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01406", "If either of colorBlendOp or alphaBlendOp is an advanced blend operation, then colorBlendOp must equal alphaBlendOp", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01410", "If colorBlendOp or alphaBlendOp is an advanced blend operation, then colorAttachmentCount of the subpass this pipeline is compiled against must be less than or equal to VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter", "colorBlendOp must be a valid VkBlendOp value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter", "colorWriteMask must be a valid combination of VkColorComponentFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-constantAlphaColorBlendFactors-04454", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, srcColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-constantAlphaColorBlendFactors-04455", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, dstColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611", "If the dualSrcBlend feature is not enabled, dstAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter", "dstAlphaBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609", "If the dualSrcBlend feature is not enabled, dstColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter", "dstColorBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610", "If the dualSrcBlend feature is not enabled, srcAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter", "srcAlphaBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608", "If the dualSrcBlend feature is not enabled, srcColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter", "srcColorBlendFactor must be a valid VkBlendFactor value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineColorBlendStateCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606", "If the logicOp feature is not enabled, logicOpEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00607", "If logicOpEnable is VK_TRUE, logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605", "If the independentBlend feature is not enabled, all elements of pAttachments must be identical", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-07353", "If any of VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, or VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT are not set, pAttachments must not be NULL", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-07354", "pAttachments must not be NULL", "1.3-khr-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-parameter", "If attachmentCount is not 0, and pAttachments is not NULL, pAttachments must be a valid pointer to an array of attachmentCount valid VkPipelineColorBlendAttachmentState structures", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineColorBlendAdvancedStateCreateInfoEXT or VkPipelineColorWriteCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-rasterizationOrderColorAttachmentAccess-06465", "If the rasterizationOrderColorAttachmentAccess feature is not enabled, flags must not include VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineColorBlendStateCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineColorWriteCreateInfoEXT-attachmentCount-04802", "attachmentCount must be equal to the attachmentCount member of the VkPipelineColorBlendStateCreateInfo structure specified during pipeline creation", "1.3-extensions"},
    {"VUID-VkPipelineColorWriteCreateInfoEXT-attachmentCount-06655", "attachmentCount must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-VkPipelineColorWriteCreateInfoEXT-pAttachments-04801", "If the colorWriteEnable feature is not enabled, all elements of pColorWriteEnables must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkPipelineColorWriteCreateInfoEXT-pColorWriteEnables-parameter", "If attachmentCount is not 0, pColorWriteEnables must be a valid pointer to an array of attachmentCount VkBool32 values", "1.3-extensions"},
    {"VUID-VkPipelineColorWriteCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineCompilerControlCreateInfoAMD-compilerControlFlags-zerobitmask", "compilerControlFlags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineCompilerControlCreateInfoAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD", "1.3-extensions"},
    {"VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationMode-parameter", "coverageModulationMode must be a valid VkCoverageModulationModeNV value", "1.3-extensions"},
    {"VUID-VkPipelineCoverageModulationStateCreateInfoNV-coverageModulationTableEnable-01405", "If coverageModulationTableEnable is VK_TRUE, coverageModulationTableCount must be equal to the number of rasterization samples divided by the number of color samples in the subpass", "1.3-extensions"},
    {"VUID-VkPipelineCoverageModulationStateCreateInfoNV-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineCoverageModulationStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineCoverageReductionStateCreateInfoNV-coverageReductionMode-parameter", "coverageReductionMode must be a valid VkCoverageReductionModeNV value", "1.3-extensions"},
    {"VUID-VkPipelineCoverageReductionStateCreateInfoNV-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineCoverageReductionStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineCoverageToColorStateCreateInfoNV-coverageToColorEnable-01404", "If coverageToColorEnable is VK_TRUE, then the render pass subpass indicated by VkGraphicsPipelineCreateInfo::renderPass and VkGraphicsPipelineCreateInfo::subpass must have a color attachment at the location selected by coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-VkPipelineCoverageToColorStateCreateInfoNV-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineCoverageToColorStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineCreationFeedback-parameter", "pPipelineCreationFeedback must be a valid pointer to a VkPipelineCreationFeedback structure", "1.3-extensions"},
    {"VUID-VkPipelineCreationFeedbackCreateInfo-pPipelineStageCreationFeedbacks-parameter", "If pipelineStageCreationFeedbackCount is not 0, pPipelineStageCreationFeedbacks must be a valid pointer to an array of pipelineStageCreationFeedbackCount VkPipelineCreationFeedback structures", "1.3-extensions"},
    {"VUID-VkPipelineCreationFeedbackCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-back-parameter", "back must be a valid VkStencilOpState structure", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-depthBoundsTestEnable-00598", "If the depthBounds feature is not enabled, depthBoundsTestEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter", "depthCompareOp must be a valid VkCompareOp value", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineDepthStencilStateCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-front-parameter", "front must be a valid VkStencilOpState structure", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-rasterizationOrderDepthAttachmentAccess-06463", "If the rasterizationOrderDepthAttachmentAccess feature is not enabled, flags must not include VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-rasterizationOrderStencilAttachmentAccess-06464", "If the rasterizationOrderStencilAttachmentAccess feature is not enabled, flags must not include VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineDepthStencilStateCreateInfo-separateStencilMaskRef-04453", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::separateStencilMaskRef is VK_FALSE, and the value of VkPipelineDepthStencilStateCreateInfo::stencilTestEnable is VK_TRUE, and the value of VkPipelineRasterizationStateCreateInfo::cullMode is VK_CULL_MODE_NONE, the value of reference in each of the VkStencilOpState structs in front and back must be the same", "1.3-extensions"},
    {"VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleCount-00582", "discardRectangleCount must be less than or equal to VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles", "1.3-extensions"},
    {"VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleMode-parameter", "discardRectangleMode must be a valid VkDiscardRectangleModeEXT value", "1.3-extensions"},
    {"VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442", "Each element of pDynamicStates must be unique", "1.3-extensions"},
    {"VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter", "If dynamicStateCount is not 0, pDynamicStates must be a valid pointer to an array of dynamicStateCount valid VkDynamicState values", "1.3-extensions"},
    {"VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineDynamicStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineExecutableInfoKHR-executableIndex-03275", "executableIndex must be less than the number of pipeline executables associated with pipeline as returned in the pExecutableCount parameter of vkGetPipelineExecutablePropertiesKHR", "1.3-extensions"},
    {"VUID-VkPipelineExecutableInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineExecutableInfoKHR-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-VkPipelineExecutableInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPipelineExecutableInternalRepresentationKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineExecutableInternalRepresentationKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR", "1.3-extensions"},
    {"VUID-VkPipelineExecutablePropertiesKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineExecutablePropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkPipelineExecutableStatisticKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineExecutableStatisticKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR", "1.3-extensions"},
    {"VUID-VkPipelineFragmentShadingRateEnumStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineFragmentShadingRateStateCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPipelineInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineInfoKHR-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-VkPipelineInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00428", "If topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, primitiveRestartEnable must be VK_FALSE", "1.3-khr-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429", "If the geometryShader feature is not enabled, topology must not be any of VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430", "If the tessellationShader feature is not enabled, topology must not be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-06252", "If topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, and primitiveRestartEnable is VK_TRUE, the primitiveTopologyListRestart feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-06253", "If topology is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, and primitiveRestartEnable is VK_TRUE, the primitiveTopologyPatchListRestart feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter", "topology must be a valid VkPrimitiveTopology value", "1.3-extensions"},
    {"VUID-VkPipelineInputAssemblyStateCreateInfo-triangleFans-04452", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::triangleFans is VK_FALSE, topology must not be VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02212", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxPerStageDescriptorInlineUniformBlocks", "default"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02213", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxDescriptorSetInlineUniformBlocks", "default"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02214", "The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxPerStageDescriptorInlineUniformBlocks", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02215", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02216", "The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxDescriptorSetInlineUniformBlocks", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02217", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxDescriptorSetUpdateAfterBindInlineUniformBlocks", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-02381", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxDescriptorSetAccelerationStructures", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03016", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03017", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03018", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03019", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages", "1.3-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03020", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03021", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03022", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindSamplers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03023", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindUniformBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03024", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindStorageBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03025", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindSampledImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03026", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindStorageImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03027", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindInputAttachments", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03028", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03029", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03030", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03031", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03032", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03033", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03034", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03035", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03571", "The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPerStageDescriptorAccelerationStructures", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03572", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPerStageDescriptorUpdateAfterBindAccelerationStructures", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03573", "The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxDescriptorSetAccelerationStructures", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-03574", "The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxDescriptorSetUpdateAfterBindAccelerationStructures", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-06531", "The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceVulkan13Properties::maxInlineUniformTotalSize", "default"},
    {"VUID-VkPipelineLayoutCreateInfo-descriptorType-06939", "The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, and VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineLayoutCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-graphicsPipelineLibrary-06753", "If graphicsPipelineLibrary is not enabled, elements of pSetLayouts must be valid VkDescriptorSetLayout objects", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pImmutableSamplers-03566", "The total number of pImmutableSamplers created with flags containing VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT or VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::maxDescriptorSetSubsampledSamplers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292", "Any two elements of pPushConstantRanges must not include the same stage in stageFlags", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter", "If pushConstantRangeCount is not 0, pPushConstantRanges must be a valid pointer to an array of pushConstantRangeCount valid VkPushConstantRange structures", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00287", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00288", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00289", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00290", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00291", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageImages", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293", "pSetLayouts must not contain more than one descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01676", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01677", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01678", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01679", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01680", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01681", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01682", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01683", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-01684", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetInputAttachments", "1.1-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindSamplers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindUniformBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindStorageBuffers", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindSampledImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindStorageImages", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindInputAttachments", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-04606", "Any element of pSetLayouts must not have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-06561", "Elements of pSetLayouts must be valid VkDescriptorSetLayout objects", "1.3-khr-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-06938", "The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, and VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, accessible to any shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSampledImages", "default"},
    {"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter", "If setLayoutCount is not 0, pSetLayouts must be a valid pointer to an array of setLayoutCount valid or VK_NULL_HANDLE VkDescriptorSetLayout handles", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286", "setLayoutCount must be less than or equal to VkPhysicalDeviceLimits::maxBoundDescriptorSets", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-03381", "Each element of pLibraries must have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-06855", "If any library in pLibraries was created with a shader stage with VkPipelineShaderStageModuleIdentifierCreateInfoEXT and identifierSize not equal to 0, the pipeline must be created with the VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-parameter", "If libraryCount is not 0, pLibraries must be a valid pointer to an array of libraryCount valid VkPipeline handles", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07404", "If pipeline is being created with VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT, every element of pLibraries must have been created with VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07405", "If pipeline is being created without VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT, every element of pLibraries must have been created without VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07406", "If pipeline is being created with VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT, every element of pLibraries must have been created with VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-pipeline-07407", "If pipeline is being created without VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT, every element of pLibraries must have been created without VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineLibraryCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785", "If the alphaToOne feature is not enabled, alphaToOneEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786", "minSampleShading must be in the range [0,1]", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCoverageModulationStateCreateInfoNV, VkPipelineCoverageReductionStateCreateInfoNV, VkPipelineCoverageToColorStateCreateInfoNV, or VkPipelineSampleLocationsStateCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter", "If pSampleMask is not NULL, pSampleMask must be a valid pointer to an array of (rasterizationSamples/32) VkSampleMask values", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-01415", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the subpass has any color attachments and rasterizationSamples is greater than the number of color samples, then sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter", "rasterizationSamples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784", "If the sampleRateShading feature is not enabled, sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelinePropertiesIdentifierEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPipelinePropertiesIdentifierEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-conservativeRasterizationMode-parameter", "conservativeRasterizationMode must be a valid VkConservativeRasterizationModeEXT value", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-extraPrimitiveOverestimationSize-01769", "extraPrimitiveOverestimationSize must be in the range of 0.0 to VkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSize inclusive", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationConservativeStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationDepthClipStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-lineRasterizationMode-02768", "If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the rectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-lineRasterizationMode-02769", "If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the bresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-lineRasterizationMode-02770", "If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the smoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-lineRasterizationMode-parameter", "lineRasterizationMode must be a valid VkLineRasterizationModeEXT value", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-stippledLineEnable-02771", "If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-stippledLineEnable-02772", "If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-stippledLineEnable-02773", "If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationLineStateCreateInfoEXT-stippledLineEnable-02774", "If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-provokingVertexMode-04883", "If provokingVertexMode is VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT, then the provokingVertexLast feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-provokingVertexMode-parameter", "provokingVertexMode must be a valid VkProvokingVertexModeEXT value", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationProvokingVertexStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter", "cullMode must be a valid combination of VkCullModeFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782", "If the depthClamp feature is not enabled, depthClampEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter", "frontFace must be a valid VkFrontFace value", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineRasterizationConservativeStateCreateInfoEXT, VkPipelineRasterizationDepthClipStateCreateInfoEXT, VkPipelineRasterizationLineStateCreateInfoEXT, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT, VkPipelineRasterizationStateRasterizationOrderAMD, or VkPipelineRasterizationStateStreamCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-pointPolygons-04458", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::pointPolygons is VK_FALSE, and rasterizerDiscardEnable is VK_FALSE, polygonMode must not be VK_POLYGON_MODE_POINT", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01413", "If the fillModeNonSolid feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL", "1.3-khr-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01414", "If the VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01507", "If the fillModeNonSolid feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter", "polygonMode must be a valid VkPolygonMode value", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateRasterizationOrderAMD-rasterizationOrder-parameter", "rasterizationOrder must be a valid VkRasterizationOrderAMD value", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateRasterizationOrderAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-geometryStreams-02324", "VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02325", "rasterizationStream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02326", "rasterizationStream must be zero if VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelect is VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRenderingCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineRepresentativeFragmentTestStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-images-parameter", "images must be a valid VkPipelineRobustnessImageBehaviorEXT value", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06926", "If the pipelineRobustness feature is not enabled, storageBuffers must be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06927", "If the pipelineRobustness feature is not enabled, uniformBuffers must be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06928", "If the pipelineRobustness feature is not enabled, vertexInputs must be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06929", "If the pipelineRobustness feature is not enabled, images must be VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06931", "If the robustBufferAccess2 feature is not supported, storageBuffers must not be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06932", "If the robustBufferAccess2 feature is not supported, uniformBuffers must not be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-robustBufferAccess2-06933", "If the robustBufferAccess2 feature is not supported, vertexInputs must not be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess-06930", "If the robustImageAccess feature is not supported, images must not be VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess2-06934", "If the robustImageAccess2 feature is not supported, images must not be VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-storageBuffers-parameter", "storageBuffers must be a valid VkPipelineRobustnessBufferBehaviorEXT value", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-uniformBuffers-parameter", "uniformBuffers must be a valid VkPipelineRobustnessBufferBehaviorEXT value", "1.3-extensions"},
    {"VUID-VkPipelineRobustnessCreateInfoEXT-vertexInputs-parameter", "vertexInputs must be a valid VkPipelineRobustnessBufferBehaviorEXT value", "1.3-extensions"},
    {"VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineSampleLocationsStateCreateInfoEXT-sampleLocationsInfo-parameter", "sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-flags-02758", "If flags has both the VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT and VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT flags set, the local workgroup size in the X dimension of the pipeline must be a multiple of maxSubgroupSize", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-flags-02759", "If flags has the VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag set and flags does not have the VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT flag set and no VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, the local workgroup size in the X dimension of the pipeline must be a multiple of subgroupSize", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-flags-02784", "If flags has the VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT flag set, the subgroupSizeControl feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-flags-02785", "If flags has the VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag set, the computeFullSubgroups feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-flags-parameter", "flags must be a valid combination of VkPipelineShaderStageCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-graphicsPipelineLibrary-06717", "If the graphicsPipelineLibrary feature is not enabled, module must be a valid VkShaderModule", "default"},
    {"VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708", "If the identified entry point includes any variable in its interface that is declared with the ClipDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxClipDistances", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710", "If the identified entry point includes any variables in its interface that are declared with the ClipDistance or CullDistance BuiltIn decoration, those variables must not have array sizes which sum to more than VkPhysicalDeviceLimits::maxCombinedClipAndCullDistances", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709", "If the identified entry point includes any variable in its interface that is declared with the CullDistance BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxCullDistances", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711", "If the identified entry point includes any variable in its interface that is declared with the SampleMask BuiltIn decoration, that variable must not have an array size greater than VkPhysicalDeviceLimits::maxSampleMaskWords", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-module-06716", "module must be a valid VkShaderModule", "1.3-khr-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-module-06718", "If module is VK_NULL_HANDLE, there must be a valid VkShaderModuleCreateInfo structure in the pNext chain", "default"},
    {"VUID-VkPipelineShaderStageCreateInfo-module-parameter", "If module is not VK_NULL_HANDLE, module must be a valid VkShaderModule handle", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pName-00707", "pName must be the name of an OpEntryPoint in module with an execution model that matches stage", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pName-parameter", "pName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pNext-02754", "If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, flags must not have the VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT flag set", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pNext-02755", "If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, the subgroupSizeControl feature must be enabled, and stage must be a valid bit specified in requiredSubgroupSizeStages", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pNext-02756", "If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain and stage is VK_SHADER_STAGE_COMPUTE_BIT, the local workgroup size of the shader must be less than or equal to the product of VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::requiredSubgroupSize and maxComputeWorkgroupSubgroups", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pNext-02757", "If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, and flags has the VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag set, the local workgroup size in the X dimension of the pipeline must be a multiple of VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::requiredSubgroupSize", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDebugUtilsObjectNameInfoEXT, VkPipelineRobustnessCreateInfoEXT, VkPipelineShaderStageModuleIdentifierCreateInfoEXT, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo, VkShaderModuleCreateInfo, or VkShaderModuleValidationCacheCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-06719", "The shader code used by the pipeline must be valid as described by the Khronos SPIR-V Specification after applying the specializations provided in pSpecializationInfo, if any, and then converting all specialization constants into fixed constants", "1.3-khr-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-06849", "If a shader module identifier is not specified, the shader code used by the pipeline must be valid as described by the Khronos SPIR-V Specification after applying the specializations provided in pSpecializationInfo, if any, and then converting all specialization constants into fixed constants", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-parameter", "If pSpecializationInfo is not NULL, pSpecializationInfo must be a valid pointer to a valid VkSpecializationInfo structure", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00704", "If the geometryShader feature is not enabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00705", "If the tessellationShader feature is not enabled, stage must not be VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00706", "stage must not be VK_SHADER_STAGE_ALL_GRAPHICS, or VK_SHADER_STAGE_ALL", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00712", "If stage is VK_SHADER_STAGE_VERTEX_BIT, the identified entry point must not include any input variable in its interface that is decorated with CullDistance", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00713", "If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, and the identified entry point has an OpExecutionMode instruction specifying a patch size with OutputVertices, the patch size must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00714", "If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction specifying a maximum output vertex count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryOutputVertices", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00715", "If stage is VK_SHADER_STAGE_GEOMETRY_BIT, the identified entry point must have an OpExecutionMode instruction specifying an invocation count that is greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxGeometryShaderInvocations", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-00718", "If stage is VK_SHADER_STAGE_FRAGMENT_BIT, the identified entry point must not include any output variables in its interface decorated with CullDistance", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-02091", "If the meshShaders feature is not enabled, stage must not be VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-02092", "If the taskShaders feature is not enabled, stage must not be VK_SHADER_STAGE_TASK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-02596", "If stage is either VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to Layer for any primitive, it must write the same value to Layer for all vertices of a given primitive", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-02597", "If stage is either VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOMETRY_BIT, and the identified entry point writes to ViewportIndex for any primitive, it must write the same value to ViewportIndex for all vertices of a given primitive", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06685", "If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragDepth in any execution path, all execution paths that are not exclusive to helper invocations must either discard the fragment, or write or initialize the value of FragDepth", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06686", "If stage is VK_SHADER_STAGE_FRAGMENT_BIT, and the identified entry point writes to FragStencilRefEXT in any execution path, all execution paths that are not exclusive to helper invocations must either discard the fragment, or write or initialize the value of FragStencilRefEXT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06844", "If a shader module identifier is specified for this stage, a VkShaderModuleCreateInfo structure must not be present in the pNext chain", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06845", "If a shader module identifier is not specified for this stage, module must be a valid VkShaderModule or there must be a valid VkShaderModuleCreateInfo structure in the pNext chain", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06846", "If a shader module identifier is not specified for this stage, and the graphicsPipelineLibrary feature is not enabled, module must be a valid VkShaderModule", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06847", "If a shader identifier is not specified for this stage, module must be a valid VkShaderModule", "default"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-06848", "If a shader module identifier is specified for this stage, module must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageCreateInfo-stage-parameter", "stage must be a valid VkShaderStageFlagBits value", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-identifierSize-06852", "identifierSize must be less-or-equal to VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pIdentifier-parameter", "If identifierSize is not 0, pIdentifier must be a valid pointer to an array of identifierSize uint8_t values", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06850", "If this structure is included in a pNext chain and identifierSize is not equal to 0, the shaderModuleIdentifier feature must be enabled", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06851", "If this struct is included in a pNext chain of VkPipelineShaderStageCreateInfo and identifierSize is not equal to 0, the pipeline must be created with the VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02760", "requiredSubgroupSize must be a power-of-two integer", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02761", "requiredSubgroupSize must be greater or equal to minSubgroupSize", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02762", "requiredSubgroupSize must be less than or equal to maxSubgroupSize", "1.3-extensions"},
    {"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineTessellationDomainOriginStateCreateInfo-domainOrigin-parameter", "domainOrigin must be a valid VkTessellationDomainOrigin value", "1.3-extensions"},
    {"VUID-VkPipelineTessellationDomainOriginStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkPipelineTessellationDomainOriginStateCreateInfo", "1.3-extensions"},
    {"VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214", "patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize", "1.3-extensions"},
    {"VUID-VkPipelineTessellationStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineTessellationStateCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-pVertexBindingDivisors-parameter", "pVertexBindingDivisors must be a valid pointer to an array of vertexBindingDivisorCount VkVertexInputBindingDivisorDescriptionEXT structures", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputDivisorStateCreateInfoEXT-vertexBindingDivisorCount-arraylength", "vertexBindingDivisorCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-binding-00615", "For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription must exist in pVertexBindingDescriptions with the same value of binding", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkPipelineVertexInputDivisorStateCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617", "All elements of pVertexAttributeDescriptions must describe distinct attribute locations", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter", "If vertexAttributeDescriptionCount is not 0, pVertexAttributeDescriptions must be a valid pointer to an array of vertexAttributeDescriptionCount valid VkVertexInputAttributeDescription structures", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616", "All elements of pVertexBindingDescriptions must describe distinct binding numbers", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter", "If vertexBindingDescriptionCount is not 0, pVertexBindingDescriptions must be a valid pointer to an array of vertexBindingDescriptionCount valid VkVertexInputBindingDescription structures", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614", "vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes", "1.3-extensions"},
    {"VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613", "vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-02234", "The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members", "1.3-extensions"},
    {"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-pCustomSampleOrders-parameter", "If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures", "1.3-extensions"},
    {"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-02072", "If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-parameter", "sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value", "1.3-extensions"},
    {"VUID-VkPipelineViewportDepthClipControlCreateInfoEXT-negativeOneToOne-06470", "If depthClipControl is not enabled, negativeOneToOne must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkPipelineViewportDepthClipControlCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02027", "If the multiViewport feature is not enabled, exclusiveScissorCount must be 0 or 1", "1.3-extensions"},
    {"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02028", "exclusiveScissorCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports", "1.3-extensions"},
    {"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02029", "exclusiveScissorCount must be 0 or greater than or equal to the viewportCount member of VkPipelineViewportStateCreateInfo", "1.3-extensions"},
    {"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-shadingRateImageEnable-02056", "If shadingRateImageEnable is VK_TRUE, viewportCount must be greater or equal to the viewportCount member of VkPipelineViewportStateCreateInfo", "1.3-extensions"},
    {"VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-viewportCount-02054", "If the multiViewport feature is not enabled, viewportCount must be 0 or 1", "1.3-extensions"},
    {"VUID-VkPipelineViewportShadingRateImageStateCreateInfoNV-viewportCount-02055", "viewportCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-offset-02822", "Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow for any element of pScissors", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-offset-02823", "Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow for any element of pScissors", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, VkPipelineViewportDepthClipControlCreateInfoEXT, VkPipelineViewportExclusiveScissorStateCreateInfoNV, VkPipelineViewportShadingRateImageStateCreateInfoNV, VkPipelineViewportSwizzleStateCreateInfoNV, or VkPipelineViewportWScalingStateCreateInfoNV", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217", "If the multiViewport feature is not enabled, scissorCount must not be greater than 1", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-scissorCount-01219", "scissorCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-scissorCount-01220", "scissorCount and viewportCount must be identical", "1.2-khr-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-scissorCount-04134", "If the graphics pipeline is being created without VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT set then scissorCount and viewportCount must be identical", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-scissorCount-04136", "If the graphics pipeline is being created with VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT set then scissorCount must be 0, otherwise it must be greater than 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-scissorCount-arraylength", "scissorCount must be greater than 0", "1.2-khr-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216", "If the multiViewport feature is not enabled, viewportCount must not be greater than 1", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-viewportCount-01218", "viewportCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-viewportCount-04135", "If the graphics pipeline is being created with VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT set then viewportCount must be 0, otherwise it must be greater than 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-viewportCount-arraylength", "viewportCount must be greater than 0", "1.2-khr-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-viewportWScalingEnable-01726", "If the viewportWScalingEnable member of a VkPipelineViewportWScalingStateCreateInfoNV structure included in the pNext chain is VK_TRUE, the viewportCount member of the VkPipelineViewportWScalingStateCreateInfoNV structure must be greater than or equal to VkPipelineViewportStateCreateInfo::viewportCount", "1.3-extensions"},
    {"VUID-VkPipelineViewportStateCreateInfo-x-02821", "The x and y members of offset member of any element of pScissors must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportSwizzleStateCreateInfoNV-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportSwizzleStateCreateInfoNV-pViewportSwizzles-parameter", "pViewportSwizzles must be a valid pointer to an array of viewportCount valid VkViewportSwizzleNV structures", "1.3-extensions"},
    {"VUID-VkPipelineViewportSwizzleStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-01215", "viewportCount must be greater than or equal to the viewportCount set in VkPipelineViewportStateCreateInfo", "1.3-extensions"},
    {"VUID-VkPipelineViewportSwizzleStateCreateInfoNV-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPipelineViewportWScalingStateCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkPipelineViewportWScalingStateCreateInfoNV-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPresentFrameTokenGGP-frameToken-02680", "frameToken must be a valid GgpFrameToken", "1.3-extensions"},
    {"VUID-VkPresentFrameTokenGGP-sType-sType", "sType must be VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP", "1.3-extensions"},
    {"VUID-VkPresentIdKHR-pPresentIds-parameter", "If pPresentIds is not NULL, pPresentIds must be a valid pointer to an array of swapchainCount uint64_t values", "1.3-extensions"},
    {"VUID-VkPresentIdKHR-presentIds-04999", "Each presentIds entry must be greater than any previous presentIds entry passed for the associated pSwapchains entry", "1.3-extensions"},
    {"VUID-VkPresentIdKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PRESENT_ID_KHR", "1.3-extensions"},
    {"VUID-VkPresentIdKHR-swapchainCount-04998", "swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where this VkPresentIdKHR is in the pNext chain of the VkPresentInfoKHR structure", "1.3-extensions"},
    {"VUID-VkPresentIdKHR-swapchainCount-arraylength", "swapchainCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-commonparent", "Both of the elements of pSwapchains, and the elements of pWaitSemaphores that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pImageIndices-01296", "Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR layout at the time the operation is executed on a VkDevice", "default"},
    {"VUID-VkPresentInfoKHR-pImageIndices-01430", "Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pImageIndices-parameter", "pImageIndices must be a valid pointer to an array of swapchainCount uint32_t values", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pNext-06235", "If a VkPresentIdKHR structure is included in the pNext chain, and the presentId feature is not enabled, each presentIds entry in that structure must be NULL", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupPresentInfoKHR, VkDisplayPresentInfoKHR, VkPresentFrameTokenGGP, VkPresentIdKHR, VkPresentRegionsKHR, or VkPresentTimesInfoGOOGLE", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pResults-parameter", "If pResults is not NULL, pResults must be a valid pointer to an array of swapchainCount VkResult values", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pSwapchains-parameter", "pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-pWaitSemaphores-parameter", "If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PRESENT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkPresentInfoKHR-swapchainCount-arraylength", "swapchainCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPresentRegionKHR-pRectangles-parameter", "If rectangleCount is not 0, and pRectangles is not NULL, pRectangles must be a valid pointer to an array of rectangleCount valid VkRectLayerKHR structures", "1.3-extensions"},
    {"VUID-VkPresentRegionsKHR-pRegions-parameter", "If pRegions is not NULL, pRegions must be a valid pointer to an array of swapchainCount valid VkPresentRegionKHR structures", "1.3-extensions"},
    {"VUID-VkPresentRegionsKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR", "1.3-extensions"},
    {"VUID-VkPresentRegionsKHR-swapchainCount-01260", "swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is included in the pNext chain of this VkPresentRegionsKHR structure", "1.3-extensions"},
    {"VUID-VkPresentRegionsKHR-swapchainCount-arraylength", "swapchainCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPresentTimesInfoGOOGLE-pTimes-parameter", "If pTimes is not NULL, pTimes must be a valid pointer to an array of swapchainCount VkPresentTimeGOOGLE structures", "1.3-extensions"},
    {"VUID-VkPresentTimesInfoGOOGLE-sType-sType", "sType must be VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE", "1.3-extensions"},
    {"VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247", "swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is included in the pNext chain of this VkPresentTimesInfoGOOGLE structure", "1.3-extensions"},
    {"VUID-VkPresentTimesInfoGOOGLE-swapchainCount-arraylength", "swapchainCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkPrivateDataSlotCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkPrivateDataSlotCreateInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkPrivateDataSlotCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkProtectedSubmitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO", "1.3-extensions"},
    {"VUID-VkPushConstantRange-offset-00294", "offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize", "1.3-extensions"},
    {"VUID-VkPushConstantRange-offset-00295", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkPushConstantRange-size-00296", "size must be greater than 0", "1.3-extensions"},
    {"VUID-VkPushConstantRange-size-00297", "size must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkPushConstantRange-size-00298", "size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset", "1.3-extensions"},
    {"VUID-VkPushConstantRange-stageFlags-parameter", "stageFlags must be a valid combination of VkShaderStageFlagBits values", "1.3-extensions"},
    {"VUID-VkPushConstantRange-stageFlags-requiredbitmask", "stageFlags must not be 0", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-meshShaderQueries-07068", "If the meshShaderQueries feature is not enabled, queryType must not be VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-meshShaderQueries-07069", "If the meshShaderQueries feature is not enabled, and queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must not contain VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT or VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkQueryPoolPerformanceCreateInfoKHR, VkQueryPoolPerformanceQueryCreateInfoINTEL, VkVideoDecodeH264ProfileInfoEXT, VkVideoDecodeH265ProfileInfoEXT, VkVideoDecodeUsageInfoKHR, VkVideoEncodeH264ProfileInfoEXT, VkVideoEncodeH265ProfileInfoEXT, VkVideoEncodeUsageInfoKHR, or VkVideoProfileInfoKHR", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-queryCount-02763", "queryCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-queryType-00791", "If the pipelineStatisticsQuery feature is not enabled, queryType must not be VK_QUERY_TYPE_PIPELINE_STATISTICS", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-queryType-00792", "If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits values", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-queryType-03222", "If queryType is VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the pNext chain must include a VkQueryPoolPerformanceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-queryType-parameter", "queryType must be a valid VkQueryType value", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkQueryPoolCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceCreateInfoKHR-counterIndexCount-arraylength", "counterIndexCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-03321", "Each element of pCounterIndices must be in the range of counters reported by vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR for the queue family specified in queueFamilyIndex", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceCreateInfoKHR-pCounterIndices-parameter", "pCounterIndices must be a valid pointer to an array of counterIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceCreateInfoKHR-performanceCounterQueryPools-03237", "The performanceCounterQueryPools feature must be enabled", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceCreateInfoKHR-queueFamilyIndex-03236", "queueFamilyIndex must be a valid queue family index of the device", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-performanceCountersSampling-parameter", "performanceCountersSampling must be a valid VkQueryPoolSamplingModeINTEL value", "1.3-extensions"},
    {"VUID-VkQueryPoolPerformanceQueryCreateInfoINTEL-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL", "1.3-extensions"},
    {"VUID-VkQueueFamilyCheckpointProperties2NV-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV", "1.3-extensions"},
    {"VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV", "1.3-extensions"},
    {"VUID-VkQueueFamilyGlobalPriorityPropertiesKHR-priorities-parameter", "Any given element of priorities must be a valid VkQueueGlobalPriorityKHR value", "1.3-extensions"},
    {"VUID-VkQueueFamilyGlobalPriorityPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkQueueFamilyProperties2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkQueueFamilyCheckpointProperties2NV, VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyGlobalPriorityPropertiesKHR, VkQueueFamilyQueryResultStatusPropertiesKHR, or VkQueueFamilyVideoPropertiesKHR", "1.3-extensions"},
    {"VUID-VkQueueFamilyProperties2-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2", "1.3-extensions"},
    {"VUID-VkQueueFamilyProperties2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkQueueFamilyQueryResultStatusPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkQueueFamilyVideoPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-commonparent", "Both of basePipelineHandle, and layout that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-02904", "flags must not include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03421", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a ray tracing VkPipeline", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03422", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03423", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03424", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03465", "If flags includes VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, pLibraryInterface must not be NULL", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03470", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, for any element of pGroups with a type of VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the anyHitShader of that element must not be VK_SHADER_UNUSED_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03471", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, for any element of pGroups with a type of VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the closestHitShader of that element must not be VK_SHADER_UNUSED_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03594", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03598", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR, rayTracingPipelineShaderGroupHandleCaptureReplay must be enabled", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-04718", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-04719", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-04720", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-04721", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-04722", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-04723", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-06546", "flags must not include both VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR and VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-07403", "If flags includes VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT, each element of pLibraryInfo->pLibraries must have been created with the VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-flags-parameter", "flags must be a valid combination of VkPipelineCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-layout-03427", "layout must be consistent with all shaders specified in pStages", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-layout-03428", "The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-maxPipelineRayRecursionDepth-03589", "maxPipelineRayRecursionDepth must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayRecursionDepth", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicState-parameter", "If pDynamicState is not NULL, pDynamicState must be a valid pointer to a valid VkPipelineDynamicStateCreateInfo structure", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicStates-03602", "Any element of the pDynamicStates member of pDynamicState must be VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pGroups-parameter", "If groupCount is not 0, pGroups must be a valid pointer to an array of groupCount valid VkRayTracingShaderGroupCreateInfoKHR structures", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraries-03591", "Each element of pLibraryInfo->pLibraries must have been created with the value of maxPipelineRayRecursionDepth equal to that in this pipeline", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03590", "If pLibraryInfo is not NULL and its libraryCount member is greater than 0, pLibraryInterface must not be NULL", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03592", "If pLibraryInfo is not NULL, each element of its pLibraries member must have been created with a layout that is compatible with the layout in this pipeline", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03593", "If pLibraryInfo is not NULL, each element of its pLibraries member must have been created with values of the maxPipelineRayPayloadSize and maxPipelineRayHitAttributeSize members of pLibraryInterface equal to those in this pipeline", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595", "If the VK_KHR_pipeline_library extension is not enabled, pLibraryInfo and pLibraryInterface must be NULL", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03600", "If pLibraryInfo is not NULL and its libraryCount is 0, stageCount must not be 0", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03601", "If pLibraryInfo is not NULL and its libraryCount is 0, groupCount must not be 0", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-parameter", "If pLibraryInfo is not NULL, pLibraryInfo must be a valid pointer to a valid VkPipelineLibraryCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInterface-parameter", "If pLibraryInterface is not NULL, pLibraryInterface must be a valid pointer to a valid VkRayTracingPipelineInterfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfo or VkPipelineRobustnessCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pStages-03426", "The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pStages-parameter", "If stageCount is not 0, pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pipelineCreationCacheControl-02905", "If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-pipelineStageCreationFeedbackCount-06652", "If VkPipelineCreationFeedbackCreateInfo::pipelineStageCreationFeedbackCount is not 0, it must be equal to stageCount", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplay-03599", "If VkPhysicalDeviceRayTracingPipelineFeaturesKHR::rayTracingPipelineShaderGroupHandleCaptureReplay is VK_TRUE and the pShaderGroupCaptureReplayHandle member of any element of pGroups is not NULL, flags must include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03596", "If the rayTraversalPrimitiveCulling feature is not enabled, flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03597", "If the rayTraversalPrimitiveCulling feature is not enabled, flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-stage-03425", "If flags does not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, the stage member of at least one element of pStages, including those implicitly added by pLibraryInfo, must be VK_SHADER_STAGE_RAYGEN_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoKHR-stage-06899", "The stage value in all pStages elements must be one of VK_SHADER_STAGE_RAYGEN_BIT_KHR, VK_SHADER_STAGE_ANY_HIT_BIT_KHR, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR, VK_SHADER_STAGE_MISS_BIT_KHR, VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or VK_SHADER_STAGE_CALLABLE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-commonparent", "Both of basePipelineHandle, and layout that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-02904", "flags must not include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-02957", "flags must not include both VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV and VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT at the same time", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03421", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid handle to a ray tracing VkPipeline", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03422", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03423", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is not -1, basePipelineHandle must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03424", "If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is not VK_NULL_HANDLE, basePipelineIndex must be -1", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03456", "flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03458", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03459", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03460", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03461", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03462", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03463", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-03588", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-04948", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-07402", "flags must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-flags-parameter", "flags must be a valid combination of VkPipelineCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-groupCount-arraylength", "groupCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-layout-03427", "layout must be consistent with all shaders specified in pStages", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-layout-03428", "The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-maxRecursionDepth-03457", "maxRecursionDepth must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxRecursionDepth", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-pGroups-parameter", "pGroups must be a valid pointer to an array of groupCount valid VkRayTracingShaderGroupCreateInfoNV structures", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkPipelineCreationFeedbackCreateInfo", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-pStages-03426", "The shader code for the entry points identified by pStages, and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-pStages-parameter", "pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-pipelineCreationCacheControl-02905", "If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-pipelineStageCreationFeedbackCount-06651", "If VkPipelineCreationFeedbackCreateInfo::pipelineStageCreationFeedbackCount is not 0, it must be equal to stageCount", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-stage-06232", "The stage member of at least one element of pStages must be VK_SHADER_STAGE_RAYGEN_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-stage-06898", "The stage value in all pStages elements must be one of VK_SHADER_STAGE_RAYGEN_BIT_KHR, VK_SHADER_STAGE_ANY_HIT_BIT_KHR, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR, VK_SHADER_STAGE_MISS_BIT_KHR, VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or VK_SHADER_STAGE_CALLABLE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineCreateInfoNV-stageCount-arraylength", "stageCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-maxPipelineRayHitAttributeSize-03605", "maxPipelineRayHitAttributeSize must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayHitAttributeSize", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkRayTracingPipelineInterfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-anyHitShader-03479", "anyHitShader must be either VK_SHADER_UNUSED_KHR or a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_ANY_HIT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-closestHitShader-03478", "closestHitShader must be either VK_SHADER_UNUSED_KHR or a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03603", "If VkPhysicalDeviceRayTracingPipelineFeaturesKHR::rayTracingPipelineShaderGroupHandleCaptureReplayMixed is VK_FALSE then pShaderGroupCaptureReplayHandle must not be provided if it has not been provided on a previous call to ray tracing pipeline creation", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-rayTracingPipelineShaderGroupHandleCaptureReplayMixed-03604", "If VkPhysicalDeviceRayTracingPipelineFeaturesKHR::rayTracingPipelineShaderGroupHandleCaptureReplayMixed is VK_FALSE then the caller must guarantee that no ray tracing pipeline creation commands with pShaderGroupCaptureReplayHandle provided execute simultaneously with ray tracing pipeline creation commands without pShaderGroupCaptureReplayHandle provided", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03474", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then generalShader must be a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_RAYGEN_BIT_KHR, VK_SHADER_STAGE_MISS_BIT_KHR, or VK_SHADER_STAGE_CALLABLE_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03475", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then closestHitShader, anyHitShader, and intersectionShader must be VK_SHADER_UNUSED_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03476", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR then intersectionShader must be a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_INTERSECTION_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03477", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR then intersectionShader must be VK_SHADER_UNUSED_KHR", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-parameter", "type must be a valid VkRayTracingShaderGroupTypeKHR value", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-anyHitShader-02418", "anyHitShader must be either VK_SHADER_UNUSED_NV or a valid index into VkRayTracingPipelineCreateInfoNV::pStages referring to a shader of VK_SHADER_STAGE_ANY_HIT_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-closestHitShader-02417", "closestHitShader must be either VK_SHADER_UNUSED_NV or a valid index into VkRayTracingPipelineCreateInfoNV::pStages referring to a shader of VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02413", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then generalShader must be a valid index into VkRayTracingPipelineCreateInfoNV::pStages referring to a shader of VK_SHADER_STAGE_RAYGEN_BIT_NV, VK_SHADER_STAGE_MISS_BIT_NV, or VK_SHADER_STAGE_CALLABLE_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02414", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV then closestHitShader, anyHitShader, and intersectionShader must be VK_SHADER_UNUSED_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02415", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV then intersectionShader must be a valid index into VkRayTracingPipelineCreateInfoNV::pStages referring to a shader of VK_SHADER_STAGE_INTERSECTION_BIT_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02416", "If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV then intersectionShader must be VK_SHADER_UNUSED_NV", "1.3-extensions"},
    {"VUID-VkRayTracingShaderGroupCreateInfoNV-type-parameter", "type must be a valid VkRayTracingShaderGroupTypeKHR value", "1.3-extensions"},
    {"VUID-VkRectLayerKHR-layer-01262", "layer must be less than the imageArrayLayers member of the VkSwapchainCreateInfoKHR structure passed to vkCreateSwapchainKHR", "1.3-extensions"},
    {"VUID-VkRectLayerKHR-offset-04864", "The sum of offset and extent, after being transformed according to the preTransform member of the VkSwapchainCreateInfoKHR structure, must be no greater than the imageExtent member of the VkSwapchainCreateInfoKHR structure passed to vkCreateSwapchainKHR", "1.3-extensions"},
    {"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-03218", "Each element of pAttachments must only specify a single mip level", "1.3-extensions"},
    {"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-03219", "Each element of pAttachments must have been created with the identity swizzle", "1.3-extensions"},
    {"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-04114", "Each element of pAttachments must have been created with VkImageViewCreateInfo::viewType not equal to VK_IMAGE_VIEW_TYPE_3D", "1.3-extensions"},
    {"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-07010", "If multisampled-render-to-single-sampled is enabled for any subpass, all element of pAttachments which have a sample count equal to VK_SAMPLE_COUNT_1_BIT must have a format that supports the sample count specified in VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples", "1.3-extensions"},
    {"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-parameter", "If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkImageView handles", "1.3-extensions"},
    {"VUID-VkRenderPassAttachmentBeginInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-clearValueCount-00902", "clearValueCount must be greater than the largest attachment index in renderPass specifying a loadOp (or stencilLoadOp, if the attachment has a depth/stencil format) of VK_ATTACHMENT_LOAD_OP_CLEAR", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-clearValueCount-04962", "If clearValueCount is not 0, pClearValues must be a valid pointer to an array of clearValueCount VkClearValue unions", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-commonparent", "Both of framebuffer, and renderPass must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-02780", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must have been created on the same VkDevice as framebuffer and renderPass", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03207", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that did not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and the pNext chain includes a VkRenderPassAttachmentBeginInfo structure, its attachmentCount must be zero", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03208", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the attachmentCount of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be equal to the value of VkFramebufferAttachmentsCreateInfo::attachmentImageInfoCount used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03209", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageCreateInfo::flags equal to the flags member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03211", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with a width equal to the width member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03212", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with a height equal to the height member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03213", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageViewCreateInfo::subresourceRange.layerCount equal to the layerCount member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03214", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageFormatListCreateInfo::viewFormatCount equal to the viewFormatCount member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03215", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a set of elements in VkImageFormatListCreateInfo::pViewFormats equal to the set of elements in the pViewFormats member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03216", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageViewCreateInfo::format equal to the corresponding value of VkAttachmentDescription::format in renderPass", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-03217", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageCreateInfo::samples equal to the corresponding value of VkAttachmentDescription::samples in renderPass", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-04627", "If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with an inherited usage equal to the usage member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-framebuffer-parameter", "framebuffer must be a valid VkFramebuffer handle", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02850", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.x must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02851", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.y must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02852", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.x + renderArea.extent.width must be less than or equal to VkFramebufferCreateInfo::width the framebuffer was created with", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02853", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.y + renderArea.extent.height must be less than or equal to VkFramebufferCreateInfo::height the framebuffer was created with", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02856", "If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, offset.x + extent.width of each element of pDeviceRenderAreas must be less than or equal to VkFramebufferCreateInfo::width the framebuffer was created with", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02857", "If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, offset.y + extent.height of each element of pDeviceRenderAreas must be less than or equal to VkFramebufferCreateInfo::height the framebuffer was created with", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02869", "If the pNext chain includes VkRenderPassTransformBeginInfoQCOM, renderArea.offset must equal (0,0)", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-02870", "If the pNext chain includes VkRenderPassTransformBeginInfoQCOM, renderArea.extent transformed by VkRenderPassTransformBeginInfoQCOM::transform must equal the framebuffer dimensions", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupRenderPassBeginInfo, VkRenderPassAttachmentBeginInfo, VkRenderPassSampleLocationsBeginInfoEXT, or VkRenderPassTransformBeginInfoQCOM", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-renderArea-02846", "renderArea.offset.x must be greater than or equal to 0", "1.0"},
    {"VUID-VkRenderPassBeginInfo-renderArea-02847", "renderArea.offset.y must be greater than or equal to 0", "1.0"},
    {"VUID-VkRenderPassBeginInfo-renderArea-02848", "renderArea.offset.x + renderArea.extent.width must be less than or equal to VkFramebufferCreateInfo::width the framebuffer was created with", "1.0"},
    {"VUID-VkRenderPassBeginInfo-renderArea-02849", "renderArea.offset.y + renderArea.extent.height must be less than or equal to VkFramebufferCreateInfo::height the framebuffer was created with", "1.0"},
    {"VUID-VkRenderPassBeginInfo-renderPass-00904", "renderPass must be compatible with the renderPass member of the VkFramebufferCreateInfo structure specified when creating framebuffer", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-renderPass-parameter", "renderPass must be a valid VkRenderPass handle", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO", "1.3-extensions"},
    {"VUID-VkRenderPassBeginInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-attachment-00834", "If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any element of pSubpasses is not VK_ATTACHMENT_UNUSED, then it must be less than attachmentCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-flags-parameter", "flags must be a valid combination of VkRenderPassCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-fragmentDensityMapAttachment-06471", "If the pNext chain includes a VkRenderPassFragmentDensityMapCreateInfoEXT structure and the fragmentDensityMapAttachment member is not VK_ATTACHMENT_UNUSED, then attachment must be less than attachmentCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pAttachments-00836", "For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pAttachments-01566", "For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pAttachments-01567", "For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pAttachments-02511", "For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pAttachments-parameter", "If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription structures", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pDependencies-00837", "For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pDependencies-00838", "For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the destination subpass", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pDependencies-06866", "For any element of pDependencies, if its srcSubpass is not VK_SUBPASS_EXTERNAL, it must be less than subpassCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pDependencies-06867", "For any element of pDependencies, if its dstSubpass is not VK_SUBPASS_EXTERNAL, it must be less than subpassCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pDependencies-parameter", "If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency structures", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-01926", "If the pNext chain includes a VkRenderPassInputAttachmentAspectCreateInfo structure, the subpass member of each element of its pAspectReferences member must be less than subpassCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-01927", "If the pNext chain includes a VkRenderPassInputAttachmentAspectCreateInfo structure, the inputAttachmentIndex member of each element of its pAspectReferences member must be less than the value of inputAttachmentCount in the element of pSubpasses identified by its subpass member", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-01928", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, and its subpassCount member is not zero, that member must be equal to the value of subpassCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-01929", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, if its dependencyCount member is not zero, it must be equal to dependencyCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-01930", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, for each non-zero element of pViewOffsets, the srcSubpass and dstSubpass members of pDependencies at the same index must not be equal", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-01963", "If the pNext chain includes a VkRenderPassInputAttachmentAspectCreateInfo structure, for any element of the pInputAttachments member of any element of pSubpasses where the attachment member is not VK_ATTACHMENT_UNUSED, the aspectMask member of the corresponding element of VkRenderPassInputAttachmentAspectCreateInfo::pAspectReferences must only include aspects that are present in images of the format specified by the element of pAttachments at attachment", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-02512", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, for any element of pDependencies with a dependencyFlags member that does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, the corresponding element of the pViewOffsets member of that VkRenderPassMultiviewCreateInfo instance must be 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-02513", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, elements of its pViewMasks member must either all be 0, or all not be 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-02514", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, and each element of its pViewMasks member is 0, the dependencyFlags member of each element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-02515", "If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, and each element of its pViewMasks member is 0, its correlationMaskCount member must be 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkRenderPassFragmentDensityMapCreateInfoEXT, VkRenderPassInputAttachmentAspectCreateInfo, or VkRenderPassMultiviewCreateInfo", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-pSubpasses-parameter", "pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription structures", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo-subpassCount-arraylength", "subpassCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-None-03049", "If any two subpasses operate on attachments with overlapping ranges of the same VkDeviceMemory object, and at least one subpass writes to that area of VkDeviceMemory, a subpass dependency must be included (either directly or via some intermediate subpasses) between them", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-attachment-02525", "If the attachment member of any element of the pInputAttachments member of any element of pSubpasses is not VK_ATTACHMENT_UNUSED, the aspectMask member of that element of pInputAttachments must only include aspects that are present in images of the format specified by the element of pAttachments specified by attachment", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-attachment-03050", "If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or the attachment indexed by any element of pPreserveAttachments in any given element of pSubpasses is bound to a range of a VkDeviceMemory object that overlaps with any other attachment in any subpass (including the same subpass), the VkAttachmentDescription2 structures describing them must include VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT in flags", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-attachment-03051", "If the attachment member of any element of pInputAttachments, pColorAttachments, pResolveAttachments or pDepthStencilAttachment, or any element of pPreserveAttachments in any given element of pSubpasses is not VK_ATTACHMENT_UNUSED, then it must be less than attachmentCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-attachment-06244", "If the attachment member of the pDepthStencilAttachment member of an element of pSubpasses is not VK_ATTACHMENT_UNUSED, the layout member of that same structure is either VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, and the pNext chain of that structure does not include a VkAttachmentReferenceStencilLayout structure, then the element of pAttachments with an index equal to attachment must not have a format that includes both depth and stencil aspects", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-attachment-06245", "If the attachment member of the pDepthStencilAttachment member of an element of pSubpasses is not VK_ATTACHMENT_UNUSED and the layout member of that same structure is either VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, then the element of pAttachments with an index equal to attachment must have a format that includes only a stencil aspect", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-attachment-06246", "If the attachment member of the pDepthStencilAttachment member of an element of pSubpasses is not VK_ATTACHMENT_UNUSED and the layout member of that same structure is either VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, then the element of pAttachments with an index equal to attachment must not have a format that includes only a stencil aspect", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-dstSubpass-02527", "The dstSubpass member of each element of pDependencies must be less than subpassCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-flags-04521", "If flags includes VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM, an element of pSubpasses includes an instance of VkFragmentShadingRateAttachmentInfoKHR in its pNext chain, and the pFragmentShadingRateAttachment member of that structure is not equal to NULL, the attachment member of pFragmentShadingRateAttachment must be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-flags-04907", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if pResolveAttachments is not NULL, then each resolve attachment must be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-flags-04908", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if pDepthStencilResolveAttachment is not NULL, then the depth/stencil resolve attachment must be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-flags-04909", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, then the subpass must be the last subpass in a subpass dependency chain", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-flags-parameter", "flags must be a valid combination of VkRenderPassCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-fragmentDensityMapAttachment-06472", "If the pNext chain includes a VkRenderPassFragmentDensityMapCreateInfoEXT structure and the fragmentDensityMapAttachment member is not VK_ATTACHMENT_UNUSED, then attachment must be less than attachmentCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pAttachments-02522", "For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pAttachments-02523", "For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pAttachments-04585", "If any element of pAttachments is used as a fragment shading rate attachment in any subpass, it must not be used as any other attachment in the render pass", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pAttachments-04586", "If any element of pAttachments is used as a fragment shading rate attachment in any subpass, it must have an image format whose potential format features contain VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pAttachments-parameter", "If attachmentCount is not 0, pAttachments must be a valid pointer to an array of attachmentCount valid VkAttachmentDescription2 structures", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pCorrelatedViewMasks-03056", "The set of bits included in any element of pCorrelatedViewMasks must not overlap with the set of bits included in any other element of pCorrelatedViewMasks", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pCorrelatedViewMasks-parameter", "If correlatedViewMaskCount is not 0, pCorrelatedViewMasks must be a valid pointer to an array of correlatedViewMaskCount uint32_t values", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pDependencies-03054", "For any element of pDependencies, if the srcSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the srcStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the source subpass", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pDependencies-03055", "For any element of pDependencies, if the dstSubpass is not VK_SUBPASS_EXTERNAL, all stage flags included in the dstStageMask member of that dependency must be a pipeline stage supported by the pipeline identified by the pipelineBindPoint member of the destination subpass", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pDependencies-03060", "For any element of pDependencies where its srcSubpass member equals its dstSubpass member, if the viewMask member of the corresponding element of pSubpasses includes more than one bit, its dependencyFlags member must include VK_DEPENDENCY_VIEW_LOCAL_BIT", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pDependencies-parameter", "If dependencyCount is not 0, pDependencies must be a valid pointer to an array of dependencyCount valid VkSubpassDependency2 structures", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkRenderPassCreationControlEXT, VkRenderPassCreationFeedbackCreateInfoEXT, or VkRenderPassFragmentDensityMapCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pSubpasses-06473", "If the pSubpasses pNext chain includes a VkSubpassDescriptionDepthStencilResolve structure and the pDepthStencilResolveAttachment member is not NULL and does not have the value VK_ATTACHMENT_UNUSED, then attachment must be less than attachmentCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-pSubpasses-parameter", "pSubpasses must be a valid pointer to an array of subpassCount valid VkSubpassDescription2 structures", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-rasterizationSamples-04905", "If the pipeline is being created with fragment shader state, and the VK_QCOM_render_pass_shader_resolve extension is enabled, and if subpass has any input attachments, and if the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the sample count of the input attachments must equal rasterizationSamples", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-sampleShadingEnable-04906", "If the pipeline is being created with fragment shader state, and the VK_QCOM_render_pass_shader_resolve extension is enabled, and if the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then sampleShadingEnable must be false", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-srcSubpass-02526", "The srcSubpass member of each element of pDependencies must be less than subpassCount", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-subpassCount-arraylength", "subpassCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-viewMask-03057", "If the VkSubpassDescription2::viewMask member of all elements of pSubpasses is 0, correlatedViewMaskCount must be 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-viewMask-03058", "The VkSubpassDescription2::viewMask member of all elements of pSubpasses must either all be 0, or all not be 0", "1.3-extensions"},
    {"VUID-VkRenderPassCreateInfo2-viewMask-03059", "If the VkSubpassDescription2::viewMask member of all elements of pSubpasses is 0, the dependencyFlags member of any element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT", "1.3-extensions"},
    {"VUID-VkRenderPassCreationControlEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT", "1.3-extensions"},
    {"VUID-VkRenderPassCreationFeedbackCreateInfoEXT-pRenderPassFeedback-parameter", "pRenderPassFeedback must be a valid pointer to a VkRenderPassCreationFeedbackInfoEXT structure", "1.3-extensions"},
    {"VUID-VkRenderPassCreationFeedbackCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548", "If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass", "1.3-extensions"},
    {"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02549", "If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, layout must be equal to VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02550", "If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a loadOp equal to VK_ATTACHMENT_LOAD_OP_LOAD or VK_ATTACHMENT_LOAD_OP_DONT_CARE", "1.3-extensions"},
    {"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02551", "If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a storeOp equal to VK_ATTACHMENT_STORE_OP_DONT_CARE", "1.3-extensions"},
    {"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-parameter", "fragmentDensityMapAttachment must be a valid VkAttachmentReference structure", "1.3-extensions"},
    {"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkRenderPassInputAttachmentAspectCreateInfo-aspectReferenceCount-arraylength", "aspectReferenceCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkRenderPassInputAttachmentAspectCreateInfo-pAspectReferences-parameter", "pAspectReferences must be a valid pointer to an array of aspectReferenceCount valid VkInputAttachmentAspectReference structures", "1.3-extensions"},
    {"VUID-VkRenderPassInputAttachmentAspectCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-multiview-06555", "If the multiview feature is not enabled, each element of pViewMasks must be 0", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-00841", "Each view index must not be set in more than one element of pCorrelationMasks", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-pCorrelationMasks-parameter", "If correlationMaskCount is not 0, pCorrelationMasks must be a valid pointer to an array of correlationMaskCount uint32_t values", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-06697", "The index of the most significant bit in each element of pViewMasks must be less than maxMultiviewViewCount", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-parameter", "If subpassCount is not 0, pViewMasks must be a valid pointer to an array of subpassCount uint32_t values", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-pViewOffsets-parameter", "If dependencyCount is not 0, pViewOffsets must be a valid pointer to an array of dependencyCount int32_t values", "1.3-extensions"},
    {"VUID-VkRenderPassMultiviewCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkRenderPassSampleLocationsBeginInfoEXT-pAttachmentInitialSampleLocations-parameter", "If attachmentInitialSampleLocationsCount is not 0, pAttachmentInitialSampleLocations must be a valid pointer to an array of attachmentInitialSampleLocationsCount valid VkAttachmentSampleLocationsEXT structures", "1.3-extensions"},
    {"VUID-VkRenderPassSampleLocationsBeginInfoEXT-pPostSubpassSampleLocations-parameter", "If postSubpassSampleLocationsCount is not 0, pPostSubpassSampleLocations must be a valid pointer to an array of postSubpassSampleLocationsCount valid VkSubpassSampleLocationsEXT structures", "1.3-extensions"},
    {"VUID-VkRenderPassSampleLocationsBeginInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT", "1.3-extensions"},
    {"VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-pSubpassFeedback-parameter", "pSubpassFeedback must be a valid pointer to a VkRenderPassSubpassFeedbackInfoEXT structure", "1.3-extensions"},
    {"VUID-VkRenderPassSubpassFeedbackCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkRenderPassTransformBeginInfoQCOM-flags-02872", "The renderpass must have been created with VkRenderPassCreateInfo::flags containing VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM", "1.3-extensions"},
    {"VUID-VkRenderPassTransformBeginInfoQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM", "1.3-extensions"},
    {"VUID-VkRenderPassTransformBeginInfoQCOM-transform-02871", "transform must be VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR, VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR, VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR, or VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-clearValue-parameter", "clearValue must be a valid VkClearValue union", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-commonparent", "Both of imageView, and resolveImageView that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06129", "If imageView is not VK_NULL_HANDLE and has a non-integer color format, resolveMode must be VK_RESOLVE_MODE_NONE or VK_RESOLVE_MODE_AVERAGE_BIT", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06130", "If imageView is not VK_NULL_HANDLE and has an integer color format, resolveMode must be VK_RESOLVE_MODE_NONE or VK_RESOLVE_MODE_SAMPLE_ZERO_BIT", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06132", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, imageView must not have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-khr-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06135", "If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06136", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, or VK_IMAGE_LAYOUT_PREINITIALIZED", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06137", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06138", "If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06139", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06140", "If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06141", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06142", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06143", "If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06144", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06145", "If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06146", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_PRESENT_SRC_KHR", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06860", "If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageView must not be VK_NULL_HANDLE", "1.3-khr-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06861", "If imageView is not VK_NULL_HANDLE, resolveMode is not VK_RESOLVE_MODE_NONE, and the pNext chain of VkRenderingInfo does not includes a VkMultisampledRenderToSingleSampledInfoEXT structure with the multisampledRenderToSingleSampledEnable field equal to VK_TRUE, imageView must not have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06862", "If imageView is not VK_NULL_HANDLE, resolveMode is not VK_RESOLVE_MODE_NONE, and the pNext chain of VkRenderingInfo does not includes a VkMultisampledRenderToSingleSampledInfoEXT structure with the multisampledRenderToSingleSampledEnable field equal to VK_TRUE, resolveImageView must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06863", "If imageView is not VK_NULL_HANDLE, resolveMode is not VK_RESOLVE_MODE_NONE, the pNext chain of VkRenderingInfo includes a VkMultisampledRenderToSingleSampledInfoEXT structure with the multisampledRenderToSingleSampledEnable field equal to VK_TRUE, and imageView has a sample count of VK_SAMPLE_COUNT_1_BIT, resolveImageView must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06864", "If imageView is not VK_NULL_HANDLE, resolveImageView is not VK_NULL_HANDLE, and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageView must have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-06865", "If imageView is not VK_NULL_HANDLE, resolveImageView is not VK_NULL_HANDLE, and resolveMode is not VK_RESOLVE_MODE_NONE, imageView and resolveImageView must have the same VkFormat", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-imageView-parameter", "If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-loadOp-parameter", "loadOp must be a valid VkAttachmentLoadOp value", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-resolveImageLayout-parameter", "resolveImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-resolveImageView-parameter", "If resolveImageView is not VK_NULL_HANDLE, resolveImageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-resolveMode-parameter", "If resolveMode is not 0, resolveMode must be a valid VkResolveModeFlagBits value", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO", "1.3-extensions"},
    {"VUID-VkRenderingAttachmentInfo-storeOp-parameter", "storeOp must be a valid VkAttachmentStoreOp value", "1.3-extensions"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06157", "If imageView is not VK_NULL_HANDLE, layout must be VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT", "1.3-extensions"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06158", "If imageView is not VK_NULL_HANDLE, it must have been created with VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT", "1.3-extensions"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06159", "If imageView is not VK_NULL_HANDLE, it must not have been created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06160", "If imageView is not VK_NULL_HANDLE, it must have a layerCount equal to 1", "default"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-parameter", "imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06147", "If imageView is not VK_NULL_HANDLE, layout must be VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06148", "If imageView is not VK_NULL_HANDLE, it must have been created with VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06149", "If imageView is not VK_NULL_HANDLE, shadingRateAttachmentTexelSize.width must be a power of two value", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06150", "If imageView is not VK_NULL_HANDLE, shadingRateAttachmentTexelSize.width must be less than or equal to maxFragmentShadingRateAttachmentTexelSize.width", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06151", "If imageView is not VK_NULL_HANDLE, shadingRateAttachmentTexelSize.width must be greater than or equal to minFragmentShadingRateAttachmentTexelSize.width", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06152", "If imageView is not VK_NULL_HANDLE, shadingRateAttachmentTexelSize.height must be a power of two value", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06153", "If imageView is not VK_NULL_HANDLE, shadingRateAttachmentTexelSize.height must be less than or equal to maxFragmentShadingRateAttachmentTexelSize.height", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06154", "If imageView is not VK_NULL_HANDLE, shadingRateAttachmentTexelSize.height must be greater than or equal to minFragmentShadingRateAttachmentTexelSize.height", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06155", "If imageView is not VK_NULL_HANDLE, the quotient of shadingRateAttachmentTexelSize.width and shadingRateAttachmentTexelSize.height must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06156", "If imageView is not VK_NULL_HANDLE, the quotient of shadingRateAttachmentTexelSize.height and shadingRateAttachmentTexelSize.width must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-parameter", "If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06087", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, that imageView must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06090", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, the layout member of that element of pColorAttachments must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06091", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, if the resolveMode member of that element of pColorAttachments is not VK_RESOLVE_MODE_NONE, its resolveImageLayout member must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06096", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, the layout member of that element of pColorAttachments must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06097", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, if the resolveMode member of that element of pColorAttachments is not VK_RESOLVE_MODE_NONE, its resolveImageLayout member must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06100", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, the layout member of that element of pColorAttachments must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06101", "If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, if the resolveMode member of that element of pColorAttachments is not VK_RESOLVE_MODE_NONE, its resolveImageLayout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-colorAttachmentCount-06106", "colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments", "1.3-extensions"},
    {"VUID-VkRenderingInfo-flags-parameter", "flags must be a valid combination of VkRenderingFlagBits values", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06075", "The width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to renderArea.offset.x + renderArea.extent.width", "default"},
    {"VUID-VkRenderingInfo-imageView-06076", "The height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to renderArea.offset.y + renderArea.extent.height", "default"},
    {"VUID-VkRenderingInfo-imageView-06107", "If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and the fragmentDensityMapNonSubsampledImages feature is not enabled, valid imageView and resolveImageView members of pDepthAttachment, pStencilAttachment, and each element of pColorAttachments must be a VkImageView created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06108", "If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is not 0, imageView must have a layerCount greater than or equal to the index of the most significant bit in viewMask", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06109", "If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is 0, imageView must have a layerCount equal to 1", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06110", "If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{x}+renderArea_{width}}{maxFragmentDensityTexelSize_{width}}}\\right\\rceil\\)", "default"},
    {"VUID-VkRenderingInfo-imageView-06111", "If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{y}+renderArea_{height}}{maxFragmentDensityTexelSize_{height}}}\\right\\rceil\\)", "default"},
    {"VUID-VkRenderingInfo-imageView-06116", "If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, it must not be equal to the imageView or resolveImageView member of pDepthAttachment, pStencilAttachment, or any element of pColorAttachments", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06117", "If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{x}+renderArea_{width}}{shadingRateAttachmentTexelSize_{width}}}\\right\\rceil\\)", "default"},
    {"VUID-VkRenderingInfo-imageView-06118", "If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{y}+renderArea_{height}}{shadingRateAttachmentTexelSize_{height}}}\\right\\rceil\\)", "default"},
    {"VUID-VkRenderingInfo-imageView-06123", "If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is 0, imageView must have a layerCount that is either equal to 1 or greater than or equal to layerCount", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06124", "If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is not 0, imageView must have a layerCount that either equal to 1 or greater than or equal to the index of the most significant bit in viewMask", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06125", "If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, it must not be equal to the imageView or resolveImageView member of pDepthAttachment, pStencilAttachment, or any element of pColorAttachments", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06126", "If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, it must not be equal to the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06858", "If multisampled-render-to-single-sampled is enabled, then all attachments referenced by imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE must have a sample count that is either VK_SAMPLE_COUNT_1_BIT or equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples.", "1.3-extensions"},
    {"VUID-VkRenderingInfo-imageView-06859", "If multisampled-render-to-single-sampled is enabled, then all attachments referenced by imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE and have a sample count of VK_SAMPLE_COUNT_1_BIT must have been created with VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT in their VkImageCreateInfo::flags.", "1.3-extensions"},
    {"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857", "If none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE must have been created with the same sampleCount", "1.3-extensions"},
    {"VUID-VkRenderingInfo-multiview-06127", "If the multiview feature is not enabled, viewMask must be 0", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pColorAttachments-parameter", "If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkRenderingAttachmentInfo structures", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06085", "If neither pDepthAttachment or pStencilAttachment are NULL and the imageView member of either structure is not VK_NULL_HANDLE, the imageView member of each structure must be the same", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06086", "If neither pDepthAttachment or pStencilAttachment are NULL, and the resolveMode member of each is not VK_RESOLVE_MODE_NONE, the resolveImageView member of each structure must be the same", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06088", "If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->imageView must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06092", "If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->layout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06093", "If pDepthAttachment is not NULL, pDepthAttachment->imageView is not VK_NULL_HANDLE, and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06098", "If pDepthAttachment is not NULL, pDepthAttachment->imageView is not VK_NULL_HANDLE, and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06102", "If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->resolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedDepthResolveModes", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06104", "If pDepthAttachment or pStencilAttachment are both not NULL, pDepthAttachment->imageView and pStencilAttachment->imageView are both not VK_NULL_HANDLE, and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone is VK_FALSE, the resolveMode of both structures must be the same value", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06105", "If pDepthAttachment or pStencilAttachment are both not NULL, pDepthAttachment->imageView and pStencilAttachment->imageView are both not VK_NULL_HANDLE, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE, and the resolveMode of neither structure is VK_RESOLVE_MODE_NONE, the resolveMode of both structures must be the same value", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-06547", "If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->imageView must have been created with a format that includes a depth aspect", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pDepthAttachment-parameter", "If pDepthAttachment is not NULL, pDepthAttachment must be a valid pointer to a valid VkRenderingAttachmentInfo structure", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06077", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.x must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06078", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.y must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06079", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, the width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to renderArea.offset.x + renderArea.extent.width", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06080", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, the height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to renderArea.offset.y + renderArea.extent.height", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06083", "If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.x and extent.width members of each element of pDeviceRenderAreas", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06084", "If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.y and extent.height members of each element of pDeviceRenderAreas", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06112", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0 and the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{x}+renderArea_{width}}{maxFragmentDensityTexelSize_{width}}}\\right\\rceil\\)", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06113", "If the pNext chain contains a VkDeviceGroupRenderPassBeginInfo structure, its deviceRenderAreaCount member is not 0, and the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\(\\left\\lceil{\\frac{pDeviceRenderAreas_{x}+pDeviceRenderAreas_{width}}{maxFragmentDensityTexelSize_{width}}}\\right\\rceil\\) for each element of pDeviceRenderAreas", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06114", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0 and the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{y}+renderArea_{height}}{maxFragmentDensityTexelSize_{height}}}\\right\\rceil\\)", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06115", "If the pNext chain contains a VkDeviceGroupRenderPassBeginInfo structure, its deviceRenderAreaCount member is not 0, and the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\(\\left\\lceil{\\frac{pDeviceRenderAreas_{y}+pDeviceRenderAreas_{height}}{maxFragmentDensityTexelSize_{height}}}\\right\\rceil\\) for each element of pDeviceRenderAreas", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06119", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0 and the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{x}+renderArea_{width}}{shadingRateAttachmentTexelSize_{width}}}\\right\\rceil\\)", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06120", "If the pNext chain contains a VkDeviceGroupRenderPassBeginInfo structure, its deviceRenderAreaCount member is not 0, and the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\(\\left\\lceil{\\frac{pDeviceRenderAreas_{x}+pDeviceRenderAreas_{width}}{shadingRateAttachmentTexelSize_{width}}}\\right\\rceil\\) for each element of pDeviceRenderAreas", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06121", "If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0 and the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\(\\left\\lceil{\\frac{renderArea_{y}+renderArea_{height}}{shadingRateAttachmentTexelSize_{height}}}\\right\\rceil\\)", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-06122", "If the pNext chain contains a VkDeviceGroupRenderPassBeginInfo structure, its deviceRenderAreaCount member is not 0, and the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\(\\left\\lceil{\\frac{pDeviceRenderAreas_{y}+pDeviceRenderAreas_{height}}{shadingRateAttachmentTexelSize_{height}}}\\right\\rceil\\) for each element of pDeviceRenderAreas", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupRenderPassBeginInfo, VkMultisampledRenderToSingleSampledInfoEXT, VkMultiviewPerViewAttributesInfoNVX, VkRenderingFragmentDensityMapAttachmentInfoEXT, or VkRenderingFragmentShadingRateAttachmentInfoKHR", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-06089", "If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->imageView must have been created with a stencil usage including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-06094", "If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->layout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-06095", "If pStencilAttachment is not NULL, pStencilAttachment->imageView is not VK_NULL_HANDLE, and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-06099", "If pStencilAttachment is not NULL, pStencilAttachment->imageView is not VK_NULL_HANDLE, and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-06103", "If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->resolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedStencilResolveModes", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-06548", "If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->imageView must have been created with a format that includes a stencil aspect", "1.3-extensions"},
    {"VUID-VkRenderingInfo-pStencilAttachment-parameter", "If pStencilAttachment is not NULL, pStencilAttachment must be a valid pointer to a valid VkRenderingAttachmentInfo structure", "1.3-extensions"},
    {"VUID-VkRenderingInfo-renderArea-06071", "renderArea.offset.x must be greater than or equal to 0", "default"},
    {"VUID-VkRenderingInfo-renderArea-06072", "renderArea.offset.y must be greater than or equal to 0", "default"},
    {"VUID-VkRenderingInfo-renderArea-06073", "The sum of renderArea.offset.x and renderArea.extent.width must be less than or equal to maxFramebufferWidth", "default"},
    {"VUID-VkRenderingInfo-renderArea-06074", "The sum of renderArea.offset.y and renderArea.extent.height must be less than or equal to maxFramebufferHeight", "default"},
    {"VUID-VkRenderingInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_RENDERING_INFO", "1.3-extensions"},
    {"VUID-VkRenderingInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkRenderingInfo-viewMask-06069", "If viewMask is 0, layerCount must not be 0", "1.3-extensions"},
    {"VUID-VkRenderingInfo-viewMask-06128", "The index of the most significant bit in viewMask must be less than maxMultiviewViewCount", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-commonparent", "Both of dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-00258", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-00259", "dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-00276", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-00278", "If dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, dstOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-02003", "The format features of dstImage must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-02546", "dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-06764", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-06765", "The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImageLayout-00262", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImageLayout-00263", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkResolveImageInfo2-dstImageLayout-01401", "dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstOffset-00274", "For each element of pRegions, dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstOffset-00275", "For each element of pRegions, dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstOffset-00277", "For each element of pRegions, dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstSubresource-01710", "The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-dstSubresource-01712", "The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-linearColorAttachment-06519", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, the format features of dstImage must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-pRegions-00255", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkImageResolve2 structures", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-00256", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-00257", "srcImage must have a sample count equal to any valid sample count value other than VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-00271", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-00273", "If srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, srcOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-01386", "srcImage and dstImage must have been created with the same image format", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-04446", "If either srcImage or dstImage are of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer must be 0 and srcSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-04447", "If either srcImage or dstImage are of type VK_IMAGE_TYPE_3D, then for each element of pRegions, dstSubresource.baseArrayLayer must be 0 and dstSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-06762", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-06763", "The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImageLayout-00260", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImageLayout-00261", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-VkResolveImageInfo2-srcImageLayout-01400", "srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcOffset-00269", "For each element of pRegions, srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcOffset-00270", "For each element of pRegions, srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcOffset-00272", "For each element of pRegions, srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcSubresource-01709", "The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkResolveImageInfo2-srcSubresource-01711", "The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-VkSampleLocationsInfoEXT-pSampleLocations-parameter", "If sampleLocationsCount is not 0, pSampleLocations must be a valid pointer to an array of sampleLocationsCount VkSampleLocationEXT structures", "1.3-extensions"},
    {"VUID-VkSampleLocationsInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT", "1.3-extensions"},
    {"VUID-VkSampleLocationsInfoEXT-sampleLocationsCount-01527", "sampleLocationsCount must equal sampleLocationsPerPixel {times} sampleLocationGridSize.width {times} sampleLocationGridSize.height", "1.3-extensions"},
    {"VUID-VkSampleLocationsInfoEXT-sampleLocationsPerPixel-01526", "sampleLocationsPerPixel must be a bit value that is set in VkPhysicalDeviceSampleLocationsPropertiesEXT::sampleLocationSampleCounts", "1.3-extensions"},
    {"VUID-VkSamplerBorderColorComponentMappingCreateInfoEXT-borderColorSwizzle-06437", "The borderColorSwizzle feature must be enabled.", "1.3-extensions"},
    {"VUID-VkSamplerBorderColorComponentMappingCreateInfoEXT-components-parameter", "components must be a valid VkComponentMapping structure", "1.3-extensions"},
    {"VUID-VkSamplerBorderColorComponentMappingCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-None-01647", "if sampler {YCbCr} conversion is enabled and the pNext chain includes a VkSamplerReductionModeCreateInfo structure, then the sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-None-04012", "The maximum number of samplers with custom border colors which can be simultaneously created on a device is implementation-dependent and specified by the maxCustomBorderColorSamplers member of the VkPhysicalDeviceCustomBorderColorPropertiesEXT structure", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-addressModeU-01078", "If any of addressModeU, addressModeV or addressModeW are VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, borderColor must be a valid VkBorderColor value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-addressModeU-01079", "If samplerMirrorClampToEdge is not enabled, and if the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-addressModeU-01646", "If sampler {YCbCr} conversion is enabled, addressModeU, addressModeV, and addressModeW must be VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, anisotropyEnable must be VK_FALSE, and unnormalizedCoordinates must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-addressModeU-parameter", "addressModeU must be a valid VkSamplerAddressMode value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-addressModeV-parameter", "addressModeV must be a valid VkSamplerAddressMode value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-addressModeW-parameter", "addressModeW must be a valid VkSamplerAddressMode value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-anisotropyEnable-01070", "If the samplerAnisotropy feature is not enabled, anisotropyEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-anisotropyEnable-01071", "If anisotropyEnable is VK_TRUE, maxAnisotropy must be between 1.0 and VkPhysicalDeviceLimits::maxSamplerAnisotropy, inclusive", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-borderColor-04011", "If borderColor is one of VK_BORDER_COLOR_FLOAT_CUSTOM_EXT or VK_BORDER_COLOR_INT_CUSTOM_EXT, then a VkSamplerCustomBorderColorCreateInfoEXT must be included in the pNext chain", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-borderColor-04442", "If borderColor is one of VK_BORDER_COLOR_FLOAT_CUSTOM_EXT or VK_BORDER_COLOR_INT_CUSTOM_EXT, and VkSamplerCustomBorderColorCreateInfoEXT::format is not VK_FORMAT_UNDEFINED, VkSamplerCustomBorderColorCreateInfoEXT::customBorderColor must be within the range of values representable in format", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-compareEnable-01080", "If compareEnable is VK_TRUE, compareOp must be a valid VkCompareOp value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-compareEnable-01423", "If compareEnable is VK_TRUE, the reductionMode member of VkSamplerReductionModeCreateInfo must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-customBorderColors-04085", "If the customBorderColors feature is not enabled, borderColor must not be VK_BORDER_COLOR_FLOAT_CUSTOM_EXT or VK_BORDER_COLOR_INT_CUSTOM_EXT", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02574", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minFilter and magFilter must be equal", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02575", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02576", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minLod and maxLod must be zero", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02577", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02578", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then anisotropyEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02579", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then compareEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-02580", "If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then unnormalizedCoordinates must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06964", "If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then minFilter and magFilter must be VK_FILTER_NEAREST.", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06965", "If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06966", "[If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then minLod and maxLod must be zero", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06967", "If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06968", "If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, and if addressModeU or addressModeV is VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, then borderColor must be VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK.", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06969", "If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then anisotropyEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-06970", "If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then compareEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-flags-parameter", "flags must be a valid combination of VkSamplerCreateFlagBits values", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-magFilter-01081", "If either magFilter or minFilter is VK_FILTER_CUBIC_EXT, anisotropyEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-magFilter-01422", "If either magFilter or minFilter is VK_FILTER_CUBIC_EXT, the reductionMode member of VkSamplerReductionModeCreateInfo must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE", "default"},
    {"VUID-VkSamplerCreateInfo-magFilter-parameter", "magFilter must be a valid VkFilter value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-maxLod-01973", "maxLod must be greater than or equal to minLod", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-minFilter-01645", "If sampler {YCbCr} conversion is enabled and the potential format features of the sampler {YCbCr} conversion do not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT, minFilter and magFilter must be equal to the sampler {YCbCr} conversion's chromaFilter", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-minFilter-parameter", "minFilter must be a valid VkFilter value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-mipLodBias-01069", "The absolute value of mipLodBias must be less than or equal to VkPhysicalDeviceLimits::maxSamplerLodBias", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-mipmapMode-parameter", "mipmapMode must be a valid VkSamplerMipmapMode value", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-nonSeamlessCubeMap-06788", "If the nonSeamlessCubeMap feature is not enabled, flags must not include VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-pNext-06726", "If samplerFilterMinmax is not enabled and the pNext chain includes a VkSamplerReductionModeCreateInfo structure, then the sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkSamplerBorderColorComponentMappingCreateInfoEXT, VkSamplerCustomBorderColorCreateInfoEXT, VkSamplerReductionModeCreateInfo, or VkSamplerYcbcrConversionInfo", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-samplerMipLodBias-04467", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::samplerMipLodBias is VK_FALSE, mipLodBias must be zero", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072", "If unnormalizedCoordinates is VK_TRUE, minFilter and magFilter must be equal", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073", "If unnormalizedCoordinates is VK_TRUE, mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074", "If unnormalizedCoordinates is VK_TRUE, minLod and maxLod must be zero", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075", "If unnormalizedCoordinates is VK_TRUE, addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076", "If unnormalizedCoordinates is VK_TRUE, anisotropyEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077", "If unnormalizedCoordinates is VK_TRUE, compareEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-04013", "If provided format is not VK_FORMAT_UNDEFINED then the VkSamplerCreateInfo::borderColor type must match the sampled type of the provided format, as shown in the SPIR-V Sampled Type column of the Interpretation of Numeric Format table", "1.3-extensions"},
    {"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-04014", "If the customBorderColorWithoutFormat feature is not enabled then format must not be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-04015", "If the sampler is used to sample an image view of VK_FORMAT_B4G4R4A4_UNORM_PACK16, VK_FORMAT_B5G6R5_UNORM_PACK16, or VK_FORMAT_B5G5R5A1_UNORM_PACK16 format then format must not be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkSamplerCustomBorderColorCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkSamplerReductionModeCreateInfo-reductionMode-parameter", "reductionMode must be a valid VkSamplerReductionMode value", "1.3-extensions"},
    {"VUID-VkSamplerReductionModeCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-01657", "If the potential format features of the sampler {YCbCr} conversion do not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, chromaFilter must not be VK_FILTER_LINEAR", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-parameter", "chromaFilter must be a valid VkFilter value", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-components-02581", "If the format has a _422 or _420 suffix, then components.g must be the identity swizzle", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-components-02582", "If the format has a _422 or _420 suffix, then components.a must be the identity swizzle, VK_COMPONENT_SWIZZLE_ONE, or VK_COMPONENT_SWIZZLE_ZERO", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-components-02583", "If the format has a _422 or _420 suffix, then components.r must be the identity swizzle or VK_COMPONENT_SWIZZLE_B", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-components-02584", "If the format has a _422 or _420 suffix, then components.b must be the identity swizzle or VK_COMPONENT_SWIZZLE_R", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-components-02585", "If the format has a _422 or _420 suffix, and if either components.r or components.b is the identity swizzle, both values must be the identity swizzle", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-components-parameter", "components must be a valid VkComponentMapping structure", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-forceExplicitReconstruction-01656", "If the potential format features of the sampler {YCbCr} conversion do not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT forceExplicitReconstruction must be VK_FALSE", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-format-01650", "The potential format features of the sampler {YCbCr} conversion must support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-format-01904", "If an external format conversion is being created, format must be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-format-04060", "format must represent unsigned normalized values (i.e. the format must be a UNORM format)", "1.3-khr-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-format-04061", "If an external format conversion is not being created, format must represent unsigned normalized values (i.e. the format must be a UNORM format)", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkExternalFormatANDROID", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-01651", "If the potential format features of the sampler {YCbCr} conversion do not support VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_COSITED_EVEN if the corresponding components are downsampled", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-01652", "If the potential format features of the sampler {YCbCr} conversion do not support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT, xChromaOffset and yChromaOffset must not be VK_CHROMA_LOCATION_MIDPOINT if the corresponding components are downsampled", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-xChromaOffset-parameter", "xChromaOffset must be a valid VkChromaLocation value", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-yChromaOffset-parameter", "yChromaOffset must be a valid VkChromaLocation value", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-01655", "If ycbcrModel is not VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY, then components.r, components.g, and components.b must correspond to components of the format; that is, components.r, components.g, and components.b must not be VK_COMPONENT_SWIZZLE_ZERO or VK_COMPONENT_SWIZZLE_ONE, and must not correspond to a component containing zero or one as a consequence of conversion to RGBA", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrModel-parameter", "ycbcrModel must be a valid VkSamplerYcbcrModelConversion value", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-02748", "If ycbcrRange is VK_SAMPLER_YCBCR_RANGE_ITU_NARROW then the R, G and B components obtained by applying the component swizzle to format must each have a bit-depth greater than or equal to 8", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionCreateInfo-ycbcrRange-parameter", "ycbcrRange must be a valid VkSamplerYcbcrRange value", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionImageFormatProperties-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionInfo-conversion-parameter", "conversion must be a valid VkSamplerYcbcrConversion handle", "1.3-extensions"},
    {"VUID-VkSamplerYcbcrConversionInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO", "1.3-extensions"},
    {"VUID-VkScreenSurfaceCreateInfoQNX-context-04741", "context must point to a valid QNX Screen struct _screen_context", "1.3-extensions"},
    {"VUID-VkScreenSurfaceCreateInfoQNX-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkScreenSurfaceCreateInfoQNX-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkScreenSurfaceCreateInfoQNX-sType-sType", "sType must be VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX", "1.3-extensions"},
    {"VUID-VkScreenSurfaceCreateInfoQNX-window-04742", "window must point to a valid QNX Screen struct _screen_window", "1.3-extensions"},
    {"VUID-VkSemaphoreCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkSemaphoreCreateInfo-pNext-06789", "If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkSemaphoreCreateInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkExportMetalObjectCreateInfoEXT, VkExportSemaphoreCreateInfo, VkExportSemaphoreWin32HandleInfoKHR, VkImportMetalSharedEventInfoEXT, or VkSemaphoreTypeCreateInfo", "1.3-extensions"},
    {"VUID-VkSemaphoreCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkSemaphoreCreateInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique, with the exception of structures of type VkExportMetalObjectCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-01132", "handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when semaphore's current payload was created", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-01134", "If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-01135", "If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-01136", "handleType must be defined as a POSIX file descriptor handle", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-03253", "If handleType refers to a handle type with copy payload transference semantics, semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-03254", "If handleType refers to a handle type with copy payload transference semantics, semaphore must have an associated semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) must have also been submitted for execution", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter", "handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-semaphore-01133", "semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType", "1.3-extensions"},
    {"VUID-VkSemaphoreGetFdInfoKHR-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01126", "handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when the semaphore's current payload was created", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01127", "If handleType is defined as an NT handle, vkGetSemaphoreWin32HandleKHR must be called no more than once for each valid unique combination of semaphore and handleType", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01129", "If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01130", "If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01131", "handleType must be defined as an NT handle or a global share handle", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter", "handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-01128", "semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType", "1.3-extensions"},
    {"VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-04758", "handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when semaphore's current payload was created", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-04760", "If handleType refers to a handle type with copy payload transference semantics, as defined below in Importing Semaphore Payloads, there must be no queue waiting on semaphore", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-04761", "If handleType refers to a handle type with copy payload transference semantics, semaphore must be signaled, or have an associated semaphore signal operation pending execution", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-04762", "handleType must be defined as a Zircon event handle", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-handleType-parameter", "handleType must be a valid VkExternalSemaphoreHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-semaphore-04759", "semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-semaphore-04763", "semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY", "1.3-extensions"},
    {"VUID-VkSemaphoreGetZirconHandleInfoFUCHSIA-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-semaphore-03257", "semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-value-03258", "value must have a value greater than the current value of the semaphore", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-value-03259", "value must be less than the value of any pending semaphore signal operations", "1.3-extensions"},
    {"VUID-VkSemaphoreSignalInfo-value-03260", "value must have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-device-03888", "If the device that semaphore was created on is not a device group, deviceIndex must be 0", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-device-03889", "If the device that semaphore was created on is a device group, deviceIndex must be a valid device index", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03929", "If the geometryShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03930", "If the tessellationShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03931", "If the conditionalRendering feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03933", "If the transformFeedback feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03934", "If the meshShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-03935", "If the taskShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-04956", "If the shadingRateImage feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-04957", "If the subpassShading feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-04995", "If the invocationMask feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-VkSemaphoreSubmitInfo-stageMask-parameter", "stageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-VkSemaphoreTypeCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkSemaphoreTypeCreateInfo-semaphoreType-03279", "If semaphoreType is VK_SEMAPHORE_TYPE_BINARY, initialValue must be zero", "1.3-extensions"},
    {"VUID-VkSemaphoreTypeCreateInfo-semaphoreType-parameter", "semaphoreType must be a valid VkSemaphoreType value", "1.3-extensions"},
    {"VUID-VkSemaphoreTypeCreateInfo-timelineSemaphore-03252", "If the timelineSemaphore feature is not enabled, semaphoreType must not equal VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-flags-parameter", "flags must be a valid combination of VkSemaphoreWaitFlagBits values", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-pSemaphores-03256", "All of the elements of pSemaphores must reference a semaphore that was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-pSemaphores-parameter", "pSemaphores must be a valid pointer to an array of semaphoreCount valid VkSemaphore handles", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-pValues-parameter", "pValues must be a valid pointer to an array of semaphoreCount uint64_t values", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO", "1.3-extensions"},
    {"VUID-VkSemaphoreWaitInfo-semaphoreCount-arraylength", "semaphoreCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-codeSize-01085", "codeSize must be greater than 0", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-codeSize-01086", "codeSize must be a multiple of 4", "1.3-khr-extensions"},
    {"VUID-VkShaderModuleCreateInfo-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01087", "pCode must point to valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification", "1.3-khr-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01088", "pCode must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix", "1.3-khr-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01089", "pCode must declare the Shader capability for SPIR-V code", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01090", "pCode must not declare any capability that is not supported by the API, as described by the Capabilities section of the SPIR-V Environment appendix", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01091", "If pCode declares any of the capabilities listed in the SPIR-V Environment appendix, one of the corresponding requirements must be satisfied", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01376", "If pCode is a pointer to SPIR-V code, codeSize must be a multiple of 4", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01377", "pCode must point to either valid SPIR-V code, formatted and packed as described by the Khronos SPIR-V Specification or valid GLSL code which must be written to the GL_KHR_vulkan_glsl extension specification", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01378", "If pCode is a pointer to SPIR-V code, that code must adhere to the validation rules described by the Validation Rules within a Module section of the SPIR-V Environment appendix", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-01379", "If pCode is a pointer to GLSL code, it must be valid GLSL code written to the GL_KHR_vulkan_glsl GLSL extension specification", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-04146", "pCode must not declare any SPIR-V extension that is not supported by the API, as described by the Extension section of the SPIR-V Environment appendix", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-04147", "If pCode declares any of the SPIR-V extensions listed in the SPIR-V Environment appendix, one of the corresponding requirements must be satisfied", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-pCode-parameter", "pCode must be a valid pointer to an array of (codeSize/4) uint32_t values", "1.3-extensions"},
    {"VUID-VkShaderModuleCreateInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO", "1.3-extensions"},
    {"VUID-VkShaderModuleIdentifierEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkShaderModuleIdentifierEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT", "1.3-extensions"},
    {"VUID-VkShaderModuleValidationCacheCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkShaderModuleValidationCacheCreateInfoEXT-validationCache-parameter", "validationCache must be a valid VkValidationCacheEXT handle", "1.3-extensions"},
    {"VUID-VkShadingRatePaletteNV-pShadingRatePaletteEntries-parameter", "pShadingRatePaletteEntries must be a valid pointer to an array of shadingRatePaletteEntryCount valid VkShadingRatePaletteEntryNV values", "1.3-extensions"},
    {"VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-02071", "shadingRatePaletteEntryCount must be between 1 and VkPhysicalDeviceShadingRateImagePropertiesNV::shadingRatePaletteSize, inclusive", "1.3-extensions"},
    {"VUID-VkShadingRatePaletteNV-shadingRatePaletteEntryCount-arraylength", "shadingRatePaletteEntryCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkSharedPresentSurfaceCapabilitiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR", "1.3-extensions"},
    {"VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength", "bindCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkSparseBufferMemoryBindInfo-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter", "pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures", "1.3-extensions"},
    {"VUID-VkSparseImageFormatProperties2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSparseImageFormatProperties2-sType-sType", "sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-extent-01108", "extent.width must either be a multiple of the sparse image block width of the image, or else (extent.width + offset.x) must equal the width of the image subresource", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-extent-01110", "extent.height must either be a multiple of the sparse image block height of the image, or else (extent.height + offset.y) must equal the height of the image subresource", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-extent-01112", "extent.depth must either be a multiple of the sparse image block depth of the image, or else (extent.depth + offset.z) must equal the depth of the image subresource", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-flags-parameter", "flags must be a valid combination of VkSparseMemoryBindFlagBits values", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-memory-01104", "If the sparseResidencyAliased feature is not enabled, and if any other resources are bound to ranges of memory, the range of memory being bound must not overlap with those bound ranges", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-memory-01105", "memory and memoryOffset must match the memory requirements of the calling command's image, as described in section Resource Memory Association", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-memory-02732", "If memory was created with VkExportMemoryAllocateInfo::handleTypes not equal to 0, at least one handle type it contained must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when the image was created", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-memory-02733", "If memory was created by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-memory-parameter", "If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-offset-01107", "offset.x must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of the image", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-offset-01109", "offset.y must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of the image", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-offset-01111", "offset.z must be a multiple of the sparse image block depth (VkSparseImageFormatProperties::imageGranularity.depth) of the image", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-subresource-01106", "subresource must be a valid image subresource for image (see Image Views)", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBind-subresource-parameter", "subresource must be a valid VkImageSubresource structure", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength", "bindCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBindInfo-image-02901", "image must have been created with VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT set", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBindInfo-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBindInfo-pBinds-parameter", "pBinds must be a valid pointer to an array of bindCount valid VkSparseImageMemoryBind structures", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBindInfo-subresource-01722", "The subresource.mipLevel member of each element of pBinds must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryBindInfo-subresource-01723", "The subresource.arrayLayer member of each element of pBinds must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryRequirements2-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSparseImageMemoryRequirements2-sType-sType", "sType must be VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2", "1.3-extensions"},
    {"VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength", "bindCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkSparseImageOpaqueMemoryBindInfo-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-01103", "If the flags member of any element of pBinds contains VK_SPARSE_MEMORY_BIND_METADATA_BIT, the binding range defined must be within the mip tail region of the metadata aspect of image", "1.3-extensions"},
    {"VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter", "pBinds must be a valid pointer to an array of bindCount valid VkSparseMemoryBind structures", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-flags-parameter", "flags must be a valid combination of VkSparseMemoryBindFlagBits values", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-memory-01096", "If memory is not VK_NULL_HANDLE, memory and memoryOffset must match the memory requirements of the resource, as described in section Resource Memory Association", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-memory-01097", "If memory is not VK_NULL_HANDLE, memory must not have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-memory-02730", "If memory was created with VkExportMemoryAllocateInfo::handleTypes not equal to 0, at least one handle type it contained must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes or VkExternalMemoryImageCreateInfo::handleTypes when the resource was created", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-memory-02731", "If memory was created by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes or VkExternalMemoryImageCreateInfo::handleTypes when the resource was created", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-memory-parameter", "If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-memoryOffset-01101", "memoryOffset must be less than the size of memory", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-resourceOffset-01099", "resourceOffset must be less than the size of the resource", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-size-01098", "size must be greater than 0", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-size-01100", "size must be less than or equal to the size of the resource minus resourceOffset", "1.3-extensions"},
    {"VUID-VkSparseMemoryBind-size-01102", "size must be less than or equal to the size of memory minus memoryOffset", "1.3-extensions"},
    {"VUID-VkSpecializationInfo-constantID-04911", "The constantID value of each element of pMapEntries must be unique within pMapEntries", "1.3-extensions"},
    {"VUID-VkSpecializationInfo-offset-00773", "The offset member of each element of pMapEntries must be less than dataSize", "1.3-extensions"},
    {"VUID-VkSpecializationInfo-pData-parameter", "If dataSize is not 0, pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-VkSpecializationInfo-pMapEntries-00774", "The size member of each element of pMapEntries must be less than or equal to dataSize minus offset", "1.3-extensions"},
    {"VUID-VkSpecializationInfo-pMapEntries-parameter", "If mapEntryCount is not 0, pMapEntries must be a valid pointer to an array of mapEntryCount valid VkSpecializationMapEntry structures", "1.3-extensions"},
    {"VUID-VkSpecializationMapEntry-constantID-00776", "For a constantID specialization constant declared in a shader, size must match the byte size of the constantID. If the specialization constant is of type boolean, size must be the byte size of VkBool32", "1.3-extensions"},
    {"VUID-VkStencilOpState-compareOp-parameter", "compareOp must be a valid VkCompareOp value", "1.3-extensions"},
    {"VUID-VkStencilOpState-depthFailOp-parameter", "depthFailOp must be a valid VkStencilOp value", "1.3-extensions"},
    {"VUID-VkStencilOpState-failOp-parameter", "failOp must be a valid VkStencilOp value", "1.3-extensions"},
    {"VUID-VkStencilOpState-passOp-parameter", "passOp must be a valid VkStencilOp value", "1.3-extensions"},
    {"VUID-VkStreamDescriptorSurfaceCreateInfoGGP-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkStreamDescriptorSurfaceCreateInfoGGP-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkStreamDescriptorSurfaceCreateInfoGGP-sType-sType", "sType must be VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP", "1.3-extensions"},
    {"VUID-VkStreamDescriptorSurfaceCreateInfoGGP-streamDescriptor-02681", "streamDescriptor must be a valid GgpStreamDescriptor", "1.3-extensions"},
    {"VUID-VkStridedDeviceAddressRegionKHR-size-04631", "If size is not zero, all addresses between deviceAddress and deviceAddress + size - 1 must be in the buffer device address range of the same buffer", "1.3-extensions"},
    {"VUID-VkStridedDeviceAddressRegionKHR-size-04632", "If size is not zero, stride must be less than or equal to the size of the buffer from which deviceAddress was queried", "1.3-extensions"},
    {"VUID-VkSubmitInfo-commonparent", "Each of the elements of pCommandBuffers, the elements of pSignalSemaphores, and the elements of pWaitSemaphores that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkSubmitInfo-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkSubmitInfo-pCommandBuffers-00075", "Each element of pCommandBuffers must not have been allocated with VK_COMMAND_BUFFER_LEVEL_SECONDARY", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pCommandBuffers-06014", "If pCommandBuffers contains any suspended render pass instances, they must be resumed by a render pass instance later in submission order within pCommandBuffers", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pCommandBuffers-06015", "If pCommandBuffers contains any suspended render pass instances, there must be no action or synchronization commands executed in a primary or secondary command buffer between that render pass instance and the render pass instance that resumes it", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pCommandBuffers-06016", "If pCommandBuffers contains any suspended render pass instances, there must be no render pass instances between that render pass instance and the render pass instance that resumes it", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pCommandBuffers-06193", "If pCommandBuffers contains any resumed render pass instances, they must be suspended by a render pass instance earlier in submission order within pCommandBuffers", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pCommandBuffers-parameter", "If commandBufferCount is not 0, pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pNext-03240", "If the pNext chain of this structure includes a VkTimelineSemaphoreSubmitInfo structure and any element of pWaitSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE, then its waitSemaphoreValueCount member must equal waitSemaphoreCount", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pNext-03241", "If the pNext chain of this structure includes a VkTimelineSemaphoreSubmitInfo structure and any element of pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE, then its signalSemaphoreValueCount member must equal signalSemaphoreCount", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pNext-04120", "If the pNext chain of this structure does not include a VkProtectedSubmitInfo structure with protectedSubmit set to VK_TRUE, then each element of the pCommandBuffers array must be an unprotected command buffer", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pNext-04148", "If the pNext chain of this structure includes a VkProtectedSubmitInfo structure with protectedSubmit set to VK_TRUE, then each element of the pCommandBuffers array must be a protected command buffer", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAmigoProfilingSubmitInfoSEC, VkD3D12FenceSubmitInfoKHR, VkDeviceGroupSubmitInfo, VkPerformanceQuerySubmitInfoKHR, VkProtectedSubmitInfo, VkTimelineSemaphoreSubmitInfo, VkWin32KeyedMutexAcquireReleaseInfoKHR, or VkWin32KeyedMutexAcquireReleaseInfoNV", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pSignalSemaphores-03242", "For each element of pSignalSemaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE the corresponding element of VkTimelineSemaphoreSubmitInfo::pSignalSemaphoreValues must have a value greater than the current value of the semaphore when the semaphore signal operation is executed", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pSignalSemaphores-03244", "For each element of pSignalSemaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE the corresponding element of VkTimelineSemaphoreSubmitInfo::pSignalSemaphoreValues must have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pSignalSemaphores-parameter", "If signalSemaphoreCount is not 0, pSignalSemaphores must be a valid pointer to an array of signalSemaphoreCount valid VkSemaphore handles", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-00078", "Each element of pWaitDstStageMask must not include VK_PIPELINE_STAGE_HOST_BIT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-03937", "If the synchronization2 feature is not enabled, pname:pWaitDstStageMask must not be 0", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04090", "If the geometryShader feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04091", "If the tessellationShader feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04092", "If the conditionalRendering feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04094", "If the transformFeedback feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04095", "If the meshShader feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04096", "If the taskShader feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04097", "If the shadingRateImage feature is not enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-04996", "pname:pWaitDstStageMask must not be 0", "1.2"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-parameter", "If waitSemaphoreCount is not 0, pWaitDstStageMask must be a valid pointer to an array of waitSemaphoreCount valid combinations of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitDstStageMask-requiredbitmask", "Each element of pWaitDstStageMask must not be 0", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitSemaphores-03239", "If any element of pWaitSemaphores or pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE, then the pNext chain must include a VkTimelineSemaphoreSubmitInfo structure", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitSemaphores-03243", "For each element of pWaitSemaphores created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE the corresponding element of VkTimelineSemaphoreSubmitInfo::pWaitSemaphoreValues must have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkSubmitInfo-pWaitSemaphores-parameter", "If waitSemaphoreCount is not 0, pWaitSemaphores must be a valid pointer to an array of waitSemaphoreCount valid VkSemaphore handles", "1.3-extensions"},
    {"VUID-VkSubmitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBMIT_INFO", "1.3-extensions"},
    {"VUID-VkSubmitInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSubmitInfo-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:pWaitDstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkSubmitInfo-variableSampleLocations-06017", "If the variableSampleLocations limit is not supported, and any element of pCommandBuffers contains any suspended render pass instances, where a graphics pipeline has been bound, any pipelines bound in the render pass instance that resumes it, or any subsequent render pass instances that resume from that one and so on, must use the same sample locations", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-flags-03886", "If flags includes VK_SUBMIT_PROTECTED_BIT, all elements of pCommandBuffers must be protected command buffers", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-flags-03887", "If flags does not include VK_SUBMIT_PROTECTED_BIT, each element of pCommandBuffers must not be a protected command buffer", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-flags-parameter", "flags must be a valid combination of VkSubmitFlagBits values", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-pCommandBufferInfos-parameter", "If commandBufferInfoCount is not 0, pCommandBufferInfos must be a valid pointer to an array of commandBufferInfoCount valid VkCommandBufferSubmitInfo structures", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPerformanceQuerySubmitInfoKHR, VkWin32KeyedMutexAcquireReleaseInfoKHR, or VkWin32KeyedMutexAcquireReleaseInfoNV", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-pSignalSemaphoreInfos-parameter", "If signalSemaphoreInfoCount is not 0, pSignalSemaphoreInfos must be a valid pointer to an array of signalSemaphoreInfoCount valid VkSemaphoreSubmitInfo structures", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-pWaitSemaphoreInfos-parameter", "If waitSemaphoreInfoCount is not 0, pWaitSemaphoreInfos must be a valid pointer to an array of waitSemaphoreInfoCount valid VkSemaphoreSubmitInfo structures", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBMIT_INFO_2", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-semaphore-03881", "If the same semaphore is used as the semaphore member of both an element of pSignalSemaphoreInfos and pWaitSemaphoreInfos, and that semaphore is a timeline semaphore, the value member of the pSignalSemaphoreInfos element must be greater than the value member of the pWaitSemaphoreInfos element", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-semaphore-03882", "If the semaphore member of any element of pSignalSemaphoreInfos is a timeline semaphore, the value member of that element must have a value greater than the current value of the semaphore when the semaphore signal operation is executed", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-semaphore-03883", "If the semaphore member of any element of pSignalSemaphoreInfos is a timeline semaphore, the value member of that element must have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkSubmitInfo2-semaphore-03884", "If the semaphore member of any element of pWaitSemaphoreInfos is a timeline semaphore, the value member of that element must have a value which does not differ from the current value of the semaphore or the value of any outstanding semaphore wait or signal operation on that semaphore by more than maxTimelineSemaphoreValueDifference", "1.3-extensions"},
    {"VUID-VkSubmitInfo2KHR-commandBuffer-06010", "If any commandBuffer member of an element of pCommandBufferInfos contains any suspended render pass instances, they must be resumed by a render pass instance later in submission order within pCommandBufferInfos", "1.3-extensions"},
    {"VUID-VkSubmitInfo2KHR-commandBuffer-06011", "If any commandBuffer member of an element of pCommandBufferInfos contains any suspended render pass instances, there must be no action or synchronization commands between that render pass instance and the render pass instance that resumes it", "1.3-extensions"},
    {"VUID-VkSubmitInfo2KHR-commandBuffer-06012", "If any commandBuffer member of an element of pCommandBufferInfos contains any suspended render pass instances, there must be no render pass instances between that render pass instance and the render pass instance that resumes it", "1.3-extensions"},
    {"VUID-VkSubmitInfo2KHR-commandBuffer-06192", "If any commandBuffer member of an element of pCommandBufferInfos contains any resumed render pass instances, they must be suspended by a render pass instance earlier in submission order within pCommandBufferInfos", "1.3-extensions"},
    {"VUID-VkSubmitInfo2KHR-variableSampleLocations-06013", "If the variableSampleLocations limit is not supported, and any commandBuffer member of an element of pCommandBufferInfos contains any suspended render pass instances, where a graphics pipeline has been bound, any pipelines bound in the render pass instance that resumes it, or any subsequent render pass instances that resume from that one and so on, must use the same sample locations", "1.3-extensions"},
    {"VUID-VkSubpassBeginInfo-contents-parameter", "contents must be a valid VkSubpassContents value", "1.3-extensions"},
    {"VUID-VkSubpassBeginInfo-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSubpassBeginInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dependencyFlags-02520", "If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dependencyFlags-02521", "If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dependencyFlags-parameter", "dependencyFlags must be a valid combination of VkDependencyFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstAccessMask-00869", "Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstAccessMask-parameter", "dstAccessMask must be a valid combination of VkAccessFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-03937", "If the synchronization2 feature is not enabled, pname:dstStageMask must not be 0", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04090", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04091", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04092", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04094", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04095", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04096", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-dstStageMask-04097", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkSubpassDependency-dstStageMask-04996", "pname:dstStageMask must not be 0", "1.2"},
    {"VUID-VkSubpassDependency-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkSubpassDependency-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcAccessMask-00868", "Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcAccessMask-parameter", "srcAccessMask must be a valid combination of VkAccessFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-03937", "If the synchronization2 feature is not enabled, pname:srcStageMask must not be 0", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04090", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04091", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04092", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04094", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04095", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04096", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcStageMask-04097", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkSubpassDependency-srcStageMask-04996", "pname:srcStageMask must not be 0", "1.2"},
    {"VUID-VkSubpassDependency-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcSubpass-00864", "srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcSubpass-00865", "srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcSubpass-00872", "If srcSubpass equals dstSubpass and that subpass has more than one bit set in the view mask, then dependencyFlags must include VK_DEPENDENCY_VIEW_LOCAL_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcSubpass-02243", "If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency-srcSubpass-06809", "If srcSubpass is equal to dstSubpass and srcStageMask includes a framebuffer-space stage, dstStageMask must only contain framebuffer-space stages", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dependencyFlags-03090", "If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, srcSubpass must not be equal to VK_SUBPASS_EXTERNAL", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dependencyFlags-03091", "If dependencyFlags includes VK_DEPENDENCY_VIEW_LOCAL_BIT, dstSubpass must not be equal to VK_SUBPASS_EXTERNAL", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dependencyFlags-03092", "If dependencyFlags does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, viewOffset must be 0", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dependencyFlags-parameter", "dependencyFlags must be a valid combination of VkDependencyFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstAccessMask-03089", "Any access flag included in dstAccessMask must be supported by one of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstAccessMask-parameter", "dstAccessMask must be a valid combination of VkAccessFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-03937", "If the synchronization2 feature is not enabled, pname:dstStageMask must not be 0", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04090", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04091", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04092", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04094", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04095", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04096", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-dstStageMask-04097", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkSubpassDependency2-dstStageMask-04996", "pname:dstStageMask must not be 0", "1.2"},
    {"VUID-VkSubpassDependency2-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-VkSubpassDependency2-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkMemoryBarrier2", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcAccessMask-03088", "Any access flag included in srcAccessMask must be supported by one of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcAccessMask-parameter", "srcAccessMask must be a valid combination of VkAccessFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-03937", "If the synchronization2 feature is not enabled, pname:srcStageMask must not be 0", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04090", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04091", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04092", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04094", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04095", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04096", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcStageMask-04097", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-VkSubpassDependency2-srcStageMask-04996", "pname:srcStageMask must not be 0", "1.2"},
    {"VUID-VkSubpassDependency2-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcSubpass-02245", "If srcSubpass equals dstSubpass, and srcStageMask and dstStageMask both include a framebuffer-space stage, then dependencyFlags must include VK_DEPENDENCY_BY_REGION_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcSubpass-03084", "srcSubpass must be less than or equal to dstSubpass, unless one of them is VK_SUBPASS_EXTERNAL, to avoid cyclic dependencies and ensure a valid execution order", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcSubpass-03085", "srcSubpass and dstSubpass must not both be equal to VK_SUBPASS_EXTERNAL", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-srcSubpass-06810", "If srcSubpass is equal to dstSubpass and srcStageMask includes a framebuffer-space stage, dstStageMask must only contain framebuffer-space stages", "1.3-extensions"},
    {"VUID-VkSubpassDependency2-viewOffset-02530", "If viewOffset is not equal to 0, srcSubpass must not be equal to dstSubpass", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-00853", "Each element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06912", "If the attachment member of an element of pInputAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06913", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06914", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06915", "If the attachment member of pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED, ts layout member must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06916", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06917", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06918", "If the attachment member of an element of pInputAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06919", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06920", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06921", "If the attachment member of an element of pInputAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06922", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDescription-attachment-06923", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDescription-colorAttachmentCount-00845", "colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments", "1.3-extensions"},
    {"VUID-VkSubpassDescription-flags-00856", "If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX", "1.3-extensions"},
    {"VUID-VkSubpassDescription-flags-03341", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if pResolveAttachments is not NULL, then each resolve attachment must be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription-flags-03343", "If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, then the subpass must be the last subpass in a subpass dependency chain", "1.3-extensions"},
    {"VUID-VkSubpassDescription-flags-parameter", "flags must be a valid combination of VkSubpassDescriptionFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDescription-layout-02519", "If any attachment is used by more than one VkAttachmentReference member, then each use must use the same layout", "1.3-extensions"},
    {"VUID-VkSubpassDescription-linearColorAttachment-06496", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, all attachments in pInputAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkSubpassDescription-linearColorAttachment-06497", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkSubpassDescription-linearColorAttachment-06498", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, all attachments in pResolveAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkSubpassDescription-loadOp-00846", "If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pColorAttachments-01506", "If the VK_AMD_mixed_attachment_samples extension is enabled, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pColorAttachments-02648", "All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pColorAttachments-06868", "If neither the VK_AMD_mixed_attachment_samples extension nor the VK_NV_framebuffer_mixed_samples extension is enabled, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pColorAttachments-parameter", "If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pDepthStencilAttachment-01418", "If neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, and if pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and any attachments in pColorAttachments are not VK_ATTACHMENT_UNUSED, they must have the same sample count", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pDepthStencilAttachment-02650", "If pDepthStencilAttachment is not NULL and the attachment is not VK_ATTACHMENT_UNUSED then it must have an image format whose potential format features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pDepthStencilAttachment-04438", "pDepthStencilAttachment and pColorAttachments must not contain references to the same attachment", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pDepthStencilAttachment-parameter", "If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference structure", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pInputAttachments-02647", "All attachments in pInputAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features contain at least VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pInputAttachments-02868", "If the render pass is created with VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM each of the elements of pInputAttachments must be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pInputAttachments-parameter", "If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference structures", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pPreserveAttachments-00854", "Each element of pPreserveAttachments must not also be an element of any other member of the subpass description", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pPreserveAttachments-parameter", "If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pResolveAttachments-00847", "If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pResolveAttachments-00848", "If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pResolveAttachments-00849", "If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pResolveAttachments-00850", "If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have the same VkFormat as its corresponding color attachment", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pResolveAttachments-02649", "All attachments in pResolveAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pResolveAttachments-parameter", "If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference structures", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pipelineBindPoint-00844", "pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-khr-extensions"},
    {"VUID-VkSubpassDescription-pipelineBindPoint-04952", "pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS or VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI", "1.3-extensions"},
    {"VUID-VkSubpassDescription-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-02799", "If the attachment member of any element of pInputAttachments is not VK_ATTACHMENT_UNUSED, then the aspectMask member must be a valid combination of VkImageAspectFlagBits", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-02800", "If the attachment member of any element of pInputAttachments is not VK_ATTACHMENT_UNUSED, then the aspectMask member must not be 0", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-02801", "If the attachment member of any element of pInputAttachments is not VK_ATTACHMENT_UNUSED, then the aspectMask member must not include VK_IMAGE_ASPECT_METADATA_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-03073", "Each element of pPreserveAttachments must not be VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-04563", "If the attachment member of any element of pInputAttachments is not VK_ATTACHMENT_UNUSED, then the aspectMask member must not include VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT for any index i", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06251", "If the attachment member of pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED and its pNext chain includes a VkAttachmentDescriptionStencilLayout structure, the layout member of pDepthStencilAttachment must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06912", "If the attachment member of an element of pInputAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06913", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06914", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06915", "If the attachment member of pDepthStencilAttachment is not VK_ATTACHMENT_UNUSED, ts layout member must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06916", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06917", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06918", "If the attachment member of an element of pInputAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06919", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06920", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06921", "If the attachment member of an element of pInputAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06922", "If the attachment member of an element of pColorAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-attachment-06923", "If the attachment member of an element of pResolveAttachments is not VK_ATTACHMENT_UNUSED, its layout member must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-colorAttachmentCount-03063", "colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-flags-03076", "If flags includes VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX, it must also include VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-flags-parameter", "flags must be a valid combination of VkSubpassDescriptionFlagBits values", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-layout-02528", "If any attachment is used by more than one VkAttachmentReference2 member, then each use must use the same layout", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-linearColorAttachment-06499", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, all attachments in pInputAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-linearColorAttachment-06500", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-linearColorAttachment-06501", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, all attachments in pResolveAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-loadOp-03064", "If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then loadOp must not be VK_ATTACHMENT_LOAD_OP_CLEAR", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-multisampledRenderToSingleSampled-06869", "If none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-multisampledRenderToSingleSampled-06872", "If none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, all attachments in pDepthStencilAttachment or pColorAttachments that are not VK_ATTACHMENT_UNUSED must have the same sample count", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-multiview-06558", "If the multiview feature is not enabled, viewMask must be 0", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pColorAttachments-02898", "All attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pColorAttachments-03070", "If the VK_AMD_mixed_attachment_samples extension is enabled, all attachments in pColorAttachments that are not VK_ATTACHMENT_UNUSED must have a sample count that is smaller than or equal to the sample count of pDepthStencilAttachment if it is not VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pColorAttachments-parameter", "If colorAttachmentCount is not 0, pColorAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2 structures", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pDepthStencilAttachment-02900", "If pDepthStencilAttachment is not NULL and the attachment is not VK_ATTACHMENT_UNUSED then it must have an image format whose potential format features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pDepthStencilAttachment-04440", "An attachment must not be used in both pDepthStencilAttachment and pColorAttachments", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pDepthStencilAttachment-parameter", "If pDepthStencilAttachment is not NULL, pDepthStencilAttachment must be a valid pointer to a valid VkAttachmentReference2 structure", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pInputAttachments-02897", "All attachments in pInputAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features contain at least VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pInputAttachments-parameter", "If inputAttachmentCount is not 0, pInputAttachments must be a valid pointer to an array of inputAttachmentCount valid VkAttachmentReference2 structures", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pNext-06870", "If the pNext chain includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then all attachments in pColorAttachments and pDepthStencilAttachment that are not VK_ATTACHMENT_UNUSED must have a sample count that is either VK_SAMPLE_COUNT_1_BIT or equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pNext-06871", "If the pNext chain includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, and pDepthStencilAttachment is not NULL, does not have the value VK_ATTACHMENT_UNUSED, and has a sample count of VK_SAMPLE_COUNT_1_BIT, the pNext chain must also include a VkSubpassDescriptionDepthStencilResolve structure with pDepthStencilResolveAttachment that is either NULL or has the value VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkFragmentShadingRateAttachmentInfoKHR, VkMultisampledRenderToSingleSampledInfoEXT, VkRenderPassCreationControlEXT, VkRenderPassSubpassFeedbackCreateInfoEXT, or VkSubpassDescriptionDepthStencilResolve", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pPreserveAttachments-03074", "Any given element of pPreserveAttachments must not also be an element of any other member of the subpass description", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pPreserveAttachments-parameter", "If preserveAttachmentCount is not 0, pPreserveAttachments must be a valid pointer to an array of preserveAttachmentCount uint32_t values", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pResolveAttachments-02899", "All attachments in pResolveAttachments that are not VK_ATTACHMENT_UNUSED must have image formats whose potential format features contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pResolveAttachments-03065", "If pResolveAttachments is not NULL, for each resolve attachment that does not have the value VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have the value VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pResolveAttachments-03066", "If pResolveAttachments is not NULL, for each resolve attachment that is not VK_ATTACHMENT_UNUSED, the corresponding color attachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pResolveAttachments-03067", "If pResolveAttachments is not NULL, each resolve attachment that is not VK_ATTACHMENT_UNUSED must have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pResolveAttachments-03068", "Any given element of pResolveAttachments must have the same VkFormat as its corresponding color attachment", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pResolveAttachments-parameter", "If colorAttachmentCount is not 0, and pResolveAttachments is not NULL, pResolveAttachments must be a valid pointer to an array of colorAttachmentCount valid VkAttachmentReference2 structures", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pipelineBindPoint-03062", "pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-khr-extensions"},
    {"VUID-VkSubpassDescription2-pipelineBindPoint-04953", "pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS or VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSubpassDescription2-viewMask-06706", "The index of the most significant bit in viewMask must be less than maxMultiviewViewCount", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-depthResolveMode-03183", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED and the VkFormat of pDepthStencilResolveAttachment has a depth component, then the value of depthResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedDepthResolveModes or VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-02651", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED then it must have an image format whose potential format features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03177", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not be NULL or have the value VK_ATTACHMENT_UNUSED", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03179", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilAttachment must not have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03180", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilResolveAttachment must have a sample count of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03181", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED and VkFormat of pDepthStencilResolveAttachment has a depth component, then the VkFormat of pDepthStencilAttachment must have a depth component with the same number of bits and numerical type", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03182", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, and VkFormat of pDepthStencilResolveAttachment has a stencil component, then the VkFormat of pDepthStencilAttachment must have a stencil component with the same number of bits and numerical type", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03185", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE, and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone is VK_FALSE, then the values of depthResolveMode and stencilResolveMode must be identical", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03186", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone is VK_TRUE, then the values of depthResolveMode and stencilResolveMode must be identical or one of them must be VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-parameter", "If pDepthStencilResolveAttachment is not NULL, pDepthStencilResolveAttachment must be a valid pointer to a valid VkAttachmentReference2 structure", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pNext-06873", "If the pNext chain of VkSubpassDescription2 includes a VkMultisampledRenderToSingleSampledInfoEXT structure, the multisampledRenderToSingleSampledEnable field is VK_TRUE, and pDepthStencilAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pNext-06874", "If the pNext chain of VkSubpassDescription2 includes a VkMultisampledRenderToSingleSampledInfoEXT structure whose multisampledRenderToSingleSampledEnable field is VK_TRUE, and pDepthStencilAttachment is not NULL, does not have the value VK_ATTACHMENT_UNUSED, and has a VkFormat that has a depth component, then the value of depthResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedDepthResolveModes or VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pNext-06875", "If the pNext chain of VkSubpassDescription2 includes a VkMultisampledRenderToSingleSampledInfoEXT structure whose multisampledRenderToSingleSampledEnable field is VK_TRUE, and pDepthStencilAttachment is not NULL, does not have the value VK_ATTACHMENT_UNUSED, and has a VkFormat with a stencil component, then the value of stencilResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedStencilResolveModes or VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pNext-06876", "If the pNext chain of VkSubpassDescription2 includes a VkMultisampledRenderToSingleSampledInfoEXT structure whose multisampledRenderToSingleSampledEnable field is VK_TRUE, pDepthStencilAttachment is not NULL, does not have the value VK_ATTACHMENT_UNUSED, and has a VkFormat with both depth and stencil components, and both VkPhysicalDeviceDepthStencilResolveProperties::independentResolve and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone are VK_FALSE, then the values of depthResolveMode and stencilResolveMode must be identical", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-pNext-06877", "If the pNext chain of VkSubpassDescription2 includes a VkMultisampledRenderToSingleSampledInfoEXT structure whose multisampledRenderToSingleSampledEnable field is VK_TRUE, pDepthStencilAttachment is not NULL, does not have the value VK_ATTACHMENT_UNUSED, and has a VkFormat with both depth and stencil components, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE, and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone is VK_TRUE, then the values of depthResolveMode and stencilResolveMode must be identical or one of them must be VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE", "1.3-extensions"},
    {"VUID-VkSubpassDescriptionDepthStencilResolve-stencilResolveMode-03184", "If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED and the VkFormat of pDepthStencilResolveAttachment has a stencil component, then the value of stencilResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedStencilResolveModes or VK_RESOLVE_MODE_NONE", "1.3-extensions"},
    {"VUID-VkSubpassEndInfo-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkSubpassFragmentDensityMapOffsetEndInfoQCOM", "1.3-extensions"},
    {"VUID-VkSubpassEndInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_END_INFO", "1.3-extensions"},
    {"VUID-VkSubpassEndInfo-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityMapAttachment-06504", "If VkSubpassDescription::fragmentDensityMapAttachment is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityMapOffsets-06503", "If the fragmentDensityMapOffsets feature is not enabled or fragment density map is not enabled in the render pass, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityOffsetCount-06510", "If fragmentDensityOffsetCount is not 0 and multiview is enabled for the render pass, fragmentDensityOffsetCount must equal the layerCount that was specified in creating the fragment density map attachment view.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityOffsetCount-06511", "If fragmentDensityOffsetCount is not 0 and multiview is not enabled for the render pass, fragmentDensityOffsetCount must equal 1.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pColorAttachments-06507", "If any element of VkSubpassDescription::pColorAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pDepthStencilAttachment-06505", "If VkSubpassDescription::pDepthStencilAttachment is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pFragmentDensityOffsets-parameter", "If fragmentDensityOffsetCount is not 0, pFragmentDensityOffsets must be a valid pointer to an array of fragmentDensityOffsetCount VkOffset2D structures", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pInputAttachments-06506", "If any element of VkSubpassDescription::pInputAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pPreserveAttachments-06509", "If any element of VkSubpassDescription::pPreserveAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pResolveAttachments-06508", "If any element of VkSubpassDescription::pResolveAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-x-06512", "The x component of each element of pFragmentDensityOffsets must be an integer multiple of fragmentDensityOffsetGranularity.width.", "1.3-extensions"},
    {"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-y-06513", "The y component of each element of pFragmentDensityOffsets must be an integer multiple of fragmentDensityOffsetGranularity.height.", "1.3-extensions"},
    {"VUID-VkSubpassResolvePerformanceQueryEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT", "1.3-extensions"},
    {"VUID-VkSubpassSampleLocationsEXT-sampleLocationsInfo-parameter", "sampleLocationsInfo must be a valid VkSampleLocationsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkSubpassSampleLocationsEXT-subpassIndex-01532", "subpassIndex must be less than the subpassCount specified in VkRenderPassCreateInfo the render pass specified by VkRenderPassBeginInfo::renderPass was created with", "1.3-extensions"},
    {"VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI", "1.3-extensions"},
    {"VUID-VkSubpassShadingPipelineCreateInfoHUAWEI-subpass-04946", "subpass must be created with VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI bind point", "1.3-extensions"},
    {"VUID-VkSubresourceLayout2EXT-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkImageCompressionPropertiesEXT", "1.3-extensions"},
    {"VUID-VkSubresourceLayout2EXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT", "1.3-extensions"},
    {"VUID-VkSubresourceLayout2EXT-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilities2EXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilities2EXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilities2EXT-supportedSurfaceCounters-01246", "supportedSurfaceCounters must not include VK_SURFACE_COUNTER_VBLANK_BIT_EXT unless the surface queried is a display surface", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilities2KHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDisplayNativeHdrSurfaceCapabilitiesAMD, VkSharedPresentSurfaceCapabilitiesKHR, VkSurfaceCapabilitiesFullScreenExclusiveEXT, VkSurfaceCapabilitiesPresentBarrierNV, or VkSurfaceProtectedCapabilitiesKHR", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilities2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilities2KHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilitiesFullScreenExclusiveEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT", "1.3-extensions"},
    {"VUID-VkSurfaceCapabilitiesPresentBarrierNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV", "1.3-extensions"},
    {"VUID-VkSurfaceFormat2KHR-pNext-06749", "The pNext chain must not include an VkImageCompressionPropertiesEXT structure", "default"},
    {"VUID-VkSurfaceFormat2KHR-pNext-06750", "If the imageCompressionControlSwapchain feature is not enabled, the pNext chain must not include an VkImageCompressionPropertiesEXT structure", "1.3-extensions"},
    {"VUID-VkSurfaceFormat2KHR-pNext-pNext", "pNext must be NULL or a pointer to a valid instance of VkImageCompressionPropertiesEXT", "1.3-extensions"},
    {"VUID-VkSurfaceFormat2KHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR", "1.3-extensions"},
    {"VUID-VkSurfaceFormat2KHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSurfaceFullScreenExclusiveInfoEXT-fullScreenExclusive-parameter", "fullScreenExclusive must be a valid VkFullScreenExclusiveEXT value", "1.3-extensions"},
    {"VUID-VkSurfaceFullScreenExclusiveInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-hmonitor-02673", "hmonitor must be a valid HMONITOR", "1.3-extensions"},
    {"VUID-VkSurfaceFullScreenExclusiveWin32InfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT", "1.3-extensions"},
    {"VUID-VkSurfaceProtectedCapabilitiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR", "1.3-extensions"},
    {"VUID-VkSwapchainCounterCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-01244", "The bits in surfaceCounters must be supported by VkSwapchainCreateInfoKHR::surface, as reported by vkGetPhysicalDeviceSurfaceCapabilities2EXT", "1.3-extensions"},
    {"VUID-VkSwapchainCounterCreateInfoEXT-surfaceCounters-parameter", "surfaceCounters must be a valid combination of VkSurfaceCounterFlagBitsEXT values", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-commonparent", "Both of oldSwapchain, and surface that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-compositeAlpha-01280", "compositeAlpha must be one of the bits present in the supportedCompositeAlpha member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-compositeAlpha-parameter", "compositeAlpha must be a valid VkCompositeAlphaFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-flags-03168", "If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the pNext chain must include a VkImageFormatListCreateInfo structure with a viewFormatCount greater than zero and pViewFormats must have an element equal to imageFormat", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-flags-03187", "If flags contains VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR, then VkSurfaceProtectedCapabilitiesKHR::supportsProtected must be VK_TRUE in the VkSurfaceProtectedCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-flags-04100", "If flags does not contain VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR and the pNext chain include a VkImageFormatListCreateInfo structure then VkImageFormatListCreateInfo::viewFormatCount must be 0 or 1", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-flags-parameter", "flags must be a valid combination of VkSwapchainCreateFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275", "imageArrayLayers must be greater than 0 and less than or equal to the maxImageArrayLayers member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageColorSpace-parameter", "imageColorSpace must be a valid VkColorSpaceKHR value", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageExtent-01274", "imageExtent must be between minImageExtent and maxImageExtent, inclusive, where minImageExtent and maxImageExtent are members of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageExtent-01689", "imageExtent members width and height must both be non-zero", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageFormat-01273", "imageFormat and imageColorSpace must match the format and colorSpace members, respectively, of one of the VkSurfaceFormatKHR structures returned by vkGetPhysicalDeviceSurfaceFormatsKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageFormat-01778", "The implied image creation parameters of the swapchain must be supported as reported by vkGetPhysicalDeviceImageFormatProperties", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageFormat-parameter", "imageFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277", "If imageSharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278", "If imageSharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01393", "If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the physicalDevice that was used to create device", "default"},
    {"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01428", "If imageSharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than pQueueFamilyPropertyCount returned by either vkGetPhysicalDeviceQueueFamilyProperties or vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-parameter", "imageSharingMode must be a valid VkSharingMode value", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageUsage-01276", "imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "default"},
    {"VUID-VkSwapchainCreateInfoKHR-imageUsage-01384", "If presentMode is VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, imageUsage must be a subset of the supported usage flags present in the sharedPresentSupportedUsageFlags member of the VkSharedPresentSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilities2KHR for surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageUsage-parameter", "imageUsage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-imageUsage-requiredbitmask", "imageUsage must not be 0", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-minImageCount-01271", "minImageCount must be greater than or equal to the value returned in the minImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "default"},
    {"VUID-VkSwapchainCreateInfoKHR-minImageCount-01272", "minImageCount must be less than or equal to the value returned in the maxImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface if the returned maxImageCount is not zero", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-minImageCount-01383", "minImageCount must be 1 if presentMode is either VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR or VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-oldSwapchain-01933", "If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a non-retired swapchain associated with native window referred to by surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parameter", "If oldSwapchain is not VK_NULL_HANDLE, oldSwapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-oldSwapchain-parent", "If oldSwapchain is a valid handle, it must have been created, allocated, or retrieved from surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-pNext-02679", "If the pNext chain includes a VkSurfaceFullScreenExclusiveInfoEXT structure with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, a VkSurfaceFullScreenExclusiveWin32InfoEXT structure must be included in the pNext chain", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-pNext-04099", "If a VkImageFormatListCreateInfo structure was included in the pNext chain and VkImageFormatListCreateInfo::viewFormatCount is not zero then all of the formats in VkImageFormatListCreateInfo::pViewFormats must be compatible with the format as described in the compatibility table", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-pNext-06751", "The pNext chain must not include an VkImageCompressionControlEXT structure", "default"},
    {"VUID-VkSwapchainCreateInfoKHR-pNext-06752", "If the imageCompressionControlSwapchain feature is not enabled, the pNext chain must not include an VkImageCompressionControlEXT structure", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceGroupSwapchainCreateInfoKHR, VkImageCompressionControlEXT, VkImageFormatListCreateInfo, VkSurfaceFullScreenExclusiveInfoEXT, VkSurfaceFullScreenExclusiveWin32InfoEXT, VkSwapchainCounterCreateInfoEXT, VkSwapchainDisplayNativeHdrCreateInfoAMD, or VkSwapchainPresentBarrierCreateInfoNV", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-physicalDeviceCount-01429", "If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-preTransform-01279", "preTransform must be one of the bits present in the supportedTransforms member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-preTransform-parameter", "preTransform must be a valid VkSurfaceTransformFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-presentMode-01281", "presentMode must be one of the VkPresentModeKHR values returned by vkGetPhysicalDeviceSurfacePresentModesKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-presentMode-01427", "If presentMode is VK_PRESENT_MODE_IMMEDIATE_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_FIFO_KHR or VK_PRESENT_MODE_FIFO_RELAXED_KHR, imageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-presentMode-02839", "If presentMode is not VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR nor VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, then minImageCount must be greater than or equal to the value returned in the minImageCount member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-presentMode-parameter", "presentMode must be a valid VkPresentModeKHR value", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-surface-01270", "surface must be a surface that is supported by the device as determined using vkGetPhysicalDeviceSurfaceSupportKHR", "1.3-extensions"},
    {"VUID-VkSwapchainCreateInfoKHR-surface-parameter", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-localDimmingEnable-04449", "It is only valid to set localDimmingEnable to VK_TRUE if VkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupport is supported", "1.3-extensions"},
    {"VUID-VkSwapchainDisplayNativeHdrCreateInfoAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD", "1.3-extensions"},
    {"VUID-VkSwapchainPresentBarrierCreateInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV", "1.3-extensions"},
    {"VUID-VkSysmemColorSpaceFUCHSIA-colorSpace-06402", "colorSpace must be a ColorSpaceType as defined in fuchsia.sysmem/image_formats.fidl", "1.3-extensions"},
    {"VUID-VkSysmemColorSpaceFUCHSIA-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkSysmemColorSpaceFUCHSIA-sType-sType", "sType must be VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA", "1.3-extensions"},
    {"VUID-VkTextureLODGatherFormatPropertiesAMD-sType-sType", "sType must be VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD", "1.3-extensions"},
    {"VUID-VkTilePropertiesQCOM-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkTilePropertiesQCOM-sType-sType", "sType must be VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM", "1.3-extensions"},
    {"VUID-VkTimelineSemaphoreSubmitInfo-pSignalSemaphoreValues-parameter", "If signalSemaphoreValueCount is not 0, and pSignalSemaphoreValues is not NULL, pSignalSemaphoreValues must be a valid pointer to an array of signalSemaphoreValueCount uint64_t values", "1.3-extensions"},
    {"VUID-VkTimelineSemaphoreSubmitInfo-pWaitSemaphoreValues-parameter", "If waitSemaphoreValueCount is not 0, and pWaitSemaphoreValues is not NULL, pWaitSemaphoreValues must be a valid pointer to an array of waitSemaphoreValueCount uint64_t values", "1.3-extensions"},
    {"VUID-VkTimelineSemaphoreSubmitInfo-sType-sType", "sType must be VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-depth-03640", "depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-flags-03511", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, the shader group handle identified by pname:missShaderBindingTableAddress must not be set to zero", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-flags-03512", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, entries in the table identified by pname:hitShaderBindingTableAddress accessed as a result of this command in order to execute an any-hit shader must not be set to zero", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-flags-03513", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, entries in the table identified by pname:hitShaderBindingTableAddress accessed as a result of this command in order to execute a closest hit shader must not be set to zero", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-flags-03514", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, entries in the table identified by pname:hitShaderBindingTableAddress accessed as a result of this command in order to execute an intersection shader must not be set to zero", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-flags-03696", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, pname:hitShaderBindingTableAddress must not be zero", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-flags-03697", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, pname:hitShaderBindingTableAddress must not be zero", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-height-03639", "height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pCallableShaderBindingTable-03691", "If the buffer from which pname:callableShaderBindingTableAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pCallableShaderBindingTable-03692", "The buffer from which the pname:callableShaderBindingTableAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pCallableShaderBindingTable-03693", "pname:callableShaderBindingTableAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pHitShaderBindingTable-03687", "If the buffer from which pname:hitShaderBindingTableAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pHitShaderBindingTable-03688", "The buffer from which the pname:hitShaderBindingTableAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pHitShaderBindingTable-03689", "pname:hitShaderBindingTableAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pHitShaderBindingTable-04735", "Any non-zero hit shader group entries in the table identified by pname:hitShaderBindingTableAddress accessed by this call from a geometry with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR must have been created with VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pHitShaderBindingTable-04736", "Any non-zero hit shader group entries in the table identified by pname:hitShaderBindingTableAddress accessed by this call from a geometry with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR must have been created with VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pMissShaderBindingTable-03683", "If the buffer from which pname:missShaderBindingTableAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pMissShaderBindingTable-03684", "The buffer from which the pname:missShaderBindingTableAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pMissShaderBindingTable-03685", "pname:missShaderBindingTableAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pRayGenShaderBindingTable-03680", "If the buffer from which pname:raygenShaderRecordAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pRayGenShaderBindingTable-03681", "The buffer from which the pname:raygenShaderRecordAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-pRayGenShaderBindingTable-03682", "pname:raygenShaderRecordAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-stride-03686", "pname:missShaderBindingTableStride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-stride-03690", "pname:hitShaderBindingTableStride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-stride-03694", "pname:callableShaderBindingTableStride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-stride-04029", "pname:missShaderBindingTableStride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-stride-04035", "pname:hitShaderBindingTableStride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-stride-04041", "pname:callableShaderBindingTableStride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-width-03638", "width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommand2KHR-width-03641", "width {times} height {times} depth must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayDispatchInvocationCount", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommandKHR-depth-03640", "depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommandKHR-height-03639", "height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommandKHR-width-03638", "width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]", "1.3-extensions"},
    {"VUID-VkTraceRaysIndirectCommandKHR-width-03641", "width {times} height {times} depth must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayDispatchInvocationCount", "1.3-extensions"},
    {"VUID-VkTransformMatrixKHR-matrix-03799", "The first three columns of matrix must define an invertible 3x3 matrix", "1.3-extensions"},
    {"VUID-VkValidationCacheCreateInfoEXT-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkValidationCacheCreateInfoEXT-initialDataSize-01534", "If initialDataSize is not 0, it must be equal to the size of pInitialData, as returned by vkGetValidationCacheDataEXT when pInitialData was originally retrieved", "1.3-extensions"},
    {"VUID-VkValidationCacheCreateInfoEXT-initialDataSize-01535", "If initialDataSize is not 0, pInitialData must have been retrieved from a previous call to vkGetValidationCacheDataEXT", "1.3-extensions"},
    {"VUID-VkValidationCacheCreateInfoEXT-pInitialData-parameter", "If initialDataSize is not 0, pInitialData must be a valid pointer to an array of initialDataSize bytes", "1.3-extensions"},
    {"VUID-VkValidationCacheCreateInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkValidationCacheCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkValidationFeaturesEXT-pDisabledValidationFeatures-parameter", "If disabledValidationFeatureCount is not 0, pDisabledValidationFeatures must be a valid pointer to an array of disabledValidationFeatureCount valid VkValidationFeatureDisableEXT values", "1.3-extensions"},
    {"VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-02967", "If the pEnabledValidationFeatures array contains VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT, then it must also contain VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT", "1.3-extensions"},
    {"VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-02968", "If the pEnabledValidationFeatures array contains VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT, then it must not contain VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT", "1.3-extensions"},
    {"VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-parameter", "If enabledValidationFeatureCount is not 0, pEnabledValidationFeatures must be a valid pointer to an array of enabledValidationFeatureCount valid VkValidationFeatureEnableEXT values", "1.3-extensions"},
    {"VUID-VkValidationFeaturesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT", "1.3-extensions"},
    {"VUID-VkValidationFlagsEXT-disabledValidationCheckCount-arraylength", "disabledValidationCheckCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkValidationFlagsEXT-pDisabledValidationChecks-parameter", "pDisabledValidationChecks must be a valid pointer to an array of disabledValidationCheckCount valid VkValidationCheckEXT values", "1.3-extensions"},
    {"VUID-VkValidationFlagsEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription-binding-00621", "binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription-format-00623", "format must be allowed as a vertex buffer format, as specified by the VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription-location-00620", "location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription-offset-00622", "offset must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributeOffset", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription-vertexAttributeAccessBeyondStride-04457", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::vertexAttributeAccessBeyondStride is VK_FALSE, the sum of offset plus the size of the vertex attribute data described by format must not be greater than stride in the VkVertexInputBindingDescription referenced in binding", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-binding-06229", "binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-format-04805", "format must be allowed as a vertex buffer format, as specified by the VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT flag in VkFormatProperties::bufferFeatures returned by vkGetPhysicalDeviceFormatProperties", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-location-06228", "location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-offset-06230", "offset must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributeOffset", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT", "1.3-extensions"},
    {"VUID-VkVertexInputAttributeDescription2EXT-vertexAttributeAccessBeyondStride-04806", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::vertexAttributeAccessBeyondStride is VK_FALSE, the sum of offset plus the size of the vertex attribute data described by format must not be greater than stride in the VkVertexInputBindingDescription2EXT referenced in binding", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription-binding-00618", "binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription-inputRate-parameter", "inputRate must be a valid VkVertexInputRate value", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription-stride-00619", "stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription-stride-04456", "If the VK_KHR_portability_subset extension is enabled, stride must be a multiple of, and at least as large as, VkPhysicalDevicePortabilitySubsetPropertiesKHR::minVertexInputBindingStrideAlignment", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-binding-04796", "binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-divisor-04798", "If the vertexAttributeInstanceRateZeroDivisor feature is not enabled, divisor must not be 0", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-divisor-04799", "If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-divisor-06226", "divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor, inclusive", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-divisor-06227", "If divisor is not 1 then inputRate must be of type VK_VERTEX_INPUT_RATE_INSTANCE", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-inputRate-parameter", "inputRate must be a valid VkVertexInputRate value", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDescription2EXT-stride-04797", "stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDivisorDescriptionEXT-binding-01869", "binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDivisorDescriptionEXT-divisor-01870", "divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor, inclusive", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDivisorDescriptionEXT-inputRate-01871", "VkVertexInputBindingDescription::inputRate must be of type VK_VERTEX_INPUT_RATE_INSTANCE for this binding", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDivisorDescriptionEXT-vertexAttributeInstanceRateDivisor-02229", "If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1", "1.3-extensions"},
    {"VUID-VkVertexInputBindingDivisorDescriptionEXT-vertexAttributeInstanceRateZeroDivisor-02228", "If the vertexAttributeInstanceRateZeroDivisor feature is not enabled, divisor must not be 0", "1.3-extensions"},
    {"VUID-VkViSurfaceCreateInfoNN-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkViSurfaceCreateInfoNN-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkViSurfaceCreateInfoNN-sType-sType", "sType must be VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN", "1.3-extensions"},
    {"VUID-VkViSurfaceCreateInfoNN-window-01318", "window must be a valid nn::vi::NativeWindowHandle", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-commonparent", "Both of videoSession, and videoSessionParameters that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-pReferenceSlots-parameter", "If referenceSlotCount is not 0, pReferenceSlots must be a valid pointer to an array of referenceSlotCount valid VkVideoReferenceSlotInfoKHR structures", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-referenceSlotCount-04856", "VkVideoBeginCodingInfoKHR::referenceSlotCount must not exceed the value specified in VkVideoSessionCreateInfoKHR::maxDpbSlots when creating the video session object that is being provided in videoSession", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-videoSession-parameter", "videoSession must be a valid VkVideoSessionKHR handle", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-videoSessionParameters-04857", "If videoSessionParameters is not VK_NULL_HANDLE, it must have been created using videoSession as a parent object", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-videoSessionParameters-parameter", "If videoSessionParameters is not VK_NULL_HANDLE, videoSessionParameters must be a valid VkVideoSessionParametersKHR handle", "1.3-extensions"},
    {"VUID-VkVideoBeginCodingInfoKHR-videoSessionParameters-parent", "If videoSessionParameters is a valid handle, it must have been created, allocated, or retrieved from videoSession", "1.3-extensions"},
    {"VUID-VkVideoCapabilitiesKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoDecodeCapabilitiesKHR, VkVideoDecodeH264CapabilitiesEXT, VkVideoDecodeH265CapabilitiesEXT, VkVideoEncodeCapabilitiesKHR, VkVideoEncodeH264CapabilitiesEXT, or VkVideoEncodeH265CapabilitiesEXT", "1.3-extensions"},
    {"VUID-VkVideoCapabilitiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR", "1.3-extensions"},
    {"VUID-VkVideoCapabilitiesKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07016", "flags must include at least one bit", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07017", "If the bound video session object is in uninitialized state, then flags must include VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07018", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, then the pNext chain must include a valid VkVideoEncodeRateControlInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07019", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR, then the pNext chain must include a valid VkVideoEncodeRateControlLayerInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07020", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, then it must not also include VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07021", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, the rateControlMode member of VkVideoEncodeRateControlInfoKHR included in the pNext chain is not VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR, and the bound video session was created with VkVideoProfileInfoKHR::videoCodecOperation set to VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, then the pNext chain must include a VkVideoEncodeH264RateControlInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07023", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR and the bound video session was created with VkVideoProfileInfoKHR::videoCodecOperation set to VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT, then the pNext chain must include a VkVideoEncodeH264RateControlLayerInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07024", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, the rateControlMode member of VkVideoEncodeRateControlInfoKHR included in the pNext chain is not VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR, and the bound video session was created with VkVideoProfileInfoKHR::videoCodecOperation set to VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT, then the pNext chain must include a VkVideoEncodeH265RateControlInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-07026", "If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR and the bound video session was created with VkVideoProfileInfoKHR::videoCodecOperation set to VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT, then the pNext chain must include a VkVideoEncodeH265RateControlLayerInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-parameter", "flags must be a valid combination of VkVideoCodingControlFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-flags-requiredbitmask", "flags must not be 0", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-pNext-07022", "If the pNext chain includes a VkVideoEncodeRateControlInfoKHR, and VkVideoEncodeRateControlInfoKHR::layerCount is greater than 1, then VkVideoEncodeH264RateControlInfoEXT::temporalLayerCount must be equal to layerCount", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-pNext-07025", "If the pNext chain includes a VkVideoEncodeRateControlInfoKHR, and VkVideoEncodeRateControlInfoKHR::layerCount is greater than 1, then VkVideoEncodeH265RateControlInfoEXT::subLayerCount must be equal to layerCount", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoEncodeH264RateControlInfoEXT, VkVideoEncodeH264RateControlLayerInfoEXT, VkVideoEncodeH265RateControlInfoEXT, VkVideoEncodeH265RateControlLayerInfoEXT, VkVideoEncodeRateControlInfoKHR, or VkVideoEncodeRateControlLayerInfoKHR", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoCodingControlInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkVideoDecodeCapabilitiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264CapabilitiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264DpbSlotInfoEXT-pStdReferenceInfo-parameter", "pStdReferenceInfo must be a valid pointer to a valid StdVideoDecodeH264ReferenceInfo value", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264DpbSlotInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264PictureInfoEXT-pSliceOffsets-parameter", "pSliceOffsets must be a valid pointer to an array of sliceCount uint32_t values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264PictureInfoEXT-pStdPictureInfo-parameter", "pStdPictureInfo must be a valid pointer to a valid StdVideoDecodeH264PictureInfo value", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264PictureInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264PictureInfoEXT-sliceCount-arraylength", "sliceCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264ProfileInfoEXT-pNext-06259", "If the VkVideoDecodeH264ProfileInfoEXT structure is included in the pNext chain of the VkVideoCapabilitiesKHR structure passed to vkGetPhysicalDeviceVideoCapabilitiesKHR, the value in pictureLayout is treated as a bitmask of requested picture layouts. It is always valid to use the value VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT as the implementation is guaranteed to support decoding of progressive content.", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264ProfileInfoEXT-pNext-06260", "If the VkVideoDecodeH264ProfileInfoEXT structure is included in the pNext chain of the VkVideoSessionCreateInfoKHR structure passed to vkCreateVideoSessionKHR, the value in pictureLayout must be exactly one of VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT, VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT or VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT.", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264ProfileInfoEXT-pictureLayout-parameter", "If pictureLayout is not 0, pictureLayout must be a valid VkVideoDecodeH264PictureLayoutFlagBitsEXT value", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264ProfileInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-None-04825", "Each entry to be added must have a unique, to the rest of the parameter array entries and the existing parameters in the Video Session Parameters Object that is being updated, SPS-PPS IDs", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-None-04826", "Parameter entries that already exist in Video Session Parameters object with a particular SPS-PPS IDs cannot be replaced nor updated", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-None-04827", "When creating a new object using a Video Session Parameters as a template, the array's parameters with the same SPS-PPS IDs as the ones from the template take precedence", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-None-04828", "SPS/PPS parameters must comply with the limits specified in VkVideoSessionCreateInfoKHR during Video Session creation", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-maxStdPPSCount-04824", "When the maxStdPPSCount number of parameters of type StdVideoH264PictureParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to this object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-maxStdSPSCount-04823", "When the maxStdSPSCount number of parameters of type StdVideoH264SequenceParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to this object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-pStdPPSs-parameter", "If stdPPSCount is not 0, pStdPPSs must be a valid pointer to an array of stdPPSCount StdVideoH264PictureParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-pStdSPSs-parameter", "If stdSPSCount is not 0, pStdSPSs must be a valid pointer to an array of stdSPSCount StdVideoH264SequenceParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersAddInfoEXT-stdSPSCount-04822", "The values of stdSPSCount and stdPPSCount must be less than or equal to the values of maxStdSPSCount and maxStdPPSCount, respectively", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersCreateInfoEXT-pParametersAddInfo-parameter", "If pParametersAddInfo is not NULL, pParametersAddInfo must be a valid pointer to a valid VkVideoDecodeH264SessionParametersAddInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoDecodeH264SessionParametersCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265CapabilitiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265DpbSlotInfoEXT-pStdReferenceInfo-parameter", "pStdReferenceInfo must be a valid pointer to a valid StdVideoDecodeH265ReferenceInfo value", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265DpbSlotInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265PictureInfoEXT-pSliceOffsets-parameter", "pSliceOffsets must be a valid pointer to an array of sliceCount uint32_t values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265PictureInfoEXT-pStdPictureInfo-parameter", "pStdPictureInfo must be a valid pointer to a StdVideoDecodeH265PictureInfo value", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265PictureInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265PictureInfoEXT-sliceCount-arraylength", "sliceCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265ProfileInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-None-04833", "Each entry to be added must have a unique, to the rest of the parameter array entries and the existing parameters in the Video Session Parameters Object that is being updated, VPS-SPS-PPS IDs", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-None-04834", "Parameter entries that already exist in Video Session Parameters object with a particular VPS-SPS-PPS IDs cannot be replaced nor updated", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-None-04835", "When creating a new object using a Video Session Parameters as a template, the array's parameters with the same VPS-SPS-PPS IDs as the ones from the template take precedence", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-None-04836", "VPS/SPS/PPS parameters must comply with the limits specified in VkVideoSessionCreateInfoKHR during Video Session creation", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-maxStdPPSCount-04832", "When the maxStdPPSCount number of parameters of type StdVideoH265PictureParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-maxStdSPSCount-04831", "When the maxStdSPSCount number of parameters of type StdVideoH265SequenceParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-maxStdVPSCount-04830", "When the maxStdVPSCount number of parameters of type StdVideoH265VideoParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-pStdPPSs-parameter", "If stdPPSCount is not 0, pStdPPSs must be a valid pointer to an array of stdPPSCount StdVideoH265PictureParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-pStdSPSs-parameter", "If stdSPSCount is not 0, pStdSPSs must be a valid pointer to an array of stdSPSCount StdVideoH265SequenceParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-pStdVPSs-parameter", "If stdVPSCount is not 0, pStdVPSs must be a valid pointer to an array of stdVPSCount StdVideoH265VideoParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersAddInfoEXT-stdVPSCount-04829", "The values of stdVPSCount, stdSPSCount and stdPPSCount must be less than or equal to the values of maxStdVPSCount, maxStdSPSCount and maxStdPPSCount, respectively", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersCreateInfoEXT-pParametersAddInfo-parameter", "If pParametersAddInfo is not NULL, pParametersAddInfo must be a valid pointer to a valid VkVideoDecodeH265SessionParametersAddInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoDecodeH265SessionParametersCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-dstPictureResource-parameter", "dstPictureResource must be a valid VkVideoPictureResourceInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoDecodeH264PictureInfoEXT or VkVideoDecodeH265PictureInfoEXT", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-pReferenceSlots-parameter", "If referenceSlotCount is not 0, pReferenceSlots must be a valid pointer to an array of referenceSlotCount valid VkVideoReferenceSlotInfoKHR structures", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-parameter", "If pSetupReferenceSlot is not NULL, pSetupReferenceSlot must be a valid pointer to a valid VkVideoReferenceSlotInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkVideoDecodeInfoKHR-srcBuffer-parameter", "srcBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkVideoDecodeUsageInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoDecodeUsageInfoKHR-videoUsageHints-parameter", "videoUsageHints must be a valid combination of VkVideoDecodeUsageFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoEncodeCapabilitiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264CapabilitiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264DpbSlotInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264DpbSlotInfoEXT-pStdReferenceInfo-parameter", "pStdReferenceInfo must be a valid pointer to a valid StdVideoEncodeH264ReferenceInfo value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264DpbSlotInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264EmitPictureParametersInfoEXT-ppsIdEntries-parameter", "ppsIdEntries must be a valid pointer to an array of ppsIdEntryCount uint8_t values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264EmitPictureParametersInfoEXT-ppsIdEntryCount-arraylength", "ppsIdEntryCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264EmitPictureParametersInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264NaluSliceInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264NaluSliceInfoEXT-pReferenceFinalLists-parameter", "If pReferenceFinalLists is not NULL, pReferenceFinalLists must be a valid pointer to a valid VkVideoEncodeH264ReferenceListsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264NaluSliceInfoEXT-pSliceHeaderStd-parameter", "pSliceHeaderStd must be a valid pointer to a valid StdVideoEncodeH264SliceHeader value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264NaluSliceInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264ProfileInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlInfoEXT-rateControlStructure-parameter", "rateControlStructure must be a valid VkVideoEncodeH264RateControlStructureEXT value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-initialRcQp-parameter", "initialRcQp must be a valid VkVideoEncodeH264QpEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-maxFrameSize-parameter", "maxFrameSize must be a valid VkVideoEncodeH264FrameSizeEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-maxQp-parameter", "maxQp must be a valid VkVideoEncodeH264QpEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-minQp-parameter", "minQp must be a valid VkVideoEncodeH264QpEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-rateControlMode-06474", "When VkVideoEncodeRateControlInfoKHR::rateControlMode is VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR, both useMinQp and useMaxQp must be set to VK_TRUE.", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-rateControlMode-06475", "When VkVideoEncodeRateControlInfoKHR::rateControlMode is VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR, the values provided in minQP must be identical to those provided in maxQp.", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264RateControlLayerInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264ReferenceListsInfoEXT-pMemMgmtCtrlOperations-parameter", "pMemMgmtCtrlOperations must be a valid pointer to a valid StdVideoEncodeH264RefMemMgmtCtrlOperations value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264ReferenceListsInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264ReferenceListsInfoEXT-pReferenceList0Entries-parameter", "If referenceList0EntryCount is not 0, pReferenceList0Entries must be a valid pointer to an array of referenceList0EntryCount valid VkVideoEncodeH264DpbSlotInfoEXT structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264ReferenceListsInfoEXT-pReferenceList1Entries-parameter", "If referenceList1EntryCount is not 0, pReferenceList1Entries must be a valid pointer to an array of referenceList1EntryCount valid VkVideoEncodeH264DpbSlotInfoEXT structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264ReferenceListsInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_REFERENCE_LISTS_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-None-04840", "Each entry to be added must have a unique, to the rest of the parameter array entries and the existing parameters in the Video Session Parameters Object that is being updated, SPS-PPS IDs", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-None-04841", "Parameter entries that already exist in Video Session Parameters object with a particular SPS-PPS IDs cannot be replaced nor updated", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-None-04842", "When creating a new object using a Video Session Parameters as a template, the array's parameters with the same SPS-PPS IDs as the ones from the template take precedence", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-None-04843", "SPS/PPS parameters must comply with the limits specified in VkVideoSessionCreateInfoKHR during Video Session creation", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-maxStdPPSCount-04839", "When the maxStdPPSCount number of parameters of type StdVideoH264PictureParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-maxStdSPSCount-04838", "When the maxStdSPSCount number of parameters of type StdVideoH264SequenceParameterSet in the Video Session Parameters object is reached, no additional parameters of that type can be added to the object. VK_ERROR_TOO_MANY_OBJECTS will be returned if an attempt is made to add additional data to this object at this point", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-pStdPPSs-parameter", "If pStdPPSs is not NULL, pStdPPSs must be a valid pointer to an array of stdPPSCount StdVideoH264PictureParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-pStdSPSs-parameter", "If pStdSPSs is not NULL, pStdSPSs must be a valid pointer to an array of stdSPSCount StdVideoH264SequenceParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdPPSCount-arraylength", "stdPPSCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdSPSCount-04837", "The values of stdSPSCount and stdPPSCount must be less than or equal to the values of maxStdSPSCount and maxStdPPSCount, respectively", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersAddInfoEXT-stdSPSCount-arraylength", "stdSPSCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersCreateInfoEXT-pParametersAddInfo-parameter", "If pParametersAddInfo is not NULL, pParametersAddInfo must be a valid pointer to a valid VkVideoEncodeH264SessionParametersAddInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264SessionParametersCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264VclFrameInfoEXT-naluSliceEntryCount-arraylength", "naluSliceEntryCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264VclFrameInfoEXT-pCurrentPictureInfo-parameter", "pCurrentPictureInfo must be a valid pointer to a valid StdVideoEncodeH264PictureInfo value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264VclFrameInfoEXT-pNaluSliceEntries-parameter", "pNaluSliceEntries must be a valid pointer to an array of naluSliceEntryCount valid VkVideoEncodeH264NaluSliceInfoEXT structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264VclFrameInfoEXT-pReferenceFinalLists-parameter", "If pReferenceFinalLists is not NULL, pReferenceFinalLists must be a valid pointer to a valid VkVideoEncodeH264ReferenceListsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH264VclFrameInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265CapabilitiesEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265DpbSlotInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265DpbSlotInfoEXT-pStdReferenceInfo-parameter", "pStdReferenceInfo must be a valid pointer to a valid StdVideoEncodeH265ReferenceInfo value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265DpbSlotInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265EmitPictureParametersInfoEXT-ppsIdEntries-parameter", "If ppsIdEntryCount is not 0, ppsIdEntries must be a valid pointer to an array of ppsIdEntryCount uint8_t values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265EmitPictureParametersInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265NaluSliceSegmentInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265NaluSliceSegmentInfoEXT-pReferenceFinalLists-parameter", "If pReferenceFinalLists is not NULL, pReferenceFinalLists must be a valid pointer to a valid VkVideoEncodeH265ReferenceListsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265NaluSliceSegmentInfoEXT-pSliceSegmentHeaderStd-parameter", "pSliceSegmentHeaderStd must be a valid pointer to a valid StdVideoEncodeH265SliceSegmentHeader value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265NaluSliceSegmentInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265ProfileInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlInfoEXT-rateControlStructure-parameter", "rateControlStructure must be a valid VkVideoEncodeH265RateControlStructureEXT value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-initialRcQp-parameter", "initialRcQp must be a valid VkVideoEncodeH265QpEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-maxFrameSize-parameter", "maxFrameSize must be a valid VkVideoEncodeH265FrameSizeEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-maxQp-parameter", "maxQp must be a valid VkVideoEncodeH265QpEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-minQp-parameter", "minQp must be a valid VkVideoEncodeH265QpEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-rateControlMode-06476", "When VkVideoEncodeRateControlInfoKHR::rateControlMode is VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR, both useMinQp and useMaxQp must be set to VK_TRUE.", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-rateControlMode-06477", "When VkVideoEncodeRateControlInfoKHR::rateControlMode is VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR, the values provided in minQP must be identical to those provided in maxQp.", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265RateControlLayerInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265ReferenceListsInfoEXT-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265ReferenceListsInfoEXT-pReferenceList0Entries-parameter", "If referenceList0EntryCount is not 0, pReferenceList0Entries must be a valid pointer to an array of referenceList0EntryCount valid VkVideoEncodeH265DpbSlotInfoEXT structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265ReferenceListsInfoEXT-pReferenceList1Entries-parameter", "If referenceList1EntryCount is not 0, pReferenceList1Entries must be a valid pointer to an array of referenceList1EntryCount valid VkVideoEncodeH265DpbSlotInfoEXT structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265ReferenceListsInfoEXT-pReferenceModifications-parameter", "pReferenceModifications must be a valid pointer to a valid StdVideoEncodeH265ReferenceModifications value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265ReferenceListsInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-None-06442", "Each entry to be added must have a unique, to the rest of the parameter array entries and the existing parameters in the Video Session Parameters Object that is being updated, VPS-SPS-PPS IDs", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-None-06443", "Parameter entries that already exist in Video Session Parameters object with a particular VPS-SPS-PPS IDs must not be replaced nor updated", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-None-06444", "When creating a new object using a Video Session Parameters as a template, the array's parameters with the same VPS-SPS-PPS IDs as the ones from the template take precedence", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-None-06445", "VPS/SPS/PPS parameters must comply with the limits specified in VkVideoSessionCreateInfoKHR during Video Session creation", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdPPSs-06441", "Each StdVideoH265PictureParameterSet entry in pStdPPSs must have a unique H.265 VPS-SPS-PPS ID tuple", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdPPSs-parameter", "If pStdPPSs is not NULL, pStdPPSs must be a valid pointer to an array of stdPPSCount StdVideoH265PictureParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdSPSs-06440", "Each StdVideoH265SequenceParameterSet entry in pStdSPSs must have a unique H.265 VPS-SPS ID pair", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdSPSs-parameter", "If pStdSPSs is not NULL, pStdSPSs must be a valid pointer to an array of stdSPSCount StdVideoH265SequenceParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdVPSs-06439", "Each StdVideoH265VideoParameterSet entry in pStdVPSs must have a unique H.265 VPS ID", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-pStdVPSs-parameter", "If pStdVPSs is not NULL, pStdVPSs must be a valid pointer to an array of stdVPSCount StdVideoH265VideoParameterSet values", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdPPSCount-arraylength", "stdPPSCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdSPSCount-arraylength", "stdSPSCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdVPSCount-06438", "The values of stdVPSCount, stdSPSCount and stdPPSCount must be less than or equal to the values of VkVideoEncodeH265SessionParametersCreateInfoEXT::maxStdVPSCount, VkVideoEncodeH265SessionParametersCreateInfoEXT:maxStdSPSCount, and VkVideoEncodeH265SessionParametersCreateInfoEXT:maxStdPPSCount, respectively", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersAddInfoEXT-stdVPSCount-arraylength", "stdVPSCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersCreateInfoEXT-pParametersAddInfo-parameter", "If pParametersAddInfo is not NULL, pParametersAddInfo must be a valid pointer to a valid VkVideoEncodeH265SessionParametersAddInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265SessionParametersCreateInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265VclFrameInfoEXT-naluSliceSegmentEntryCount-arraylength", "naluSliceSegmentEntryCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265VclFrameInfoEXT-pCurrentPictureInfo-parameter", "pCurrentPictureInfo must be a valid pointer to a valid StdVideoEncodeH265PictureInfo value", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265VclFrameInfoEXT-pNaluSliceSegmentEntries-parameter", "pNaluSliceSegmentEntries must be a valid pointer to an array of naluSliceSegmentEntryCount valid VkVideoEncodeH265NaluSliceSegmentInfoEXT structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265VclFrameInfoEXT-pReferenceFinalLists-parameter", "If pReferenceFinalLists is not NULL, pReferenceFinalLists must be a valid pointer to a valid VkVideoEncodeH265ReferenceListsInfoEXT structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeH265VclFrameInfoEXT-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-None-07012", "The bound video session object must not be in uninitialized state", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-dstBitstreamBuffer-parameter", "dstBitstreamBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoEncodeH264EmitPictureParametersInfoEXT, VkVideoEncodeH264VclFrameInfoEXT, VkVideoEncodeH265EmitPictureParametersInfoEXT, or VkVideoEncodeH265VclFrameInfoEXT", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-pReferenceSlots-parameter", "If referenceSlotCount is not 0, pReferenceSlots must be a valid pointer to an array of referenceSlotCount valid VkVideoReferenceSlotInfoKHR structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-parameter", "If pSetupReferenceSlot is not NULL, pSetupReferenceSlot must be a valid pointer to a valid VkVideoReferenceSlotInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkVideoEncodeInfoKHR-srcPictureResource-parameter", "srcPictureResource must be a valid VkVideoPictureResourceInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoEncodeRateControlInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-arraylength", "layerCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkVideoEncodeRateControlInfoKHR-pLayerConfigs-parameter", "pLayerConfigs must be a valid pointer to an array of layerCount valid VkVideoEncodeRateControlLayerInfoKHR structures", "1.3-extensions"},
    {"VUID-VkVideoEncodeRateControlInfoKHR-rateControlMode-parameter", "rateControlMode must be a valid VkVideoEncodeRateControlModeFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkVideoEncodeRateControlInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoEncodeRateControlLayerInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoEncodeUsageInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoEncodeUsageInfoKHR-tuningMode-parameter", "If tuningMode is not 0, tuningMode must be a valid VkVideoEncodeTuningModeKHR value", "1.3-extensions"},
    {"VUID-VkVideoEncodeUsageInfoKHR-videoContentHints-parameter", "videoContentHints must be a valid combination of VkVideoEncodeContentFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoEncodeUsageInfoKHR-videoUsageHints-parameter", "videoUsageHints must be a valid combination of VkVideoEncodeUsageFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoEndCodingInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkVideoEndCodingInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoEndCodingInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoFormatPropertiesKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoFormatPropertiesKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR", "1.3-extensions"},
    {"VUID-VkVideoPictureResourceInfoKHR-imageViewBinding-parameter", "imageViewBinding must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-VkVideoPictureResourceInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoPictureResourceInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-chromaBitDepth-parameter", "chromaBitDepth must be a valid combination of VkVideoComponentBitDepthFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-chromaSubsampling-07013", "chromaSubsampling must have a single bit set", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-chromaSubsampling-07015", "If chromaSubsampling is not VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR, then chromaBitDepth must have a single bit set", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-chromaSubsampling-parameter", "chromaSubsampling must be a valid combination of VkVideoChromaSubsamplingFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-chromaSubsampling-requiredbitmask", "chromaSubsampling must not be 0", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-lumaBitDepth-07014", "lumaBitDepth must have a single bit set", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-lumaBitDepth-parameter", "lumaBitDepth must be a valid combination of VkVideoComponentBitDepthFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-lumaBitDepth-requiredbitmask", "lumaBitDepth must not be 0", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoProfileInfoKHR-videoCodecOperation-parameter", "videoCodecOperation must be a valid VkVideoCodecOperationFlagBitsKHR value", "1.3-extensions"},
    {"VUID-VkVideoProfileListInfoKHR-pProfiles-06813", "If the pProfiles list contains more than one VkVideoProfileInfoKHR entry, then it must not contain more than one entry whose videoCodecOperation member specifies a decode operation", "1.3-extensions"},
    {"VUID-VkVideoProfileListInfoKHR-pProfiles-parameter", "If profileCount is not 0, pProfiles must be a valid pointer to an array of profileCount valid VkVideoProfileInfoKHR structures", "1.3-extensions"},
    {"VUID-VkVideoProfileListInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoReferenceSlotInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoDecodeH264DpbSlotInfoEXT or VkVideoDecodeH265DpbSlotInfoEXT", "1.3-extensions"},
    {"VUID-VkVideoReferenceSlotInfoKHR-pPictureResource-parameter", "If pPictureResource is not NULL, pPictureResource must be a valid pointer to a valid VkVideoPictureResourceInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoReferenceSlotInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoReferenceSlotInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-flags-parameter", "flags must be a valid combination of VkVideoSessionCreateFlagBitsKHR values", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-maxActiveReferencePictures-04848", "If Reference Pictures are required for use with the created video session, the maxActiveReferencePictures must be set to a value bigger than 0", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-maxActiveReferencePictures-04849", "maxActiveReferencePictures cannot exceed the implementation reported VkVideoCapabilitiesKHR::maxActiveReferencePictures", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-maxActiveReferencePictures-04850", "maxActiveReferencePictures cannot exceed the maxDpbSlots", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-maxCodedExtent-04851", "maxCodedExtent cannot be smaller than VkVideoCapabilitiesKHR::minExtent and bigger than VkVideoCapabilitiesKHR::maxExtent", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-maxDpbSlots-04846", "If Reference Pictures are required for use with the created video session, the maxDpbSlots must be set to a value bigger than 0", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-maxDpbSlots-04847", "maxDpbSlots cannot exceed the implementation reported VkVideoCapabilitiesKHR::maxDpbSlots", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-parameter", "pStdHeaderVersion must be a valid pointer to a valid VkExtensionProperties structure", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-04845", "pVideoProfile must be a pointer to a valid VkVideoProfileInfoKHR structure whose pNext chain must include a valid codec-specific profile structure", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-parameter", "pVideoProfile must be a valid pointer to a valid VkVideoProfileInfoKHR structure", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pictureFormat-04853", "If the videoCodecOperation member of pVideoProfile specifies a decode operation then pictureFormat must be one of the supported decode output formats as reported by vkGetPhysicalDeviceVideoFormatPropertiesKHR in the format member of VkVideoFormatPropertiesKHR when called with the imageUsage member of its pVideoFormatInfo parameter containing VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, and with a VkVideoProfileListInfoKHR structure chained to its pVideoFormatInfo parameter whose pProfiles member contains an entry matching pVideoProfile", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pictureFormat-04854", "If the videoCodecOperation member of pVideoProfile specifies an encode operation then pictureFormat must be one of the supported encode input formats as reported by vkGetPhysicalDeviceVideoFormatPropertiesKHR in the format member of VkVideoFormatPropertiesKHR when called with the imageUsage member of its pVideoFormatInfo parameter containing VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, and with a VkVideoProfileListInfoKHR structure chained to its pVideoFormatInfo parameter whose pProfiles member contains an entry matching pVideoProfile", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-pictureFormat-parameter", "pictureFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-parameter", "referencePictureFormat must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-referencePicturesFormat-04852", "If the videoCodecOperation member of pVideoProfile specifies a decode operation then referencePicturesFormat must be one of the supported decode DPB formats as reported by vkGetPhysicalDeviceVideoFormatPropertiesKHR in the format member of VkVideoFormatPropertiesKHR when called with the imageUsage member of its pVideoFormatInfo parameter containing VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, and with a VkVideoProfileListInfoKHR structure chained to its pVideoFormatInfo parameter whose pProfiles member contains an entry matching pVideoProfile", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoSessionCreateInfoKHR-videoCodecOperation-06814", "If the videoCodecOperation member of pVideoProfile specifies an encode operation then referencePicturesFormat must be one of the supported encode DPB formats as reported by vkGetPhysicalDeviceVideoFormatPropertiesKHR in the format member of VkVideoFormatPropertiesKHR when called with the imageUsage member of its pVideoFormatInfo parameter containing VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, and with a VkVideoProfileListInfoKHR structure chained to its pVideoFormatInfo parameter whose pProfiles member contains an entry matching pVideoProfile", "1.3-extensions"},
    {"VUID-VkVideoSessionMemoryRequirementsKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkVideoSessionMemoryRequirementsKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-commonparent", "Both of videoSession, and videoSessionParametersTemplate that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoDecodeH264SessionParametersCreateInfoEXT, VkVideoDecodeH265SessionParametersCreateInfoEXT, VkVideoEncodeH264SessionParametersCreateInfoEXT, or VkVideoEncodeH265SessionParametersCreateInfoEXT", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-parameter", "videoSession must be a valid VkVideoSessionKHR handle", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-videoSessionParametersTemplate-04855", "If videoSessionParametersTemplate represents a valid handle, it must have been created against videoSession", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-videoSessionParametersTemplate-parameter", "If videoSessionParametersTemplate is not VK_NULL_HANDLE, videoSessionParametersTemplate must be a valid VkVideoSessionParametersKHR handle", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersCreateInfoKHR-videoSessionParametersTemplate-parent", "If videoSessionParametersTemplate is a valid handle, it must have been created, allocated, or retrieved from videoSession", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersUpdateInfoKHR-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkVideoDecodeH264SessionParametersAddInfoEXT, VkVideoDecodeH265SessionParametersAddInfoEXT, VkVideoEncodeH264SessionParametersAddInfoEXT, or VkVideoEncodeH265SessionParametersAddInfoEXT", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersUpdateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkVideoSessionParametersUpdateInfoKHR-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkViewport-height-01772", "height must be greater than 0.0", "1.0"},
    {"VUID-VkViewport-height-01773", "The absolute value of height must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[1]", "1.3-extensions"},
    {"VUID-VkViewport-maxDepth-01235", "Unless VK_EXT_depth_range_unrestricted extension is enabled maxDepth must be between 0.0 and 1.0, inclusive", "1.3-extensions"},
    {"VUID-VkViewport-maxDepth-02541", "maxDepth must be between 0.0 and 1.0, inclusive", "1.3-khr-extensions"},
    {"VUID-VkViewport-minDepth-01234", "Unless VK_EXT_depth_range_unrestricted extension is enabled minDepth must be between 0.0 and 1.0, inclusive", "1.3-extensions"},
    {"VUID-VkViewport-minDepth-02540", "minDepth must be between 0.0 and 1.0, inclusive", "1.3-khr-extensions"},
    {"VUID-VkViewport-width-01770", "width must be greater than 0.0", "1.3-extensions"},
    {"VUID-VkViewport-width-01771", "width must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[0]", "1.3-extensions"},
    {"VUID-VkViewport-x-01232", "(x + width) must be less than or equal to viewportBoundsRange[1]", "1.3-extensions"},
    {"VUID-VkViewport-x-01774", "x must be greater than or equal to viewportBoundsRange[0]", "1.3-extensions"},
    {"VUID-VkViewport-y-01233", "(y + height) must be less than or equal to viewportBoundsRange[1]", "1.3-extensions"},
    {"VUID-VkViewport-y-01775", "y must be greater than or equal to viewportBoundsRange[0]", "1.3-extensions"},
    {"VUID-VkViewport-y-01776", "y must be less than or equal to viewportBoundsRange[1]", "1.3-extensions"},
    {"VUID-VkViewport-y-01777", "(y + height) must be greater than or equal to viewportBoundsRange[0]", "1.3-extensions"},
    {"VUID-VkViewportSwizzleNV-w-parameter", "w must be a valid VkViewportCoordinateSwizzleNV value", "1.3-extensions"},
    {"VUID-VkViewportSwizzleNV-x-parameter", "x must be a valid VkViewportCoordinateSwizzleNV value", "1.3-extensions"},
    {"VUID-VkViewportSwizzleNV-y-parameter", "y must be a valid VkViewportCoordinateSwizzleNV value", "1.3-extensions"},
    {"VUID-VkViewportSwizzleNV-z-parameter", "z must be a valid VkViewportCoordinateSwizzleNV value", "1.3-extensions"},
    {"VUID-VkWaylandSurfaceCreateInfoKHR-display-01304", "display must point to a valid Wayland wl_display", "1.3-extensions"},
    {"VUID-VkWaylandSurfaceCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkWaylandSurfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkWaylandSurfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305", "surface must point to a valid Wayland wl_surface", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-commonparent", "Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireKeys-parameter", "If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-00081", "Each member of pAcquireSyncs and pReleaseSyncs must be a device memory object imported by setting VkImportMemoryWin32HandleInfoKHR::handleType to VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireSyncs-parameter", "If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pAcquireTimeouts-parameter", "If acquireCount is not 0, pAcquireTimeouts must be a valid pointer to an array of acquireCount uint32_t values", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseKeys-parameter", "If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-pReleaseSyncs-parameter", "If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-commonparent", "Both of the elements of pAcquireSyncs, and the elements of pReleaseSyncs that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireKeys-parameter", "If acquireCount is not 0, pAcquireKeys must be a valid pointer to an array of acquireCount uint64_t values", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireSyncs-parameter", "If acquireCount is not 0, pAcquireSyncs must be a valid pointer to an array of acquireCount valid VkDeviceMemory handles", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pAcquireTimeoutMilliseconds-parameter", "If acquireCount is not 0, pAcquireTimeoutMilliseconds must be a valid pointer to an array of acquireCount uint32_t values", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseKeys-parameter", "If releaseCount is not 0, pReleaseKeys must be a valid pointer to an array of releaseCount uint64_t values", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-pReleaseSyncs-parameter", "If releaseCount is not 0, pReleaseSyncs must be a valid pointer to an array of releaseCount valid VkDeviceMemory handles", "1.3-extensions"},
    {"VUID-VkWin32KeyedMutexAcquireReleaseInfoNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV", "1.3-extensions"},
    {"VUID-VkWin32SurfaceCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkWin32SurfaceCreateInfoKHR-hinstance-01307", "hinstance must be a valid Win32 HINSTANCE", "1.3-extensions"},
    {"VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308", "hwnd must be a valid Win32 HWND", "1.3-extensions"},
    {"VUID-VkWin32SurfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkWin32SurfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-commonparent", "Both of dstSet, and the elements of pTexelBufferView that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorCount-00317", "All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must have identical descriptorType and stageFlags", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorCount-00318", "All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must all either use immutable samplers or must all not use immutable samplers", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorCount-arraylength", "descriptorCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00319", "descriptorType must match the type of dstBinding within dstSet", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00324", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pBufferInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorBufferInfo structures", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00325", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00327", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00328", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00329", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, and the buffer member of any element of pBufferInfo is the handle of a non-sparse buffer, then that buffer must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00330", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00331", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00332", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxUniformBufferRange", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00333", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the range member of each element of pBufferInfo, or the effective range if range is VK_WHOLE_SIZE, must be less than or equal to VkPhysicalDeviceLimits::maxStorageBufferRange", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00334", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00335", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the VkBuffer that each element of pTexelBufferView was created from must have been created with VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00336", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with the identity swizzle", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00337", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_SAMPLED_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00338", "If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-00339", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_STORAGE_BIT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-01946", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, then the imageView member of each pImageInfo element must have been created without a VkSamplerYcbcrConversionInfo structure in its pNext chain", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-01948", "If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was allocated with a layout that included immutable samplers for dstBinding, then the imageView member of each element of pImageInfo which corresponds to an immutable sampler that enables sampler {YCbCr} conversion must have been created with a VkSamplerYcbcrConversionInfo structure in its pNext chain with an identically defined VkSamplerYcbcrConversionInfo to the corresponding immutable sampler", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02219", "If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, dstArrayElement must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02220", "If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, descriptorCount must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02221", "If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, the pNext chain must include a VkWriteDescriptorSetInlineUniformBlock structure whose dataSize member equals descriptorCount", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02382", "If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, the pNext chain must include a VkWriteDescriptorSetAccelerationStructureKHR structure whose accelerationStructureCount member equals descriptorCount", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02738", "If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and if any element of pImageInfo has a imageView member that was created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, then dstSet must have been allocated with a layout that included immutable samplers for dstBinding, and the corresponding immutable sampler must have been created with an identically defined VkSamplerYcbcrConversionInfo object", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02752", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER, then dstSet must not have been allocated with a layout that included immutable samplers for dstBinding", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02994", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, each element of pTexelBufferView must be either a valid VkBufferView handle or VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02995", "If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER and the nullDescriptor feature is not enabled, each element of pTexelBufferView must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02996", "If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must be either a valid VkImageView handle or VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-02997", "If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT and the nullDescriptor feature is not enabled, the imageView member of each element of pImageInfo must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-03817", "If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, the pNext chain must include a VkWriteDescriptorSetAccelerationStructureNV structure whose accelerationStructureCount member equals descriptorCount", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-04149", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE the imageLayout member of each element of pImageInfo must be a member of the list given in Sampled Image", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-04150", "If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER the imageLayout member of each element of pImageInfo must be a member of the list given in Combined Image Sampler", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-04151", "If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT the imageLayout member of each element of pImageInfo must be a member of the list given in Input Attachment", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-04152", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE the imageLayout member of each element of pImageInfo must be a member of the list given in Storage Image", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-06450", "If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have either been created without a VkImageViewMinLodCreateInfoEXT present in the pNext chain or with a VkImageViewMinLodCreateInfoEXT::minLod of 0.0", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-06710", "If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, each imageView member of each element of pImageInfo that is a 2D image view created from a 3D image must have been created from an image created with VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-06942", "If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, the imageView member of each element of pImageInfo must have been created with a view created with an image created with VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-06943", "If descriptorType is VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, the imageView member of each element of pImageInfo must have been created with a view created with an image created with VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-descriptorType-parameter", "descriptorType must be a valid VkDescriptorType value", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-dstArrayElement-00321", "The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-dstBinding-00315", "dstBinding must be less than or equal to the maximum value of binding of all VkDescriptorSetLayoutBinding structures specified when dstSet's descriptor set layout was created", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-dstBinding-00316", "dstBinding must be a binding with a non-zero descriptorCount", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-dstSet-00320", "dstSet must be a valid VkDescriptorSet handle", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-dstSet-04611", "If the VkDescriptorSetLayoutBinding for dstSet at dstBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the new active descriptor type descriptorType must exist in the corresponding pMutableDescriptorTypeLists list for dstBinding", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-pNext-pNext", "Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkWriteDescriptorSetAccelerationStructureKHR, VkWriteDescriptorSetAccelerationStructureNV, or VkWriteDescriptorSetInlineUniformBlock", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-sType-sType", "sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSet-sType-unique", "The sType value of each struct in the pNext chain must be unique", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-02236", "accelerationStructureCount must be equal to descriptorCount in the extended structure", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureKHR-accelerationStructureCount-arraylength", "accelerationStructureCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03579", "Each acceleration structure in pAccelerationStructures must have been created with a type of VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-03580", "If the nullDescriptor feature is not enabled, each element of pAccelerationStructures must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureKHR-pAccelerationStructures-parameter", "pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid or VK_NULL_HANDLE VkAccelerationStructureKHR handles", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-03747", "accelerationStructureCount must be equal to descriptorCount in the extended structure", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength", "accelerationStructureCount must be greater than 0", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03748", "Each acceleration structure in pAccelerationStructures must have been created with VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03749", "If the nullDescriptor feature is not enabled, each member of pAccelerationStructures must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-parameter", "pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid or VK_NULL_HANDLE VkAccelerationStructureNV handles", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetAccelerationStructureNV-sType-sType", "sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-02222", "dataSize must be an integer multiple of 4", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetInlineUniformBlock-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-VkWriteDescriptorSetInlineUniformBlock-sType-sType", "sType must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK", "1.3-extensions"},
    {"VUID-VkXcbSurfaceCreateInfoKHR-connection-01310", "connection must point to a valid X11 xcb_connection_t", "1.3-extensions"},
    {"VUID-VkXcbSurfaceCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkXcbSurfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkXcbSurfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkXcbSurfaceCreateInfoKHR-window-01311", "window must be a valid X11 xcb_window_t", "1.3-extensions"},
    {"VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313", "dpy must point to a valid Xlib Display", "1.3-extensions"},
    {"VUID-VkXlibSurfaceCreateInfoKHR-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-VkXlibSurfaceCreateInfoKHR-pNext-pNext", "pNext must be NULL", "1.3-extensions"},
    {"VUID-VkXlibSurfaceCreateInfoKHR-sType-sType", "sType must be VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR", "1.3-extensions"},
    {"VUID-VkXlibSurfaceCreateInfoKHR-window-01314", "window must be a valid Xlib Window", "1.3-extensions"},
    {"VUID-WarpIDNV-WarpIDNV-04420", "The variable decorated with WarpIDNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-WarpIDNV-WarpIDNV-04421", "The variable decorated with WarpIDNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-WarpsPerSMNV-WarpsPerSMNV-04418", "The variable decorated with WarpsPerSMNV must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-WarpsPerSMNV-WarpsPerSMNV-04419", "The variable decorated with WarpsPerSMNV must be declared as a scalar 32-bit integer value", "1.3-extensions"},
    {"VUID-WorkgroupId-WorkgroupId-04422", "The WorkgroupId decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-WorkgroupId-WorkgroupId-04423", "The variable decorated with WorkgroupId must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-WorkgroupId-WorkgroupId-04424", "The variable decorated with WorkgroupId must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-WorkgroupSize-WorkgroupSize-04425", "The WorkgroupSize decoration must be used only within the GLCompute, MeshEXT, TaskEXT, MeshNV, or TaskNV {ExecutionModel}", "1.3-extensions"},
    {"VUID-WorkgroupSize-WorkgroupSize-04426", "The variable decorated with WorkgroupSize must be a specialization constant or a constant", "1.3-extensions"},
    {"VUID-WorkgroupSize-WorkgroupSize-04427", "The variable decorated with WorkgroupSize must be declared as a three-component vector of 32-bit integer values", "1.3-extensions"},
    {"VUID-WorldRayDirectionKHR-WorldRayDirectionKHR-04428", "The WorldRayDirectionKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-WorldRayDirectionKHR-WorldRayDirectionKHR-04429", "The variable decorated with WorldRayDirectionKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-WorldRayDirectionKHR-WorldRayDirectionKHR-04430", "The variable decorated with WorldRayDirectionKHR must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-WorldRayOriginKHR-WorldRayOriginKHR-04431", "The WorldRayOriginKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, ClosestHitKHR, or MissKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-WorldRayOriginKHR-WorldRayOriginKHR-04432", "The variable decorated with WorldRayOriginKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-WorldRayOriginKHR-WorldRayOriginKHR-04433", "The variable decorated with WorldRayOriginKHR must be declared as a three-component vector of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-WorldToObjectKHR-WorldToObjectKHR-04434", "The WorldToObjectKHR decoration must be used only within the IntersectionKHR, AnyHitKHR, or ClosestHitKHR {ExecutionModel}", "1.3-extensions"},
    {"VUID-WorldToObjectKHR-WorldToObjectKHR-04435", "The variable decorated with WorldToObjectKHR must be declared using the Input {StorageClass}", "1.3-extensions"},
    {"VUID-WorldToObjectKHR-WorldToObjectKHR-04436", "The variable decorated with WorldToObjectKHR must be declared as a matrix with four columns of three-component vectors of 32-bit floating-point values", "1.3-extensions"},
    {"VUID-vkAcquireDrmDisplayEXT-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkAcquireDrmDisplayEXT-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkAcquireDrmDisplayEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkAcquireFullScreenExclusiveModeEXT-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkAcquireFullScreenExclusiveModeEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02674", "swapchain must not be in the retired state", "1.3-extensions"},
    {"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02675", "swapchain must be a swapchain created with a VkSurfaceFullScreenExclusiveInfoEXT structure, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT", "1.3-extensions"},
    {"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02676", "swapchain must not currently have exclusive full-screen access", "1.3-extensions"},
    {"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkAcquireNextImage2KHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAcquireNextImage2KHR-pAcquireInfo-parameter", "pAcquireInfo must be a valid pointer to a valid VkAcquireNextImageInfoKHR structure", "1.3-extensions"},
    {"VUID-vkAcquireNextImage2KHR-pImageIndex-parameter", "pImageIndex must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkAcquireNextImage2KHR-swapchain-01803", "If the number of currently acquired images is greater than the difference between the number of images in the swapchain member of pAcquireInfo and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, the timeout member of pAcquireInfo must not be UINT64_MAX", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-commonparent", "Both of device, and swapchain that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-fence-01287", "If fence is not VK_NULL_HANDLE it must be unsignaled and must not be associated with any other queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-fence-parameter", "If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-fence-parent", "If fence is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-pImageIndex-parameter", "pImageIndex must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-semaphore-01286", "If semaphore is not VK_NULL_HANDLE it must be unsignaled", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-semaphore-01779", "If semaphore is not VK_NULL_HANDLE it must not have any uncompleted signal or wait operations pending", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-semaphore-01780", "semaphore and fence must not both be equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-semaphore-03265", "semaphore must have a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-semaphore-parameter", "If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-semaphore-parent", "If semaphore is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-swapchain-01285", "swapchain must not be in the retired state", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-swapchain-01802", "If the number of currently acquired images is greater than the difference between the number of images in swapchain and the value of VkSurfaceCapabilitiesKHR::minImageCount as returned by a call to vkGetPhysicalDeviceSurfaceCapabilities2KHR with the surface used to create swapchain, timeout must not be UINT64_MAX", "1.3-extensions"},
    {"VUID-vkAcquireNextImageKHR-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkAcquirePerformanceConfigurationINTEL-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAcquirePerformanceConfigurationINTEL-pAcquireInfo-parameter", "pAcquireInfo must be a valid pointer to a valid VkPerformanceConfigurationAcquireInfoINTEL structure", "1.3-extensions"},
    {"VUID-vkAcquirePerformanceConfigurationINTEL-pConfiguration-parameter", "pConfiguration must be a valid pointer to a VkPerformanceConfigurationINTEL handle", "1.3-extensions"},
    {"VUID-vkAcquireProfilingLockKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAcquireProfilingLockKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkAcquireProfilingLockInfoKHR structure", "1.3-extensions"},
    {"VUID-vkAcquireWinrtDisplayNV-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkAcquireWinrtDisplayNV-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkAcquireWinrtDisplayNV-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkAcquireXlibDisplayEXT-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkAcquireXlibDisplayEXT-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkAcquireXlibDisplayEXT-dpy-parameter", "dpy must be a valid pointer to a Display value", "1.3-extensions"},
    {"VUID-vkAcquireXlibDisplayEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkAllocateCommandBuffers-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter", "pAllocateInfo must be a valid pointer to a valid VkCommandBufferAllocateInfo structure", "1.3-extensions"},
    {"VUID-vkAllocateCommandBuffers-pAllocateInfo::commandBufferCount-arraylength", "pAllocateInfo->commandBufferCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter", "pCommandBuffers must be a valid pointer to an array of pAllocateInfo->commandBufferCount VkCommandBuffer handles", "1.3-extensions"},
    {"VUID-vkAllocateDescriptorSets-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter", "pAllocateInfo must be a valid pointer to a valid VkDescriptorSetAllocateInfo structure", "1.3-extensions"},
    {"VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength", "pAllocateInfo->descriptorSetCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter", "pDescriptorSets must be a valid pointer to an array of pAllocateInfo->descriptorSetCount VkDescriptorSet handles", "1.3-extensions"},
    {"VUID-vkAllocateMemory-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkAllocateMemory-deviceCoherentMemory-02790", "If the deviceCoherentMemory feature is not enabled, pAllocateInfo->memoryTypeIndex must not identify a memory type supporting VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD", "1.3-extensions"},
    {"VUID-vkAllocateMemory-maxMemoryAllocationCount-04101", "There must be less than VkPhysicalDeviceLimits::maxMemoryAllocationCount device memory allocations currently allocated on the device", "1.3-extensions"},
    {"VUID-vkAllocateMemory-pAllocateInfo-01713", "pAllocateInfo->allocationSize must be less than or equal to VkPhysicalDeviceMemoryProperties::memoryHeaps[memindex].size where memindex = VkPhysicalDeviceMemoryProperties::memoryTypes[pAllocateInfo->memoryTypeIndex].heapIndex as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from", "1.3-extensions"},
    {"VUID-vkAllocateMemory-pAllocateInfo-01714", "pAllocateInfo->memoryTypeIndex must be less than VkPhysicalDeviceMemoryProperties::memoryTypeCount as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from", "1.3-extensions"},
    {"VUID-vkAllocateMemory-pAllocateInfo-parameter", "pAllocateInfo must be a valid pointer to a valid VkMemoryAllocateInfo structure", "1.3-extensions"},
    {"VUID-vkAllocateMemory-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkAllocateMemory-pMemory-parameter", "pMemory must be a valid pointer to a VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-commandBuffer-00049", "commandBuffer must not be in the recording or pending state", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-commandBuffer-00050", "If commandBuffer was allocated from a VkCommandPool which did not have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, commandBuffer must be in the initial state", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-commandBuffer-00051", "If commandBuffer is a secondary command buffer, the pInheritanceInfo member of pBeginInfo must be a valid VkCommandBufferInheritanceInfo structure", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-commandBuffer-00052", "If commandBuffer is a secondary command buffer and either the occlusionQueryEnable member of the pInheritanceInfo member of pBeginInfo is VK_FALSE, or the occlusionQueryPrecise feature is not enabled, then pBeginInfo->pInheritanceInfo->queryFlags must not contain VK_QUERY_CONTROL_PRECISE_BIT", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-commandBuffer-02840", "If commandBuffer is a primary command buffer, then pBeginInfo->flags must not set both the VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT and the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flags", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkBeginCommandBuffer-pBeginInfo-parameter", "pBeginInfo must be a valid pointer to a valid VkCommandBufferBeginInfo structure", "1.3-extensions"},
    {"VUID-vkBindAccelerationStructureMemoryNV-bindInfoCount-arraylength", "bindInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkBindAccelerationStructureMemoryNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindAccelerationStructureMemoryNV-pBindInfos-parameter", "pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindAccelerationStructureMemoryInfoNV structures", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-None-01898", "If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit set, the buffer must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-None-01899", "If buffer was created with the VK_BUFFER_CREATE_PROTECTED_BIT bit not set, the buffer must not be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-01030", "buffer must not have been created with any sparse memory binding flags", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-01038", "If buffer was created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been allocated with VkDedicatedAllocationMemoryAllocateInfoNV::buffer equal to a buffer handle created with identical creation parameters to buffer and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-01039", "If buffer was not created with VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image", "default"},
    {"VUID-vkBindBufferMemory-buffer-01444", "If buffer requires a dedicated allocation (as reported by vkGetBufferMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for buffer), memory must have been allocated with VkMemoryDedicatedAllocateInfo::buffer equal to buffer", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-06408", "If buffer was created with VkBufferCollectionBufferCreateInfoFUCHSIA chained to VkBufferCreateInfo::pNext, memory must be allocated with a VkImportMemoryBufferCollectionFUCHSIA chained to VkMemoryAllocateInfo::pNext", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-07459", "buffer must not have been bound to a memory object", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-buffer-parent", "buffer must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-bufferDeviceAddress-03339", "If the VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress feature is enabled and buffer was created with the VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT bit set, memory must have been allocated with the VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT bit set", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-01035", "memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-01508", "If the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::buffer was not VK_NULL_HANDLE, then buffer must equal VkMemoryDedicatedAllocateInfo::buffer, and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-02726", "If the value of VkExportMemoryAllocateInfo::handleTypes used to allocate memory is not 0, it must include at least one of the handles set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-02727", "If memory was allocated by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-khr-extensions"},
    {"VUID-vkBindBufferMemory-memory-02985", "If memory was allocated by a memory import operation, that is not VkImportAndroidHardwareBufferInfoANDROID with a non-NULL buffer value, the external handle type of the imported memory must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-02986", "If memory was allocated with the VkImportAndroidHardwareBufferInfoANDROID memory import operation with a non-NULL buffer value, VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes when buffer was created", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memoryOffset-01031", "memoryOffset must be less than the size of memory", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-memoryOffset-01036", "memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer", "1.3-extensions"},
    {"VUID-vkBindBufferMemory-size-01037", "The size member of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with buffer must be less than or equal to the size of memory minus memoryOffset", "1.3-extensions"},
    {"VUID-vkBindBufferMemory2-bindInfoCount-arraylength", "bindInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkBindBufferMemory2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindBufferMemory2-pBindInfos-parameter", "pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindBufferMemoryInfo structures", "1.3-extensions"},
    {"VUID-vkBindImageMemory-None-01901", "If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit set, the image must be bound to a memory object allocated with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-vkBindImageMemory-None-01902", "If image was created with the VK_IMAGE_CREATE_PROTECTED_BIT bit not set, the image must not be bound to a memory object created with a memory type that reports VK_MEMORY_PROPERTY_PROTECTED_BIT", "1.3-extensions"},
    {"VUID-vkBindImageMemory-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-01045", "image must not have been created with any sparse memory binding flags", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-01050", "If image was created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must have been created with VkDedicatedAllocationMemoryAllocateInfoNV::image equal to an image handle created with identical creation parameters to image and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-01051", "If image was not created with VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation equal to VK_TRUE, memory must not have been allocated dedicated for a specific buffer or image", "default"},
    {"VUID-vkBindImageMemory-image-01445", "If image requires a dedicated allocation (as reported by vkGetImageMemoryRequirements2 in VkMemoryDedicatedRequirements::requiresDedicatedAllocation for image), memory must have been created with VkMemoryDedicatedAllocateInfo::image equal to image", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-01608", "image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT set", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-06392", "If image was created with VkBufferCollectionImageCreateInfoFUCHSIA chained to VkImageCreateInfo::pNext, memory must be allocated with a VkImportMemoryBufferCollectionFUCHSIA chained to VkMemoryAllocateInfo::pNext", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-07460", "image must not have been bound to a memory object", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkBindImageMemory-image-parent", "image must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-01047", "memory must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-01509", "If the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero", "1.3-khr-extensions"},
    {"VUID-vkBindImageMemory-memory-02628", "If the dedicatedAllocationImageAliasing feature is not enabled, and the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then image must equal VkMemoryDedicatedAllocateInfo::image and memoryOffset must be zero", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-02629", "If the dedicatedAllocationImageAliasing feature is enabled, and the VkMemoryAllocateInfo provided when memory was allocated included a VkMemoryDedicatedAllocateInfo structure in its pNext chain, and VkMemoryDedicatedAllocateInfo::image was not VK_NULL_HANDLE, then memoryOffset must be zero, and image must be either equal to VkMemoryDedicatedAllocateInfo::image or an image that was created using the same parameters in VkImageCreateInfo, with the exception that extent and arrayLayers may differ subject to the following restrictions: every dimension in the extent parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created; and the arrayLayers parameter of the image being bound must be equal to or smaller than the original image for which the allocation was created", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-02728", "If the value of VkExportMemoryAllocateInfo::handleTypes used to allocate memory is not 0, it must include at least one of the handles set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-02729", "If memory was created by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-khr-extensions"},
    {"VUID-vkBindImageMemory-memory-02989", "If memory was created by a memory import operation, that is not VkImportAndroidHardwareBufferInfoANDROID with a non-NULL buffer value, the external handle type of the imported memory must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-02990", "If memory was created with the VkImportAndroidHardwareBufferInfoANDROID memory import operation with a non-NULL buffer value, VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memoryOffset-01046", "memoryOffset must be less than the size of memory", "1.3-extensions"},
    {"VUID-vkBindImageMemory-memoryOffset-01048", "memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with image", "1.3-extensions"},
    {"VUID-vkBindImageMemory-size-01049", "The difference of the size of memory and memoryOffset must be greater than or equal to the size member of the VkMemoryRequirements structure returned from a call to vkGetImageMemoryRequirements with the same image", "1.3-extensions"},
    {"VUID-vkBindImageMemory2-bindInfoCount-arraylength", "bindInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkBindImageMemory2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindImageMemory2-pBindInfos-02858", "If any VkBindImageMemoryInfo::image was created with VK_IMAGE_CREATE_DISJOINT_BIT then all planes of VkBindImageMemoryInfo::image must be bound individually in separate pBindInfos", "1.3-extensions"},
    {"VUID-vkBindImageMemory2-pBindInfos-04006", "pBindInfos must not refer to the same image subresource more than once", "1.3-extensions"},
    {"VUID-vkBindImageMemory2-pBindInfos-parameter", "pBindInfos must be a valid pointer to an array of bindInfoCount valid VkBindImageMemoryInfo structures", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-bindingPoint-parameter", "bindingPoint must be a valid VkOpticalFlowSessionBindingPointNV value", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-layout-parameter", "layout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-session-parameter", "session must be a valid VkOpticalFlowSessionNV handle", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-session-parent", "session must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-view-parameter", "If view is not VK_NULL_HANDLE, view must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-vkBindOpticalFlowSessionImageNV-view-parent", "If view is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBindVideoSessionMemoryKHR-bindSessionMemoryInfoCount-arraylength", "bindSessionMemoryInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkBindVideoSessionMemoryKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-parameter", "pBindSessionMemoryInfos must be a valid pointer to an array of bindSessionMemoryInfoCount valid VkBindVideoSessionMemoryInfoKHR structures", "1.3-extensions"},
    {"VUID-vkBindVideoSessionMemoryKHR-videoSession-parameter", "videoSession must be a valid VkVideoSessionKHR handle", "1.3-extensions"},
    {"VUID-vkBindVideoSessionMemoryKHR-videoSession-parent", "videoSession must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-None-03407", "The dstAccelerationStructure member of any element of pInfos must not be referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR in any other element of pInfos", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-accelerationStructureHostCommands-03581", "The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03698", "The dstAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03701", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the srcAccelerationStructure member of any other element of pInfos with a mode equal to VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03702", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the dstAccelerationStructure member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03703", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any element of pInfos (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03706", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing any acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR in any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03800", "The dstAccelerationStructure member of any element of pInfos must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-firstVertex-03770", "For each VkAccelerationStructureBuildRangeInfoKHR referenced by this command, if the corresponding geometry uses indices, its firstVertex member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-infoCount-arraylength", "infoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-mode-04628", "The mode member of each element of pInfos must be a valid VkBuildAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03403", "The srcAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03663", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, inactive primitives in its srcAccelerationStructure member must not be made active", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03664", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, active primitives in its srcAccelerationStructure member must not be made inactive", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03667", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must have previously been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR set in VkAccelerationStructureBuildGeometryInfoKHR::flags in the build", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03668", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure and dstAccelerationStructure members must either be the same VkAccelerationStructureKHR, or not have any memory aliasing", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03675", "For each pInfos[i], dstAccelerationStructure must have been created with a value of VkAccelerationStructureCreateInfoKHR::size greater than or equal to the memory size required by the build operation, as returned by vkGetAccelerationStructureBuildSizesKHR with pBuildInfo = pInfos[i] and with each element of the pMaxPrimitiveCounts array greater than or equal to the equivalent ppBuildRangeInfos[i][j].primitiveCount values for j in [0,pInfos[i].geometryCount)", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03699", "For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03700", "For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03722", "For each element of pInfos, the buffer used to create its dstAccelerationStructure member must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03723", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the buffer used to create its srcAccelerationStructure member must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03724", "For each element of pInfos, the buffer used to create each acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03725", "If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR, all addresses between pInfos[i].scratchData.hostAddress and pInfos[i].scratchData.hostAddress + N - 1 must be valid host memory, where N is given by the buildScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03726", "If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, all addresses between pInfos[i].scratchData.hostAddress and pInfos[i].scratchData.hostAddress + N - 1 must be valid host memory, where N is given by the updateScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03758", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its geometryCount member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03759", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its flags member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03760", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its type member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03761", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, its geometryType member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03762", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, its flags member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03763", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.vertexFormat member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03764", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.maxVertex member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03765", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.indexType member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03766", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, if its geometry.triangles.transformData address was NULL when srcAccelerationStructure was last built, then it must be NULL", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03767", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, if its geometry.triangles.transformData address was not NULL when srcAccelerationStructure was last built, then it must not be NULL", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03768", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, and geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, then the value of each index referenced must be the same as the corresponding index value when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03771", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.hostAddress must be a valid host address", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03772", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.hostAddress must be a valid host address", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03773", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.hostAddress is not 0, it must be a valid host address", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03774", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.hostAddress must be a valid host address", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03775", "For each element of pInfos, the buffer used to create its dstAccelerationStructure member must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03776", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the buffer used to create its srcAccelerationStructure member must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03777", "For each element of pInfos, the buffer used to create each acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03778", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, geometry.instances.data.hostAddress must be a valid host address", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03779", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, each VkAccelerationStructureInstanceKHR::accelerationStructureReference value in geometry.instances.data.hostAddress must be a valid VkAccelerationStructureKHR object", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-03801", "For each element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, the corresponding pname:ppBuildRangeInfos[i][j].pname:primitiveCount must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxInstanceCount", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-04630", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-04930", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR with VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV set, each accelerationStructureReference in any structure in VkAccelerationStructureMotionInstanceNV value in geometry.instances.data.hostAddress must be a valid VkAccelerationStructureKHR object", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-pInfos-parameter", "pInfos must be a valid pointer to an array of infoCount valid VkAccelerationStructureBuildGeometryInfoKHR structures", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-ppBuildRangeInfos-03676", "Each element of ppBuildRangeInfos[i] must be a valid pointer to an array of pInfos[i].geometryCount VkAccelerationStructureBuildRangeInfoKHR structures", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter", "ppBuildRangeInfos must be a valid pointer to an array of infoCount VkAccelerationStructureBuildRangeInfoKHR structures", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-primitiveCount-03769", "For each VkAccelerationStructureBuildRangeInfoKHR referenced by this command, its primitiveCount member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-scratchData-03704", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-scratchData-03705", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the srcAccelerationStructure member of any element of pInfos with a mode equal to VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildAccelerationStructuresKHR-srcAccelerationStructure-04629", "If the srcAccelerationStructure member of any element of pInfos is not VK_NULL_HANDLE, the srcAccelerationStructure member must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-dstMicromap-07463", "The dstMicromap member of any element of pInfos must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-dstMicromap-07465", "The range of memory backing the dstMicromap member of any element of pInfos that is accessed by this command must not overlap the memory backing the dstMicromap member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-dstMicromap-07466", "The range of memory backing the dstMicromap member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any element of pInfos (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-infoCount-arraylength", "infoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-micromapHostCommands-07555", "The VkPhysicalDeviceOpacityMicromapFeaturesEXT::micromapHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-mode-07462", "The mode member of each element of pInfos must be a valid VkBuildMicromapModeEXT value", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07461", "For each pInfos[i], dstMicromap must have been created with a value of VkMicromapCreateInfoEXT::size greater than or equal to the memory size required by the build operation, as returned by vkGetMicromapBuildSizesEXT with pBuildInfo = pInfos[i]", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07464", "For each element of pInfos its type member must match the value of VkMicromapCreateInfoEXT::type when its dstMicromap was created", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07552", "For each element of pInfos, the buffer used to create its dstMicromap member must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07553", "For each element of pInfos, all referenced addresses of pInfos[i].data.hostAddress must be valid host memory", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07554", "For each element of pInfos, all referenced addresses of pInfos[i].triangleArray.hostAddress must be valid host memory", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07556", "If pInfos[i].mode is VK_BUILD_MICROMAP_MODE_BUILD_EXT, all addresses between pInfos[i].scratchData.hostAddress and pInfos[i].scratchData.hostAddress + N - 1 must be valid host memory, where N is given by the buildScratchSize member of the VkMicromapBuildSizesInfoEXT structure returned from a call to vkGetMicromapBuildSizesEXT with an identical VkMicromapBuildInfoEXT structure and primitive count", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-07557", "For each element of pInfos, the buffer used to create its dstMicromap member must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-pInfos-parameter", "pInfos must be a valid pointer to an array of infoCount valid VkMicromapBuildInfoEXT structures", "1.3-extensions"},
    {"VUID-vkBuildMicromapsEXT-scratchData-07467", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBeginConditionalRenderingEXT-None-01980", "Conditional rendering must not already be active", "1.3-extensions"},
    {"VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginConditionalRenderingEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginConditionalRenderingEXT-pConditionalRenderingBegin-parameter", "pConditionalRenderingBegin must be a valid pointer to a valid VkConditionalRenderingBeginInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdBeginConditionalRenderingEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginDebugUtilsLabelEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginDebugUtilsLabelEXT-pLabelInfo-parameter", "pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure", "1.3-extensions"},
    {"VUID-vkCmdBeginDebugUtilsLabelEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-None-00807", "All queries used by the command must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-None-02863", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, this command must not be recorded in a command buffer that, either directly or through secondary command buffers, also contains a vkCmdResetQueryPool command affecting the same query", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-commandBuffer-01885", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-flags-parameter", "flags must be a valid combination of VkQueryControlFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-query-00802", "query must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-query-00808", "If called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-01922", "queryPool must have been created with a queryType that differs from that of any queries that are active within commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-03223", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the profiling lock must have been held before vkBeginCommandBuffer was called on commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-03224", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR, the query begin must be the first recorded command in commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-03225", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR, the begin command must not be recorded within a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-03226", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and another query pool with a queryType VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR has been used within commandBuffer, its parent primary command buffer or secondary command buffer recorded within the same parent primary command buffer as commandBuffer, the performanceCounterMultipleQueryPools feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-07289", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then the VkQueryPoolPerformanceCreateInfoKHR::queueFamilyIndex queryPool was created with must equal the queue family index of the VkCommandPool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-00800", "If the occlusionQueryPrecise feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-00803", "If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-00804", "If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-00805", "If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-02327", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-02328", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT then VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackQueries must be supported", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-02804", "The queryType used to create queryPool must not be VK_QUERY_TYPE_TIMESTAMP", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-04728", "The queryType used to create queryPool must not be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-04729", "The queryType used to create queryPool must not be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-04862", "If the queryType used to create queryPool was VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR the VkCommandPool that commandBuffer was allocated from must support video encode operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-06687", "If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-06688", "If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT then primitivesGeneratedQuery must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-06741", "The queryType used to create queryPool must not be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR", "1.3-extensions"},
    {"VUID-vkCmdBeginQuery-queryType-07070", "If the queryType used to create queryPool was VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-None-00807", "All queries used by the command must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-None-02863", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, this command must not be recorded in a command buffer that, either directly or through secondary command buffers, also contains a vkCmdResetQueryPool command affecting the same query", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-01885", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-flags-parameter", "flags must be a valid combination of VkQueryControlFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-query-00802", "query must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-query-00808", "If called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-03223", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the profiling lock must have been held before vkBeginCommandBuffer was called on commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-03224", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR, the query begin must be the first recorded command in commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-03225", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR, the begin command must not be recorded within a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-03226", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and another query pool with a queryType VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR has been used within commandBuffer, its parent primary command buffer or secondary command buffer recorded within the same parent primary command buffer as commandBuffer, the performanceCounterMultipleQueryPools feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-04753", "If the queryPool was created with the same queryType as that of another active query within commandBuffer, then index must not match the index used for the active query", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-07289", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then the VkQueryPoolPerformanceCreateInfoKHR::queueFamilyIndex queryPool was created with must equal the queue family index of the VkCommandPool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-00800", "If the occlusionQueryPrecise feature is not enabled, or the queryType used to create queryPool was not VK_QUERY_TYPE_OCCLUSION, flags must not contain VK_QUERY_CONTROL_PRECISE_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-00803", "If the queryType used to create queryPool was VK_QUERY_TYPE_OCCLUSION, the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-00804", "If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate graphics operations, the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-00805", "If the queryType used to create queryPool was VK_QUERY_TYPE_PIPELINE_STATISTICS and any of the pipelineStatistics indicate compute operations, the VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-02338", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-02339", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-02340", "If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index must be zero", "default"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-02341", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT then VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackQueries must be supported", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-02804", "The queryType used to create queryPool must not be VK_QUERY_TYPE_TIMESTAMP", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-04728", "The queryType used to create queryPool must not be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-04729", "The queryType used to create queryPool must not be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-04862", "If the queryType used to create queryPool was VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR the VkCommandPool that commandBuffer was allocated from must support video encode operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-06689", "If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-06690", "If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-06691", "If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT and the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled, the index parameter must be zero.", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-06692", "If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT and not VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, the index must be zero", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-06693", "If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT then primitivesGeneratedQuery must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-06741", "The queryType used to create queryPool must not be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-queryType-07071", "The queryType used to create queryPool must not be VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT", "1.3-extensions"},
    {"VUID-vkCmdBeginQueryIndexedEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-contents-parameter", "contents must be a valid VkSubpassContents value", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-dstStageMask-06452", "The dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-framebuffer-02532", "For any attachment in framebuffer that is used by renderPass and is bound to memory locations that are also bound to another attachment used by renderPass, and if at least one of those uses causes either attachment to be written to, both attachments must have had the VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT set", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-00895", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-00896", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.0"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-00897", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-00898", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-00899", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-00900", "If the initialLayout member of any of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-01758", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-02842", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-07000", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including either the VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT and either the VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT or VK_IMAGE_USAGE_SAMPLED_BIT usage bits.", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-initialLayout-07001", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value the VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT usage bit.", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter", "pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-srcStageMask-06451", "The srcStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-stencilInitialLayout-02843", "If any of the stencilInitialLayout or stencilFinalLayout member of the VkAttachmentDescriptionStencilLayout structures or the stencilLayout member of the VkAttachmentReferenceStencilLayout structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-dstStageMask-06454", "The dstStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-framebuffer-02533", "For any attachment in framebuffer that is used by renderPass and is bound to memory locations that are also bound to another attachment used by renderPass, and if at least one of those uses causes either attachment to be written to, both attachments must have had the VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT set", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-framebuffer-02779", "Both the framebuffer and renderPass members of pRenderPassBegin must have been created on the same VkDevice that commandBuffer was allocated on", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-02844", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-03094", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-03096", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-03097", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_SAMPLED_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-03098", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-03099", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-03100", "If the initialLayout member of any of the VkAttachmentDescription structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is not VK_IMAGE_LAYOUT_UNDEFINED, then each such initialLayout must be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the framebuffer member of pRenderPassBegin", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-07002", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including either the VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT and either the VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT or VK_IMAGE_USAGE_SAMPLED_BIT usage bits.", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-initialLayout-07003", "If any of the initialLayout or finalLayout member of the VkAttachmentDescription structures or the layout member of the VkAttachmentReference structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value the VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT usage bit.", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-pRenderPassBegin-parameter", "pRenderPassBegin must be a valid pointer to a valid VkRenderPassBeginInfo structure", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-pSubpassBeginInfo-parameter", "pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfo structure", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-srcStageMask-06453", "The srcStageMask members of any element of the pDependencies member of VkRenderPassCreateInfo used to create renderPass must be supported by the capabilities of the queue family identified by the queueFamilyIndex member of the VkCommandPoolCreateInfo used to create the command pool which commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-stencilInitialLayout-02845", "If any of the stencilInitialLayout or stencilFinalLayout member of the VkAttachmentDescriptionStencilLayout structures or the stencilLayout member of the VkAttachmentReferenceStencilLayout structures specified when creating the render pass specified in the renderPass member of pRenderPassBegin is VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL then the corresponding attachment image view of the framebuffer specified in the framebuffer member of pRenderPassBegin must have been created with a usage value including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRenderPass2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-commandBuffer-06068", "If commandBuffer is a secondary command buffer, pRenderingInfo->flags must not include VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-dynamicRendering-06446", "The dynamicRendering feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-pRenderingInfo-parameter", "pRenderingInfo must be a valid pointer to a valid VkRenderingInfo structure", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginRendering-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-None-02367", "Transform feedback must not be active", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-None-02373", "Transform feedback must not be made active in a render pass instance with multiview enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-None-04128", "The last pre-rasterization shader stage of the bound graphics pipeline must have been declared with the Xfb execution mode", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-None-06233", "A valid graphics pipeline must be bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-commonparent", "Both of commandBuffer, and the elements of pCounterBuffers that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-counterBufferCount-02607", "If counterBufferCount is not 0, and pCounterBuffers is not NULL, pCounterBuffers must be a valid pointer to an array of counterBufferCount VkBuffer handles that are either valid or VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02368", "firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02369", "The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffer-02371", "If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBufferOffsets-02370", "For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBufferOffsets-parameter", "If counterBufferCount is not 0, and pCounterBufferOffsets is not NULL, pCounterBufferOffsets must be a valid pointer to an array of counterBufferCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffers-02372", "For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-transformFeedback-02366", "VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBeginTransformFeedbackEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-parameter", "pBeginInfo must be a valid pointer to a valid VkVideoBeginCodingInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBeginVideoCodingKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-commonparent", "Each of commandBuffer, layout, and the elements of pDescriptorSets that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength", "descriptorSetCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359", "dynamicOffsetCount must be equal to the total number of dynamic descriptors in pDescriptorSets", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-firstSet-00360", "The sum of firstSet and descriptorSetCount must be less than or equal to VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-graphicsPipelineLibrary-06754", "If graphicsPipelineLibrary is not enabled, each element of pDescriptorSets must be a valid VkDescriptorSet", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358", "Each element of pDescriptorSets must have been allocated with a VkDescriptorSetLayout that matches (is the same as, or identically defined as) the VkDescriptorSetLayout at set n in layout, where n is the sum of firstSet and the index into pDescriptorSets", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979", "For each dynamic uniform or storage buffer binding in pDescriptorSets, the sum of the effective offset and the range of the binding must be less than or equal to the size of the buffer", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDescriptorSets-04616", "Each element of pDescriptorSets must not have been allocated from a VkDescriptorPool with the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT flag set", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDescriptorSets-06563", "Each element of pDescriptorSets must be a valid VkDescriptorSet", "1.3-khr-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDescriptorSets-06715", "For each dynamic uniform or storage buffer binding in pDescriptorSets, if the range was set with VK_WHOLE_SIZE then pDynamicOffsets which corresponds to the descriptor binding must be 0", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter", "pDescriptorSets must be a valid pointer to an array of descriptorSetCount valid or VK_NULL_HANDLE VkDescriptorSet handles", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971", "Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972", "Each element of pDynamicOffsets which corresponds to a descriptor binding with type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter", "If dynamicOffsetCount is not 0, pDynamicOffsets must be a valid pointer to an array of dynamicOffsetCount uint32_t values", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361", "pipelineBindPoint must be supported by the commandBuffer's parent VkCommandPool's queue family", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-vkCmdBindDescriptorSets-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-buffer-00433", "buffer must have been created with the VK_BUFFER_USAGE_INDEX_BUFFER_BIT flag", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-buffer-00434", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-commonparent", "Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-indexType-02507", "indexType must not be VK_INDEX_TYPE_NONE_KHR", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-indexType-02765", "If indexType is VK_INDEX_TYPE_UINT8_EXT, the indexTypeUint8 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-indexType-parameter", "indexType must be a valid VkIndexType value", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-offset-00431", "offset must be less than the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-offset-00432", "The sum of offset and the address of the range of VkDeviceMemory object that is backing buffer, must be a multiple of the type indicated by indexType", "1.3-extensions"},
    {"VUID-vkCmdBindIndexBuffer-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-None-04976", "The invocationMask feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-None-04982", "Each element in the invocation mask image must have the value 0 or 1. The value 1 means the invocation is active", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-commonparent", "Both of commandBuffer, and imageView that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-04977", "If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-04978", "If imageView is not VK_NULL_HANDLE, it must have a format of VK_FORMAT_R8_UINT", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-04979", "If imageView is not VK_NULL_HANDLE, it must have been created with VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI set", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-04980", "If imageView is not VK_NULL_HANDLE, imageLayout must be VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-parameter", "If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-width-04981", "Thread mask image resolution must match the width and height in vkCmdTraceRaysKHR", "1.3-extensions"},
    {"VUID-vkCmdBindInvocationMaskHUAWEI-width-04983", "width in vkCmdTraceRaysKHR should be 1", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-None-02323", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-commandBuffer-04808", "If commandBuffer is a secondary command buffer with VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled and pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, then the pipeline must have been created with VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT or VK_DYNAMIC_STATE_VIEWPORT, and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT or VK_DYNAMIC_STATE_SCISSOR enabled", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-commandBuffer-04809", "If commandBuffer is a secondary command buffer with VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled and pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS and pipeline was created with VkPipelineDiscardRectangleStateCreateInfoEXT structure and its discardRectangleCount member is not 0, then the pipeline must have been created with VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT enabled", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-commonparent", "Both of commandBuffer, and pipeline must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-00781", "If the variableMultisampleRate feature is not supported, pipeline is a graphics pipeline, the current subpass uses no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline must match that set in the previous pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-03382", "pipeline must not have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR set", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-06194", "If pipeline is a graphics pipeline, this command has been called inside a render pass instance started with vkCmdBeginRendering, and commands using the previously bound graphics pipeline have been recorded within the render pass instance, then the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat specified by this pipeline must match that set in the previous pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-06195", "If pipeline is a graphics pipeline, this command has been called inside a render pass instance started with vkCmdBeginRendering, and commands using the previously bound graphics pipeline have been recorded within the render pass instance, then the value of VkPipelineRenderingCreateInfo::colorAttachmentCount specified by this pipeline must match that set in the previous pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-06196", "If pipeline is a graphics pipeline, this command has been called inside a render pass instance started with vkCmdBeginRendering, and commands using the previously bound graphics pipeline have been recorded within the render pass instance, then the elements of VkPipelineRenderingCreateInfo::pColorAttachmentFormats specified by this pipeline must match that set in the previous pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-06197", "If pipeline is a graphics pipeline, this command has been called inside a render pass instance started with vkCmdBeginRendering, and commands using the previously bound graphics pipeline have been recorded within the render pass instance, then the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat specified by this pipeline must match that set in the previous pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-06856", "If pipeline is a graphics pipeline, this command has been called inside a render pass instance started with vkCmdBeginRendering, and the pNext chain of VkRenderingInfo includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then the value of VkGraphicsPipelineCreateInfo::pMultisampleState::rasterizationSamples must be equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples.", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-00777", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, the VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-00778", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, the VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-00779", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, pipeline must be a compute pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-00780", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline must be a graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-02391", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, the VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-02392", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline must be a ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-04881", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS and the provokingVertexModePerPipeline limit is VK_FALSE, then pipeline's VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::provokingVertexMode must be the same as that of any other pipelines previously bound to this bind point within the current render pass instance, including any pipeline already bound when beginning the render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-04949", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, the VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-04950", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, pipeline must be a subpass shading pipeline", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-06653", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline must have been created without VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-06721", "If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineProtectedAccess-07408", "If the pipelineProtectedAccess feature is enabled, and commandBuffer is a protected command buffer, pipeline must have been created without VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-pipelineProtectedAccess-07409", "If the pipelineProtectedAccess feature is enabled, and commandBuffer is not a protected command buffer, pipeline must have been created without VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-variableSampleLocations-01525", "If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE, and pipeline is a graphics pipeline created with a VkPipelineSampleLocationsStateCreateInfoEXT structure having its sampleLocationsEnable member set to VK_TRUE but without VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the current render pass instance must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sampleLocationsInfo specified in VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was created", "1.3-extensions"},
    {"VUID-vkCmdBindPipeline-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-commonparent", "Both of commandBuffer, and pipeline must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-deviceGeneratedCommands-02896", "The deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-groupIndex-02893", "groupIndex must be 0 or less than the effective VkGraphicsPipelineShaderGroupsCreateInfoNV::groupCount including the referenced pipelines", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-groupIndex-02895", "The same restrictions as vkCmdBindPipeline apply as if the bound pipeline was created only with the Shader Group from the groupIndex information", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-02894", "The pipelineBindPoint must be VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-vkCmdBindPipelineShaderGroupNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-None-02058", "The shadingRateImage feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-commonparent", "Both of commandBuffer, and imageView that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageLayout-02063", "If imageView is not VK_NULL_HANDLE, imageLayout must be VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageView-02059", "If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageView-02060", "If imageView is not VK_NULL_HANDLE, it must have a format of VK_FORMAT_R8_UINT", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageView-02061", "If imageView is not VK_NULL_HANDLE, it must have been created with a usage value including VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageView-02062", "If imageView is not VK_NULL_HANDLE, imageLayout must match the actual VkImageLayout of each subresource accessible from imageView at the time the subresource is accessed", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-imageView-parameter", "If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-vkCmdBindShadingRateImageNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-None-02365", "Transform feedback must not be active when the vkCmdBindTransformFeedbackBuffersEXT command is recorded", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-bindingCount-arraylength", "bindingCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-commonparent", "Both of commandBuffer, and the elements of pBuffers must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02356", "firstBinding must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02357", "The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-02360", "All elements of pBuffers must have been created with the VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT flag", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-02364", "Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-parameter", "pBuffers must be a valid pointer to an array of bindingCount valid VkBuffer handles", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02358", "All elements of pOffsets must be less than the size of the corresponding element in pBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02359", "All elements of pOffsets must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02363", "All elements of pOffsets plus pSizes, where the pSizes, element is not VK_WHOLE_SIZE, must be less than or equal to the size of the corresponding buffer in pBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-parameter", "pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pSize-02361", "If the optional pSize array is specified, each element of pSizes must either be VK_WHOLE_SIZE, or be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferSize", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-pSizes-02362", "All elements of pSizes must be either VK_WHOLE_SIZE, or less than or equal to the size of the corresponding buffer in pBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-transformFeedback-02355", "VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBindTransformFeedbackBuffersEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-bindingCount-arraylength", "bindingCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-commonparent", "Both of commandBuffer, and the elements of pBuffers that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-firstBinding-00624", "firstBinding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-firstBinding-00625", "The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pBuffers-00627", "All elements of pBuffers must have been created with the VK_BUFFER_USAGE_VERTEX_BUFFER_BIT flag", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pBuffers-00628", "Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pBuffers-04001", "If the nullDescriptor feature is not enabled, all elements of pBuffers must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pBuffers-04002", "If an element of pBuffers is VK_NULL_HANDLE, then the corresponding element of pOffsets must be zero", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pBuffers-parameter", "pBuffers must be a valid pointer to an array of bindingCount valid or VK_NULL_HANDLE VkBuffer handles", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pOffsets-00626", "All elements of pOffsets must be less than the size of the corresponding element in pBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-pOffsets-parameter", "pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-bindingCount-arraylength", "If any of pSizes, or pStrides are not NULL, bindingCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-commonparent", "Both of commandBuffer, and the elements of pBuffers that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-firstBinding-03355", "firstBinding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-firstBinding-03356", "The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pBuffers-03359", "All elements of pBuffers must have been created with the VK_BUFFER_USAGE_VERTEX_BUFFER_BIT flag", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pBuffers-03360", "Each element of pBuffers that is non-sparse must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pBuffers-04111", "If the nullDescriptor feature is not enabled, all elements of pBuffers must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pBuffers-04112", "If an element of pBuffers is VK_NULL_HANDLE, then the corresponding element of pOffsets must be zero", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pBuffers-parameter", "pBuffers must be a valid pointer to an array of bindingCount valid or VK_NULL_HANDLE VkBuffer handles", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pOffsets-03357", "All elements of pOffsets must be less than the size of the corresponding element in pBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pOffsets-parameter", "pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pSizes-03358", "If pSizes is not NULL, all elements of pOffsets plus pSizes must be less than or equal to the size of the corresponding element in pBuffers", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pSizes-parameter", "If pSizes is not NULL, pSizes must be a valid pointer to an array of bindingCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pStrides-03362", "If pStrides is not NULL each element of pStrides must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pStrides-06209", "If pStrides is not NULL each element of pStrides must be either 0 or greater than or equal to the maximum extent of all vertex input attributes fetched from the corresponding binding, where the extent is calculated as the VkVertexInputAttributeDescription::offset plus VkVertexInputAttributeDescription::format size", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-pStrides-parameter", "If pStrides is not NULL, pStrides must be a valid pointer to an array of bindingCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdBindVertexBuffers2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-aspectMask-00241", "For each element of pRegions, srcSubresource.aspectMask must specify aspects present in srcImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-aspectMask-00242", "For each element of pRegions, dstSubresource.aspectMask must specify aspects present in dstImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commandBuffer-01834", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commandBuffer-01835", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commandBuffer-01836", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-commonparent", "Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-00224", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-00225", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-00234", "dstImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-00250", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffsets[0].y must be 0 and dstOffsets[1].y must be 1", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-00252", "If dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, dstOffsets[0].z must be 0 and dstOffsets[1].z must be 1", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-02000", "The format features of dstImage must contain VK_FORMAT_FEATURE_BLIT_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-02545", "dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-06422", "dstImage must not use a format that requires a sampler {YCbCr} conversion", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImageLayout-00226", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImageLayout-00227", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdBlitImage-dstImageLayout-01399", "dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstOffset-00248", "For each element of pRegions, dstOffsets[0].x and dstOffsets[1].x must both be greater than or equal to 0 and less than or equal to the width of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstOffset-00249", "For each element of pRegions, dstOffsets[0].y and dstOffsets[1].y must both be greater than or equal to 0 and less than or equal to the height of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstOffset-00251", "For each element of pRegions, dstOffsets[0].z and dstOffsets[1].z must both be greater than or equal to 0 and less than or equal to the depth of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstSubresource-01706", "The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-dstSubresource-01708", "The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-filter-00237", "If filter is VK_FILTER_CUBIC_EXT, srcImage must be of type VK_IMAGE_TYPE_2D", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-filter-02001", "If filter is VK_FILTER_LINEAR, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-filter-02002", "If filter is VK_FILTER_CUBIC_EXT, then the format features of srcImage must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-filter-parameter", "filter must be a valid VkFilter value", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-pRegions-00215", "The source region specified by each element of pRegions must be a region that is contained within srcImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-pRegions-00216", "The destination region specified by each element of pRegions must be a region that is contained within dstImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-pRegions-00217", "The union of all destination regions, specified by the elements of pRegions, must not overlap in memory with any texel that may be sampled during the blit operation", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkImageBlit structures", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00219", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00220", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00229", "If either of srcImage or dstImage was created with a signed integer VkFormat, the other must also have been created with a signed integer VkFormat", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00230", "If either of srcImage or dstImage was created with an unsigned integer VkFormat, the other must also have been created with an unsigned integer VkFormat", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00231", "If either of srcImage or dstImage was created with a depth/stencil format, the other must have exactly the same format", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00232", "If srcImage was created with a depth/stencil format, filter must be VK_FILTER_NEAREST", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00233", "srcImage must have been created with a samples value of VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00240", "If either srcImage or dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer and dstSubresource.baseArrayLayer must each be 0, and srcSubresource.layerCount and dstSubresource.layerCount must each be 1", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00245", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffsets[0].y must be 0 and srcOffsets[1].y must be 1", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-00247", "If srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, srcOffsets[0].z must be 0 and srcOffsets[1].z must be 1", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-01999", "The format features of srcImage must contain VK_FORMAT_FEATURE_BLIT_SRC_BIT", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-06421", "srcImage must not use a format that requires a sampler {YCbCr} conversion", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImageLayout-00221", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImageLayout-00222", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdBlitImage-srcImageLayout-01398", "srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcOffset-00243", "For each element of pRegions, srcOffsets[0].x and srcOffsets[1].x must both be greater than or equal to 0 and less than or equal to the width of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcOffset-00244", "For each element of pRegions, srcOffsets[0].y and srcOffsets[1].y must both be greater than or equal to 0 and less than or equal to the height of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcOffset-00246", "For each element of pRegions, srcOffsets[0].z and srcOffsets[1].z must both be greater than or equal to 0 and less than or equal to the depth of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcSubresource-01705", "The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-srcSubresource-01707", "The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdBlitImage-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-commandBuffer-01834", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-commandBuffer-01835", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-commandBuffer-01836", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-pBlitImageInfo-parameter", "pBlitImageInfo must be a valid pointer to a valid VkBlitImageInfo2 structure", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBlitImage2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-accelerationStructureReference-03786", "Each VkAccelerationStructureInstanceKHR::accelerationStructureReference value in instanceData must be a valid device address containing a value obtained from vkGetAccelerationStructureHandleNV", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-commonparent", "Each of commandBuffer, dst, instanceData, scratch, and src that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-dst-02488", "dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-dst-parameter", "dst must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241", "geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-instanceData-03523", "If instanceData is not VK_NULL_HANDLE, instanceData must have been created with VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-instanceData-parameter", "If instanceData is not VK_NULL_HANDLE, instanceData must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-pInfo-parameter", "pInfo must be a valid pointer to a valid VkAccelerationStructureInfoNV structure", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-scratch-03522", "scratch must have been created with VK_BUFFER_USAGE_RAY_TRACING_BIT_NV usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-scratch-parameter", "scratch must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-src-parameter", "If src is not VK_NULL_HANDLE, src must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-02489", "If update is VK_TRUE, src must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-02490", "If update is VK_TRUE, src must have previously been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in VkAccelerationStructureInfoNV::flags in the original build", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-02491", "If update is VK_FALSE, the size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-02492", "If update is VK_TRUE, the size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-03524", "If update is VK_TRUE, then objects that were previously active must not be made inactive as per Inactive Primitives and Instances", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-03525", "If update is VK_TRUE, then objects that were previously inactive must not be made active as per Inactive Primitives and Instances", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-update-03526", "If update is VK_TRUE, the src and dst objects must either be the same object or not have any memory aliasing", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructureNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-None-03407", "The dstAccelerationStructure member of any element of pInfos must not be referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR in any other element of pInfos", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-accelerationStructureIndirectBuild-03650", "The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureIndirectBuild feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-03649", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03698", "The dstAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03701", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the srcAccelerationStructure member of any other element of pInfos with a mode equal to VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03702", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the dstAccelerationStructure member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03703", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any element of pInfos (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03706", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing any acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR in any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03800", "The dstAccelerationStructure member of any element of pInfos must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-firstVertex-03770", "For each VkAccelerationStructureBuildRangeInfoKHR referenced by this command, if the corresponding geometry uses indices, its firstVertex member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-geometry-03673", "The buffers from which the buffer device addresses for all of the geometry.triangles.vertexData, geometry.triangles.indexData, geometry.triangles.transformData, geometry.aabbs.data, and geometry.instances.data members of all pInfos[i].pGeometries and pInfos[i].ppGeometries are queried must have been created with the VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-infoCount-arraylength", "infoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-mode-04628", "The mode member of each element of pInfos must be a valid VkBuildAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03645", "For any element of pIndirectDeviceAddresses, if the buffer from which it was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03646", "For any element of pIndirectDeviceAddresses[i], all device addresses between pIndirectDeviceAddresses[i] and pIndirectDeviceAddresses[i] + (pInfos[i].geometryCount {times} pIndirectStrides[i]) - 1 must be in the buffer device address range of the same buffer", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03647", "For any element of pIndirectDeviceAddresses, the buffer from which it was queried must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03648", "Each element of pIndirectDeviceAddresses must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03651", "Each VkAccelerationStructureBuildRangeInfoKHR structure referenced by any element of pIndirectDeviceAddresses must be a valid VkAccelerationStructureBuildRangeInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-parameter", "pIndirectDeviceAddresses must be a valid pointer to an array of infoCount VkDeviceAddress values", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-03787", "Each element of pIndirectStrides must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-parameter", "pIndirectStrides must be a valid pointer to an array of infoCount uint32_t values", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03403", "The srcAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03652", "pInfos[i].dstAccelerationStructure must have been created with a value of VkAccelerationStructureCreateInfoKHR::size greater than or equal to the memory size required by the build operation, as returned by vkGetAccelerationStructureBuildSizesKHR with pBuildInfo = pInfos[i] and pMaxPrimitiveCounts = ppMaxPrimitiveCounts[i]", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03663", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, inactive primitives in its srcAccelerationStructure member must not be made active", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03664", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, active primitives in its srcAccelerationStructure member must not be made inactive", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03667", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must have previously been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR set in VkAccelerationStructureBuildGeometryInfoKHR::flags in the build", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03668", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure and dstAccelerationStructure members must either be the same VkAccelerationStructureKHR, or not have any memory aliasing", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03671", "If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR, all addresses between pInfos[i].scratchData.deviceAddress and pInfos[i].scratchData.deviceAddress + N - 1 must be in the buffer device address range of the same buffer, where N is given by the buildScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03672", "If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, all addresses between pInfos[i].scratchData.deviceAddress and pInfos[i].scratchData.deviceAddress + N - 1 must be in the buffer device address range of the same buffer, where N is given by the updateScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03674", "The buffer from which the buffer device address pInfos[i].scratchData.deviceAddress is queried must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03699", "For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03700", "For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03707", "For each element of pInfos, the buffer used to create its dstAccelerationStructure member must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03708", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the buffer used to create its srcAccelerationStructure member must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03709", "For each element of pInfos, the buffer used to create each acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03710", "For each element of pInfos, its scratchData.deviceAddress member must be a multiple of VkPhysicalDeviceAccelerationStructurePropertiesKHR::minAccelerationStructureScratchOffsetAlignment", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03711", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.deviceAddress must be aligned to the size in bytes of the smallest component of the format in vertexFormat", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03712", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, and with geometry.triangles.indexType not equal to VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.deviceAddress must be aligned to the size in bytes of the type in indexType", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03714", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.deviceAddress must be aligned to 8 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03715", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.arrayOfPointers is VK_FALSE, geometry.instances.data.deviceAddress must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03716", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.arrayOfPointers is VK_TRUE, geometry.instances.data.deviceAddress must be aligned to 8 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03717", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.arrayOfPointers is VK_TRUE, each element of geometry.instances.data.deviceAddress in device memory must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03758", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its geometryCount member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03759", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its flags member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03760", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its type member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03761", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, its geometryType member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03762", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, its flags member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03763", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.vertexFormat member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03764", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.maxVertex member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03765", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.indexType member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03766", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, if its geometry.triangles.transformData address was NULL when srcAccelerationStructure was last built, then it must be NULL", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03767", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, if its geometry.triangles.transformData address was not NULL when srcAccelerationStructure was last built, then it must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03768", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, and geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, then the value of each index referenced must be the same as the corresponding index value when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03801", "For each element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, the corresponding pname:ppMaxPrimitiveCounts[i][j] must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxInstanceCount", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03802", "For each element of pInfos, its scratchData.deviceAddress member must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03803", "For each element of pInfos, if scratchData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03804", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03805", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.vertexData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03806", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03807", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, if geometry.triangles.indexData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03808", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03809", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03810", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03811", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03812", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, if geometry.aabbs.data.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03813", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, geometry.instances.data.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03814", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.instances.data.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-04630", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-06707", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, each VkAccelerationStructureInstanceKHR::accelerationStructureReference value in geometry.instances.data.deviceAddress must be a valid device address containing a value obtained from vkGetAccelerationStructureDeviceAddressKHR or 0", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-parameter", "pInfos must be a valid pointer to an array of infoCount valid VkAccelerationStructureBuildGeometryInfoKHR structures", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-03653", "Each ppMaxPrimitiveCounts[i][j] must be greater than or equal to the the primitiveCount value specified by the VkAccelerationStructureBuildRangeInfoKHR structure located at pIndirectDeviceAddresses[i] + (j {times} pIndirectStrides[i])", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-ppMaxPrimitiveCounts-parameter", "ppMaxPrimitiveCounts must be a valid pointer to an array of infoCount uint32_t values", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-primitiveCount-03769", "For each VkAccelerationStructureBuildRangeInfoKHR referenced by this command, its primitiveCount member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-scratchData-03704", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-scratchData-03705", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the srcAccelerationStructure member of any element of pInfos with a mode equal to VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-srcAccelerationStructure-04629", "If the srcAccelerationStructure member of any element of pInfos is not VK_NULL_HANDLE, the srcAccelerationStructure member must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-None-03407", "The dstAccelerationStructure member of any element of pInfos must not be referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR in any other element of pInfos", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03698", "The dstAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03701", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the srcAccelerationStructure member of any other element of pInfos with a mode equal to VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03702", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the dstAccelerationStructure member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03703", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any element of pInfos (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03706", "The range of memory backing the dstAccelerationStructure member of any element of pInfos that is accessed by this command must not overlap the memory backing any acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR in any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03800", "The dstAccelerationStructure member of any element of pInfos must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-firstVertex-03770", "For each VkAccelerationStructureBuildRangeInfoKHR referenced by this command, if the corresponding geometry uses indices, its firstVertex member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-geometry-03673", "The buffers from which the buffer device addresses for all of the geometry.triangles.vertexData, geometry.triangles.indexData, geometry.triangles.transformData, geometry.aabbs.data, and geometry.instances.data members of all pInfos[i].pGeometries and pInfos[i].ppGeometries are queried must have been created with the VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-infoCount-arraylength", "infoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-mode-04628", "The mode member of each element of pInfos must be a valid VkBuildAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03403", "The srcAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03663", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, inactive primitives in its srcAccelerationStructure member must not be made active", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03664", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, active primitives in its srcAccelerationStructure member must not be made inactive", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03667", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must have previously been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR set in VkAccelerationStructureBuildGeometryInfoKHR::flags in the build", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03668", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure and dstAccelerationStructure members must either be the same VkAccelerationStructureKHR, or not have any memory aliasing", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03671", "If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR, all addresses between pInfos[i].scratchData.deviceAddress and pInfos[i].scratchData.deviceAddress + N - 1 must be in the buffer device address range of the same buffer, where N is given by the buildScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03672", "If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, all addresses between pInfos[i].scratchData.deviceAddress and pInfos[i].scratchData.deviceAddress + N - 1 must be in the buffer device address range of the same buffer, where N is given by the updateScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03674", "The buffer from which the buffer device address pInfos[i].scratchData.deviceAddress is queried must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03675", "For each pInfos[i], dstAccelerationStructure must have been created with a value of VkAccelerationStructureCreateInfoKHR::size greater than or equal to the memory size required by the build operation, as returned by vkGetAccelerationStructureBuildSizesKHR with pBuildInfo = pInfos[i] and with each element of the pMaxPrimitiveCounts array greater than or equal to the equivalent ppBuildRangeInfos[i][j].primitiveCount values for j in [0,pInfos[i].geometryCount)", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03699", "For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03700", "For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03707", "For each element of pInfos, the buffer used to create its dstAccelerationStructure member must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03708", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the buffer used to create its srcAccelerationStructure member must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03709", "For each element of pInfos, the buffer used to create each acceleration structure referenced by the geometry.instances.data member of any element of pGeometries or ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03710", "For each element of pInfos, its scratchData.deviceAddress member must be a multiple of VkPhysicalDeviceAccelerationStructurePropertiesKHR::minAccelerationStructureScratchOffsetAlignment", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03711", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.deviceAddress must be aligned to the size in bytes of the smallest component of the format in vertexFormat", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03712", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, and with geometry.triangles.indexType not equal to VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.deviceAddress must be aligned to the size in bytes of the type in indexType", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03714", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.deviceAddress must be aligned to 8 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03715", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.arrayOfPointers is VK_FALSE, geometry.instances.data.deviceAddress must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03716", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.arrayOfPointers is VK_TRUE, geometry.instances.data.deviceAddress must be aligned to 8 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03717", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.arrayOfPointers is VK_TRUE, each element of geometry.instances.data.deviceAddress in device memory must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03758", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its geometryCount member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03759", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its flags member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03760", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its type member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03761", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, its geometryType member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03762", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, its flags member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03763", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.vertexFormat member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03764", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.maxVertex member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03765", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, its geometry.triangles.indexType member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03766", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, if its geometry.triangles.transformData address was NULL when srcAccelerationStructure was last built, then it must be NULL", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03767", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, if its geometry.triangles.transformData address was not NULL when srcAccelerationStructure was last built, then it must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03768", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, if geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR, and geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, then the value of each index referenced must be the same as the corresponding index value when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03801", "For each element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, the corresponding pname:ppBuildRangeInfos[i][j].pname:primitiveCount must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxInstanceCount", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03802", "For each element of pInfos, its scratchData.deviceAddress member must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03803", "For each element of pInfos, if scratchData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03804", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03805", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.vertexData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03806", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03807", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, if geometry.triangles.indexData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03808", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03809", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03810", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03811", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03812", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, if geometry.aabbs.data.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03813", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, geometry.instances.data.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03814", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, if geometry.instances.data.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-04630", "For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-06707", "For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, each VkAccelerationStructureInstanceKHR::accelerationStructureReference value in geometry.instances.data.deviceAddress must be a valid device address containing a value obtained from vkGetAccelerationStructureDeviceAddressKHR or 0", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-parameter", "pInfos must be a valid pointer to an array of infoCount valid VkAccelerationStructureBuildGeometryInfoKHR structures", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-ppBuildRangeInfos-03676", "Each element of ppBuildRangeInfos[i] must be a valid pointer to an array of pInfos[i].geometryCount VkAccelerationStructureBuildRangeInfoKHR structures", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-ppBuildRangeInfos-parameter", "ppBuildRangeInfos must be a valid pointer to an array of infoCount VkAccelerationStructureBuildRangeInfoKHR structures", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-primitiveCount-03769", "For each VkAccelerationStructureBuildRangeInfoKHR referenced by this command, its primitiveCount member must have the same value which was specified when srcAccelerationStructure was last built", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-scratchData-03704", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-scratchData-03705", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the srcAccelerationStructure member of any element of pInfos with a mode equal to VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-srcAccelerationStructure-04629", "If the srcAccelerationStructure member of any element of pInfos is not VK_NULL_HANDLE, the srcAccelerationStructure member must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkCmdBuildAccelerationStructuresKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-data-07510", "The buffers from which the buffer device addresses for all of the data and triangleArray members of all pInfos[i] are queried must have been created with the VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-dstMicromap-07463", "The dstMicromap member of any element of pInfos must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-dstMicromap-07465", "The range of memory backing the dstMicromap member of any element of pInfos that is accessed by this command must not overlap the memory backing the dstMicromap member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-dstMicromap-07466", "The range of memory backing the dstMicromap member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any element of pInfos (including the same element), which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-infoCount-arraylength", "infoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-mode-07462", "The mode member of each element of pInfos must be a valid VkBuildMicromapModeEXT value", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07461", "For each pInfos[i], dstMicromap must have been created with a value of VkMicromapCreateInfoEXT::size greater than or equal to the memory size required by the build operation, as returned by vkGetMicromapBuildSizesEXT with pBuildInfo = pInfos[i]", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07464", "For each element of pInfos its type member must match the value of VkMicromapCreateInfoEXT::type when its dstMicromap was created", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07508", "For each element of pInfos, the buffer used to create its dstMicromap member must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07509", "If pInfos[i].mode is VK_BUILD_MICROMAP_MODE_BUILD_EXT, all addresses between pInfos[i].scratchData.deviceAddress and pInfos[i].scratchData.deviceAddress + N - 1 must be in the buffer device address range of the same buffer, where N is given by the buildScratchSize member of the VkMicromapBuildSizesInfoEXT structure returned from a call to vkGetMicromapBuildSizesEXT with an identical VkMicromapBuildInfoEXT structure and primitive count", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07511", "For each element of pInfos[i] the buffer from which the buffer device address pInfos[i].scratchData.deviceAddress is queried must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07512", "For each element of pInfos, its scratchData.deviceAddress, data.deviceAddress, and triangleArray.deviceAddress members must be valid device addresses obtained from vkGetBufferDeviceAddress", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07513", "For each element of pInfos, if scratchData.deviceAddress, data.deviceAddress, or triangleArray.deviceAddress is the address of a non-sparse buffer then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07514", "For each element of pInfos, its scratchData.deviceAddress member must be a multiple of VkPhysicalDeviceAccelerationStructurePropertiesKHR::minAccelerationStructureScratchOffsetAlignment", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-07515", "For each element of pInfos, its triangleArray.deviceAddress and data.deviceAddress members must be a multiple of 256", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-pInfos-parameter", "pInfos must be a valid pointer to an array of infoCount valid VkMicromapBuildInfoEXT structures", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-scratchData-07467", "The range of memory backing the scratchData member of any element of pInfos that is accessed by this command must not overlap the memory backing the scratchData member of any other element of pInfos, which is accessed by this command", "1.3-extensions"},
    {"VUID-vkCmdBuildMicromapsEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-aspectMask-07271", "If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_COLOR_BIT, the colorAttachment must be a valid color attachment index in the current render pass instance", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-attachmentCount-arraylength", "attachmentCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-baseArrayLayer-00018", "If the render pass instance this is recorded in uses multiview, then baseArrayLayer must be zero and layerCount must be one", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-commandBuffer-02504", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, each attachment to be cleared must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-commandBuffer-02505", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, each attachment to be cleared must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-layerCount-01934", "The layerCount member of each element of pRects must not be 0", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-pAttachments-07270", "For each element of pAttachments, the corresponding attachment in the current render pass instance must either not be backed by an image view, or contain each of the aspects specified in aspectMask", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-pAttachments-parameter", "pAttachments must be a valid pointer to an array of attachmentCount valid VkClearAttachment structures", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-pRects-00016", "The rectangular region specified by each element of pRects must be contained within the render area of the current render pass instance", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-pRects-06937", "The layers specified by each element of pRects must be contained within every attachment that pAttachments refers to, i.e. for each element of pRects, VkClearRect::baseArrayLayer VkClearRect::layerCount must be less than or equal to the number of layers rendered to in the current render pass instance", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-pRects-parameter", "pRects must be a valid pointer to an array of rectCount VkClearRect structures", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-rect-02682", "The rect member of each element of pRects must have an extent.width greater than 0", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-rect-02683", "The rect member of each element of pRects must have an extent.height greater than 0", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-rectCount-arraylength", "rectCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdClearAttachments-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-aspectMask-02498", "The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-baseArrayLayer-01472", "The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-baseMipLevel-01470", "The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-commandBuffer-01805", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, image must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-commandBuffer-01806", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-commonparent", "Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-image-00002", "image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-image-00003", "If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-image-00007", "image must not have a compressed or depth/stencil format", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-image-01545", "image must not use any of the formats that require a sampler {YCbCr} conversion", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-image-01993", "The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-imageLayout-00004", "imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-imageLayout-00005", "imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdClearColorImage-imageLayout-01394", "imageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-pColor-04961", "pColor must be a valid pointer to a VkClearColorValue union", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-pRanges-01692", "For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-pRanges-01693", "For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-pRanges-parameter", "pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-rangeCount-arraylength", "rangeCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdClearColorImage-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-aspectMask-02824", "The VkImageSubresourceRange::aspectMask member of each element of the pRanges array must not include bits other than VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-baseArrayLayer-01476", "The VkImageSubresourceRange::baseArrayLayer members of the elements of the pRanges array must each be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-baseMipLevel-01474", "The VkImageSubresourceRange::baseMipLevel members of the elements of the pRanges array must each be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-commandBuffer-01807", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, image must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-commandBuffer-01808", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, image must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-commonparent", "Both of commandBuffer, and image must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-00009", "image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.1-khr-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-00010", "If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-00014", "image must have a depth/stencil format", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-01994", "The format features of image must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-02825", "If the image's format does not have a stencil component, then the VkImageSubresourceRange::aspectMask member of each element of the pRanges array must not include the VK_IMAGE_ASPECT_STENCIL_BIT bit", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-02826", "If the image's format does not have a depth component, then the VkImageSubresourceRange::aspectMask member of each element of the pRanges array must not include the VK_IMAGE_ASPECT_DEPTH_BIT bit", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-imageLayout-00011", "imageLayout must specify the layout of the image subresource ranges of image specified in pRanges at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-imageLayout-00012", "imageLayout must be either of VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-imageLayout-parameter", "imageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter", "pDepthStencil must be a valid pointer to a valid VkClearDepthStencilValue structure", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pRanges-01694", "For each VkImageSubresourceRange element of pRanges, if the levelCount member is not VK_REMAINING_MIP_LEVELS, then baseMipLevel + levelCount must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pRanges-01695", "For each VkImageSubresourceRange element of pRanges, if the layerCount member is not VK_REMAINING_ARRAY_LAYERS, then baseArrayLayer + layerCount must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pRanges-02658", "If the aspect member of any element of pRanges includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageStencilUsageCreateInfo::stencilUsage used to create image", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pRanges-02659", "If the aspect member of any element of pRanges includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pRanges-02660", "If the aspect member of any element of pRanges includes VK_IMAGE_ASPECT_DEPTH_BIT, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-pRanges-parameter", "pRanges must be a valid pointer to an array of rangeCount valid VkImageSubresourceRange structures", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength", "rangeCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdClearDepthStencilImage-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-parameter", "pCodingControlInfo must be a valid pointer to a valid VkVideoCodingControlInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdControlVideoCodingKHR-videocoding", "This command must only be called inside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-buffer-03737", "The buffer used to create pInfo->src must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-buffer-03738", "The buffer used to create pInfo->dst must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyAccelerationStructureInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-buffer-03718", "The buffer used to create src must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-buffer-03719", "The buffer used to create dst must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-commonparent", "Each of commandBuffer, dst, and src must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-dst-parameter", "dst must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-mode-03410", "mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-mode-parameter", "mode must be a valid VkCopyAccelerationStructureModeKHR value", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-src-03411", "If mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR, src must have been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR in the build", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-src-04963", "The source acceleration structure src must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-src-parameter", "src must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-None-03559", "The buffer used to create pInfo->src must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03739", "pInfo->dst.deviceAddress must be a valid device address for a buffer bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03740", "pInfo->dst.deviceAddress must be aligned to 256 bytes", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03741", "If the buffer pointed to by pInfo->dst.deviceAddress is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyAccelerationStructureToMemoryInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commandBuffer-01822", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commandBuffer-01823", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commandBuffer-01824", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-commonparent", "Each of commandBuffer, dstBuffer, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-dstBuffer-00120", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-dstBuffer-00121", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-dstOffset-00114", "The dstOffset member of each element of pRegions must be less than the size of dstBuffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-pRegions-00117", "The union of the source regions, and the union of the destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkBufferCopy structures", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-size-00115", "The size member of each element of pRegions must be less than or equal to the size of srcBuffer minus srcOffset", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-size-00116", "The size member of each element of pRegions must be less than or equal to the size of dstBuffer minus dstOffset", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-srcBuffer-00118", "srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-srcBuffer-00119", "If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-srcBuffer-parameter", "srcBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-srcOffset-00113", "The srcOffset member of each element of pRegions must be less than the size of srcBuffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-commandBuffer-01822", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-commandBuffer-01823", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-commandBuffer-01824", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-pCopyBufferInfo-parameter", "pCopyBufferInfo must be a valid pointer to a valid VkCopyBufferInfo2 structure", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyBuffer2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-None-00214", "For each element of pRegions whose imageSubresource contains a depth aspect, the data in srcBuffer must be in the range [0,1]", "1.3-khr-extensions"},
    {"VUID-vkCmdCopyBufferToImage-aspectMask-00211", "For each element of pRegions, imageSubresource.aspectMask must specify aspects present in pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-aspectMask-01560", "If pname:dstImage has a multi-planar format, then for each element of pRegions, imageSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-baseArrayLayer-00213", "If pname:dstImage is of type VK_IMAGE_TYPE_3D, for each element of pRegions, imageSubresource.baseArrayLayer must be 0 and imageSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-bufferImageHeight-00204", "For each element of pRegions, bufferImageHeight must be a multiple of the texel block extent height of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-bufferOffset-00193", "If pname:dstImage does not have a depth/stencil format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "1.0"},
    {"VUID-vkCmdCopyBufferToImage-bufferOffset-01558", "If pname:dstImage does not have either a depth/stencil or a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-bufferOffset-01559", "If pname:dstImage has a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in Compatible formats of planes of multi-planar formats", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-bufferRowLength-00203", "For each element of pRegions, bufferRowLength must be a multiple of the texel block extent width of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-01828", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-01829", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-01830", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-04052", "If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-04477", "If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT, for each element of pRegions, the aspectMask member of imageSubresource must not be VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-commonparent", "Each of commandBuffer, dstImage, and srcBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImage-00177", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImage-00178", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImage-00179", "dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImage-01997", "The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImage-02543", "dstImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImageLayout-00180", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImageLayout-00181", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdCopyBufferToImage-dstImageLayout-01396", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageExtent-00207", "For each element of pRegions, if the sum of imageOffset.x and extent.width does not equal the width of the the subresource specified by srcSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageExtent-00208", "For each element of pRegions, if the sum of imageOffset.y and extent.height does not equal the height of the the subresource specified by srcSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageExtent-00209", "For each element of pRegions, if the sum of imageOffset.z and extent.depth does not equal the depth of the the subresource specified by srcSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageOffset-00200", "For each element of pRegions, imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified imageSubresource of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageOffset-01793", "The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageSubresource-01701", "The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-imageSubresource-01702", "The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-00171", "srcBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-00173", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-06217", "The image region specified by each element of pRegions must be contained within the specified imageSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-06218", "For each element of pRegions, imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified imageSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-06219", "For each element of pRegions, imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified imageSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-07273", "For each element of pRegions, bufferOffset must be a multiple of the texel block size of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-07274", "For each element of pRegions, imageOffset.x must be a multiple of the texel block extent width of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-07275", "For each element of pRegions, imageOffset.y must be a multiple of the texel block extent height of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-07276", "For each element of pRegions, imageOffset.z must be a multiple of the texel block extent depth of the VkFormat of pname:dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-07277", "For each element of pRegions, bufferRowLength divided by the texel block extent width and then multiplied by the texel block size of pname:dstImage must be less than or equal to 231-1", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-srcBuffer-00174", "srcBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-srcBuffer-00176", "If srcBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-srcBuffer-parameter", "srcBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-srcImage-00199", "If pname:dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, imageOffset.y must be 0 and imageExtent.height must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-srcImage-00201", "If pname:dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, imageOffset.z must be 0 and imageExtent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-srcImage-04053", "If pname:dstImage has a depth/stencil format, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-commandBuffer-01828", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-commandBuffer-01829", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-commandBuffer-01830", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-pCopyBufferToImageInfo-parameter", "pCopyBufferToImageInfo must be a valid pointer to a valid VkCopyBufferToImageInfo2 structure", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyBufferToImage2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-None-01549", "In a copy to or from a plane of a multi-planar image, the VkFormat of the image and plane must be compatible according to the description of compatible planes for the plane being copied", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-aspect-06662", "If the aspect member of any element of pRegions includes any flag other than VK_IMAGE_ASPECT_STENCIL_BIT or srcImage was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_SRC_BIT must have been included in the VkImageCreateInfo::usage used to create srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-aspect-06663", "If the aspect member of any element of pRegions includes any flag other than VK_IMAGE_ASPECT_STENCIL_BIT or dstImage was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-aspect-06664", "If the aspect member of any element of pRegions includes VK_IMAGE_ASPECT_STENCIL_BIT, and srcImage was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_SRC_BIT must have been included in the VkImageStencilUsageCreateInfo::stencilUsage used to create srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-aspect-06665", "If the aspect member of any element of pRegions includes VK_IMAGE_ASPECT_STENCIL_BIT, and dstImage was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageStencilUsageCreateInfo::stencilUsage used to create dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-aspectMask-00142", "For each element of pRegions, srcSubresource.aspectMask must specify aspects present in srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-aspectMask-00143", "For each element of pRegions, dstSubresource.aspectMask must specify aspects present in dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commandBuffer-01825", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commandBuffer-01826", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commandBuffer-01827", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-commonparent", "Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-00131", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.1-khr-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-00132", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.0"},
    {"VUID-vkCmdCopyImage-dstImage-00152", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01547", "If dstImage is non-sparse then the image or disjoint plane that is the destination of the copy must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01554", "If dstImage has a VkFormat with two planes then for each element of pRegions, dstSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01555", "If dstImage has a VkFormat with three planes then for each element of pRegions, dstSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01557", "If dstImage has a multi-planar image format and the srcImage does not have a multi-planar image format, then for each element of pRegions, srcSubresource.aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01732", "For each element of pRegions, if the sum of dstOffset.x and extent.width does not equal the width of the the subresource specified by dstSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01733", "For each element of pRegions, if the sum of dstOffset.y and extent.height does not equal the height of the the subresource specified by dstSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01734", "For each element of pRegions, if the sum of dstOffset.z and extent.depth does not equal the depth of the the subresource specified by dstSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01786", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01788", "If dstImage is of type VK_IMAGE_TYPE_2D, then for each element of pRegions, dstOffset.z must be 0", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01792", "If dstImage is of type VK_IMAGE_TYPE_2D, and srcImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, extent.depth must equal dstSubresource.layerCount", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-01996", "The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-02542", "dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-04444", "If dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, dstSubresource.baseArrayLayer must be 0 and dstSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImageLayout-00133", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImageLayout-00134", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdCopyImage-dstImageLayout-01395", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstOffset-00150", "For each element of pRegions, dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstOffset-00151", "For each element of pRegions, dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstOffset-00153", "If dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstOffset-01784", "The dstOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstSubresource-01697", "The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-dstSubresource-01699", "The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-00124", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-07278", "For each element of pRegions, srcOffset.x must be a multiple of the texel block extent width of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-07279", "For each element of pRegions, srcOffset.y must be a multiple of the texel block extent height of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-07280", "For each element of pRegions, srcOffset.z must be a multiple of the texel block extent depth of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-07281", "For each element of pRegions, dstOffset.x must be a multiple of the texel block extent width of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-07282", "For each element of pRegions, dstOffset.y must be a multiple of the texel block extent height of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-07283", "For each element of pRegions, dstOffset.z must be a multiple of the texel block extent depth of the VkFormat of dstImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkImageCopy structures", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-00126", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.1-khr-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-00127", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.0"},
    {"VUID-vkCmdCopyImage-srcImage-00135", "The VkFormat of each of srcImage and dstImage must be size-compatible", "1.0"},
    {"VUID-vkCmdCopyImage-srcImage-00136", "The sample count of srcImage and dstImage must match", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-00139", "If either srcImage or dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer and dstSubresource.baseArrayLayer must each be 0, and srcSubresource.layerCount and dstSubresource.layerCount must each be 1", "1.0"},
    {"VUID-vkCmdCopyImage-srcImage-00146", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01546", "If srcImage is non-sparse then the image or disjoint plane to be copied must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01548", "If the VkFormat of each of srcImage and dstImage is not a multi-planar format, the VkFormat of each of srcImage and dstImage must be size-compatible", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01551", "If neither srcImage nor dstImage has a multi-planar image format then for each element of pRegions, srcSubresource.aspectMask and dstSubresource.aspectMask must match", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01552", "If srcImage has a VkFormat with two planes then for each element of pRegions, srcSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01553", "If srcImage has a VkFormat with three planes then for each element of pRegions, srcSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01556", "If srcImage has a multi-planar image format and the dstImage does not have a multi-planar image format, then for each element of pRegions, dstSubresource.aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01728", "For each element of pRegions, if the sum of srcOffset.x and extent.width does not equal the width of the the subresource specified by srcSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01729", "For each element of pRegions, if the sum of srcOffset.y and extent.height does not equal the height of the the subresource specified by srcSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01730", "For each element of pRegions, if the sum of srcOffset.z and extent.depth does not equal the depth of the the subresource specified by srcSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01785", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01787", "If srcImage is of type VK_IMAGE_TYPE_2D, then for each element of pRegions, srcOffset.z must be 0", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01789", "If srcImage or dstImage is of type VK_IMAGE_TYPE_2D, then for each element of pRegions, extent.depth must be 1", "1.0"},
    {"VUID-vkCmdCopyImage-srcImage-01790", "If srcImage and dstImage are both of type VK_IMAGE_TYPE_2D, then for each element of pRegions, extent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01791", "If srcImage is of type VK_IMAGE_TYPE_2D, and dstImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, extent.depth must equal srcSubresource.layerCount", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-01995", "The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-04443", "If srcImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer must be 0 and srcSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImageLayout-00128", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImageLayout-00129", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdCopyImage-srcImageLayout-01917", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcOffset-00144", "For each element of pRegions, srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcOffset-00145", "For each element of pRegions, srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcOffset-00147", "If srcImage is of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcOffset-01783", "The srcOffset and extent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcSubresource-01696", "The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-srcSubresource-01698", "The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyImage-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-commandBuffer-01825", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-commandBuffer-01826", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-commandBuffer-01827", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-pCopyImageInfo-parameter", "pCopyImageInfo must be a valid pointer to a valid VkCopyImageInfo2 structure", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyImage2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-aspectMask-00211", "For each element of pRegions, imageSubresource.aspectMask must specify aspects present in pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-aspectMask-01560", "If pname:srcImage has a multi-planar format, then for each element of pRegions, imageSubresource.aspectMask must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT (with VK_IMAGE_ASPECT_PLANE_2_BIT valid only for image formats with three planes)", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-baseArrayLayer-00213", "If pname:srcImage is of type VK_IMAGE_TYPE_3D, for each element of pRegions, imageSubresource.baseArrayLayer must be 0 and imageSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-bufferImageHeight-00204", "For each element of pRegions, bufferImageHeight must be a multiple of the texel block extent height of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-bufferOffset-00193", "If pname:srcImage does not have a depth/stencil format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "1.0"},
    {"VUID-vkCmdCopyImageToBuffer-bufferOffset-01558", "If pname:srcImage does not have either a depth/stencil or a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the format's texel block size", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-bufferOffset-01559", "If pname:srcImage has a multi-planar format, then for each element of pRegions, bufferOffset must be a multiple of the element size of the compatible format for the format and the aspectMask of the imageSubresource as defined in Compatible formats of planes of multi-planar formats", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-bufferRowLength-00203", "For each element of pRegions, bufferRowLength must be a multiple of the texel block extent width of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-01831", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-01832", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-01833", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-04052", "If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-commonparent", "Each of commandBuffer, dstBuffer, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-dstBuffer-00191", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-dstBuffer-00192", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageExtent-00207", "For each element of pRegions, if the sum of imageOffset.x and extent.width does not equal the width of the the subresource specified by srcSubresource, extent.width must be a multiple of the texel block extent width of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageExtent-00208", "For each element of pRegions, if the sum of imageOffset.y and extent.height does not equal the height of the the subresource specified by srcSubresource, extent.height must be a multiple of the texel block extent height of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageExtent-00209", "For each element of pRegions, if the sum of imageOffset.z and extent.depth does not equal the depth of the the subresource specified by srcSubresource, extent.depth must be a multiple of the texel block extent depth of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageOffset-00200", "For each element of pRegions, imageOffset.z and (imageExtent.depth + imageOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified imageSubresource of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageOffset-01794", "The imageOffset and imageExtent members of each element of pRegions must respect the image transfer granularity requirements of commandBuffer's command pool's queue family, as described in VkQueueFamilyProperties", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageSubresource-01703", "The imageSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-imageSubresource-01704", "The imageSubresource.baseArrayLayer + imageSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-00183", "dstBuffer must be large enough to contain all buffer locations that are accessed according to Buffer and Image Addressing, for each element of pRegions", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-00184", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-06220", "The image region specified by each element of pRegions must be contained within the specified imageSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-06221", "For each element of pRegions, imageOffset.x and (imageExtent.width + imageOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified imageSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-06222", "For each element of pRegions, imageOffset.y and (imageExtent.height + imageOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified imageSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-07273", "For each element of pRegions, bufferOffset must be a multiple of the texel block size of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-07274", "For each element of pRegions, imageOffset.x must be a multiple of the texel block extent width of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-07275", "For each element of pRegions, imageOffset.y must be a multiple of the texel block extent height of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-07276", "For each element of pRegions, imageOffset.z must be a multiple of the texel block extent depth of the VkFormat of pname:srcImage", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-07277", "For each element of pRegions, bufferRowLength divided by the texel block extent width and then multiplied by the texel block size of pname:srcImage must be less than or equal to 231-1", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkBufferImageCopy structures", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-00186", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-00187", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-00188", "srcImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-00199", "If pname:srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, imageOffset.y must be 0 and imageExtent.height must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-00201", "If pname:srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, imageOffset.z must be 0 and imageExtent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-01998", "The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-02544", "srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-04053", "If pname:srcImage has a depth/stencil format, the bufferOffset member of any element of pRegions must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImageLayout-00189", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImageLayout-00190", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdCopyImageToBuffer-srcImageLayout-01397", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_GENERAL, or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-commandBuffer-01831", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-commandBuffer-01832", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-commandBuffer-01833", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-pCopyImageToBufferInfo-parameter", "pCopyImageToBufferInfo must be a valid pointer to a valid VkCopyImageToBufferInfo2 structure", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyImageToBuffer2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-buffer-03745", "The buffer used to create pInfo->dst must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03742", "pInfo->src.deviceAddress must be a valid device address for a buffer bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03743", "pInfo->src.deviceAddress must be aligned to 256 bytes", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03744", "If the buffer pointed to by pInfo->src.deviceAddress is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMemoryToAccelerationStructureInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-buffer-07546", "The buffer used to create pInfo->dst must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-07543", "pInfo->src.deviceAddress must be a valid device address for a buffer bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-07544", "pInfo->src.deviceAddress must be aligned to 256 bytes", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-07545", "If the buffer pointed to by pInfo->src.deviceAddress is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMemoryToMicromapInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyMemoryToMicromapEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-buffer-07529", "The buffer used to create pInfo->src must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-buffer-07530", "The buffer used to create pInfo->dst must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMicromapInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-buffer-07539", "The buffer used to create pInfo->src must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-07536", "pInfo->dst.deviceAddress must be a valid device address for a buffer bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-07537", "pInfo->dst.deviceAddress must be aligned to 256 bytes", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-07538", "If the buffer pointed to by pInfo->dst.deviceAddress is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMicromapToMemoryInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyMicromapToMemoryEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-None-07429", "All queries used by the command must not be active", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-commonparent", "Each of commandBuffer, dstBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824", "dstBuffer must have enough storage, from dstOffset, to contain the result of each query, as described here", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-dstBuffer-00825", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-dstBuffer-00826", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-dstOffset-00819", "dstOffset must be less than the size of dstBuffer", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-firstQuery-00820", "firstQuery must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-firstQuery-00821", "The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-flags-00822", "If VK_QUERY_RESULT_64_BIT is not set in flags then dstOffset and stride must be multiples of 4", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-flags-00823", "If VK_QUERY_RESULT_64_BIT is set in flags then dstOffset and stride must be multiples of 8", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-flags-06902", "If flags includes VK_QUERY_RESULT_WITH_STATUS_BIT_KHR, it must not include VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-flags-parameter", "flags must be a valid combination of VkQueryResultFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-00827", "If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-02734", "vkCmdCopyQueryPoolResults must not be called if the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-03232", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, VkPhysicalDevicePerformanceQueryPropertiesKHR::allowCommandBufferQueryCopies must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-03233", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, flags must not contain VK_QUERY_RESULT_WITH_AVAILABILITY_BIT, VK_QUERY_RESULT_PARTIAL_BIT or VK_QUERY_RESULT_64_BIT", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-03234", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the queryPool must have been submitted once for each pass as retrieved via a call to vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-06901", "If the queryType used to create queryPool was VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR, flags must include VK_QUERY_RESULT_WITH_STATUS_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-queryType-06903", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, flags must not contain VK_QUERY_RESULT_WITH_STATUS_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdCopyQueryPoolResults-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdCuLaunchKernelNVX-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdCuLaunchKernelNVX-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdCuLaunchKernelNVX-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdCuLaunchKernelNVX-pLaunchInfo-parameter", "pLaunchInfo must be a valid pointer to a valid VkCuLaunchInfoNVX structure", "1.3-extensions"},
    {"VUID-vkCmdCuLaunchKernelNVX-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerBeginEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerBeginEXT-pMarkerInfo-parameter", "pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerBeginEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01239", "There must be an outstanding vkCmdDebugMarkerBeginEXT command prior to the vkCmdDebugMarkerEndEXT on the queue that commandBuffer is submitted to", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerEndEXT-commandBuffer-01240", "If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerEndEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerEndEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerEndEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerEndEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerInsertEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerInsertEXT-pMarkerInfo-parameter", "pMarkerInfo must be a valid pointer to a valid VkDebugMarkerMarkerInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdDebugMarkerInsertEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-None-07011", "The bound video session object must not be in uninitialized state", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support decode operations", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-parameter", "pDecodeInfo must be a valid pointer to a valid VkVideoDecodeInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDecodeVideoKHR-videocoding", "This command must only be called inside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDispatch-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDispatch-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDispatch-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDispatch-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDispatch-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDispatch-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDispatch-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDispatch-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDispatch-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDispatch-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDispatch-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-02712", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-02713", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-04617", "If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDispatch-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDispatch-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDispatch-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDispatch-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDispatch-groupCountX-00386", "groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-vkCmdDispatch-groupCountY-00387", "groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-vkCmdDispatch-groupCountZ-00388", "groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-vkCmdDispatch-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDispatch-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatch-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDispatch-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatch-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatch-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDispatch-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDispatch-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDispatchBase-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDispatchBase-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDispatchBase-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDispatchBase-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDispatchBase-baseGroupX-00421", "baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-baseGroupX-00422", "baseGroupY must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-baseGroupX-00427", "If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-baseGroupZ-00423", "baseGroupZ must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-02712", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-02713", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-04617", "If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-groupCountX-00424", "groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] minus baseGroupX", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-groupCountY-00425", "groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] minus baseGroupY", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-groupCountZ-00426", "groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] minus baseGroupZ", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDispatchBase-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDispatchIndirect-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDispatchIndirect-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDispatchIndirect-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-commonparent", "Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-offset-00407", "The sum of offset and the size of VkDispatchIndirectCommand must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDispatchIndirect-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDraw-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDraw-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDraw-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDraw-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDraw-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDraw-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDraw-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDraw-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDraw-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDraw-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDraw-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDraw-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDraw-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDraw-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDraw-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDraw-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-02712", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-02713", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-04617", "If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDraw-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDraw-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDraw-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDraw-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDraw-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDraw-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDraw-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDraw-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDraw-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDraw-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDraw-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDraw-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDraw-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDraw-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDraw-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDraw-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDraw-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDraw-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDraw-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDraw-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDraw-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDraw-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDraw-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDraw-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDraw-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDraw-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDraw-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDraw-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDraw-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-khr-extensions"},
    {"VUID-vkCmdDraw-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDraw-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDraw-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-khr-extensions"},
    {"VUID-vkCmdDraw-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDraw-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDraw-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDraw-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-khr-extensions"},
    {"VUID-vkCmdDraw-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDraw-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDraw-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDraw-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDraw-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDraw-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDraw-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDraw-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDraw-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDraw-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDraw-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDraw-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDraw-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDraw-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDraw-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDraw-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDraw-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDraw-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDraw-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDraw-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDraw-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDraw-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawIndexed-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDrawIndexed-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-07312", "An index buffer must be bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDrawIndexed-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-02712", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-02713", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-04617", "If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-firstIndex-04932", "(indexSize {times} (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndexed-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndexed-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexed-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexed-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexed-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndexed-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexed-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-07312", "An index buffer must be bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDrawIndexedIndirect-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawIndexedIndirect-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-commonparent", "Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-drawCount-00528", "If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-drawCount-00539", "If drawCount is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-drawCount-00540", "If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-drawCount-02718", "If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-drawCount-02719", "drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndexedIndirect-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndexedIndirect-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndexedIndirect-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirect-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04445", "If drawIndirectCount is not enabled this function must not be used", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-07312", "An index buffer must be bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDrawIndexedIndirectCount-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-commonparent", "Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-02714", "If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-02715", "countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-02717", "The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-03153", "If count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-03154", "If count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-parameter", "countBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBufferOffset-02716", "countBufferOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-countBufferOffset-04129", "(countBufferOffset + sizeof(uint32_t)) must be less than or equal to the size of countBuffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-maxDrawCount-03143", "If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndexedIndirectCount-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-stride-03142", "stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndexedIndirectCount-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawIndirect-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDrawIndirect-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDrawIndirect-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawIndirect-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-commonparent", "Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-drawCount-00476", "If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-drawCount-00487", "If drawCount is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-drawCount-00488", "If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-drawCount-02718", "If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-drawCount-02719", "drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndirect-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndirect-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirect-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirect-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirect-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndirect-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirect-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02646", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-commonparent", "Both of commandBuffer, and counterBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-counterBuffer-02290", "counterBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-counterBuffer-04567", "If counterBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-counterBuffer-parameter", "counterBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-counterBufferOffset-04568", "counterBufferOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-transformFeedback-02287", "VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-transformFeedbackDraw-02288", "The implementation must support VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackDraw", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-02289", "vertexStride must be greater than 0 and less than or equal to VkPhysicalDeviceLimits::maxTransformFeedbackBufferDataStride", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectByteCountEXT-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawIndirectCount-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.2"},
    {"VUID-vkCmdDrawIndirectCount-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04445", "If drawIndirectCount is not enabled this function must not be used", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "1.2"},
    {"VUID-vkCmdDrawIndirectCount-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawIndirectCount-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-commonparent", "Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBuffer-02714", "If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBuffer-02715", "countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBuffer-02717", "The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBuffer-03121", "If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBuffer-03122", "If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBuffer-parameter", "countBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBufferOffset-02716", "countBufferOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-countBufferOffset-04129", "(countBufferOffset + sizeof(uint32_t)) must be less than or equal to the size of countBuffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-maxDrawCount-03111", "If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndirectCount-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawIndirectCount-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirectCount-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirectCount-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-khr-extensions"},
    {"VUID-vkCmdDrawIndirectCount-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawIndirectCount-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-stride-03110", "stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawIndirectCount-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-MeshEXT-07087", "The current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS must contain a shader stage using the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07322", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, groupCountX must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07323", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, groupCountY must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07324", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07325", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS contains a shader using the TaskEXT {ExecutionModel}, The product of groupCountX, groupCountY and groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxTaskWorkGroupTotalCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07326", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, groupCountX must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07327", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, groupCountY must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07328", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-TaskEXT-07329", "If the current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS does not contain a shader using the TaskEXT {ExecutionModel}, The product of groupCountX, groupCountY and groupCountZ must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshWorkGroupTotalCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksEXT-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksEXT-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-MeshEXT-07100", "The current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS must contain a shader stage using the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-04445", "If drawIndirectCount is not enabled this function must not be used", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commonparent", "Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBuffer-02714", "If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBuffer-02715", "countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBuffer-02717", "The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBuffer-07098", "If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBuffer-07099", "If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBuffer-parameter", "countBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBufferOffset-02716", "countBufferOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-countBufferOffset-04129", "(countBufferOffset + sizeof(uint32_t)) must be less than or equal to the size of countBuffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-maxDrawCount-07097", "If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stride-07096", "stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandEXT)", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountEXT-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-MeshNV-07082", "The current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS must contain a shader stage using the MeshNV {ExecutionModel}.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-04445", "If drawIndirectCount is not enabled this function must not be used", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-07074", "Transform Feedback Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-07075", "Primitives Generated Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-commonparent", "Each of buffer, commandBuffer, and countBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02191", "If the count stored in countBuffer is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02192", "If the count stored in countBuffer is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02714", "If countBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02715", "countBuffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-02717", "The count stored in countBuffer must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBuffer-parameter", "countBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBufferOffset-02716", "countBufferOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBufferOffset-04129", "(countBufferOffset + sizeof(uint32_t)) must be less than or equal to the size of countBuffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-maxDrawCount-02183", "If maxDrawCount is greater than or equal to 1, (stride {times} (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-pipelineStatistics-07076", "The pipelineStatistics member used to create any active Pipeline Statistics Query must not contain VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT, VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, or VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stage-06480", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-stride-02182", "stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectCountNV-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-MeshEXT-07091", "The current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS must contain a shader stage using the MeshEXT {ExecutionModel}", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-commonparent", "Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-02718", "If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-02719", "drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07088", "If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandEXT)", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07089", "If drawCount is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07090", "If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectEXT-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-MeshNV-07081", "The current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS must contain a shader stage using the MeshNV {ExecutionModel}.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-07074", "Transform Feedback Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-07075", "Primitives Generated Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-buffer-02708", "If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-buffer-02709", "buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-02711", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-commonparent", "Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02146", "If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02156", "If drawCount is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02157", "If drawCount is greater than 1, (stride {times} (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02718", "If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02719", "drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-offset-02710", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-pipelineStatistics-07076", "The pipelineStatistics member used to create any active Pipeline Statistics Query must not contain VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT, VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, or VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-stage-06480", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksIndirectNV-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-MeshNV-07080", "The current pipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS must contain a shader stage using the MeshNV {ExecutionModel}.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-07074", "Transform Feedback Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-07075", "Primitives Generated Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-pipelineStatistics-07076", "The pipelineStatistics member used to create any active Pipeline Statistics Query must not contain VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT, VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT, VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT, or VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMeshTasksNV-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-stage-06480", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-taskCount-02119", "taskCount must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxDrawMeshTasksCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMeshTasksNV-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMultiEXT-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMultiEXT-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMultiEXT-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMultiEXT-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-04933", "The multiDraw feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMultiEXT-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-02712", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-02713", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-04617", "If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-drawCount-04934", "drawCount must be less than VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-drawCount-04935", "If drawCount is greater than zero, pVertexInfo must be a valid pointer to memory containing one or more valid instances of VkMultiDrawInfoEXT structures", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMultiEXT-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMultiEXT-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "default"},
    {"VUID-vkCmdDrawMultiEXT-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "default"},
    {"VUID-vkCmdDrawMultiEXT-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMultiEXT-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMultiEXT-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-stride-04936", "stride must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiEXT-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-04937", "The multiDraw feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-07312", "An index buffer must be bound", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-02712", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-02713", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-04617", "If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-drawCount-04939", "drawCount must be less than VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-drawCount-04940", "If drawCount is greater than zero, pIndexInfo must be a valid pointer to memory containing one or more valid instances of VkMultiDrawIndexedInfoEXT structures", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-firstIndex-04938", "(indexSize {times} (firstIndex + indexCount) + offset) must be less than or equal to the size of the bound index buffer, with indexSize being based on the type specified by indexType, where the index buffer, indexType, and offset are specified via vkCmdBindIndexBuffer", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-pVertexOffset-parameter", "If pVertexOffset is not NULL, pVertexOffset must be a valid pointer to a valid int32_t value", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdDrawMultiIndexedEXT-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-stride-04941", "stride must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdDrawMultiIndexedEXT-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support encode operations", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-parameter", "pEncodeInfo must be a valid pointer to a valid VkVideoEncodeInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEncodeVideoKHR-videocoding", "This command must only be called inside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-None-01985", "Conditional rendering must be active", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-None-01986", "If conditional rendering was made active outside of a render pass instance, it must not be ended inside a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-None-01987", "If conditional rendering was made active within a subpass it must be ended in the same subpass", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndConditionalRenderingEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01912", "There must be an outstanding vkCmdBeginDebugUtilsLabelEXT command prior to the vkCmdEndDebugUtilsLabelEXT on the queue that commandBuffer is submitted to", "1.3-extensions"},
    {"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01913", "If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT", "1.3-extensions"},
    {"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndDebugUtilsLabelEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-None-01923", "All queries used by the command must be active", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-None-07007", "If called within a subpass of a render pass instance, the corresponding vkCmdBeginQuery* command must have been called previously within the same subpass", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-None-07008", "If called outside of a render pass instance, the corresponding vkCmdBeginQuery* command must have been called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-commandBuffer-01886", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-query-00810", "query must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-query-00812", "If vkCmdEndQuery is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-queryPool-03227", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one or more of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR, the vkCmdEndQuery must be the last recorded command in commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-queryPool-03228", "If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one or more of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR, the vkCmdEndQuery must not be recorded within a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndQuery-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-None-02342", "All queries used by the command must be active", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-None-07007", "If called within a subpass of a render pass instance, the corresponding vkCmdBeginQuery* command must have been called previously within the same subpass", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-None-07008", "If called outside of a render pass instance, the corresponding vkCmdBeginQuery* command must have been called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-commandBuffer-02344", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-query-02343", "query must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-query-02345", "If vkCmdEndQueryIndexedEXT is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryType-02346", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "default"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryType-02347", "If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT the index must be zero", "default"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryType-02723", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT index must equal the index used to begin the query", "default"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryType-06694", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT or VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryType-06695", "If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT and not VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, the index must be zero", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-queryType-06696", "If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT or VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, index must equal the index used to begin the query", "1.3-extensions"},
    {"VUID-vkCmdEndQueryIndexedEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-None-00910", "The current subpass index must be equal to the number of subpasses in the render pass minus one", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-None-02351", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-None-06170", "The current render pass instance must not have been begun with vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-None-07004", "If vkCmdBeginQuery* was called within a subpass of the render pass, the corresponding vkCmdEndQuery* must have been called subsequently within the same subpass.", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-None-02352", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-None-03103", "The current subpass index must be equal to the number of subpasses in the render pass minus one", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-None-06171", "The current render pass instance must not have been begun with vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-None-07005", "If vkCmdBeginQuery* was called within a subpass of the render pass, the corresponding vkCmdEndQuery* must have been called subsequently within the same subpass.", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-pSubpassEndInfo-parameter", "pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfo structure", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndRenderPass2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-None-06161", "The current render pass instance must have been begun with vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-None-06781", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-None-06999", "If vkCmdBeginQuery* was called within the render pass, the corresponding vkCmdEndQuery* must have been called subsequently within the same subpass.", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-commandBuffer-06162", "The current render pass instance must have been begun in commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndRendering-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-None-02375", "Transform feedback must be active", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-commonparent", "Both of commandBuffer, and the elements of pCounterBuffers that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-counterBufferCount-02608", "If counterBufferCount is not 0, and pCounterBuffers is not NULL, pCounterBuffers must be a valid pointer to an array of counterBufferCount VkBuffer handles that are either valid or VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02376", "firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02377", "The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffer-02379", "If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-pCounterBufferOffsets-02378", "For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-pCounterBufferOffsets-parameter", "If counterBufferCount is not 0, and pCounterBufferOffsets is not NULL, pCounterBufferOffsets must be a valid pointer to an array of counterBufferCount VkDeviceSize values", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffers-02380", "For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-transformFeedback-02374", "VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled", "1.3-extensions"},
    {"VUID-vkCmdEndTransformFeedbackEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-pEndCodingInfo-parameter", "pEndCodingInfo must be a valid pointer to a valid VkVideoEndCodingInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdEndVideoCodingKHR-videocoding", "This command must only be called inside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-None-02286", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-colorAttachmentCount-06027", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the colorAttachmentCount member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the VkRenderingInfo::colorAttachmentCount parameter to vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-00101", "If the inheritedQueries feature is not enabled, commandBuffer must not have any queries active", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-00102", "If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::occlusionQueryEnable set to VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-00103", "If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::queryFlags having all bits set that are set for the query", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-00104", "If commandBuffer has a VK_QUERY_TYPE_PIPELINE_STATISTICS query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::pipelineStatistics having all bits set that are set in the VkQueryPool the query uses", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-01820", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, each element of pCommandBuffers must be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-01821", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, each element of pCommandBuffers must be an unprotected command buffer", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-06533", "If vkCmdExecuteCommands is being called within a render pass instance and any recorded command in commandBuffer in the current subpass will write to an image subresource as an attachment, commands recorded in elements of pCommandBuffers must not read from the memory backing that image subresource in any other way", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-06534", "If vkCmdExecuteCommands is being called within a render pass instance and any recorded command in commandBuffer in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, commands recorded in elements of pCommandBuffers must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commandBufferCount-arraylength", "commandBufferCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-commonparent", "Both of commandBuffer, and the elements of pCommandBuffers must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-contents-00095", "If vkCmdExecuteCommands is being called within a render pass instance, that render pass instance must have been begun with the contents parameter of vkCmdBeginRenderPass set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS", "1.2"},
    {"VUID-vkCmdExecuteCommands-contents-06018", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRenderPass, its contents parameter must have been set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-flags-06024", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, its VkRenderingInfo::flags parameter must have included VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-flags-06026", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the flags member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the VkRenderingInfo::flags parameter to vkCmdBeginRendering, excluding VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-imageView-06028", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the imageView member of an element of the VkRenderingInfo::pColorAttachments parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the corresponding element of the pColorAttachmentFormats member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the format used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pBeginInfo-06020", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRenderPass, the render passes specified in the pBeginInfo->pInheritanceInfo->renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be compatible with the current render pass", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pBeginInfo-06025", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the render passes specified in the pBeginInfo->pInheritanceInfo->renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00088", "Each element of pCommandBuffers must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_SECONDARY", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00089", "Each element of pCommandBuffers must be in the pending or executable state", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00091", "If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not be in the pending state", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00092", "If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not have already been recorded to commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00093", "If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not appear more than once in pCommandBuffers", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00094", "Each element of pCommandBuffers must have been allocated from a VkCommandPool that was created for the same queue family as the VkCommandPool from which commandBuffer was allocated", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00096", "If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00097", "If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::subpass set to the index of the subpass which the given command buffer will be executed in", "1.2"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00099", "If vkCmdExecuteCommands is being called within a render pass instance, and any element of pCommandBuffers was recorded with VkCommandBufferInheritanceInfo::framebuffer not equal to VK_NULL_HANDLE, that VkFramebuffer must match the VkFramebuffer used in the current render pass instance", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00100", "If vkCmdExecuteCommands is not being called within a render pass instance, each element of pCommandBuffers must not have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-00105", "Each element of pCommandBuffers must not begin any query types that are active in commandBuffer", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-06019", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRenderPass, each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::subpass set to the index of the subpass which the given command buffer will be executed in", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-06021", "If pCommandBuffers contains any suspended render pass instances, there must be no action or synchronization commands between that render pass instance and any render pass instance that resumes it", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-06022", "If pCommandBuffers contains any suspended render pass instances, there must be no render pass instances between that render pass instance and any render pass instance that resumes it", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-06535", "If vkCmdExecuteCommands is being called within a render pass instance and any recorded command in a given element of pCommandBuffers will write to an image subresource as an attachment, commands recorded in elements of pCommandBuffers at a higher index must not read from the memory backing that image subresource in any other way", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-06536", "If vkCmdExecuteCommands is being called within a render pass instance and any recorded command in a given element of pCommandBuffers will read from an image subresource used as an attachment in any way other than as an attachment, commands recorded in elements of pCommandBuffers at a higher index must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pCommandBuffers-parameter", "pCommandBuffers must be a valid pointer to an array of commandBufferCount valid VkCommandBuffer handles", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pDepthAttachment-06029", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of the depthAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the format used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pDepthAttachment-06774", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering was VK_NULL_HANDLE, the value of the depthAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pInheritanceInfo-00098", "If vkCmdExecuteCommands is being called within a render pass instance, the render passes specified in the pBeginInfo->pInheritanceInfo->renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be compatible with the current render pass", "1.2"},
    {"VUID-vkCmdExecuteCommands-pNext-02865", "If vkCmdExecuteCommands is being called within a render pass instance that included VkRenderPassTransformBeginInfoQCOM in the pNext chain of VkRenderPassBeginInfo, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceRenderPassTransformInfoQCOM in the pNext chain of VkCommandBufferBeginInfo", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-02866", "If vkCmdExecuteCommands is being called within a render pass instance that included VkRenderPassTransformBeginInfoQCOM in the pNext chain of VkRenderPassBeginInfo, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceRenderPassTransformInfoQCOM::transform identical to VkRenderPassTransformBeginInfoQCOM::transform", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-02867", "If vkCmdExecuteCommands is being called within a render pass instance that included VkRenderPassTransformBeginInfoQCOM in the pNext chain of VkRenderPassBeginInfo, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceRenderPassTransformInfoQCOM::renderArea identical to VkRenderPassBeginInfo::renderArea", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-06032", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo includes a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the imageView member of an element of the VkRenderingInfo::pColorAttachments parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the corresponding element of the pColorAttachmentSamples member of the VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the sample count used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-06033", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo includes a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of the VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the sample count used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-06034", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo includes a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of the VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the sample count used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-06035", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo does not include a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the imageView member of an element of the VkRenderingInfo::pColorAttachments parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of VkCommandBufferInheritanceRenderingInfo::rasterizationSamples must be equal to the sample count used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-06036", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo does not include a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of VkCommandBufferInheritanceRenderingInfo::rasterizationSamples must be equal to the sample count used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pNext-06037", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo does not include a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of VkCommandBufferInheritanceRenderingInfo::rasterizationSamples must be equal to the sample count used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pStencilAttachment-06030", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of the stencilAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the format used to create that image view", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-pStencilAttachment-06775", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering was VK_NULL_HANDLE, the value of the stencilAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be VK_FORMAT_UNDEFINED", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-variableSampleLocations-06023", "If the variableSampleLocations limit is not supported, and any element of pCommandBuffers contains any suspended render pass instances, where a graphics pipeline has been bound, any pipelines bound in the render pass instance that resumes it, or any subsequent render pass instances that resume from that one and so on, must use the same sample locations", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdExecuteCommands-viewMask-06031", "If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the viewMask member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the VkRenderingInfo::viewMask parameter to vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02686", "Every input attachment used by the current subpass must be bound to the pipeline via a descriptor set", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02721", "For a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-02910", "Transform feedback must not be active", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04007", "All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must have either valid or VK_NULL_HANDLE buffers bound", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04008", "If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point's interface must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04875", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled then vkCmdSetPatchControlPointsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04876", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled then vkCmdSetRasterizerDiscardEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04877", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled then vkCmdSetDepthBiasEnable must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04879", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT dynamic state enabled then vkCmdSetPrimitiveRestartEnableEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04912", "If the bound graphics pipeline was created with both the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT and VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic states enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-04914", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdSetVertexInputEXT must have been called in the current command buffer prior to this draw command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06537", "Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06538", "If any recorded command in the current subpass will write to an image subresource as an attachment, this command must not read from the memory backing that image subresource in any other way than as an attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06539", "If any recorded command in the current subpass will read from an image subresource used as an attachment in any way other than as an attachment, this command must not write to that image subresource as an attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06666", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled then vkCmdSetSampleLocationsEXT must have been called in the current command buffer prior to this drawing command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06886", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-06887", "If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-None-07469", "Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition be created with a VkImageView that is an attachment in the currently bound VkFramebuffer at an index that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07468", "If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-VkPipelineVieportCreateInfo-04141", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-VkPipelineVieportCreateInfo-04142", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-advancedBlendMaxColorAttachments-07480", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-attachmentCount-06667", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-attachmentCount-06815", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-blendEnable-04727", "If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view's format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-06179", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-06180", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-06185", "If the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-06188", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-02970", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-conservativePointAndLineRasterization-07499", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-coverageModulationTableEnable-07488", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-coverageReductionMode-07491", "If this VK_NV_coverage_reduction_mode extension is enabled, the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, the current coverage reduction mode coverageReductionMode, then the current rasterizationSamples, and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-coverageToColorEnable-07490", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-deviceGeneratedCommands-02911", "The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-dynamicPrimitiveTopologyUnrestricted-07500", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter in the last call to vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07476", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07477", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07478", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07479", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06172", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06173", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06174", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06175", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06176", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06177", "If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06183", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06184", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the currently bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-isPreprocessed-02908", "If isPreprocessed is VK_TRUE then vkCmdPreprocessGeneratedCommandsNV must have already been executed on the device, using the same pGeneratedCommandsInfo content as well as the content of the input buffers it references (all except VkGeneratedCommandsInfoNV::preprocessBuffer). Furthermore pGeneratedCommandsInfo`s indirectCommandsLayout must have been created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV bit set", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-logicOp-04878", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled then vkCmdSetLogicOpEXT must have been called in the current command buffer prior to this drawing command and the logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-maxMultiviewInstanceIndex-02688", "If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07284", "If rasterization is not disabled in the bound graphics pipeline, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07285", "If the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07286", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07287", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07475", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and none of the VK_AMD_mixed_attachment_samples extension, VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature is enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pColorBlendEnables-07470", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pDepthAttachment-06181", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pDepthAttachment-06186", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pDepthAttachment-06189", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "pGeneratedCommandsInfo must be a valid pointer to a valid VkGeneratedCommandsInfoNV structure", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pStencilAttachment-06182", "If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the currently bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pStencilAttachment-06187", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pStencilAttachment-06190", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineMultisampleStateCreateInfo::rasterizationSamples used to create the currently bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pStrides-04884", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this drawing command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pStrides-04913", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT dynamic state enabled, but not the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2EXT must have been called in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2EXT must not be NULL", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-pipeline-02909", "VkGeneratedCommandsInfoNV::pipeline must match the current bound pipeline at VkGeneratedCommandsInfoNV::pipelineBindPoint", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-primitiveFragmentShadingRateWithMultipleViewports-04552", "If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-primitiveTopology-03420", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT dynamic state enabled then vkCmdSetPrimitiveTopologyEXT must have been called in the current command buffer prior to this drawing command, and the primitiveTopology parameter of vkCmdSetPrimitiveTopologyEXT must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-primitivesGeneratedQueryWithNonZeroStreams-06709", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream.", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-primitivesGeneratedQueryWithNonZeroStreams-07481", "If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-primitivesGeneratedQueryWithRasterizerDiscard-06708", "If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled.", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-04740", "If rasterization is not disabled in the bound graphics pipeline, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07471", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07474", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments", "default"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07489", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the currently bound pipeline state, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07494", "If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the current subpass has any color attachments and rasterizationSamples of the last call to vkCmdSetRasterizationSamplesEXT is greater than the number of color samples, then the pipeline sampleShadingEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-renderPass-02684", "The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-renderPass-06198", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-02689", "If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07484", "If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07485", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07486", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.sampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::sampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07487", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsPerPixel-07482", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsPerPixel-07483", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-samples-07472", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-samples-07473", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-scissorCount-03418", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, then vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the scissorCount parameter of vkCmdSetScissorWithCount must match the VkPipelineViewportStateCreateInfo::viewportCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-stage-06481", "The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-stage-07073", "If the currently bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07495", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the stippledRectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07496", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the stippledBresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07497", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the stippledSmoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07498", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-subpass-02685", "The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewMask-06178", "If the current render pass instance was begun with vkCmdBeginRendering, the currently bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-03417", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the VkPipelineViewportStateCreateInfo::scissorCount of the pipeline", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-03419", "If the bound graphics pipeline state was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled then both vkCmdSetViewportWithCount and vkCmdSetScissorWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04137", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04138", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04139", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04140", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-07492", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-07493", "If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-commandBuffer-00030", "The VkCommandPool that commandBuffer was allocated from must support graphics or compute operations", "1.0"},
    {"VUID-vkCmdFillBuffer-commandBuffer-01811", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-commandBuffer-01812", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics or compute operations", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-commonparent", "Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-dstBuffer-00029", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-dstBuffer-00031", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-dstOffset-00024", "dstOffset must be less than the size of dstBuffer", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-dstOffset-00025", "dstOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-size-00026", "If size is not equal to VK_WHOLE_SIZE, size must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-size-00027", "If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of dstBuffer minus dstOffset", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-size-00028", "If size is not equal to VK_WHOLE_SIZE, size must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdFillBuffer-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdInsertDebugUtilsLabelEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdInsertDebugUtilsLabelEXT-pLabelInfo-parameter", "pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure", "1.3-extensions"},
    {"VUID-vkCmdInsertDebugUtilsLabelEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-None-00909", "The current subpass index must be less than the number of subpasses in the render pass minus one", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-None-02349", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-contents-parameter", "contents must be a valid VkSubpassContents value", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-None-02350", "This command must not be recorded when transform feedback is active", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-None-03102", "The current subpass index must be less than the number of subpasses in the render pass minus one", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-bufferlevel", "commandBuffer must be a primary VkCommandBuffer", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-pSubpassBeginInfo-parameter", "pSubpassBeginInfo must be a valid pointer to a valid VkSubpassBeginInfo structure", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-pSubpassEndInfo-parameter", "pSubpassEndInfo must be a valid pointer to a valid VkSubpassEndInfo structure", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdNextSubpass2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support opticalflow operations", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-commonparent", "Both of commandBuffer, and session must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-pExecuteInfo-parameter", "pExecuteInfo must be a valid pointer to a valid VkOpticalFlowExecuteInfoNV structure", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-session-parameter", "session must be a valid VkOpticalFlowSessionNV handle", "1.3-extensions"},
    {"VUID-vkCmdOpticalFlowExecuteNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-None-06191", "If fname:vkCmdPipelineBarrier is called within a render pass instance, the render pass must not have been started with vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-bufferMemoryBarrierCount-01178", "If fname:vkCmdPipelineBarrier is called within a render pass instance, it must not include any buffer memory barriers", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dependencyFlags-01186", "If fname:vkCmdPipelineBarrier is called outside of a render pass instance, VK_DEPENDENCY_VIEW_LOCAL_BIT must not be included in the dependency flags", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dependencyFlags-parameter", "dependencyFlags must be a valid combination of VkDependencyFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstAccessMask-02816", "The dstAccessMask member of each element of pMemoryBarriers must only include access flags that are supported by one or more of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-03937", "If the synchronization2 feature is not enabled, pname:dstStageMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04090", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04091", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04092", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04094", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04095", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04096", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04097", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-04996", "pname:dstStageMask must not be 0", "1.2"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-06462", "Any pipeline stage included in dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdPipelineBarrier-image-04073", "If fname:vkCmdPipelineBarrier is called within a render pass instance, the image member of any image memory barrier included in this command must be an attachment used in the current subpass both as an input attachment, and as either a color or depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-oldLayout-01181", "If fname:vkCmdPipelineBarrier is called within a render pass instance, the oldLayout and newLayout members of any image memory barrier included in this command must be equal", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-02817", "For any element of pBufferMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its srcQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its srcAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-02818", "For any element of pBufferMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its dstQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its dstAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter", "If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pDependencies-02285", "If fname:vkCmdPipelineBarrier is called within a render pass instance, the render pass must have been created with at least one VkSubpassDependency instance in VkRenderPassCreateInfo::pDependencies that expresses a dependency from the current subpass to itself, with synchronization scopes and access scopes that are all supersets of the scopes defined in this command", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-02819", "For any element of pImageMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its srcQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its srcAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-02820", "For any element of pImageMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its dstQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its dstAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter", "If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter", "If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcAccessMask-02815", "The srcAccessMask member of each element of pMemoryBarriers must only include access flags that are supported by one or more of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcQueueFamilyIndex-01182", "If fname:vkCmdPipelineBarrier is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any image memory barrier included in this command must be equal", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-03937", "If the synchronization2 feature is not enabled, pname:srcStageMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04090", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04091", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04092", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04094", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04095", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04096", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04097", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-04996", "pname:srcStageMask must not be 0", "1.2"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-06461", "Any pipeline stage included in srcStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-None-06191", "If fname:vkCmdPipelineBarrier2 is called within a render pass instance, the render pass must not have been started with vkCmdBeginRendering", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-bufferMemoryBarrierCount-01178", "If fname:vkCmdPipelineBarrier2 is called within a render pass instance, it must not include any buffer memory barriers", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-dependencyFlags-01186", "If fname:vkCmdPipelineBarrier2 is called outside of a render pass instance, VK_DEPENDENCY_VIEW_LOCAL_BIT must not be included in the dependency flags", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-dstStageMask-03850", "The dstStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfo must only include pipeline stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-image-04073", "If fname:vkCmdPipelineBarrier2 is called within a render pass instance, the image member of any image memory barrier included in this command must be an attachment used in the current subpass both as an input attachment, and as either a color or depth/stencil attachment", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-oldLayout-01181", "If fname:vkCmdPipelineBarrier2 is called within a render pass instance, the oldLayout and newLayout members of any image memory barrier included in this command must be equal", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-pDependencies-02285", "If fname:vkCmdPipelineBarrier2 is called within a render pass instance, the render pass must have been created with at least one VkSubpassDependency instance in VkRenderPassCreateInfo::pDependencies that expresses a dependency from the current subpass to itself, with synchronization scopes and access scopes that are all supersets of the scopes defined in this command", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-pDependencyInfo-parameter", "pDependencyInfo must be a valid pointer to a valid VkDependencyInfo structure", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-srcQueueFamilyIndex-01182", "If fname:vkCmdPipelineBarrier2 is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any image memory barrier included in this command must be equal", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-srcStageMask-03849", "The srcStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfo must only include pipeline stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdPipelineBarrier2-synchronization2-03848", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-02974", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-deviceGeneratedCommands-02928", "The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-02927", "pGeneratedCommandsInfo`s indirectCommandsLayout must have been created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV bit set", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-parameter", "pGeneratedCommandsInfo must be a valid pointer to a valid VkGeneratedCommandsInfoNV structure", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdPreprocessGeneratedCommandsNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-commonparent", "Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-offset-00368", "offset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-offset-00370", "offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-offset-01795", "For each byte in the range specified by offset and size and for each shader stage in stageFlags, there must be a push constant range in layout that includes that byte and that stage", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-offset-01796", "For each byte in the range specified by offset and size and for each push constant range that overlaps that byte, stageFlags must include all stages in that push constant range's VkPushConstantRange::stageFlags", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-pValues-parameter", "pValues must be a valid pointer to an array of size bytes", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-size-00369", "size must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-size-00371", "size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-size-arraylength", "size must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-stageFlags-parameter", "stageFlags must be a valid combination of VkShaderStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-stageFlags-requiredbitmask", "stageFlags must not be 0", "1.3-extensions"},
    {"VUID-vkCmdPushConstants-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-commonparent", "Both of commandBuffer, and layout must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-descriptorWriteCount-arraylength", "descriptorWriteCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-06494", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pDescriptorWrites[i].pImageInfo must be a valid pointer to an array of pDescriptorWrites[i].descriptorCount valid VkDescriptorImageInfo structures", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-pDescriptorWrites-parameter", "pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-00363", "pipelineBindPoint must be supported by the commandBuffer's parent VkCommandPool's queue family", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-pipelineBindPoint-parameter", "pipelineBindPoint must be a valid VkPipelineBindPoint value", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-set-00364", "set must be less than VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-set-00365", "set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-00366", "The pipelineBindPoint specified during the creation of the descriptor update template must be supported by the commandBuffer's parent VkCommandPool's queue family", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-commonparent", "Each of commandBuffer, descriptorUpdateTemplate, and layout must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-descriptorUpdateTemplate-parameter", "descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-layout-parameter", "layout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-pData-01686", "pData must be a valid pointer to a memory containing one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplate", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-set-07304", "set must be less than VkPipelineLayoutCreateInfo::setLayoutCount provided when layout was created", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-set-07305", "set must be the unique set number in the pipeline layout that uses a descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdPushDescriptorSetWithTemplateKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-commandBuffer-01157", "commandBuffer's current device mask must include exactly one physical device", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-commonparent", "Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-event-03834", "There must be an execution dependency between vkCmdResetEvent and the execution of any vkCmdWaitEvents that includes event in its pEvents parameter", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-event-03835", "There must be an execution dependency between vkCmdResetEvent and the execution of any vkCmdWaitEvents2 that includes event in its pEvents parameter", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdResetEvent-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-01153", "stageMask must not include VK_PIPELINE_STAGE_HOST_BIT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-03937", "If the synchronization2 feature is not enabled, pname:stageMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04090", "If the geometryShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04091", "If the tessellationShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04092", "If the conditionalRendering feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04094", "If the transformFeedback feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04095", "If the meshShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04096", "If the taskShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-04097", "If the shadingRateImage feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdResetEvent-stageMask-04996", "pname:stageMask must not be 0", "1.2"},
    {"VUID-vkCmdResetEvent-stageMask-06458", "Any pipeline stage included in stageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkCmdResetEvent-stageMask-parameter", "stageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-commandBuffer-03833", "commandBuffer's current device mask must include exactly one physical device", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-commonparent", "Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-event-03831", "There must be an execution dependency between vkCmdResetEvent2 and the execution of any vkCmdWaitEvents that includes event in its pEvents parameter", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-event-03832", "There must be an execution dependency between vkCmdResetEvent2 and the execution of any vkCmdWaitEvents2 that includes event in its pEvents parameter", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdResetEvent2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03830", "stageMask must not include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03929", "If the geometryShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03930", "If the tessellationShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03931", "If the conditionalRendering feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03932", "If the fragmentDensityMap feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03933", "If the transformFeedback feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03934", "If the meshShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-03935", "If the taskShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-04956", "If the shadingRateImage feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdResetEvent2-stageMask-04957", "If the subpassShading feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-04995", "If the invocationMask feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-stageMask-parameter", "stageMask must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-vkCmdResetEvent2-synchronization2-03829", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-None-02841", "All queries used by the command must not be active", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-firstQuery-00796", "firstQuery must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-firstQuery-00797", "The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-firstQuery-02862", "If queryPool was created with VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, this command must not be recorded in a command buffer that, either directly or through secondary command buffers, also contains begin commands for a query from the set of queries [firstQuery, firstQuery + queryCount - 1]", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdResetQueryPool-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commandBuffer-01837", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commandBuffer-01838", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commandBuffer-01839", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-commonparent", "Each of commandBuffer, dstImage, and srcImage must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-00258", "If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-00259", "dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-00276", "If dstImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, dstOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-00278", "If dstImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, dstOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-02003", "The format features of dstImage must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-02546", "dstImage and srcImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-06764", "dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-06765", "The format features of dstImage must contain VK_FORMAT_FEATURE_TRANSFER_DST_BIT", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImage-parameter", "dstImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImageLayout-00262", "dstImageLayout must specify the layout of the image subresources of dstImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImageLayout-00263", "dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdResolveImage-dstImageLayout-01401", "dstImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstImageLayout-parameter", "dstImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstOffset-00274", "For each element of pRegions, dstOffset.x and (extent.width + dstOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstOffset-00275", "For each element of pRegions, dstOffset.y and (extent.height + dstOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstOffset-00277", "For each element of pRegions, dstOffset.z and (extent.depth + dstOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified dstSubresource of dstImage", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstSubresource-01710", "The dstSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-dstSubresource-01712", "The dstSubresource.baseArrayLayer + dstSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when dstImage was created", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-linearColorAttachment-06519", "If the linearColorAttachment feature is enabled and the image is created with VK_IMAGE_TILING_LINEAR, the format features of dstImage must contain VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-pRegions-00255", "The union of all source regions, and the union of all destination regions, specified by the elements of pRegions, must not overlap in memory", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-pRegions-parameter", "pRegions must be a valid pointer to an array of regionCount valid VkImageResolve structures", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-regionCount-arraylength", "regionCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-00256", "If srcImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-00257", "srcImage must have a sample count equal to any valid sample count value other than VK_SAMPLE_COUNT_1_BIT", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-00271", "If srcImage is of type VK_IMAGE_TYPE_1D, then for each element of pRegions, srcOffset.y must be 0 and extent.height must be 1", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-00273", "If srcImage is of type VK_IMAGE_TYPE_1D or VK_IMAGE_TYPE_2D, then for each element of pRegions, srcOffset.z must be 0 and extent.depth must be 1", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-01386", "srcImage and dstImage must have been created with the same image format", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-04446", "If either srcImage or dstImage are of type VK_IMAGE_TYPE_3D, then for each element of pRegions, srcSubresource.baseArrayLayer must be 0 and srcSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-04447", "If either srcImage or dstImage are of type VK_IMAGE_TYPE_3D, then for each element of pRegions, dstSubresource.baseArrayLayer must be 0 and dstSubresource.layerCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-06762", "srcImage must have been created with VK_IMAGE_USAGE_TRANSFER_SRC_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-06763", "The format features of srcImage must contain VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImage-parameter", "srcImage must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImageLayout-00260", "srcImageLayout must specify the layout of the image subresources of srcImage specified in pRegions at the time this command is executed on a VkDevice", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImageLayout-00261", "srcImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3"},
    {"VUID-vkCmdResolveImage-srcImageLayout-01400", "srcImageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcImageLayout-parameter", "srcImageLayout must be a valid VkImageLayout value", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcOffset-00269", "For each element of pRegions, srcOffset.x and (extent.width + srcOffset.x) must both be greater than or equal to 0 and less than or equal to the width of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcOffset-00270", "For each element of pRegions, srcOffset.y and (extent.height + srcOffset.y) must both be greater than or equal to 0 and less than or equal to the height of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcOffset-00272", "For each element of pRegions, srcOffset.z and (extent.depth + srcOffset.z) must both be greater than or equal to 0 and less than or equal to the depth of the specified srcSubresource of srcImage", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcSubresource-01709", "The srcSubresource.mipLevel member of each element of pRegions must be less than the mipLevels specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-srcSubresource-01711", "The srcSubresource.baseArrayLayer + srcSubresource.layerCount of each element of pRegions must be less than or equal to the arrayLayers specified in VkImageCreateInfo when srcImage was created", "1.3-extensions"},
    {"VUID-vkCmdResolveImage-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-commandBuffer-01837", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, srcImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-commandBuffer-01838", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstImage must not be a protected image", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-commandBuffer-01839", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstImage must not be an unprotected image", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-pResolveImageInfo-parameter", "pResolveImageInfo must be a valid pointer to a valid VkResolveImageInfo2 structure", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdResolveImage2-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToCoverageEnableEXT-alphaToOne-07344", "If the alphaToOne feature is not enabled, alphaToOneEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToCoverageEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToCoverageEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToCoverageEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToCoverageEnableEXT-extendedDynamicState3AlphaToCoverageEnable-07343", "The extendedDynamicState3AlphaToCoverageEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToCoverageEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToOneEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToOneEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToOneEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToOneEnableEXT-extendedDynamicState3AlphaToOneEnable-07345", "The extendedDynamicState3AlphaToOneEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetAlphaToOneEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetBlendConstants-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetBlendConstants-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetBlendConstants-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetBlendConstants-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCheckpointNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations", "1.3-extensions"},
    {"VUID-vkCmdSetCheckpointNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCheckpointNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCheckpointNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-02235", "The array pCustomSampleOrders must not contain two structures with matching values for both the shadingRate and sampleCount members", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-pCustomSampleOrders-parameter", "If customSampleOrderCount is not 0, pCustomSampleOrders must be a valid pointer to an array of customSampleOrderCount valid VkCoarseSampleOrderCustomNV structures", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-02081", "If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-parameter", "sampleOrderType must be a valid VkCoarseSampleOrderTypeNV value", "1.3-extensions"},
    {"VUID-vkCmdSetCoarseSampleOrderNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-attachmentCount-arraylength", "attachmentCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-extendedDynamicState3ColorBlendAdvanced-07504", "The extendedDynamicState3ColorBlendAdvanced feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-pColorBlendAdvanced-parameter", "pColorBlendAdvanced must be a valid pointer to an array of attachmentCount valid VkColorBlendAdvancedEXT structures", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendAdvancedEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-attachmentCount-arraylength", "attachmentCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-extendedDynamicState3ColorBlendEnable-07355", "The extendedDynamicState3ColorBlendEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-pColorBlendEnables-parameter", "pColorBlendEnables must be a valid pointer to an array of attachmentCount VkBool32 values", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-attachmentCount-arraylength", "attachmentCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-extendedDynamicState3ColorBlendEquation-07356", "The extendedDynamicState3ColorBlendEquation feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-pColorBlendEquations-parameter", "pColorBlendEquations must be a valid pointer to an array of attachmentCount valid VkColorBlendEquationEXT structures", "1.3-extensions"},
    {"VUID-vkCmdSetColorBlendEquationEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-None-04803", "The colorWriteEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-attachmentCount-06656", "attachmentCount must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-attachmentCount-arraylength", "attachmentCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-pColorWriteEnables-parameter", "pColorWriteEnables must be a valid pointer to an array of attachmentCount VkBool32 values", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-attachmentCount-arraylength", "attachmentCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-extendedDynamicState3ColorWriteMask-07364", "The extendedDynamicState3ColorWriteMask feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-pColorWriteMasks-parameter", "pColorWriteMasks must be a valid pointer to an array of attachmentCount valid combinations of VkColorComponentFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-pColorWriteMasks-requiredbitmask", "Each element of pColorWriteMasks must not be 0", "1.3-extensions"},
    {"VUID-vkCmdSetColorWriteMaskEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetConservativeRasterizationModeEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetConservativeRasterizationModeEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetConservativeRasterizationModeEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetConservativeRasterizationModeEXT-conservativeRasterizationMode-parameter", "conservativeRasterizationMode must be a valid VkConservativeRasterizationModeEXT value", "1.3-extensions"},
    {"VUID-vkCmdSetConservativeRasterizationModeEXT-extendedDynamicState3ConservativeRasterizationMode-07426", "The extendedDynamicState3ConservativeRasterizationMode feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetConservativeRasterizationModeEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationModeNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationModeNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationModeNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationModeNV-coverageModulationMode-parameter", "coverageModulationMode must be a valid VkCoverageModulationModeNV value", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationModeNV-extendedDynamicState3CoverageModulationMode-07350", "The extendedDynamicState3CoverageModulationMode feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationModeNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableEnableNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableEnableNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableEnableNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableEnableNV-extendedDynamicState3CoverageModulationTableEnable-07351", "The extendedDynamicState3CoverageModulationTableEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableEnableNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-coverageModulationTableCount-arraylength", "coverageModulationTableCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-extendedDynamicState3CoverageModulationTable-07352", "The extendedDynamicState3CoverageModulationTable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-pCoverageModulationTable-parameter", "pCoverageModulationTable must be a valid pointer to an array of coverageModulationTableCount float values", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageModulationTableNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageReductionModeNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageReductionModeNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageReductionModeNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageReductionModeNV-coverageReductionMode-parameter", "coverageReductionMode must be a valid VkCoverageReductionModeNV value", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageReductionModeNV-extendedDynamicState3CoverageReductionMode-07349", "The extendedDynamicState3CoverageReductionMode feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageReductionModeNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorEnableNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorEnableNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorEnableNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorEnableNV-extendedDynamicState3CoverageToColorEnable-07347", "The extendedDynamicState3CoverageToColorEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorEnableNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorLocationNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorLocationNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorLocationNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorLocationNV-extendedDynamicState3CoverageToColorLocation-07348", "The extendedDynamicState3CoverageToColorLocation feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetCoverageToColorLocationNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetCullMode-None-03384", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetCullMode-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetCullMode-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetCullMode-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetCullMode-cullMode-parameter", "cullMode must be a valid combination of VkCullModeFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetCullMode-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBias-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBias-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBias-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBias-depthBiasClamp-00790", "If the depthBiasClamp feature is not enabled, depthBiasClamp must be 0.0", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBias-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBiasEnable-None-04872", "The extendedDynamicState2 feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetDepthBiasEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBiasEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBiasEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBiasEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBounds-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBounds-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBounds-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBounds-maxDepthBounds-00601", "Unless the VK_EXT_depth_range_unrestricted extension is enabled maxDepthBounds must be between 0.0 and 1.0, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBounds-maxDepthBounds-02509", "maxDepthBounds must be between 0.0 and 1.0, inclusive", "1.3-khr-extensions"},
    {"VUID-vkCmdSetDepthBounds-minDepthBounds-00600", "Unless the VK_EXT_depth_range_unrestricted extension is enabled minDepthBounds must be between 0.0 and 1.0, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBounds-minDepthBounds-02508", "minDepthBounds must be between 0.0 and 1.0, inclusive", "1.3-khr-extensions"},
    {"VUID-vkCmdSetDepthBounds-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBoundsTestEnable-None-03349", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetDepthBoundsTestEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBoundsTestEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBoundsTestEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthBoundsTestEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClampEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClampEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClampEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClampEnableEXT-depthClamp-07449", "If the depthClamp feature is not enabled, depthClampEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClampEnableEXT-extendedDynamicState3DepthClampEnable-07448", "The extendedDynamicState3DepthClampEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClampEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipEnableEXT-depthClipEnable-07451", "The depthClipEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipEnableEXT-extendedDynamicState3DepthClipEnable-07450", "The extendedDynamicState3DepthClipEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-depthClipControl-07453", "The depthClipControl feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-extendedDynamicState3DepthClipNegativeOneToOne-07452", "The extendedDynamicState3DepthClipNegativeOneToOne feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthCompareOp-None-03353", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetDepthCompareOp-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthCompareOp-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthCompareOp-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthCompareOp-depthCompareOp-parameter", "depthCompareOp must be a valid VkCompareOp value", "1.3-extensions"},
    {"VUID-vkCmdSetDepthCompareOp-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthTestEnable-None-03352", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetDepthTestEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthTestEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthTestEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthTestEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDepthWriteEnable-None-03354", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetDepthWriteEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDepthWriteEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDepthWriteEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDepthWriteEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-deviceMask-00108", "deviceMask must be a valid device mask value", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-deviceMask-00109", "deviceMask must not be zero", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-deviceMask-00110", "deviceMask must not include any set bits that were not in the VkDeviceGroupCommandBufferBeginInfo::deviceMask value when the command buffer began recording", "1.3-extensions"},
    {"VUID-vkCmdSetDeviceMask-deviceMask-00111", "If vkCmdSetDeviceMask is called inside a render pass instance, deviceMask must not include any set bits that were not in the VkDeviceGroupRenderPassBeginInfo::deviceMask value when the render pass instance began recording", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-discardRectangleCount-arraylength", "discardRectangleCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-firstDiscardRectangle-00585", "The sum of firstDiscardRectangle and discardRectangleCount must be less than or equal to VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-offset-00588", "Evaluation of (offset.x + extent.width) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-offset-00589", "Evaluation of (offset.y + extent.height) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-pDiscardRectangles-parameter", "pDiscardRectangles must be a valid pointer to an array of discardRectangleCount VkRect2D structures", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-viewportScissor2D-04788", "If this command is recorded in a secondary command buffer with VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled, then this function must not be called", "1.3-extensions"},
    {"VUID-vkCmdSetDiscardRectangleEXT-x-00587", "The x and y member of offset in each VkRect2D element of pDiscardRectangles must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-commandBuffer-01152", "commandBuffer's current device mask must include exactly one physical device", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-commonparent", "Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdSetEvent-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-01149", "stageMask must not include VK_PIPELINE_STAGE_HOST_BIT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-03937", "If the synchronization2 feature is not enabled, pname:stageMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04090", "If the geometryShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04091", "If the tessellationShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04092", "If the conditionalRendering feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04094", "If the transformFeedback feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04095", "If the meshShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04096", "If the taskShader feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-04097", "If the shadingRateImage feature is not enabled, pname:stageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdSetEvent-stageMask-04996", "pname:stageMask must not be 0", "1.2"},
    {"VUID-vkCmdSetEvent-stageMask-06457", "Any pipeline stage included in stageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkCmdSetEvent-stageMask-parameter", "stageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-commandBuffer-03826", "The current device mask of commandBuffer must include exactly one physical device", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-commonparent", "Both of commandBuffer, and event must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-dependencyFlags-03825", "The dependencyFlags member of pDependencyInfo must be 0", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-dstStageMask-03828", "The dstStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfo must only include pipeline stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-pDependencyInfo-parameter", "pDependencyInfo must be a valid pointer to a valid VkDependencyInfo structure", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-srcStageMask-03827", "The srcStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfo must only include pipeline stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdSetEvent2-synchronization2-03824", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-None-02031", "The exclusiveScissor feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-02036", "If the multiViewport feature is not enabled, exclusiveScissorCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-arraylength", "exclusiveScissorCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02034", "The sum of firstExclusiveScissor and exclusiveScissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02035", "If the multiViewport feature is not enabled, firstExclusiveScissor must be 0", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-offset-02038", "Evaluation of (offset.x + extent.width) for each member of pExclusiveScissors must not cause a signed integer addition overflow", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-offset-02039", "Evaluation of (offset.y + extent.height) for each member of pExclusiveScissors must not cause a signed integer addition overflow", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-pExclusiveScissors-parameter", "pExclusiveScissors must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetExclusiveScissorNV-x-02037", "The x and y members of offset in each member of pExclusiveScissors must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-extendedDynamicState3ExtraPrimitiveOverestimationSize-07427", "The extendedDynamicState3ExtraPrimitiveOverestimationSize feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-extraPrimitiveOverestimationSize-07428", "extraPrimitiveOverestimationSize must be in the range of 0.0 to VkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSize inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-attachmentFragmentShadingRate-04582", "If the attachmentFragmentShadingRate feature is not enabled, combinerOps[1] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-combinerOps-parameter", "Any given element of combinerOps must be a valid VkFragmentShadingRateCombinerOpKHR value", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-fragmentShadingRateEnums-04579", "The fragmentShadingRateEnums feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-fragmentSizeNonTrivialCombinerOps-04583", "If the fragmentSizeNonTrivialCombinerOps limit is not supported, elements of combinerOps must be either VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-noInvocationFragmentShadingRates-04578", "If noInvocationFragmentShadingRates is not enabled, shadingRate must not be VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-pipelineFragmentShadingRate-04576", "If pipelineFragmentShadingRate is not enabled, shadingRate must be VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-pipelineFragmentShadingRate-04580", "One of the pipelineFragmentShadingRate, primitiveFragmentShadingRate, or attachmentFragmentShadingRate features must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-primitiveFragmentShadingRate-04581", "If the primitiveFragmentShadingRate feature is not enabled, combinerOps[0] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-shadingRate-parameter", "shadingRate must be a valid VkFragmentShadingRateNV value", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-supersampleFragmentShadingRates-04577", "If supersampleFragmentShadingRates is not enabled, shadingRate must not be VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV, VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV, VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV, or VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateEnumNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-attachmentFragmentShadingRate-04511", "If the attachmentFragmentShadingRate feature is not enabled, combinerOps[1] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-combinerOps-parameter", "Any given element of combinerOps must be a valid VkFragmentShadingRateCombinerOpKHR value", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-fragmentSizeNonTrivialCombinerOps-04512", "If the fragmentSizeNonTrivialCombinerOps limit is not supported, elements of combinerOps must be either VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04513", "pFragmentSize->width must be greater than or equal to 1", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04514", "pFragmentSize->height must be greater than or equal to 1", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04515", "pFragmentSize->width must be a power-of-two value", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04516", "pFragmentSize->height must be a power-of-two value", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04517", "pFragmentSize->width must be less than or equal to 4", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04518", "pFragmentSize->height must be less than or equal to 4", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-parameter", "pFragmentSize must be a valid pointer to a valid VkExtent2D structure", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04507", "If pipelineFragmentShadingRate is not enabled, pFragmentSize->width must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04508", "If pipelineFragmentShadingRate is not enabled, pFragmentSize->height must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04509", "One of pipelineFragmentShadingRate, primitiveFragmentShadingRate, or attachmentFragmentShadingRate must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-primitiveFragmentShadingRate-04510", "If the primitiveFragmentShadingRate feature is not enabled, combinerOps[0] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR", "1.3-extensions"},
    {"VUID-vkCmdSetFragmentShadingRateKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetFrontFace-None-03383", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetFrontFace-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetFrontFace-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetFrontFace-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetFrontFace-frontFace-parameter", "frontFace must be a valid VkFrontFace value", "1.3-extensions"},
    {"VUID-vkCmdSetFrontFace-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-extendedDynamicState3LineRasterizationMode-07417", "The extendedDynamicState3LineRasterizationMode feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07418", "If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT, then the rectangularLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07419", "If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT, then the bresenhamLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07420", "If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT, then the smoothLines feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-parameter", "lineRasterizationMode must be a valid VkLineRasterizationModeEXT value", "1.3-extensions"},
    {"VUID-vkCmdSetLineRasterizationModeEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEXT-lineStippleFactor-02776", "lineStippleFactor must be in the range [1,256]", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEnableEXT-extendedDynamicState3LineStippleEnable-07421", "The extendedDynamicState3LineStippleEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLineStippleEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetLineWidth-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetLineWidth-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetLineWidth-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetLineWidth-lineWidth-00788", "If the wideLines feature is not enabled, lineWidth must be 1.0", "1.3-extensions"},
    {"VUID-vkCmdSetLineWidth-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEXT-None-04867", "The extendedDynamicState2LogicOp feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEXT-logicOp-parameter", "logicOp must be a valid VkLogicOp value", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEnableEXT-extendedDynamicState3LogicOpEnable-07365", "The extendedDynamicState3LogicOpEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEnableEXT-logicOp-07366", "If the logicOp feature is not enabled, logicOpEnable must be VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdSetLogicOpEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPatchControlPointsEXT-None-04873", "The extendedDynamicState2PatchControlPoints feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetPatchControlPointsEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetPatchControlPointsEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPatchControlPointsEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPatchControlPointsEXT-patchControlPoints-04874", "patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize", "1.3-extensions"},
    {"VUID-vkCmdSetPatchControlPointsEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceMarkerINTEL-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceMarkerINTEL-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceMarkerINTEL-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceMarkerINTEL-pMarkerInfo-parameter", "pMarkerInfo must be a valid pointer to a valid VkPerformanceMarkerInfoINTEL structure", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceMarkerINTEL-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceOverrideINTEL-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceOverrideINTEL-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceOverrideINTEL-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceOverrideINTEL-pOverrideInfo-02736", "pOverrideInfo must not be used with a VkPerformanceOverrideTypeINTEL that is not reported available by vkGetPerformanceParameterINTEL", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceOverrideINTEL-pOverrideInfo-parameter", "pOverrideInfo must be a valid pointer to a valid VkPerformanceOverrideInfoINTEL structure", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceOverrideINTEL-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceStreamMarkerINTEL-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, or transfer operations", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceStreamMarkerINTEL-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceStreamMarkerINTEL-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceStreamMarkerINTEL-pMarkerInfo-parameter", "pMarkerInfo must be a valid pointer to a valid VkPerformanceStreamMarkerInfoINTEL structure", "1.3-extensions"},
    {"VUID-vkCmdSetPerformanceStreamMarkerINTEL-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-extendedDynamicState3PolygonMode-07422", "The extendedDynamicState3PolygonMode feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-fillModeNonSolid-07423", "If the fillModeNonSolid feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL", "default"},
    {"VUID-vkCmdSetPolygonModeEXT-fillModeNonSolid-07424", "If the fillModeNonSolid feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-polygonMode-07425", "If the VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-polygonMode-parameter", "polygonMode must be a valid VkPolygonMode value", "1.3-extensions"},
    {"VUID-vkCmdSetPolygonModeEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveRestartEnable-None-04866", "The extendedDynamicState2 feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetPrimitiveRestartEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveRestartEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveRestartEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveRestartEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveTopology-None-03347", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetPrimitiveTopology-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveTopology-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveTopology-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveTopology-primitiveTopology-parameter", "primitiveTopology must be a valid VkPrimitiveTopology value", "1.3-extensions"},
    {"VUID-vkCmdSetPrimitiveTopology-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-extendedDynamicState3ProvokingVertexMode-07446", "The extendedDynamicState3ProvokingVertexMode feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-07447", "If provokingVertexMode is VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT, then the provokingVertexLast feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-parameter", "provokingVertexMode must be a valid VkProvokingVertexModeEXT value", "1.3-extensions"},
    {"VUID-vkCmdSetProvokingVertexModeEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationSamplesEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationSamplesEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationSamplesEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationSamplesEXT-extendedDynamicState3RasterizationSamples-07414", "The extendedDynamicState3RasterizationSamples feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationSamplesEXT-rasterizationSamples-parameter", "rasterizationSamples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationSamplesEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-extendedDynamicState3RasterizationStream-07410", "The extendedDynamicState3RasterizationStream feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-rasterizationStream-07412", "rasterizationStream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-rasterizationStream-07413", "rasterizationStream must be zero if VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelect is VK_FALSE", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-transformFeedback-07411", "The transformFeedback feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizationStreamEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizerDiscardEnable-None-04871", "The extendedDynamicState2 feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetRasterizerDiscardEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizerDiscardEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizerDiscardEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetRasterizerDiscardEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetRayTracingPipelineStackSizeKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdSetRayTracingPipelineStackSizeKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetRayTracingPipelineStackSizeKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetRayTracingPipelineStackSizeKHR-pipelineStackSize-03610", "pipelineStackSize must be large enough for any dynamic execution through the shaders in the ray tracing pipeline used by a subsequent trace call", "1.3-extensions"},
    {"VUID-vkCmdSetRayTracingPipelineStackSizeKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdSetRayTracingPipelineStackSizeKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetRepresentativeFragmentTestEnableNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetRepresentativeFragmentTestEnableNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetRepresentativeFragmentTestEnableNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetRepresentativeFragmentTestEnableNV-extendedDynamicState3RepresentativeFragmentTestEnable-07346", "The extendedDynamicState3RepresentativeFragmentTestEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetRepresentativeFragmentTestEnableNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEXT-pSampleLocationsInfo-parameter", "pSampleLocationsInfo must be a valid pointer to a valid VkSampleLocationsInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEXT-sampleLocationsPerPixel-01529", "The sampleLocationsPerPixel member of pSampleLocationsInfo must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with", "default"},
    {"VUID-vkCmdSetSampleLocationsEXT-variableSampleLocations-01530", "If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE then the current render pass must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sample locations state pointed to by pSampleLocationsInfo", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEnableEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEnableEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEnableEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEnableEXT-extendedDynamicState3SampleLocationsEnable-07415", "The extendedDynamicState3SampleLocationsEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetSampleLocationsEnableEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-extendedDynamicState3SampleMask-07342", "The extendedDynamicState3SampleMask feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-pSampleMask-parameter", "pSampleMask must be a valid pointer to an array of \\(\\lceil{\\mathit{samples} \\over 32}\\rceil\\) VkSampleMask values", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-vkCmdSetSampleMaskEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-firstScissor-00592", "The sum of firstScissor and scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-firstScissor-00593", "If the multiViewport feature is not enabled, firstScissor must be 0", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-offset-00596", "Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow for any element of pScissors", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-offset-00597", "Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow for any element of pScissors", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-pScissors-parameter", "pScissors must be a valid pointer to an array of scissorCount VkRect2D structures", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-scissorCount-00594", "If the multiViewport feature is not enabled, scissorCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-scissorCount-arraylength", "scissorCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-viewportScissor2D-04789", "If this command is recorded in a secondary command buffer with VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled, then this function must not be called", "1.3-extensions"},
    {"VUID-vkCmdSetScissor-x-00595", "The x and y members of offset member of any element of pScissors must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-None-03396", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetScissorWithCount-commandBuffer-04820", "commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-offset-03400", "Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow for any element of pScissors", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-offset-03401", "Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow for any element of pScissors", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-pScissors-parameter", "pScissors must be a valid pointer to an array of scissorCount VkRect2D structures", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-scissorCount-03397", "scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-scissorCount-03398", "If the multiViewport feature is not enabled, scissorCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-scissorCount-arraylength", "scissorCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetScissorWithCount-x-03399", "The x and y members of offset member of any element of pScissors must be greater than or equal to 0", "1.3-extensions"},
    {"VUID-vkCmdSetShadingRateImageEnableNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetShadingRateImageEnableNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetShadingRateImageEnableNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetShadingRateImageEnableNV-extendedDynamicState3ShadingRateImageEnable-07416", "The extendedDynamicState3ShadingRateImageEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetShadingRateImageEnableNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetStencilCompareMask-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetStencilCompareMask-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetStencilCompareMask-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetStencilCompareMask-faceMask-parameter", "faceMask must be a valid combination of VkStencilFaceFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask", "faceMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdSetStencilCompareMask-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-None-03351", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetStencilOp-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-compareOp-parameter", "compareOp must be a valid VkCompareOp value", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-depthFailOp-parameter", "depthFailOp must be a valid VkStencilOp value", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-faceMask-parameter", "faceMask must be a valid combination of VkStencilFaceFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-faceMask-requiredbitmask", "faceMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-failOp-parameter", "failOp must be a valid VkStencilOp value", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-passOp-parameter", "passOp must be a valid VkStencilOp value", "1.3-extensions"},
    {"VUID-vkCmdSetStencilOp-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetStencilReference-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetStencilReference-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetStencilReference-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetStencilReference-faceMask-parameter", "faceMask must be a valid combination of VkStencilFaceFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetStencilReference-faceMask-requiredbitmask", "faceMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdSetStencilReference-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetStencilTestEnable-None-03350", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetStencilTestEnable-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetStencilTestEnable-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetStencilTestEnable-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetStencilTestEnable-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetStencilWriteMask-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetStencilWriteMask-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetStencilWriteMask-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetStencilWriteMask-faceMask-parameter", "faceMask must be a valid combination of VkStencilFaceFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask", "faceMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdSetStencilWriteMask-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetTessellationDomainOriginEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetTessellationDomainOriginEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetTessellationDomainOriginEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetTessellationDomainOriginEXT-domainOrigin-parameter", "domainOrigin must be a valid VkTessellationDomainOrigin value", "1.3-extensions"},
    {"VUID-vkCmdSetTessellationDomainOriginEXT-extendedDynamicState3TessellationDomainOrigin-07444", "The extendedDynamicState3TessellationDomainOrigin feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetTessellationDomainOriginEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-None-04790", "The vertexInputDynamicState feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-binding-04793", "For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription2EXT must exist in pVertexBindingDescriptions with the same value of binding", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-04795", "All elements of pVertexAttributeDescriptions must describe distinct attribute locations", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-parameter", "If vertexAttributeDescriptionCount is not 0, pVertexAttributeDescriptions must be a valid pointer to an array of vertexAttributeDescriptionCount valid VkVertexInputAttributeDescription2EXT structures", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-04794", "All elements of pVertexBindingDescriptions must describe distinct binding numbers", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-parameter", "If vertexBindingDescriptionCount is not 0, pVertexBindingDescriptions must be a valid pointer to an array of vertexBindingDescriptionCount valid VkVertexInputBindingDescription2EXT structures", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-vertexAttributeDescriptionCount-04792", "vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-vertexBindingDescriptionCount-04791", "vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings", "1.3-extensions"},
    {"VUID-vkCmdSetVertexInputEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-commandBuffer-04821", "commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-firstViewport-01223", "The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-firstViewport-01224", "If the multiViewport feature is not enabled, firstViewport must be 0", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-pViewports-parameter", "pViewports must be a valid pointer to an array of viewportCount valid VkViewport structures", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-viewportCount-01225", "If the multiViewport feature is not enabled, viewportCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetViewport-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-None-02064", "The shadingRateImage feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02067", "The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02068", "If the multiViewport feature is not enabled, firstViewport must be 0", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-pShadingRatePalettes-parameter", "pShadingRatePalettes must be a valid pointer to an array of viewportCount valid VkShadingRatePaletteNV structures", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-02069", "If the multiViewport feature is not enabled, viewportCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-extendedDynamicState3ViewportSwizzle-07445", "The extendedDynamicState3ViewportSwizzle feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-pViewportSwizzles-parameter", "pViewportSwizzles must be a valid pointer to an array of viewportCount valid VkViewportSwizzleNV structures", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewportSwizzleNV-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingEnableNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingEnableNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingEnableNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingEnableNV-extendedDynamicState3ViewportWScalingEnable-07580", "The extendedDynamicState3ViewportWScalingEnable feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingEnableNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-firstViewport-01324", "The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-pViewportWScalings-parameter", "pViewportWScalings must be a valid pointer to an array of viewportCount VkViewportWScalingNV structures", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWScalingNV-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-None-03393", "The extendedDynamicState feature must be enabled", "1.2-extensions"},
    {"VUID-vkCmdSetViewportWithCount-commandBuffer-04819", "commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-pViewports-parameter", "pViewports must be a valid pointer to an array of viewportCount valid VkViewport structures", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-viewportCount-03394", "viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-viewportCount-03395", "If the multiViewport feature is not enabled, viewportCount must be 1", "1.3-extensions"},
    {"VUID-vkCmdSetViewportWithCount-viewportCount-arraylength", "viewportCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-04931", "This command must be called in a subpass with bind point VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI. No draw commands can be called in the same subpass. Only one vkCmdSubpassShadingHUAWEI command can be called in a subpass", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics operations", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-renderpass", "This command must only be called inside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdSubpassShadingHUAWEI-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-03429", "Any shader group handle referenced by this call must have been queried from the currently bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-commandBuffer-03635", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-indirectDeviceAddress-03632", "If the buffer from which indirectDeviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-indirectDeviceAddress-03633", "The buffer from which indirectDeviceAddress was queried must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-indirectDeviceAddress-03634", "indirectDeviceAddress must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-indirectDeviceAddress-03636", "All device addresses between indirectDeviceAddress and indirectDeviceAddress + sizeof(sname:VkTraceRaysIndirectCommand2KHR) - 1 must be in the buffer device address range of the same buffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-maxPipelineRayRecursionDepth-03679", "This command must not cause a shader call instruction to be executed from a shader invocation with a recursion depth greater than the value of maxPipelineRayRecursionDepth used to create the bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-rayTracingMotionBlurPipelineTraceRaysIndirect-04951", "If the bound ray tracing pipeline was created with VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV VkPhysicalDeviceRayTracingMotionBlurFeaturesNV::rayTracingMotionBlurPipelineTraceRaysIndirect feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-rayTracingPipelineTraceRaysIndirect2-03637", "The pname:rayTracingPipelineTraceRaysIndirect2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirect2KHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-03429", "Any shader group handle referenced by this call must have been queried from the currently bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-03635", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-03511", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, the shader group handle identified by pname:pMissShaderBindingTable->deviceAddress must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-03512", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed as a result of this command in order to execute an any-hit shader must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-03513", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed as a result of this command in order to execute a closest hit shader must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-03514", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed as a result of this command in order to execute an intersection shader must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-03696", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, pname:pHitShaderBindingTable->deviceAddress must not be zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-flags-03697", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, pname:pHitShaderBindingTable->deviceAddress must not be zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03632", "If the buffer from which indirectDeviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03633", "The buffer from which indirectDeviceAddress was queried must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03634", "indirectDeviceAddress must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03636", "All device addresses between indirectDeviceAddress and indirectDeviceAddress + sizeof(sname:VkTraceRaysIndirectCommandKHR) - 1 must be in the buffer device address range of the same buffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-maxPipelineRayRecursionDepth-03679", "This command must not cause a shader call instruction to be executed from a shader invocation with a recursion depth greater than the value of maxPipelineRayRecursionDepth used to create the bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-03691", "If the buffer from which pname:pCallableShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-03692", "The buffer from which the pname:pCallableShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-03693", "pname:pCallableShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pCallableShaderBindingTable-parameter", "pCallableShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-03687", "If the buffer from which pname:pHitShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-03688", "The buffer from which the pname:pHitShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-03689", "pname:pHitShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-04735", "Any non-zero hit shader group entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed by this call from a geometry with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR must have been created with VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-04736", "Any non-zero hit shader group entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed by this call from a geometry with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR must have been created with VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pHitShaderBindingTable-parameter", "pHitShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-03683", "If the buffer from which pname:pMissShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-03684", "The buffer from which the pname:pMissShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-03685", "pname:pMissShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pMissShaderBindingTable-parameter", "pMissShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pRayGenShaderBindingTable-03680", "If the buffer from which pname:pRayGenShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pRayGenShaderBindingTable-03681", "The buffer from which the pname:pRayGenShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pRayGenShaderBindingTable-03682", "pname:pRayGenShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-pRaygenShaderBindingTable-parameter", "pRaygenShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-rayTracingMotionBlurPipelineTraceRaysIndirect-04951", "If the bound ray tracing pipeline was created with VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV VkPhysicalDeviceRayTracingMotionBlurFeaturesNV::rayTracingMotionBlurPipelineTraceRaysIndirect feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-rayTracingPipelineTraceRaysIndirect-03637", "The pname:rayTracingPipelineTraceRaysIndirect feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-size-04023", "The size member of pRayGenShaderBindingTable must be equal to its stride member", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-stride-03686", "pname:pMissShaderBindingTable->stride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-stride-03690", "pname:pHitShaderBindingTable->stride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-stride-03694", "pname:pCallableShaderBindingTable->stride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-stride-04029", "pname:pMissShaderBindingTable->stride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-stride-04035", "pname:pHitShaderBindingTable->stride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-stride-04041", "pname:pCallableShaderBindingTable->stride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysIndirectKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdTraceRaysKHR-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdTraceRaysKHR-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-khr-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-03429", "Any shader group handle referenced by this call must have been queried from the currently bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdTraceRaysKHR-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-commandBuffer-03635", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-depth-03640", "depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-03511", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR, the shader group handle identified by pname:pMissShaderBindingTable->deviceAddress must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-03512", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed as a result of this command in order to execute an any-hit shader must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-03513", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed as a result of this command in order to execute a closest hit shader must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-03514", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed as a result of this command in order to execute an intersection shader must not be set to zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-03696", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, pname:pHitShaderBindingTable->deviceAddress must not be zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-flags-03697", "If the currently bound ray tracing pipeline was created with flags that included VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR, pname:pHitShaderBindingTable->deviceAddress must not be zero", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-height-03639", "height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-maxPipelineRayRecursionDepth-03679", "This command must not cause a shader call instruction to be executed from a shader invocation with a recursion depth greater than the value of maxPipelineRayRecursionDepth used to create the bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-03691", "If the buffer from which pname:pCallableShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-03692", "The buffer from which the pname:pCallableShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-03693", "pname:pCallableShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pCallableShaderBindingTable-parameter", "pCallableShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-03687", "If the buffer from which pname:pHitShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-03688", "The buffer from which the pname:pHitShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-03689", "pname:pHitShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-04735", "Any non-zero hit shader group entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed by this call from a geometry with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR must have been created with VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-04736", "Any non-zero hit shader group entries in the table identified by pname:pHitShaderBindingTable->deviceAddress accessed by this call from a geometry with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR must have been created with VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pHitShaderBindingTable-parameter", "pHitShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-03683", "If the buffer from which pname:pMissShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-03684", "The buffer from which the pname:pMissShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-03685", "pname:pMissShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pMissShaderBindingTable-parameter", "pMissShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pRayGenShaderBindingTable-03680", "If the buffer from which pname:pRayGenShaderBindingTable->deviceAddress was queried is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pRayGenShaderBindingTable-03681", "The buffer from which the pname:pRayGenShaderBindingTable->deviceAddress is queried must have been created with the VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR usage flag", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pRayGenShaderBindingTable-03682", "pname:pRayGenShaderBindingTable->deviceAddress must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-pRaygenShaderBindingTable-parameter", "pRaygenShaderBindingTable must be a valid pointer to a valid VkStridedDeviceAddressRegionKHR structure", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-size-04023", "The size member of pRayGenShaderBindingTable must be equal to its stride member", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-stride-03686", "pname:pMissShaderBindingTable->stride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-stride-03690", "pname:pHitShaderBindingTable->stride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-stride-03694", "pname:pCallableShaderBindingTable->stride must be a multiple of VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-stride-04029", "pname:pMissShaderBindingTable->stride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-stride-04035", "pname:pHitShaderBindingTable->stride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-stride-04041", "pname:pCallableShaderBindingTable->stride must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-width-03638", "width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] {times} VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysKHR-width-03641", "width {times} height {times} depth must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayDispatchInvocationCount", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-ConstOffset-06551", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must not use the ConstOffset and Offset operands", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02691", "If a VkImageView is accessed using atomic operations as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02692", "If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02693", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY", "default"},
    {"VUID-vkCmdTraceRaysNV-None-02697", "For each set n that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02698", "For each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "default"},
    {"VUID-vkCmdTraceRaysNV-None-02699", "Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid if they are statically used by the VkPipeline bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02700", "A valid pipeline must be bound to the pipeline bind point used by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02702", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used to sample from any VkImage with a VkImageView of the type VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, VK_IMAGE_VIEW_TYPE_1D_ARRAY, VK_IMAGE_VIEW_TYPE_2D_ARRAY or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02703", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02704", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler object that uses unnormalized coordinates, that sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values, in any shader stage", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-02705", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdTraceRaysNV-None-02706", "If the robustBufferAccess feature is not enabled, and if the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "default"},
    {"VUID-vkCmdTraceRaysNV-None-02859", "There must not have been any calls to dynamic state setting commands for any state not specified as dynamic in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-03429", "Any shader group handle referenced by this call must have been queried from the currently bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-04115", "If a VkImageView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-06479", "If a VkImageView is sampled with depth comparison, the image view's format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-06550", "If the VkPipeline object bound to the pipeline bind point used by this command accesses a VkSampler or VkImageView object that enables sampler {YCbCr} conversion, that object must only be used with OpImageSample* or OpImageSparseSample* instructions", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-None-07288", "Any shader invocation executed by this command must terminate", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageBlockMatchSADQCOM-06975", "If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageBlockMatchSADQCOM-06976", "If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageBlockMatchSSDQCOM-06974", "If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageBoxFilterQCOM-06973", "If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageWeightedSampleQCOM-06971", "If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageWeightedSampleQCOM-06972", "If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageWeightedSampleQCOM-06977", "If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageWeightedSampleQCOM-06978", "If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM.", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpImageWrite-04469", "If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view's format", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpTypeImage-07027", "For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpTypeImage-07028", "For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view's format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpTypeImage-07029", "For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-OpTypeImage-07030", "Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view's buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-SampledType-04470", "If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-SampledType-04471", "If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-SampledType-04472", "If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-SampledType-04473", "If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-aspectMask-06478", "If a VkImageView is sampled with depth comparison, the image view must have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT.", "default"},
    {"VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02461", "callableShaderBindingOffset must be less than the size of callableShaderBindingTableBuffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02462", "callableShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02465", "callableShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02468", "callableShaderBindingStride must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-callableShaderBindingTableBuffer-04045", "If callableShaderBindingTableBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-callableShaderBindingTableBuffer-parameter", "If callableShaderBindingTableBuffer is not VK_NULL_HANDLE, callableShaderBindingTableBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commandBuffer-02701", "If the VkPipeline object bound to the pipeline bind point used by this command requires any dynamic state, that state must have been set or inherited (if the VK_NV_inherited_viewport_scissor extension is enabled) for commandBuffer, and done so after any previously bound pipeline with the corresponding state not specified as dynamic", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commandBuffer-02707", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by the VkPipeline object bound to the pipeline bind point used by this command must not be a protected resource", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commandBuffer-04624", "commandBuffer must not be a protected command buffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-commonparent", "Each of callableShaderBindingTableBuffer, commandBuffer, hitShaderBindingTableBuffer, missShaderBindingTableBuffer, and raygenShaderBindingTableBuffer that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-depth-02471", "depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-filterCubic-02694", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-filterCubicMinmax-02695", "Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-flags-02696", "Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-height-02470", "height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02459", "hitShaderBindingOffset must be less than the size of hitShaderBindingTableBuffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02460", "hitShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02464", "hitShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02467", "hitShaderBindingStride must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-hitShaderBindingTableBuffer-04044", "If hitShaderBindingTableBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-hitShaderBindingTableBuffer-parameter", "If hitShaderBindingTableBuffer is not VK_NULL_HANDLE, hitShaderBindingTableBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-magFilter-04553", "If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-maintenance4-06425", "If the maintenance4 feature is not enabled, then for each push constant that is statically used by the VkPipeline bound to the pipeline bind point used by this command, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline, as described in Pipeline Layout Compatibility", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-maxRecursionDepth-03625", "This command must not cause a pipeline trace ray instruction to be executed from a shader invocation with a recursion depth greater than the value of maxRecursionDepth used to create the bound ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-mipmapMode-04770", "If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view's format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02457", "missShaderBindingOffset must be less than the size of missShaderBindingTableBuffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02458", "missShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-missShaderBindingStride-02463", "missShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-missShaderBindingStride-02466", "missShaderBindingStride must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-missShaderBindingTableBuffer-04043", "If missShaderBindingTableBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-missShaderBindingTableBuffer-parameter", "If missShaderBindingTableBuffer is not VK_NULL_HANDLE, missShaderBindingTableBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02455", "raygenShaderBindingOffset must be less than the size of raygenShaderBindingTableBuffer", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02456", "raygenShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-raygenShaderBindingTableBuffer-04042", "If raygenShaderBindingTableBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-raygenShaderBindingTableBuffer-parameter", "raygenShaderBindingTableBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-sparseImageInt64Atomics-04474", "If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-sparseImageInt64Atomics-04475", "If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-storageBuffers-06936", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-uniformBuffers-06935", "If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdTraceRaysNV-width-02469", "width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-commandBuffer-01813", "If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-commandBuffer-01814", "If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-commonparent", "Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dataSize-00033", "dataSize must be less than or equal to the size of dstBuffer minus dstOffset", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dataSize-00037", "dataSize must be less than or equal to 65536", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dataSize-00038", "dataSize must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dstBuffer-00034", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dstBuffer-00035", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dstOffset-00032", "dstOffset must be less than the size of dstBuffer", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-dstOffset-00036", "dstOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdUpdateBuffer-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-commandBuffer-01167", "commandBuffer's current device mask must include exactly one physical device", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-commonparent", "Both of commandBuffer, and the elements of pEvents must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstAccessMask-02816", "The dstAccessMask member of each element of pMemoryBarriers must only include access flags that are supported by one or more of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-03937", "If the synchronization2 feature is not enabled, pname:dstStageMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04090", "If the geometryShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04091", "If the tessellationShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04092", "If the conditionalRendering feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04094", "If the transformFeedback feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04095", "If the meshShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04096", "If the taskShader feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04097", "If the shadingRateImage feature is not enabled, pname:dstStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdWaitEvents-dstStageMask-04996", "pname:dstStageMask must not be 0", "1.2"},
    {"VUID-vkCmdWaitEvents-dstStageMask-06460", "Any pipeline stage included in dstStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-dstStageMask-parameter", "dstStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-eventCount-arraylength", "eventCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-fragmentShadingRate-07319", "If the attachmentFragmentShadingRate feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdWaitEvents-pBufferMemoryBarriers-02817", "For any element of pBufferMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its srcQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its srcAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pBufferMemoryBarriers-02818", "For any element of pBufferMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its dstQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its dstAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter", "If bufferMemoryBarrierCount is not 0, pBufferMemoryBarriers must be a valid pointer to an array of bufferMemoryBarrierCount valid VkBufferMemoryBarrier structures", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pEvents-03847", "Elements of pEvents must not have been signaled by vkCmdSetEvent2", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pEvents-parameter", "pEvents must be a valid pointer to an array of eventCount valid VkEvent handles", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pImageMemoryBarriers-02819", "For any element of pImageMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its srcQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its srcAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pImageMemoryBarriers-02820", "For any element of pImageMemoryBarriers, if its srcQueueFamilyIndex and dstQueueFamilyIndex members are equal, or if its dstQueueFamilyIndex is the queue family index that was used to create the command pool that commandBuffer was allocated from, then its dstAccessMask member must only contain access flags that are supported by one or more of the pipeline stages in dstStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter", "If imageMemoryBarrierCount is not 0, pImageMemoryBarriers must be a valid pointer to an array of imageMemoryBarrierCount valid VkImageMemoryBarrier structures", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-pMemoryBarriers-parameter", "If memoryBarrierCount is not 0, pMemoryBarriers must be a valid pointer to an array of memoryBarrierCount valid VkMemoryBarrier structures", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-shadingRateImage-07318", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcAccessMask-02815", "The srcAccessMask member of each element of pMemoryBarriers must only include access flags that are supported by one or more of the pipeline stages in srcStageMask, as specified in the table of supported access types", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcQueueFamilyIndex-02803", "The srcQueueFamilyIndex and dstQueueFamilyIndex members of any element of pBufferMemoryBarriers or pImageMemoryBarriers must be equal", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-01158", "srcStageMask must be the bitwise OR of the stageMask parameter used in previous calls to vkCmdSetEvent with any of the elements of pEvents and VK_PIPELINE_STAGE_HOST_BIT if any of the elements of pEvents was set using vkSetEvent", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-03937", "If the synchronization2 feature is not enabled, pname:srcStageMask must not be 0", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04090", "If the geometryShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04091", "If the tessellationShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04092", "If the conditionalRendering feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04093", "If the fragmentDensityMap feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04094", "If the transformFeedback feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04095", "If the meshShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04096", "If the taskShader feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04097", "If the shadingRateImage feature is not enabled, pname:srcStageMask must not contain VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdWaitEvents-srcStageMask-04996", "pname:srcStageMask must not be 0", "1.2"},
    {"VUID-vkCmdWaitEvents-srcStageMask-06459", "Any pipeline stage included in srcStageMask must be supported by the capabilities of the queue family specified by the queueFamilyIndex member of the VkCommandPoolCreateInfo structure that was used to create the VkCommandPool that commandBuffer was allocated from, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-07308", "If vkCmdWaitEvents is being called inside a render pass instance, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents-srcStageMask-parameter", "srcStageMask must be a valid combination of VkPipelineStageFlagBits values", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-commandBuffer-03846", "commandBuffer's current device mask must include exactly one physical device", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-commonparent", "Both of commandBuffer, and the elements of pEvents must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-dependencyFlags-03844", "If vkCmdWaitEvents2 is being called inside a render pass instance, the srcStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfos must not include VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-dstStageMask-03843", "The dstStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfos must only include pipeline stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-eventCount-arraylength", "eventCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pDependencyInfos-parameter", "pDependencyInfos must be a valid pointer to an array of eventCount valid VkDependencyInfo structures", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pEvents-03837", "Members of pEvents must not have been signaled by vkCmdSetEvent", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pEvents-03838", "For any element i of pEvents, if that event is signaled by vkCmdSetEvent2, that command's dependencyInfo parameter must be exactly equal to the ith element of pDependencyInfos", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pEvents-03839", "For any element i of pEvents, if that event is signaled by vkSetEvent, barriers in the ith element of pDependencyInfos must include only host operations in their first synchronization scope", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pEvents-03840", "For any element i of pEvents, if barriers in the ith element of pDependencyInfos include only host operations, the ith element of pEvents must be signaled before vkCmdWaitEvents2 is executed", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pEvents-03841", "For any element i of pEvents, if barriers in the ith element of pDependencyInfos do not include host operations, the ith element of pEvents must be signaled by a corresponding vkCmdSetEvent2 that occurred earlier in submission order", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-pEvents-parameter", "pEvents must be a valid pointer to an array of eventCount valid VkEvent handles", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-srcStageMask-03842", "The srcStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfos must either include only pipeline stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from, or include only VK_PIPELINE_STAGE_2_HOST_BIT", "1.3-extensions"},
    {"VUID-vkCmdWaitEvents2-synchronization2-03836", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength", "accelerationStructureCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructures-03431", "All acceleration structures in pAccelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-buffer-03736", "The buffer used to create each acceleration structure in pAccelerationStructures must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-commonparent", "Each of commandBuffer, queryPool, and the elements of pAccelerationStructures must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-04964", "All acceleration structures in pAccelerationStructures must have been built prior to the execution of this command", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-parameter", "pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureKHR handles", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-query-04880", "The sum of query plus accelerationStructureCount must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02493", "queryPool must have been created with a queryType matching queryType", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02494", "The queries identified by queryPool and firstQuery must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-03432", "queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "default"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-06742", "queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-parameter", "queryType must be a valid VkQueryType value", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructure-03757", "accelerationStructure must be bound completely and contiguously to a single VkDeviceMemory object via vkBindAccelerationStructureMemoryNV", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-accelerationStructureCount-arraylength", "accelerationStructureCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-commonparent", "Each of commandBuffer, queryPool, and the elements of pAccelerationStructures must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-04958", "All acceleration structures in pAccelerationStructures must have been built prior to the execution of this command", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-06215", "All acceleration structures in pAccelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-parameter", "pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureNV handles", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03755", "queryPool must have been created with a queryType matching queryType", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03756", "The queries identified by queryPool and firstQuery must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-06216", "queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-parameter", "queryType must be a valid VkQueryType value", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-commonparent", "Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-dstBuffer-03897", "dstBuffer must have been created with the VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-dstBuffer-03898", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-dstOffset-03896", "dstOffset must be less than or equal to the size of dstBuffer minus 4", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-dstOffset-03899", "dstOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "default"},
    {"VUID-vkCmdWriteBufferMarker2AMD-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03894", "stage must include only a single pipeline stage", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03895", "stage must include only stages that are valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03929", "If the geometryShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03930", "If the tessellationShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03931", "If the conditionalRendering feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03932", "If the fragmentDensityMap feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03933", "If the transformFeedback feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03934", "If the meshShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-03935", "If the taskShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-04956", "If the shadingRateImage feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-04957", "If the subpassShading feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-04995", "If the invocationMask feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-stage-parameter", "stage must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-synchronization2-03893", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarker2AMD-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, or compute operations", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-commonparent", "Both of commandBuffer, and dstBuffer must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-01799", "dstBuffer must have been created with VK_BUFFER_USAGE_TRANSFER_DST_BIT usage flag", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-01800", "If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-parameter", "dstBuffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-dstOffset-01798", "dstOffset must be less than or equal to the size of dstBuffer minus 4", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-dstOffset-01801", "dstOffset must be a multiple of 4", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-fragmentShadingRate-07315", "If the attachmentFragmentShadingRate feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "default"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04074", "pipelineStage must be a valid stage for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04075", "If the geometryShader feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04076", "If the tessellationShader feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04077", "If the conditionalRendering feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04078", "If the fragmentDensityMap feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04079", "If the transformFeedback feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04080", "If the meshShader feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-04081", "If the shadingRateImage feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-06490", "pipelineStage must not be VK_PIPELINE_STAGE_NONE", "default"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-07077", "If the task shaders feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-pipelineStage-parameter", "If pipelineStage is not 0, pipelineStage must be a valid VkPipelineStageFlagBits value", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-shadingRateImage-07314", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pipelineStage must not be VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-synchronization2-06489", "If the synchronization2 feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_NONE", "1.3-extensions"},
    {"VUID-vkCmdWriteBufferMarkerAMD-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-buffer-07527", "The buffer used to create each micromap in pMicrmaps must be bound to device memory", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support compute operations", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-commonparent", "Each of commandBuffer, queryPool, and the elements of pMicromaps must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-micromapCount-arraylength", "micromapCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-pMicromaps-07501", "All micromaps in pMicromaps must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-pMicromaps-07502", "All micromaps in pMicromaps must have been constructed with VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT if queryType is VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-pMicromaps-parameter", "pMicromaps must be a valid pointer to an array of micromapCount valid VkMicromapEXT handles", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-query-07528", "The sum of query plus micromapCount must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-queryPool-07525", "queryPool must have been created with a queryType matching queryType", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-queryPool-07526", "The queries identified by queryPool and firstQuery must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-queryType-07503", "queryType must be VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT or VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-queryType-parameter", "queryType must be a valid VkQueryType value", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-renderpass", "This command must only be called outside of a render pass instance", "1.3-extensions"},
    {"VUID-vkCmdWriteMicromapsPropertiesEXT-videocoding", "This command must only be called outside of a video coding scope", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-None-00830", "All queries used by the command must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-fragmentShadingRate-07315", "If the attachmentFragmentShadingRate feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04074", "pipelineStage must be a valid stage for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04075", "If the geometryShader feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04076", "If the tessellationShader feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04077", "If the conditionalRendering feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04078", "If the fragmentDensityMap feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04079", "If the transformFeedback feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04080", "If the meshShader feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-04081", "If the shadingRateImage feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-06490", "pipelineStage must not be VK_PIPELINE_STAGE_NONE", "1.2"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-07077", "If the task shaders feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-pipelineStage-parameter", "pipelineStage must be a valid VkPipelineStageFlagBits value", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-query-00831", "If vkCmdWriteTimestamp is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-query-04904", "query must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-queryPool-00828", "The query identified by queryPool and query must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-queryPool-01416", "queryPool must have been created with a queryType of VK_QUERY_TYPE_TIMESTAMP", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-shadingRateImage-07314", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pipelineStage must not be VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-synchronization2-06489", "If the synchronization2 feature is not enabled, pipelineStage must not be VK_PIPELINE_STAGE_NONE", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp-timestampValidBits-00829", "The command pool's queue family must support a non-zero timestampValidBits", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-None-03864", "All queries used by the command must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-commandBuffer-cmdpool", "The VkCommandPool that commandBuffer was allocated from must support transfer, graphics, compute, decode, or encode operations", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-commandBuffer-recording", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-commonparent", "Both of commandBuffer, and queryPool must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-fragmentShadingRate-07317", "If the attachmentFragmentShadingRate feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-khr-extensions"},
    {"VUID-vkCmdWriteTimestamp2-query-03865", "If vkCmdWriteTimestamp2 is called within a render pass instance, the sum of query and the number of bits set in the current subpass's view mask must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-query-04903", "query must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-queryPool-03861", "queryPool must have been created with a queryType of VK_QUERY_TYPE_TIMESTAMP", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-queryPool-03862", "The query identified by queryPool and query must be unavailable", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-shadingRateImage-07316", "If neither the shadingRateImage or attachmentFragmentShadingRate are enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03859", "stage must only include a single pipeline stage", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03860", "stage must only include stages valid for the queue family that was used to create the command pool that commandBuffer was allocated from", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03929", "If the geometryShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03930", "If the tessellationShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT or VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03931", "If the conditionalRendering feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03932", "If the fragmentDensityMap feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03933", "If the transformFeedback feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03934", "If the meshShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-03935", "If the taskShader feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-04956", "If the shadingRateImage feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV", "default"},
    {"VUID-vkCmdWriteTimestamp2-stage-04957", "If the subpassShading feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-04995", "If the invocationMask feature is not enabled, pname:stage must not contain VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-stage-parameter", "stage must be a valid combination of VkPipelineStageFlagBits2 values", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-synchronization2-03858", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkCmdWriteTimestamp2-timestampValidBits-03863", "The command pool's queue family must support a non-zero timestampValidBits", "1.3-extensions"},
    {"VUID-vkCompileDeferredNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCompileDeferredNV-pipeline-02237", "pipeline must have been created with VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV", "1.3-extensions"},
    {"VUID-vkCompileDeferredNV-pipeline-04621", "pipeline must be a ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkCompileDeferredNV-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkCompileDeferredNV-pipeline-parent", "pipeline must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCompileDeferredNV-shader-02238", "shader must not have been called as a deferred compile before", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-accelerationStructureHostCommands-03582", "The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-buffer-03727", "The buffer used to create pInfo->src must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-buffer-03728", "The buffer used to create pInfo->dst must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-buffer-03780", "The buffer used to create pInfo->src must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-buffer-03781", "The buffer used to create pInfo->dst must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyAccelerationStructureInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-accelerationStructureHostCommands-03584", "The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-buffer-03731", "The buffer used to create pInfo->src must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-buffer-03783", "The buffer used to create pInfo->src must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-03732", "pInfo->dst.hostAddress must be a valid host pointer", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-03751", "pInfo->dst.hostAddress must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyAccelerationStructureToMemoryInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-accelerationStructureHostCommands-03583", "The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-buffer-03730", "The buffer used to create pInfo->dst must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-buffer-03782", "The buffer used to create pInfo->dst must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-03729", "pInfo->src.hostAddress must be a valid host pointer", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-03750", "pInfo->src.hostAddress must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMemoryToAccelerationStructureInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-buffer-07565", "The buffer used to create pInfo->dst must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-buffer-07567", "The buffer used to create pInfo->dst must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-micromapHostCommands-07566", "The VkPhysicalDeviceOpacityMicromapFeaturesEXT::micromapHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-pInfo-07563", "pInfo->src.hostAddress must be a valid host pointer", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-pInfo-07564", "pInfo->src.hostAddress must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCopyMemoryToMicromapEXT-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMemoryToMicromapInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-buffer-07558", "The buffer used to create pInfo->src must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-buffer-07559", "The buffer used to create pInfo->dst must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-buffer-07561", "The buffer used to create pInfo->src must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-buffer-07562", "The buffer used to create pInfo->dst must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-micromapHostCommands-07560", "The VkPhysicalDeviceOpacityMicromapFeaturesEXT::micromapHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCopyMicromapEXT-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMicromapInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-buffer-07568", "The buffer used to create pInfo->src must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-buffer-07572", "The buffer used to create pInfo->src must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-micromapHostCommands-07571", "The VkPhysicalDeviceOpacityMicromapFeaturesEXT::micromapHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-pInfo-07569", "pInfo->dst.hostAddress must be a valid host pointer", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-pInfo-07570", "pInfo->dst.hostAddress must be aligned to 16 bytes", "1.3-extensions"},
    {"VUID-vkCopyMicromapToMemoryEXT-pInfo-parameter", "pInfo must be a valid pointer to a valid VkCopyMicromapToMemoryInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-accelerationStructure-03611", "The accelerationStructure feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-device-03489", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-deviceAddress-03488", "If VkAccelerationStructureCreateInfoKHR::deviceAddress is not zero, the accelerationStructureCaptureReplay feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-pAccelerationStructure-parameter", "pAccelerationStructure must be a valid pointer to a VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkAccelerationStructureCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureNV-pAccelerationStructure-parameter", "pAccelerationStructure must be a valid pointer to a VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateAccelerationStructureNV-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkAccelerationStructureCreateInfoNV structure", "1.3-extensions"},
    {"VUID-vkCreateAndroidSurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateAndroidSurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateAndroidSurfaceKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkAndroidSurfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateBuffer-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateBuffer-flags-00911", "If the flags member of pCreateInfo includes VK_BUFFER_CREATE_SPARSE_BINDING_BIT, creating this VkBuffer must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize", "1.3-extensions"},
    {"VUID-vkCreateBuffer-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateBuffer-pBuffer-parameter", "pBuffer must be a valid pointer to a VkBuffer handle", "1.3-extensions"},
    {"VUID-vkCreateBuffer-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkBufferCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateBuffer-pNext-06387", "If using the VkBuffer for an import operation from a VkBufferCollectionFUCHSIA where a VkBufferCollectionBufferCreateInfoFUCHSIA has been chained to pNext, pCreateInfo must match the VkBufferConstraintsInfoFUCHSIA::createInfo used when setting the constraints on the buffer collection with vkSetBufferCollectionBufferConstraintsFUCHSIA", "1.3-extensions"},
    {"VUID-vkCreateBufferCollectionFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateBufferCollectionFUCHSIA-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateBufferCollectionFUCHSIA-pCollection-parameter", "pCollection must be a valid pointer to a VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-vkCreateBufferCollectionFUCHSIA-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkBufferCollectionCreateInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkCreateBufferView-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateBufferView-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateBufferView-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkBufferViewCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateBufferView-pView-parameter", "pView must be a valid pointer to a VkBufferView handle", "1.3-extensions"},
    {"VUID-vkCreateCommandPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateCommandPool-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateCommandPool-pCommandPool-parameter", "pCommandPool must be a valid pointer to a VkCommandPool handle", "1.3-extensions"},
    {"VUID-vkCreateCommandPool-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkCommandPoolCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateCommandPool-queueFamilyIndex-01937", "pCreateInfo->queueFamilyIndex must be the index of a queue family available in the logical device device", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-createInfoCount-arraylength", "createInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-flags-00695", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-flags-00696", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-pCreateInfos-parameter", "pCreateInfos must be a valid pointer to an array of createInfoCount valid VkComputePipelineCreateInfo structures", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-pPipelines-parameter", "pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-pipelineCache-02873", "If pipelineCache was created with VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access to pipelineCache must be externally synchronized", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-pipelineCache-parameter", "If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkCreateComputePipelines-pipelineCache-parent", "If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCreateCuFunctionNVX-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateCuFunctionNVX-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateCuFunctionNVX-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkCuFunctionCreateInfoNVX structure", "1.3-extensions"},
    {"VUID-vkCreateCuFunctionNVX-pFunction-parameter", "pFunction must be a valid pointer to a VkCuFunctionNVX handle", "1.3-extensions"},
    {"VUID-vkCreateCuModuleNVX-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateCuModuleNVX-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateCuModuleNVX-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkCuModuleCreateInfoNVX structure", "1.3-extensions"},
    {"VUID-vkCreateCuModuleNVX-pModule-parameter", "pModule must be a valid pointer to a VkCuModuleNVX handle", "1.3-extensions"},
    {"VUID-vkCreateDebugReportCallbackEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateDebugReportCallbackEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDebugReportCallbackEXT-pCallback-parameter", "pCallback must be a valid pointer to a VkDebugReportCallbackEXT handle", "1.3-extensions"},
    {"VUID-vkCreateDebugReportCallbackEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDebugReportCallbackCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateDebugUtilsMessengerEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateDebugUtilsMessengerEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDebugUtilsMessengerEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDebugUtilsMessengerCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateDebugUtilsMessengerEXT-pMessenger-parameter", "pMessenger must be a valid pointer to a VkDebugUtilsMessengerEXT handle", "1.3-extensions"},
    {"VUID-vkCreateDeferredOperationKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDeferredOperationKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDeferredOperationKHR-pDeferredOperation-parameter", "pDeferredOperation must be a valid pointer to a VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCreateDescriptorPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDescriptorPool-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDescriptorPool-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDescriptorPoolCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateDescriptorPool-pDescriptorPool-parameter", "pDescriptorPool must be a valid pointer to a VkDescriptorPool handle", "1.3-extensions"},
    {"VUID-vkCreateDescriptorSetLayout-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDescriptorSetLayout-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter", "pSetLayout must be a valid pointer to a VkDescriptorSetLayout handle", "1.3-extensions"},
    {"VUID-vkCreateDescriptorUpdateTemplate-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDescriptorUpdateTemplate-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDescriptorUpdateTemplate-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDescriptorUpdateTemplateCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateDescriptorUpdateTemplate-pDescriptorUpdateTemplate-parameter", "pDescriptorUpdateTemplate must be a valid pointer to a VkDescriptorUpdateTemplate handle", "1.3-extensions"},
    {"VUID-vkCreateDevice-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDevice-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDeviceCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateDevice-pDevice-parameter", "pDevice must be a valid pointer to a VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDevice-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDevice-ppEnabledExtensionNames-01387", "All required device extensions for each extension in the VkDeviceCreateInfo::ppEnabledExtensionNames list must also be present in that list", "1.3-extensions"},
    {"VUID-vkCreateDirectFBSurfaceEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateDirectFBSurfaceEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDirectFBSurfaceEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDirectFBSurfaceCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateDirectFBSurfaceEXT-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateDisplayModeKHR-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkCreateDisplayModeKHR-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkCreateDisplayModeKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDisplayModeKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDisplayModeCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateDisplayModeKHR-pMode-parameter", "pMode must be a valid pointer to a VkDisplayModeKHR handle", "1.3-extensions"},
    {"VUID-vkCreateDisplayModeKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkCreateDisplayPlaneSurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateDisplayPlaneSurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateDisplayPlaneSurfaceKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDisplaySurfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateEvent-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateEvent-events-04468", "If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::events is VK_FALSE, then the implementation does not support events, and vkCreateEvent must not be used", "1.3-extensions"},
    {"VUID-vkCreateEvent-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateEvent-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkEventCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateEvent-pEvent-parameter", "pEvent must be a valid pointer to a VkEvent handle", "1.3-extensions"},
    {"VUID-vkCreateFence-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateFence-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateFence-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkFenceCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateFence-pFence-parameter", "pFence must be a valid pointer to a VkFence handle", "1.3-extensions"},
    {"VUID-vkCreateFramebuffer-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateFramebuffer-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateFramebuffer-pCreateInfo-02777", "If pCreateInfo->flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and attachmentCount is not 0, each element of pCreateInfo->pAttachments must have been created on device", "1.3-extensions"},
    {"VUID-vkCreateFramebuffer-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkFramebufferCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateFramebuffer-pFramebuffer-parameter", "pFramebuffer must be a valid pointer to a VkFramebuffer handle", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength", "createInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-flags-00720", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-flags-00721", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter", "pCreateInfos must be a valid pointer to an array of createInfoCount valid VkGraphicsPipelineCreateInfo structures", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-pPipelines-parameter", "pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-pipelineCache-02876", "If pipelineCache was created with VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access to pipelineCache must be externally synchronized", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-pipelineCache-parameter", "If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkCreateGraphicsPipelines-pipelineCache-parent", "If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCreateHeadlessSurfaceEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateHeadlessSurfaceEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateHeadlessSurfaceEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkHeadlessSurfaceCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateHeadlessSurfaceEXT-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateIOSSurfaceMVK-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateIOSSurfaceMVK-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateIOSSurfaceMVK-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkIOSSurfaceCreateInfoMVK structure", "1.3-extensions"},
    {"VUID-vkCreateIOSSurfaceMVK-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateImage-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateImage-flags-00939", "If the flags member of pCreateInfo includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT, creating this VkImage must not cause the total required sparse memory for all currently valid sparse resources on the device to exceed VkPhysicalDeviceLimits::sparseAddressSpaceSize", "1.3-extensions"},
    {"VUID-vkCreateImage-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateImage-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkImageCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateImage-pImage-parameter", "pImage must be a valid pointer to a VkImage handle", "1.3-extensions"},
    {"VUID-vkCreateImage-pNext-06389", "If a VkBufferCollectionImageCreateInfoFUCHSIA has been chained to pNext, pCreateInfo must match the Sysmem chosen VkImageCreateInfo excepting members VkImageCreateInfo::extent and VkImageCreateInfo::usage in the match criteria", "1.3-extensions"},
    {"VUID-vkCreateImagePipeSurfaceFUCHSIA-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateImagePipeSurfaceFUCHSIA-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateImagePipeSurfaceFUCHSIA-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkImagePipeSurfaceCreateInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateImageView-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateImageView-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateImageView-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkImageViewCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateImageView-pView-parameter", "pView must be a valid pointer to a VkImageView handle", "1.3-extensions"},
    {"VUID-vkCreateIndirectCommandsLayoutNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateIndirectCommandsLayoutNV-deviceGeneratedCommands-02929", "The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateIndirectCommandsLayoutNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateIndirectCommandsLayoutNV-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkIndirectCommandsLayoutCreateInfoNV structure", "1.3-extensions"},
    {"VUID-vkCreateIndirectCommandsLayoutNV-pIndirectCommandsLayout-parameter", "pIndirectCommandsLayout must be a valid pointer to a VkIndirectCommandsLayoutNV handle", "1.3-extensions"},
    {"VUID-vkCreateInstance-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateInstance-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkInstanceCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateInstance-pInstance-parameter", "pInstance must be a valid pointer to a VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateInstance-ppEnabledExtensionNames-01388", "All required extensions for each extension in the VkInstanceCreateInfo::ppEnabledExtensionNames list must also be present in that list", "1.3-extensions"},
    {"VUID-vkCreateMacOSSurfaceMVK-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateMacOSSurfaceMVK-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateMacOSSurfaceMVK-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkMacOSSurfaceCreateInfoMVK structure", "1.3-extensions"},
    {"VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateMetalSurfaceEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateMetalSurfaceEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateMetalSurfaceEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkMetalSurfaceCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateMetalSurfaceEXT-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-device-07432", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-deviceAddress-07431", "If VkMicromapCreateInfoEXT::deviceAddress is not zero, the micromapCaptureReplay feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-micromap-07430", "The micromap feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkMicromapCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateMicromapEXT-pMicromap-parameter", "pMicromap must be a valid pointer to a VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-vkCreateOpticalFlowSessionNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateOpticalFlowSessionNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateOpticalFlowSessionNV-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkOpticalFlowSessionCreateInfoNV structure", "1.3-extensions"},
    {"VUID-vkCreateOpticalFlowSessionNV-pSession-parameter", "pSession must be a valid pointer to a VkOpticalFlowSessionNV handle", "1.3-extensions"},
    {"VUID-vkCreatePipelineCache-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreatePipelineCache-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreatePipelineCache-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkPipelineCacheCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreatePipelineCache-pPipelineCache-parameter", "pPipelineCache must be a valid pointer to a VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkCreatePipelineLayout-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreatePipelineLayout-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreatePipelineLayout-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkPipelineLayoutCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreatePipelineLayout-pPipelineLayout-parameter", "pPipelineLayout must be a valid pointer to a VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-vkCreatePrivateDataSlot-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreatePrivateDataSlot-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreatePrivateDataSlot-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkPrivateDataSlotCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreatePrivateDataSlot-pPrivateDataSlot-parameter", "pPrivateDataSlot must be a valid pointer to a VkPrivateDataSlot handle", "1.3-extensions"},
    {"VUID-vkCreatePrivateDataSlot-privateData-04564", "The privateData feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateQueryPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateQueryPool-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateQueryPool-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkQueryPoolCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateQueryPool-pQueryPool-parameter", "pQueryPool must be a valid pointer to a VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-createInfoCount-arraylength", "createInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03587", "If deferredOperation is not VK_NULL_HANDLE, the flags member of elements of pCreateInfos must not include VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03677", "If deferredOperation is not VK_NULL_HANDLE, it must be a valid VkDeferredOperationKHR object", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03678", "Any previous deferred operation that was associated with deferredOperation must be complete", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-parameter", "If deferredOperation is not VK_NULL_HANDLE, deferredOperation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-parent", "If deferredOperation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-flags-03415", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-flags-03416", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-flags-03816", "flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-pCreateInfos-parameter", "pCreateInfos must be a valid pointer to an array of createInfoCount valid VkRayTracingPipelineCreateInfoKHR structures", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-pPipelines-parameter", "pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-pipelineCache-02903", "If pipelineCache was created with VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access to pipelineCache must be externally synchronized", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-pipelineCache-parameter", "If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-pipelineCache-parent", "If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesKHR-rayTracingPipeline-03586", "The rayTracingPipeline feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-createInfoCount-arraylength", "createInfoCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-flags-03415", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-flags-03416", "If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-flags-03816", "flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-pCreateInfos-parameter", "pCreateInfos must be a valid pointer to an array of createInfoCount valid VkRayTracingPipelineCreateInfoNV structures", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-pPipelines-parameter", "pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-pipelineCache-02903", "If pipelineCache was created with VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access to pipelineCache must be externally synchronized", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-pipelineCache-parameter", "If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkCreateRayTracingPipelinesNV-pipelineCache-parent", "If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkCreateRenderPass-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateRenderPass-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateRenderPass-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateRenderPass-pRenderPass-parameter", "pRenderPass must be a valid pointer to a VkRenderPass handle", "1.3-extensions"},
    {"VUID-vkCreateRenderPass2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateRenderPass2-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateRenderPass2-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkRenderPassCreateInfo2 structure", "1.3-extensions"},
    {"VUID-vkCreateRenderPass2-pRenderPass-parameter", "pRenderPass must be a valid pointer to a VkRenderPass handle", "1.3-extensions"},
    {"VUID-vkCreateSampler-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateSampler-maxSamplerAllocationCount-04110", "There must be less than VkPhysicalDeviceLimits::maxSamplerAllocationCount VkSampler objects currently created on the device", "1.3-extensions"},
    {"VUID-vkCreateSampler-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateSampler-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkSamplerCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateSampler-pSampler-parameter", "pSampler must be a valid pointer to a VkSampler handle", "1.3-extensions"},
    {"VUID-vkCreateSamplerYcbcrConversion-None-01648", "The samplerYcbcrConversion feature must be enabled", "1.3-extensions"},
    {"VUID-vkCreateSamplerYcbcrConversion-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateSamplerYcbcrConversion-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateSamplerYcbcrConversion-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkSamplerYcbcrConversionCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateSamplerYcbcrConversion-pYcbcrConversion-parameter", "pYcbcrConversion must be a valid pointer to a VkSamplerYcbcrConversion handle", "1.3-extensions"},
    {"VUID-vkCreateScreenSurfaceQNX-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateScreenSurfaceQNX-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateScreenSurfaceQNX-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkScreenSurfaceCreateInfoQNX structure", "1.3-extensions"},
    {"VUID-vkCreateScreenSurfaceQNX-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateSemaphore-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateSemaphore-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateSemaphore-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkSemaphoreCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateSemaphore-pSemaphore-parameter", "pSemaphore must be a valid pointer to a VkSemaphore handle", "1.3-extensions"},
    {"VUID-vkCreateShaderModule-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateShaderModule-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateShaderModule-pCreateInfo-06904", "If pCreateInfo is not NULL, pCreateInfo->pNext must be NULL or a pointer to a VkShaderModuleValidationCacheCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateShaderModule-pCreateInfo-06905", "If pCreateInfo is not NULL, pCreateInfo->pNext must be NULL", "1.3-khr-extensions"},
    {"VUID-vkCreateShaderModule-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkShaderModuleCreateInfo structure", "1.3-extensions"},
    {"VUID-vkCreateShaderModule-pShaderModule-parameter", "pShaderModule must be a valid pointer to a VkShaderModule handle", "1.3-extensions"},
    {"VUID-vkCreateSharedSwapchainsKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateSharedSwapchainsKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateSharedSwapchainsKHR-pCreateInfos-parameter", "pCreateInfos must be a valid pointer to an array of swapchainCount valid VkSwapchainCreateInfoKHR structures", "1.3-extensions"},
    {"VUID-vkCreateSharedSwapchainsKHR-pSwapchains-parameter", "pSwapchains must be a valid pointer to an array of swapchainCount VkSwapchainKHR handles", "1.3-extensions"},
    {"VUID-vkCreateSharedSwapchainsKHR-swapchainCount-arraylength", "swapchainCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkCreateStreamDescriptorSurfaceGGP-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateStreamDescriptorSurfaceGGP-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateStreamDescriptorSurfaceGGP-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkStreamDescriptorSurfaceCreateInfoGGP structure", "1.3-extensions"},
    {"VUID-vkCreateStreamDescriptorSurfaceGGP-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateSwapchainKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateSwapchainKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateSwapchainKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkSwapchainCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateSwapchainKHR-pSwapchain-parameter", "pSwapchain must be a valid pointer to a VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkCreateValidationCacheEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateValidationCacheEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateValidationCacheEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkValidationCacheCreateInfoEXT structure", "1.3-extensions"},
    {"VUID-vkCreateValidationCacheEXT-pValidationCache-parameter", "pValidationCache must be a valid pointer to a VkValidationCacheEXT handle", "1.3-extensions"},
    {"VUID-vkCreateViSurfaceNN-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateViSurfaceNN-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateViSurfaceNN-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkViSurfaceCreateInfoNN structure", "1.3-extensions"},
    {"VUID-vkCreateViSurfaceNN-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkVideoSessionCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionKHR-pVideoSession-parameter", "pVideoSession must be a valid pointer to a VkVideoSessionKHR handle", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionParametersKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionParametersKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionParametersKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkVideoSessionParametersCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateVideoSessionParametersKHR-pVideoSessionParameters-parameter", "pVideoSessionParameters must be a valid pointer to a VkVideoSessionParametersKHR handle", "1.3-extensions"},
    {"VUID-vkCreateWaylandSurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateWaylandSurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateWaylandSurfaceKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkWaylandSurfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateWin32SurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateWin32SurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateWin32SurfaceKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkWin32SurfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateWin32SurfaceKHR-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateXcbSurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateXcbSurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateXcbSurfaceKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkXcbSurfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateXcbSurfaceKHR-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkCreateXlibSurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkCreateXlibSurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkCreateXlibSurfaceKHR-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkXlibSurfaceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkCreateXlibSurfaceKHR-pSurface-parameter", "pSurface must be a valid pointer to a VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkDebugMarkerSetObjectNameEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDebugMarkerSetObjectNameEXT-pNameInfo-parameter", "pNameInfo must be a valid pointer to a valid VkDebugMarkerObjectNameInfoEXT structure", "1.3-extensions"},
    {"VUID-vkDebugMarkerSetObjectTagEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDebugMarkerSetObjectTagEXT-pTagInfo-parameter", "pTagInfo must be a valid pointer to a valid VkDebugMarkerObjectTagInfoEXT structure", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-flags-parameter", "flags must be a valid combination of VkDebugReportFlagBitsEXT values", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-flags-requiredbitmask", "flags must not be 0", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-object-01241", "object must be a Vulkan object or VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-objectType-01498", "If objectType is not VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT and object is not VK_NULL_HANDLE, object must be a Vulkan object of the corresponding type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-objectType-parameter", "objectType must be a valid VkDebugReportObjectTypeEXT value", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter", "pLayerPrefix must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-vkDebugReportMessageEXT-pMessage-parameter", "pMessage must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-vkDeferredOperationJoinKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDeferredOperationJoinKHR-operation-parameter", "operation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkDeferredOperationJoinKHR-operation-parent", "operation must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-02442", "All submitted commands that refer to accelerationStructure must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-02443", "If VkAllocationCallbacks were provided when accelerationStructure was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-02444", "If no VkAllocationCallbacks were provided when accelerationStructure was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-parameter", "If accelerationStructure is not VK_NULL_HANDLE, accelerationStructure must be a valid VkAccelerationStructureKHR handle", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-parent", "If accelerationStructure is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-accelerationStructure-03752", "All submitted commands that refer to accelerationStructure must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-accelerationStructure-03753", "If VkAllocationCallbacks were provided when accelerationStructure was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-accelerationStructure-03754", "If no VkAllocationCallbacks were provided when accelerationStructure was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-accelerationStructure-parameter", "If accelerationStructure is not VK_NULL_HANDLE, accelerationStructure must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-accelerationStructure-parent", "If accelerationStructure is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyAccelerationStructureNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-buffer-00922", "All submitted commands that refer to buffer, either directly or via a VkBufferView, must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-buffer-00923", "If VkAllocationCallbacks were provided when buffer was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-buffer-00924", "If no VkAllocationCallbacks were provided when buffer was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-buffer-parameter", "If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-buffer-parent", "If buffer is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyBuffer-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyBufferCollectionFUCHSIA-collection-06407", "VkImage and VkBuffer objects that referenced collection upon creation by inclusion of a VkBufferCollectionImageCreateInfoFUCHSIA or VkBufferCollectionBufferCreateInfoFUCHSIA chained to their VkImageCreateInfo or VkBufferCreateInfo structures respectively, may outlive collection.", "1.3-extensions"},
    {"VUID-vkDestroyBufferCollectionFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-vkDestroyBufferCollectionFUCHSIA-collection-parent", "collection must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyBufferCollectionFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyBufferCollectionFUCHSIA-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-bufferView-00936", "All submitted commands that refer to bufferView must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-bufferView-00937", "If VkAllocationCallbacks were provided when bufferView was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-bufferView-00938", "If no VkAllocationCallbacks were provided when bufferView was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-bufferView-parameter", "If bufferView is not VK_NULL_HANDLE, bufferView must be a valid VkBufferView handle", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-bufferView-parent", "If bufferView is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyBufferView-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-commandPool-00041", "All VkCommandBuffer objects allocated from commandPool must not be in the pending state", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-commandPool-00042", "If VkAllocationCallbacks were provided when commandPool was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-commandPool-00043", "If no VkAllocationCallbacks were provided when commandPool was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-commandPool-parameter", "If commandPool is not VK_NULL_HANDLE, commandPool must be a valid VkCommandPool handle", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-commandPool-parent", "If commandPool is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyCommandPool-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyCuFunctionNVX-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyCuFunctionNVX-function-parameter", "function must be a valid VkCuFunctionNVX handle", "1.3-extensions"},
    {"VUID-vkDestroyCuFunctionNVX-function-parent", "function must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyCuFunctionNVX-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyCuModuleNVX-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyCuModuleNVX-module-parameter", "module must be a valid VkCuModuleNVX handle", "1.3-extensions"},
    {"VUID-vkDestroyCuModuleNVX-module-parent", "module must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyCuModuleNVX-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDebugReportCallbackEXT-callback-parameter", "If callback is not VK_NULL_HANDLE, callback must be a valid VkDebugReportCallbackEXT handle", "1.3-extensions"},
    {"VUID-vkDestroyDebugReportCallbackEXT-callback-parent", "If callback is a valid handle, it must have been created, allocated, or retrieved from instance", "1.3-extensions"},
    {"VUID-vkDestroyDebugReportCallbackEXT-instance-01242", "If VkAllocationCallbacks were provided when callback was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDebugReportCallbackEXT-instance-01243", "If no VkAllocationCallbacks were provided when callback was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDebugReportCallbackEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkDestroyDebugReportCallbackEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDebugUtilsMessengerEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01915", "If VkAllocationCallbacks were provided when messenger was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDebugUtilsMessengerEXT-messenger-01916", "If no VkAllocationCallbacks were provided when messenger was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDebugUtilsMessengerEXT-messenger-parameter", "If messenger is not VK_NULL_HANDLE, messenger must be a valid VkDebugUtilsMessengerEXT handle", "1.3-extensions"},
    {"VUID-vkDestroyDebugUtilsMessengerEXT-messenger-parent", "If messenger is a valid handle, it must have been created, allocated, or retrieved from instance", "1.3-extensions"},
    {"VUID-vkDestroyDebugUtilsMessengerEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-operation-03434", "If VkAllocationCallbacks were provided when operation was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-operation-03435", "If no VkAllocationCallbacks were provided when operation was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-operation-03436", "operation must be completed", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-operation-parameter", "If operation is not VK_NULL_HANDLE, operation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-operation-parent", "If operation is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyDeferredOperationKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-descriptorPool-00303", "All submitted commands that refer to descriptorPool (via any allocated descriptor sets) must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-descriptorPool-00304", "If VkAllocationCallbacks were provided when descriptorPool was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-descriptorPool-00305", "If no VkAllocationCallbacks were provided when descriptorPool was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-descriptorPool-parameter", "If descriptorPool is not VK_NULL_HANDLE, descriptorPool must be a valid VkDescriptorPool handle", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-descriptorPool-parent", "If descriptorPool is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorPool-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284", "If VkAllocationCallbacks were provided when descriptorSetLayout was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285", "If no VkAllocationCallbacks were provided when descriptorSetLayout was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter", "If descriptorSetLayout is not VK_NULL_HANDLE, descriptorSetLayout must be a valid VkDescriptorSetLayout handle", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent", "If descriptorSetLayout is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorSetLayout-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00356", "If VkAllocationCallbacks were provided when descriptorUpdateTemplate was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorUpdateTemplate-descriptorSetLayout-00357", "If no VkAllocationCallbacks were provided when descriptorUpdateTemplate was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parameter", "If descriptorUpdateTemplate is not VK_NULL_HANDLE, descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorUpdateTemplate-descriptorUpdateTemplate-parent", "If descriptorUpdateTemplate is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorUpdateTemplate-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyDescriptorUpdateTemplate-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyDevice-device-00378", "All child objects created on device must have been destroyed prior to destroying device", "1.3-extensions"},
    {"VUID-vkDestroyDevice-device-00379", "If VkAllocationCallbacks were provided when device was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyDevice-device-00380", "If no VkAllocationCallbacks were provided when device was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyDevice-device-parameter", "If device is not NULL, device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyDevice-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyEvent-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyEvent-event-01145", "All submitted commands that refer to event must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyEvent-event-01146", "If VkAllocationCallbacks were provided when event was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyEvent-event-01147", "If no VkAllocationCallbacks were provided when event was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyEvent-event-parameter", "If event is not VK_NULL_HANDLE, event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkDestroyEvent-event-parent", "If event is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyEvent-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyFence-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyFence-fence-01120", "All queue submission commands that refer to fence must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyFence-fence-01121", "If VkAllocationCallbacks were provided when fence was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyFence-fence-01122", "If no VkAllocationCallbacks were provided when fence was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyFence-fence-parameter", "If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-vkDestroyFence-fence-parent", "If fence is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyFence-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-framebuffer-00892", "All submitted commands that refer to framebuffer must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-framebuffer-00893", "If VkAllocationCallbacks were provided when framebuffer was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-framebuffer-00894", "If no VkAllocationCallbacks were provided when framebuffer was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-framebuffer-parameter", "If framebuffer is not VK_NULL_HANDLE, framebuffer must be a valid VkFramebuffer handle", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-framebuffer-parent", "If framebuffer is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyFramebuffer-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyImage-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyImage-image-01000", "All submitted commands that refer to image, either directly or via a VkImageView, must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyImage-image-01001", "If VkAllocationCallbacks were provided when image was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyImage-image-01002", "If no VkAllocationCallbacks were provided when image was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyImage-image-04882", "image must not have been acquired from vkGetSwapchainImagesKHR", "1.3-extensions"},
    {"VUID-vkDestroyImage-image-parameter", "If image is not VK_NULL_HANDLE, image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkDestroyImage-image-parent", "If image is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyImage-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyImageView-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyImageView-imageView-01026", "All submitted commands that refer to imageView must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyImageView-imageView-01027", "If VkAllocationCallbacks were provided when imageView was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyImageView-imageView-01028", "If no VkAllocationCallbacks were provided when imageView was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyImageView-imageView-parameter", "If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-vkDestroyImageView-imageView-parent", "If imageView is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyImageView-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-deviceGeneratedCommands-02941", "The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-02938", "All submitted commands that refer to indirectCommandsLayout must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-02939", "If VkAllocationCallbacks were provided when indirectCommandsLayout was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-02940", "If no VkAllocationCallbacks were provided when indirectCommandsLayout was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-parameter", "If indirectCommandsLayout is not VK_NULL_HANDLE, indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNV handle", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-indirectCommandsLayout-parent", "If indirectCommandsLayout is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyIndirectCommandsLayoutNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyInstance-instance-00629", "All child objects created using instance must have been destroyed prior to destroying instance", "1.3-extensions"},
    {"VUID-vkDestroyInstance-instance-00630", "If VkAllocationCallbacks were provided when instance was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyInstance-instance-00631", "If no VkAllocationCallbacks were provided when instance was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyInstance-instance-parameter", "If instance is not NULL, instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkDestroyInstance-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-micromap-07441", "All submitted commands that refer to micromap must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-micromap-07442", "If VkAllocationCallbacks were provided when micromap was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-micromap-07443", "If no VkAllocationCallbacks were provided when micromap was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-micromap-parameter", "If micromap is not VK_NULL_HANDLE, micromap must be a valid VkMicromapEXT handle", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-micromap-parent", "If micromap is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyMicromapEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyOpticalFlowSessionNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyOpticalFlowSessionNV-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyOpticalFlowSessionNV-session-parameter", "session must be a valid VkOpticalFlowSessionNV handle", "1.3-extensions"},
    {"VUID-vkDestroyOpticalFlowSessionNV-session-parent", "session must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-pipeline-00765", "All submitted commands that refer to pipeline must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-pipeline-00766", "If VkAllocationCallbacks were provided when pipeline was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-pipeline-00767", "If no VkAllocationCallbacks were provided when pipeline was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-pipeline-parameter", "If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkDestroyPipeline-pipeline-parent", "If pipeline is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyPipelineCache-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyPipelineCache-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyPipelineCache-pipelineCache-00771", "If VkAllocationCallbacks were provided when pipelineCache was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyPipelineCache-pipelineCache-00772", "If no VkAllocationCallbacks were provided when pipelineCache was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyPipelineCache-pipelineCache-parameter", "If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkDestroyPipelineCache-pipelineCache-parent", "If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-pipelineLayout-00299", "If VkAllocationCallbacks were provided when pipelineLayout was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-pipelineLayout-00300", "If no VkAllocationCallbacks were provided when pipelineLayout was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-pipelineLayout-02004", "pipelineLayout must not have been passed to any vkCmd* command for any command buffers that are still in the recording state when vkDestroyPipelineLayout is called", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-pipelineLayout-parameter", "If pipelineLayout is not VK_NULL_HANDLE, pipelineLayout must be a valid VkPipelineLayout handle", "1.3-extensions"},
    {"VUID-vkDestroyPipelineLayout-pipelineLayout-parent", "If pipelineLayout is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyPrivateDataSlot-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyPrivateDataSlot-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyPrivateDataSlot-privateDataSlot-04062", "If VkAllocationCallbacks were provided when privateDataSlot was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyPrivateDataSlot-privateDataSlot-04063", "If no VkAllocationCallbacks were provided when privateDataSlot was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyPrivateDataSlot-privateDataSlot-parameter", "If privateDataSlot is not VK_NULL_HANDLE, privateDataSlot must be a valid VkPrivateDataSlot handle", "1.3-extensions"},
    {"VUID-vkDestroyPrivateDataSlot-privateDataSlot-parent", "If privateDataSlot is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-queryPool-00793", "All submitted commands that refer to queryPool must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-queryPool-00794", "If VkAllocationCallbacks were provided when queryPool was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-queryPool-00795", "If no VkAllocationCallbacks were provided when queryPool was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-queryPool-parameter", "If queryPool is not VK_NULL_HANDLE, queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkDestroyQueryPool-queryPool-parent", "If queryPool is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-renderPass-00873", "All submitted commands that refer to renderPass must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-renderPass-00874", "If VkAllocationCallbacks were provided when renderPass was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-renderPass-00875", "If no VkAllocationCallbacks were provided when renderPass was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-renderPass-parameter", "If renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle", "1.3-extensions"},
    {"VUID-vkDestroyRenderPass-renderPass-parent", "If renderPass is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroySampler-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroySampler-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroySampler-sampler-01082", "All submitted commands that refer to sampler must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroySampler-sampler-01083", "If VkAllocationCallbacks were provided when sampler was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroySampler-sampler-01084", "If no VkAllocationCallbacks were provided when sampler was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroySampler-sampler-parameter", "If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle", "1.3-extensions"},
    {"VUID-vkDestroySampler-sampler-parent", "If sampler is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroySamplerYcbcrConversion-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroySamplerYcbcrConversion-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroySamplerYcbcrConversion-ycbcrConversion-parameter", "If ycbcrConversion is not VK_NULL_HANDLE, ycbcrConversion must be a valid VkSamplerYcbcrConversion handle", "1.3-extensions"},
    {"VUID-vkDestroySamplerYcbcrConversion-ycbcrConversion-parent", "If ycbcrConversion is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-semaphore-01137", "All submitted batches that refer to semaphore must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-semaphore-01138", "If VkAllocationCallbacks were provided when semaphore was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-semaphore-01139", "If no VkAllocationCallbacks were provided when semaphore was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-semaphore-parameter", "If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-vkDestroySemaphore-semaphore-parent", "If semaphore is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyShaderModule-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyShaderModule-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyShaderModule-shaderModule-01092", "If VkAllocationCallbacks were provided when shaderModule was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyShaderModule-shaderModule-01093", "If no VkAllocationCallbacks were provided when shaderModule was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyShaderModule-shaderModule-parameter", "If shaderModule is not VK_NULL_HANDLE, shaderModule must be a valid VkShaderModule handle", "1.3-extensions"},
    {"VUID-vkDestroyShaderModule-shaderModule-parent", "If shaderModule is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-surface-01266", "All VkSwapchainKHR objects created for surface must have been destroyed prior to destroying surface", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-surface-01267", "If VkAllocationCallbacks were provided when surface was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-surface-01268", "If no VkAllocationCallbacks were provided when surface was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-surface-parameter", "If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkDestroySurfaceKHR-surface-parent", "If surface is a valid handle, it must have been created, allocated, or retrieved from instance", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-commonparent", "Both of device, and swapchain that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-swapchain-01282", "All uses of presentable images acquired from swapchain must have completed execution", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-swapchain-01283", "If VkAllocationCallbacks were provided when swapchain was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-swapchain-01284", "If no VkAllocationCallbacks were provided when swapchain was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroySwapchainKHR-swapchain-parameter", "If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkDestroyValidationCacheEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyValidationCacheEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyValidationCacheEXT-validationCache-01537", "If VkAllocationCallbacks were provided when validationCache was created, a compatible set of callbacks must be provided here", "1.3-extensions"},
    {"VUID-vkDestroyValidationCacheEXT-validationCache-01538", "If no VkAllocationCallbacks were provided when validationCache was created, pAllocator must be NULL", "1.3-extensions"},
    {"VUID-vkDestroyValidationCacheEXT-validationCache-parameter", "If validationCache is not VK_NULL_HANDLE, validationCache must be a valid VkValidationCacheEXT handle", "1.3-extensions"},
    {"VUID-vkDestroyValidationCacheEXT-validationCache-parent", "If validationCache is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionKHR-videoSession-parameter", "If videoSession is not VK_NULL_HANDLE, videoSession must be a valid VkVideoSessionKHR handle", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionKHR-videoSession-parent", "If videoSession is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionParametersKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionParametersKHR-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkDestroyVideoSessionParametersKHR-videoSessionParameters-parameter", "If videoSessionParameters is not VK_NULL_HANDLE, videoSessionParameters must be a valid VkVideoSessionParametersKHR handle", "1.3-extensions"},
    {"VUID-vkDeviceWaitIdle-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDisplayPowerControlEXT-commonparent", "Both of device, and display must have been created, allocated, or retrieved from the same VkPhysicalDevice", "1.3-extensions"},
    {"VUID-vkDisplayPowerControlEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkDisplayPowerControlEXT-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkDisplayPowerControlEXT-pDisplayPowerInfo-parameter", "pDisplayPowerInfo must be a valid pointer to a valid VkDisplayPowerInfoEXT structure", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-None-01978", "Conditional rendering must not be active", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-None-06991", "There must be no video session object bound", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-commandBuffer-00059", "commandBuffer must be in the recording state", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-commandBuffer-00060", "If commandBuffer is a primary command buffer, there must not be an active render pass instance", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-commandBuffer-00061", "All queries made active during the recording of commandBuffer must have been made inactive", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-commandBuffer-00062", "If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdDebugMarkerBeginEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdDebugMarkerEndEXT", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-commandBuffer-01815", "If commandBuffer is a secondary command buffer, there must not be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT", "1.3-extensions"},
    {"VUID-vkEndCommandBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceExtensionProperties-pLayerName-parameter", "If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceExtensionProperties-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceExtensionProperties-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceExtensionProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceLayerProperties-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceLayerProperties-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumerateDeviceLayerProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkEnumerateInstanceExtensionProperties-pLayerName-parameter", "If pLayerName is not NULL, pLayerName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-vkEnumerateInstanceExtensionProperties-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkExtensionProperties structures", "1.3-extensions"},
    {"VUID-vkEnumerateInstanceExtensionProperties-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumerateInstanceLayerProperties-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkLayerProperties structures", "1.3-extensions"},
    {"VUID-vkEnumerateInstanceLayerProperties-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumerateInstanceVersion-pApiVersion-parameter", "pApiVersion must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceGroups-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupCount-parameter", "pPhysicalDeviceGroupCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter", "If the value referenced by pPhysicalDeviceGroupCount is not 0, and pPhysicalDeviceGroupProperties is not NULL, pPhysicalDeviceGroupProperties must be a valid pointer to an array of pPhysicalDeviceGroupCount VkPhysicalDeviceGroupProperties structures", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterCount-parameter", "pCounterCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterDescriptions-parameter", "If the value referenced by pCounterCount is not 0, and pCounterDescriptions is not NULL, pCounterDescriptions must be a valid pointer to an array of pCounterCount VkPerformanceCounterDescriptionKHR structures", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounters-parameter", "If the value referenced by pCounterCount is not 0, and pCounters is not NULL, pCounters must be a valid pointer to an array of pCounterCount VkPerformanceCounterKHR structures", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDevices-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter", "pPhysicalDeviceCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter", "If the value referenced by pPhysicalDeviceCount is not 0, and pPhysicalDevices is not NULL, pPhysicalDevices must be a valid pointer to an array of pPhysicalDeviceCount VkPhysicalDevice handles", "1.3-extensions"},
    {"VUID-vkExportMetalObjectsEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkExportMetalObjectsEXT-pMetalObjectsInfo-parameter", "pMetalObjectsInfo must be a valid pointer to a VkExportMetalObjectsInfoEXT structure", "1.3-extensions"},
    {"VUID-vkFlushMappedMemoryRanges-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength", "memoryRangeCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter", "pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-commandBufferCount-arraylength", "commandBufferCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-commandPool-parameter", "commandPool must be a valid VkCommandPool handle", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-commandPool-parent", "commandPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-pCommandBuffers-00047", "All elements of pCommandBuffers must not be in the pending state", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-pCommandBuffers-00048", "pCommandBuffers must be a valid pointer to an array of commandBufferCount VkCommandBuffer handles, each element of which must either be a valid handle or NULL", "1.3-extensions"},
    {"VUID-vkFreeCommandBuffers-pCommandBuffers-parent", "Each element of pCommandBuffers that is a valid handle must have been created, allocated, or retrieved from commandPool", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-descriptorPool-00312", "descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-descriptorPool-parameter", "descriptorPool must be a valid VkDescriptorPool handle", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-descriptorPool-parent", "descriptorPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength", "descriptorSetCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-pDescriptorSets-00309", "All submitted commands that refer to any element of pDescriptorSets must have completed execution", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-pDescriptorSets-00310", "pDescriptorSets must be a valid pointer to an array of descriptorSetCount VkDescriptorSet handles, each element of which must either be a valid handle or VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkFreeDescriptorSets-pDescriptorSets-parent", "Each element of pDescriptorSets that is a valid handle must have been created, allocated, or retrieved from descriptorPool", "1.3-extensions"},
    {"VUID-vkFreeMemory-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkFreeMemory-memory-00677", "All submitted commands that refer to memory (via images or buffers) must have completed execution", "1.3-extensions"},
    {"VUID-vkFreeMemory-memory-parameter", "If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkFreeMemory-memory-parent", "If memory is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkFreeMemory-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-buildType-parameter", "buildType must be a valid VkAccelerationStructureBuildTypeKHR value", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-device-03618", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-03619", "If pBuildInfo->geometryCount is not 0, pMaxPrimitiveCounts must be a valid pointer to an array of pBuildInfo->geometryCount uint32_t values", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-03785", "If pBuildInfo->pGeometries or pBuildInfo->ppGeometries has a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, each pMaxPrimitiveCounts[i] must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxInstanceCount", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-parameter", "pBuildInfo must be a valid pointer to a valid VkAccelerationStructureBuildGeometryInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-pMaxPrimitiveCounts-parameter", "If pMaxPrimitiveCounts is not NULL, pMaxPrimitiveCounts must be a valid pointer to an array of pBuildInfo->geometryCount uint32_t values", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-pSizeInfo-parameter", "pSizeInfo must be a valid pointer to a VkAccelerationStructureBuildSizesInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureBuildSizesKHR-rayTracingPipeline-03617", "The rayTracingPipeline or rayQuery feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureDeviceAddressKHR-device-03504", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureDeviceAddressKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-parameter", "pInfo must be a valid pointer to a valid VkAccelerationStructureDeviceAddressInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-accelerationStructure-02787", "accelerationStructure must be bound completely and contiguously to a single VkDeviceMemory object via vkBindAccelerationStructureMemoryNV", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-accelerationStructure-parameter", "accelerationStructure must be a valid VkAccelerationStructureNV handle", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-accelerationStructure-parent", "accelerationStructure must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-dataSize-02240", "dataSize must be large enough to contain the result of the query, as described above", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureHandleNV-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureMemoryRequirementsNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureMemoryRequirementsNV-pInfo-parameter", "pInfo must be a valid pointer to a valid VkAccelerationStructureMemoryRequirementsInfoNV structure", "1.3-extensions"},
    {"VUID-vkGetAccelerationStructureMemoryRequirementsNV-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2KHR structure", "1.3-extensions"},
    {"VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-01884", "buffer must be a valid Android hardware buffer object with at least one of the AHARDWAREBUFFER_USAGE_GPU_* flags in its AHardwareBuffer_Desc::usage", "1.3-extensions"},
    {"VUID-vkGetAndroidHardwareBufferPropertiesANDROID-buffer-parameter", "buffer must be a valid pointer to a valid AHardwareBuffer value", "1.3-extensions"},
    {"VUID-vkGetAndroidHardwareBufferPropertiesANDROID-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetAndroidHardwareBufferPropertiesANDROID-pProperties-parameter", "pProperties must be a valid pointer to a VkAndroidHardwareBufferPropertiesANDROID structure", "1.3-extensions"},
    {"VUID-vkGetBufferCollectionPropertiesFUCHSIA-None-06405", "Prior to calling vkGetBufferCollectionPropertiesFUCHSIA, the constraints on the buffer collection must have been set by either vkSetBufferCollectionImageConstraintsFUCHSIA or vkSetBufferCollectionBufferConstraintsFUCHSIA.", "1.3-extensions"},
    {"VUID-vkGetBufferCollectionPropertiesFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-vkGetBufferCollectionPropertiesFUCHSIA-collection-parent", "collection must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetBufferCollectionPropertiesFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetBufferCollectionPropertiesFUCHSIA-pProperties-parameter", "pProperties must be a valid pointer to a VkBufferCollectionPropertiesFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkGetBufferDeviceAddress-None-06542", "The bufferDeviceAddress feature must be enabled", "1.3-khr-extensions"},
    {"VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324", "The bufferDeviceAddress or VkPhysicalDeviceBufferDeviceAddressFeaturesEXT::bufferDeviceAddress feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetBufferDeviceAddress-device-03325", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice or VkPhysicalDeviceBufferDeviceAddressFeaturesEXT::bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetBufferDeviceAddress-device-06543", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-khr-extensions"},
    {"VUID-vkGetBufferDeviceAddress-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetBufferDeviceAddress-pInfo-parameter", "pInfo must be a valid pointer to a valid VkBufferDeviceAddressInfo structure", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements-buffer-parameter", "buffer must be a valid VkBuffer handle", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements-buffer-parent", "buffer must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements2-pInfo-parameter", "pInfo must be a valid pointer to a valid VkBufferMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-vkGetBufferMemoryRequirements2-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure", "1.3-extensions"},
    {"VUID-vkGetBufferOpaqueCaptureAddress-None-03326", "The bufferDeviceAddress feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetBufferOpaqueCaptureAddress-device-03327", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetBufferOpaqueCaptureAddress-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetBufferOpaqueCaptureAddress-pInfo-parameter", "pInfo must be a valid pointer to a valid VkBufferDeviceAddressInfo structure", "1.3-extensions"},
    {"VUID-vkGetCalibratedTimestampsEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetCalibratedTimestampsEXT-pMaxDeviation-parameter", "pMaxDeviation must be a valid pointer to a uint64_t value", "1.3-extensions"},
    {"VUID-vkGetCalibratedTimestampsEXT-pTimestampInfos-parameter", "pTimestampInfos must be a valid pointer to an array of timestampCount valid VkCalibratedTimestampInfoEXT structures", "1.3-extensions"},
    {"VUID-vkGetCalibratedTimestampsEXT-pTimestamps-parameter", "pTimestamps must be a valid pointer to an array of timestampCount uint64_t values", "1.3-extensions"},
    {"VUID-vkGetCalibratedTimestampsEXT-timestampCount-arraylength", "timestampCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkGetDeferredOperationMaxConcurrencyKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeferredOperationMaxConcurrencyKHR-operation-parameter", "operation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkGetDeferredOperationMaxConcurrencyKHR-operation-parent", "operation must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetDeferredOperationResultKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeferredOperationResultKHR-operation-parameter", "operation must be a valid VkDeferredOperationKHR handle", "1.3-extensions"},
    {"VUID-vkGetDeferredOperationResultKHR-operation-parent", "operation must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parameter", "descriptorSet must be a valid VkDescriptorSet handle", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetHostMappingVALVE-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter", "ppData must be a valid pointer to a pointer value", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter", "pBindingReference must be a valid pointer to a valid VkDescriptorSetBindingReferenceVALVE structure", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter", "pHostMapping must be a valid pointer to a VkDescriptorSetLayoutHostMappingInfoVALVE structure", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetLayoutSupport-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetLayoutSupport-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkDescriptorSetLayoutCreateInfo structure", "1.3-extensions"},
    {"VUID-vkGetDescriptorSetLayoutSupport-pSupport-parameter", "pSupport must be a valid pointer to a VkDescriptorSetLayoutSupport structure", "1.3-extensions"},
    {"VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pCompatibility-parameter", "pCompatibility must be a valid pointer to a VkAccelerationStructureCompatibilityKHR value", "1.3-extensions"},
    {"VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-pVersionInfo-parameter", "pVersionInfo must be a valid pointer to a valid VkAccelerationStructureVersionInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-rayTracingPipeline-03661", "The rayTracingPipeline or rayQuery feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetDeviceBufferMemoryRequirements-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceBufferMemoryRequirements-pInfo-parameter", "pInfo must be a valid pointer to a valid VkDeviceBufferMemoryRequirements structure", "1.3-extensions"},
    {"VUID-vkGetDeviceBufferMemoryRequirements-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-device-07336", "device must be in the lost state", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-07337", "If the value referenced by pFaultCounts->addressInfoCount is not 0, and pFaultInfo->pAddressInfos is not NULL, pFaultInfo->pAddressInfos must be a valid pointer to an array of pFaultCounts->addressInfoCount VkDeviceFaultAddressInfoEXT structures", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-07338", "If the value referenced by pFaultCounts->vendorInfoCount is not 0, and pFaultInfo->pVendorInfos is not NULL, pFaultInfo->pVendorInfos must be a valid pointer to an array of pFaultCounts->vendorInfoCount VkDeviceFaultVendorInfoEXT structures", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-07339", "If the value referenced by pFaultCounts->vendorBinarySize is not 0, and pFaultInfo->pVendorBinaryData is not NULL, pFaultInfo->pVendorBinaryData must be a valid pointer to an array of pFaultCounts->vendorBinarySize bytes", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-pFaultCounts-parameter", "pFaultCounts must be a valid pointer to a VkDeviceFaultCountsEXT structure", "1.3-extensions"},
    {"VUID-vkGetDeviceFaultInfoEXT-pFaultInfo-parameter", "If pFaultInfo is not NULL, pFaultInfo must be a valid pointer to a VkDeviceFaultInfoEXT structure", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPeerMemoryFeatures-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPeerMemoryFeatures-heapIndex-00691", "heapIndex must be less than memoryHeapCount", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPeerMemoryFeatures-localDeviceIndex-00692", "localDeviceIndex must be a valid device index", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPeerMemoryFeatures-localDeviceIndex-00694", "localDeviceIndex must not equal remoteDeviceIndex", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPeerMemoryFeatures-pPeerMemoryFeatures-parameter", "pPeerMemoryFeatures must be a valid pointer to a VkPeerMemoryFeatureFlags value", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPeerMemoryFeatures-remoteDeviceIndex-00693", "remoteDeviceIndex must be a valid device index", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPresentCapabilitiesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupPresentCapabilitiesKHR-pDeviceGroupPresentCapabilities-parameter", "pDeviceGroupPresentCapabilities must be a valid pointer to a VkDeviceGroupPresentCapabilitiesKHR structure", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModes2EXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pModes-parameter", "pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pSurfaceInfo-06213", "pSurfaceInfo->surface must be supported by all physical devices associated with device, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pSurfaceInfo-parameter", "pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModesKHR-commonparent", "Both of device, and surface must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter", "pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModesKHR-surface-06212", "surface must be supported by all physical devices associated with device, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetDeviceGroupSurfacePresentModesKHR-surface-parameter", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetDeviceImageMemoryRequirements-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceImageMemoryRequirements-pInfo-parameter", "pInfo must be a valid pointer to a valid VkDeviceImageMemoryRequirements structure", "1.3-extensions"},
    {"VUID-vkGetDeviceImageMemoryRequirements-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure", "1.3-extensions"},
    {"VUID-vkGetDeviceImageSparseMemoryRequirements-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceImageSparseMemoryRequirements-pInfo-parameter", "pInfo must be a valid pointer to a valid VkDeviceImageMemoryRequirements structure", "1.3-extensions"},
    {"VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter", "pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetDeviceImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter", "If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements2 structures", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryCommitment-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryCommitment-memory-00690", "memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryCommitment-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryCommitment-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter", "pCommittedMemoryInBytes must be a valid pointer to a VkDeviceSize value", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-None-03334", "The bufferDeviceAddress feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-device-03335", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-pInfo-parameter", "pInfo must be a valid pointer to a valid VkDeviceMemoryOpaqueCaptureAddressInfo structure", "1.3-extensions"},
    {"VUID-vkGetDeviceMicromapCompatibilityEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceMicromapCompatibilityEXT-micromap-07551", "The micromap feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetDeviceMicromapCompatibilityEXT-pCompatibility-parameter", "pCompatibility must be a valid pointer to a VkAccelerationStructureCompatibilityKHR value", "1.3-extensions"},
    {"VUID-vkGetDeviceMicromapCompatibilityEXT-pVersionInfo-parameter", "pVersionInfo must be a valid pointer to a valid VkMicromapVersionInfoEXT structure", "1.3-extensions"},
    {"VUID-vkGetDeviceProcAddr-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceProcAddr-pName-parameter", "pName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue-flags-01841", "VkDeviceQueueCreateInfo::flags must have been set to zero when device was created", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue-pQueue-parameter", "pQueue must be a valid pointer to a VkQueue handle", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue-queueFamilyIndex-00384", "queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue-queueIndex-00385", "queueIndex must be less than the value of VkDeviceQueueCreateInfo::queueCount for the queue family indicated by queueFamilyIndex when device was created", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue2-pQueue-parameter", "pQueue must be a valid pointer to a VkQueue handle", "1.3-extensions"},
    {"VUID-vkGetDeviceQueue2-pQueueInfo-parameter", "pQueueInfo must be a valid pointer to a valid VkDeviceQueueInfo2 structure", "1.3-extensions"},
    {"VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-pMaxWorkgroupSize-parameter", "pMaxWorkgroupSize must be a valid pointer to a VkExtent2D structure", "1.3-extensions"},
    {"VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-renderpass-parameter", "renderpass must be a valid VkRenderPass handle", "1.3-extensions"},
    {"VUID-vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI-renderpass-parent", "renderpass must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetDisplayModeProperties2KHR-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkGetDisplayModeProperties2KHR-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkGetDisplayModeProperties2KHR-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModeProperties2KHR structures", "1.3-extensions"},
    {"VUID-vkGetDisplayModeProperties2KHR-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetDisplayModeProperties2KHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetDisplayModePropertiesKHR-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkGetDisplayModePropertiesKHR-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkGetDisplayModePropertiesKHR-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayModePropertiesKHR structures", "1.3-extensions"},
    {"VUID-vkGetDisplayModePropertiesKHR-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetDisplayModePropertiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneCapabilities2KHR-pCapabilities-parameter", "pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilities2KHR structure", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneCapabilities2KHR-pDisplayPlaneInfo-parameter", "pDisplayPlaneInfo must be a valid pointer to a valid VkDisplayPlaneInfo2KHR structure", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneCapabilities2KHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parameter", "mode must be a valid VkDisplayModeKHR handle", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneCapabilitiesKHR-pCapabilities-parameter", "pCapabilities must be a valid pointer to a VkDisplayPlaneCapabilitiesKHR structure", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneCapabilitiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplayCount-parameter", "pDisplayCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneSupportedDisplaysKHR-pDisplays-parameter", "If the value referenced by pDisplayCount is not 0, and pDisplays is not NULL, pDisplays must be a valid pointer to an array of pDisplayCount VkDisplayKHR handles", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneSupportedDisplaysKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249", "planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR", "1.3-extensions"},
    {"VUID-vkGetDrmDisplayEXT-display-parameter", "display must be a valid pointer to a VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkGetDrmDisplayEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetDynamicRenderingTilePropertiesQCOM-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetDynamicRenderingTilePropertiesQCOM-pProperties-parameter", "pProperties must be a valid pointer to a VkTilePropertiesQCOM structure", "1.3-extensions"},
    {"VUID-vkGetDynamicRenderingTilePropertiesQCOM-pRenderingInfo-parameter", "pRenderingInfo must be a valid pointer to a valid VkRenderingInfo structure", "1.3-extensions"},
    {"VUID-vkGetEventStatus-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetEventStatus-event-03940", "event must not have been created with VK_EVENT_CREATE_DEVICE_ONLY_BIT", "1.3-extensions"},
    {"VUID-vkGetEventStatus-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkGetEventStatus-event-parent", "event must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetFenceFdKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetFenceFdKHR-pFd-parameter", "pFd must be a valid pointer to an int value", "1.3-extensions"},
    {"VUID-vkGetFenceFdKHR-pGetFdInfo-parameter", "pGetFdInfo must be a valid pointer to a valid VkFenceGetFdInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetFenceStatus-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetFenceStatus-fence-parameter", "fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-vkGetFenceStatus-fence-parent", "fence must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetFenceWin32HandleKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetFenceWin32HandleKHR-pGetWin32HandleInfo-parameter", "pGetWin32HandleInfo must be a valid pointer to a valid VkFenceGetWin32HandleInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetFenceWin32HandleKHR-pHandle-parameter", "pHandle must be a valid pointer to a HANDLE value", "1.3-extensions"},
    {"VUID-vkGetFramebufferTilePropertiesQCOM-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetFramebufferTilePropertiesQCOM-framebuffer-parameter", "framebuffer must be a valid VkFramebuffer handle", "1.3-extensions"},
    {"VUID-vkGetFramebufferTilePropertiesQCOM-framebuffer-parent", "framebuffer must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetFramebufferTilePropertiesQCOM-pProperties-parameter", "If the value referenced by pPropertiesCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertiesCount VkTilePropertiesQCOM structures", "1.3-extensions"},
    {"VUID-vkGetFramebufferTilePropertiesQCOM-pPropertiesCount-parameter", "pPropertiesCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetGeneratedCommandsMemoryRequirementsNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetGeneratedCommandsMemoryRequirementsNV-deviceGeneratedCommands-02906", "The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-parameter", "pInfo must be a valid pointer to a valid VkGeneratedCommandsMemoryRequirementsInfoNV structure", "1.3-extensions"},
    {"VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure", "1.3-extensions"},
    {"VUID-vkGetImageDrmFormatModifierPropertiesEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-02272", "image must have been created with tiling equal to VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT", "1.3-extensions"},
    {"VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parent", "image must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetImageDrmFormatModifierPropertiesEXT-pProperties-parameter", "pProperties must be a valid pointer to a VkImageDrmFormatModifierPropertiesEXT structure", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements-image-01588", "image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT flag set", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements-image-04004", "If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements-image-parent", "image must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements structure", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements2-pInfo-parameter", "pInfo must be a valid pointer to a valid VkImageMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-vkGetImageMemoryRequirements2-pMemoryRequirements-parameter", "pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements-image-parent", "image must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter", "pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter", "If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements structures", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements2-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements2-pInfo-parameter", "pInfo must be a valid pointer to a valid VkImageSparseMemoryRequirementsInfo2 structure", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirementCount-parameter", "pSparseMemoryRequirementCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetImageSparseMemoryRequirements2-pSparseMemoryRequirements-parameter", "If the value referenced by pSparseMemoryRequirementCount is not 0, and pSparseMemoryRequirements is not NULL, pSparseMemoryRequirements must be a valid pointer to an array of pSparseMemoryRequirementCount VkSparseImageMemoryRequirements2 structures", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-arrayLayer-01717", "The arrayLayer member of pSubresource must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-aspectMask-00997", "The aspectMask member of pSubresource must only have a single bit set", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-format-01581", "If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with two planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-format-01582", "If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with three planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-format-04461", "If format is a color format, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-format-04462", "If format has a depth component, the aspectMask member of pSubresource must contain VK_IMAGE_ASPECT_DEPTH_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-format-04463", "If format has a stencil component, the aspectMask member of pSubresource must contain VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-format-04464", "If format does not contain a stencil or depth component, the aspectMask member of pSubresource must not contain VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-image-00996", "image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR", "1.3-khr-extensions"},
    {"VUID-vkGetImageSubresourceLayout-image-01895", "If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-image-02270", "image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-image-parent", "image must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-mipLevel-01716", "The mipLevel member of pSubresource must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-pLayout-parameter", "pLayout must be a valid pointer to a VkSubresourceLayout structure", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-pSubresource-parameter", "pSubresource must be a valid pointer to a valid VkImageSubresource structure", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout-tiling-02271", "If the tiling of the image is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT and the index i must be less than the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with the image's format and VkImageDrmFormatModifierPropertiesEXT::drmFormatModifier", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-arrayLayer-01717", "The arrayLayer member of pSubresource must be less than the arrayLayers specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-aspectMask-00997", "The aspectMask member of pSubresource must only have a single bit set", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-format-01581", "If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with two planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT or VK_IMAGE_ASPECT_PLANE_1_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-format-01582", "If the tiling of the image is VK_IMAGE_TILING_LINEAR and its format is a multi-planar format with three planes, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT or VK_IMAGE_ASPECT_PLANE_2_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-format-04461", "If format is a color format, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_COLOR_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-format-04462", "If format has a depth component, the aspectMask member of pSubresource must contain VK_IMAGE_ASPECT_DEPTH_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-format-04463", "If format has a stencil component, the aspectMask member of pSubresource must contain VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-format-04464", "If format does not contain a stencil or depth component, the aspectMask member of pSubresource must not contain VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-image-00996", "image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR", "default"},
    {"VUID-vkGetImageSubresourceLayout2EXT-image-01895", "If image was created with the VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID external memory handle type, then image must be bound to memory", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-image-02270", "image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-image-parameter", "image must be a valid VkImage handle", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-image-parent", "image must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-mipLevel-01716", "The mipLevel member of pSubresource must be less than the mipLevels specified in VkImageCreateInfo when image was created", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-pLayout-parameter", "pLayout must be a valid pointer to a VkSubresourceLayout2EXT structure", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-pSubresource-parameter", "pSubresource must be a valid pointer to a valid VkImageSubresource2EXT structure", "1.3-extensions"},
    {"VUID-vkGetImageSubresourceLayout2EXT-tiling-02271", "If the tiling of the image is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_MEMORY_PLANE{ibit}BIT_EXT and the index i must be less than the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with the image's format and VkImageDrmFormatModifierPropertiesEXT::drmFormatModifier", "1.3-extensions"},
    {"VUID-vkGetImageViewAddressNVX-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageViewAddressNVX-imageView-parameter", "imageView must be a valid VkImageView handle", "1.3-extensions"},
    {"VUID-vkGetImageViewAddressNVX-imageView-parent", "imageView must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetImageViewAddressNVX-pProperties-parameter", "pProperties must be a valid pointer to a VkImageViewAddressPropertiesNVX structure", "1.3-extensions"},
    {"VUID-vkGetImageViewHandleNVX-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetImageViewHandleNVX-pInfo-parameter", "pInfo must be a valid pointer to a valid VkImageViewHandleInfoNVX structure", "1.3-extensions"},
    {"VUID-vkGetInstanceProcAddr-instance-parameter", "If instance is not NULL, instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkGetInstanceProcAddr-pName-parameter", "pName must be a null-terminated UTF-8 string", "1.3-extensions"},
    {"VUID-vkGetMemoryAndroidHardwareBufferANDROID-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryAndroidHardwareBufferANDROID-pBuffer-parameter", "pBuffer must be a valid pointer to a valid pointer to an AHardwareBuffer value", "1.3-extensions"},
    {"VUID-vkGetMemoryAndroidHardwareBufferANDROID-pInfo-parameter", "pInfo must be a valid pointer to a valid VkMemoryGetAndroidHardwareBufferInfoANDROID structure", "1.3-extensions"},
    {"VUID-vkGetMemoryFdKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryFdKHR-pFd-parameter", "pFd must be a valid pointer to an int value", "1.3-extensions"},
    {"VUID-vkGetMemoryFdKHR-pGetFdInfo-parameter", "pGetFdInfo must be a valid pointer to a valid VkMemoryGetFdInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetMemoryFdPropertiesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryFdPropertiesKHR-fd-00673", "fd must be an external memory handle created outside of the Vulkan API", "1.3-extensions"},
    {"VUID-vkGetMemoryFdPropertiesKHR-handleType-00674", "handleType must not be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT", "1.3-extensions"},
    {"VUID-vkGetMemoryFdPropertiesKHR-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-vkGetMemoryFdPropertiesKHR-pMemoryFdProperties-parameter", "pMemoryFdProperties must be a valid pointer to a VkMemoryFdPropertiesKHR structure", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01752", "handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01754", "If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, pHostPointer must be a pointer to host memory", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-01755", "If handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT, pHostPointer must be a pointer to host mapped foreign memory", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-01753", "pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment", "1.3-extensions"},
    {"VUID-vkGetMemoryHostPointerPropertiesEXT-pMemoryHostPointerProperties-parameter", "pMemoryHostPointerProperties must be a valid pointer to a VkMemoryHostPointerPropertiesEXT structure", "1.3-extensions"},
    {"VUID-vkGetMemoryRemoteAddressNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryRemoteAddressNV-pAddress-parameter", "pAddress must be a valid pointer to a VkRemoteAddressNV value", "1.3-extensions"},
    {"VUID-vkGetMemoryRemoteAddressNV-pMemoryGetRemoteAddressInfo-parameter", "pMemoryGetRemoteAddressInfo must be a valid pointer to a valid VkMemoryGetRemoteAddressInfoNV structure", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleKHR-pGetWin32HandleInfo-parameter", "pGetWin32HandleInfo must be a valid pointer to a valid VkMemoryGetWin32HandleInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter", "pHandle must be a valid pointer to a HANDLE value", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-handleType-01326", "handleType must be a flag specified in VkExportMemoryAllocateInfoNV::handleTypes when allocating memory", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-handleType-parameter", "handleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask", "handleType must not be 0", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandleNV-pHandle-parameter", "pHandle must be a valid pointer to a HANDLE value", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandlePropertiesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandlePropertiesKHR-handle-00665", "handle must be an external memory handle created outside of the Vulkan API", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-00666", "handleType must not be one of the handle types defined as opaque", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandlePropertiesKHR-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-vkGetMemoryWin32HandlePropertiesKHR-pMemoryWin32HandleProperties-parameter", "pMemoryWin32HandleProperties must be a valid pointer to a VkMemoryWin32HandlePropertiesKHR structure", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandleFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter", "pGetZirconHandleInfo must be a valid pointer to a valid VkMemoryGetZirconHandleInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandleFUCHSIA-pZirconHandle-parameter", "pZirconHandle must be a valid pointer to a zx_handle_t value", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-04773", "handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-handleType-parameter", "handleType must be a valid VkExternalMemoryHandleTypeFlagBits value", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-pMemoryZirconHandleProperties-parameter", "pMemoryZirconHandleProperties must be a valid pointer to a VkMemoryZirconHandlePropertiesFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkGetMemoryZirconHandlePropertiesFUCHSIA-zirconHandle-04774", "zirconHandle must reference a valid VMO", "1.3-extensions"},
    {"VUID-vkGetMicromapBuildSizesEXT-buildType-parameter", "buildType must be a valid VkAccelerationStructureBuildTypeKHR value", "1.3-extensions"},
    {"VUID-vkGetMicromapBuildSizesEXT-device-07440", "If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetMicromapBuildSizesEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetMicromapBuildSizesEXT-micromap-07439", "The micromap feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetMicromapBuildSizesEXT-pBuildInfo-parameter", "pBuildInfo must be a valid pointer to a valid VkMicromapBuildInfoEXT structure", "1.3-extensions"},
    {"VUID-vkGetMicromapBuildSizesEXT-pSizeInfo-parameter", "pSizeInfo must be a valid pointer to a VkMicromapBuildSizesInfoEXT structure", "1.3-extensions"},
    {"VUID-vkGetPastPresentationTimingGOOGLE-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPastPresentationTimingGOOGLE-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimingCount-parameter", "pPresentationTimingCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPastPresentationTimingGOOGLE-pPresentationTimings-parameter", "If the value referenced by pPresentationTimingCount is not 0, and pPresentationTimings is not NULL, pPresentationTimings must be a valid pointer to an array of pPresentationTimingCount VkPastPresentationTimingGOOGLE structures", "1.3-extensions"},
    {"VUID-vkGetPastPresentationTimingGOOGLE-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkGetPerformanceParameterINTEL-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPerformanceParameterINTEL-pValue-parameter", "pValue must be a valid pointer to a VkPerformanceValueINTEL structure", "1.3-extensions"},
    {"VUID-vkGetPerformanceParameterINTEL-parameter-parameter", "parameter must be a valid VkPerformanceParameterTypeINTEL value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-pTimeDomainCount-parameter", "pTimeDomainCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-pTimeDomains-parameter", "If the value referenced by pTimeDomainCount is not 0, and pTimeDomains is not NULL, pTimeDomains must be a valid pointer to an array of pTimeDomainCount VkTimeDomainEXT values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceCalibrateableTimeDomainsEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkCooperativeMatrixPropertiesNV structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceCooperativeMatrixPropertiesNV-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-dfb-parameter", "dfb must be a valid pointer to an IDirectFB value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDirectFBPresentationSupportEXT-queueFamilyIndex-04119", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlaneProperties2KHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPlaneProperties2KHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPlanePropertiesKHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPlanePropertiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayProperties2KHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayProperties2KHR-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayProperties2KHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkDisplayPropertiesKHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceDisplayPropertiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferInfo-parameter", "pExternalBufferInfo must be a valid pointer to a valid VkPhysicalDeviceExternalBufferInfo structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalBufferProperties-pExternalBufferProperties-parameter", "pExternalBufferProperties must be a valid pointer to a VkExternalBufferProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalBufferProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceInfo-parameter", "pExternalFenceInfo must be a valid pointer to a valid VkPhysicalDeviceExternalFenceInfo structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalFenceProperties-pExternalFenceProperties-parameter", "pExternalFenceProperties must be a valid pointer to a VkExternalFenceProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalFenceProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-externalHandleType-parameter", "externalHandleType must be a valid combination of VkExternalMemoryHandleTypeFlagBitsNV values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-flags-parameter", "flags must be a valid combination of VkImageCreateFlagBits values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-pExternalImageFormatProperties-parameter", "pExternalImageFormatProperties must be a valid pointer to a VkExternalImageFormatPropertiesNV structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-tiling-parameter", "tiling must be a valid VkImageTiling value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-type-parameter", "type must be a valid VkImageType value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalImageFormatPropertiesNV-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreInfo-parameter", "pExternalSemaphoreInfo must be a valid pointer to a valid VkPhysicalDeviceExternalSemaphoreInfo structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-pExternalSemaphoreProperties-parameter", "pExternalSemaphoreProperties must be a valid pointer to a VkExternalSemaphoreProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceExternalSemaphoreProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter", "pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFeatures-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFeatures2-pFeatures-parameter", "pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFeatures2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFormatProperties-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter", "pFormatProperties must be a valid pointer to a VkFormatProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFormatProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFormatProperties2-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFormatProperties2-pFormatProperties-parameter", "pFormatProperties must be a valid pointer to a VkFormatProperties2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFormatProperties2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-pFragmentShadingRateCount-parameter", "pFragmentShadingRateCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-pFragmentShadingRates-parameter", "If the value referenced by pFragmentShadingRateCount is not 0, and pFragmentShadingRates is not NULL, pFragmentShadingRates must be a valid pointer to an array of pFragmentShadingRateCount VkPhysicalDeviceFragmentShadingRateKHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceFragmentShadingRatesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter", "flags must be a valid combination of VkImageCreateFlagBits values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter", "pImageFormatProperties must be a valid pointer to a VkImageFormatProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-02248", "tiling must not be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT. (Use vkGetPhysicalDeviceImageFormatProperties2 instead)", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter", "tiling must be a valid VkImageTiling value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter", "type must be a valid VkImageType value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatInfo-parameter", "pImageFormatInfo must be a valid pointer to a valid VkPhysicalDeviceImageFormatInfo2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties2-pImageFormatProperties-parameter", "pImageFormatProperties must be a valid pointer to a VkImageFormatProperties2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-01868", "If the pNext chain of pImageFormatProperties includes a VkAndroidHardwareBufferUsageANDROID structure, the pNext chain of pImageFormatInfo must include a VkPhysicalDeviceExternalImageFormatInfo structure with handleType set to VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceImageFormatProperties2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter", "pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMemoryProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMemoryProperties2-pMemoryProperties-parameter", "pMemoryProperties must be a valid pointer to a VkPhysicalDeviceMemoryProperties2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMemoryProperties2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-pMultisampleProperties-parameter", "pMultisampleProperties must be a valid pointer to a VkMultisamplePropertiesEXT structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceMultisamplePropertiesEXT-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pFormatCount-parameter", "pFormatCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pImageFormatProperties-parameter", "If the value referenced by pFormatCount is not 0, and pImageFormatProperties is not NULL, pImageFormatProperties must be a valid pointer to an array of pFormatCount VkOpticalFlowImageFormatPropertiesNV structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-pOpticalFlowImageFormatInfo-parameter", "pOpticalFlowImageFormatInfo must be a valid pointer to a valid VkOpticalFlowImageFormatInfoNV structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceOpticalFlowImageFormatsNV-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-commonparent", "Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRectCount-parameter", "pRectCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-pRects-parameter", "If the value referenced by pRectCount is not 0, and pRects is not NULL, pRects must be a valid pointer to an array of pRectCount VkRect2D structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-surface-06211", "surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-surface-06523", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDevicePresentRectanglesKHR-surface-parameter", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceProperties-pProperties-parameter", "pProperties must be a valid pointer to a VkPhysicalDeviceProperties structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter", "pProperties must be a valid pointer to a VkPhysicalDeviceProperties2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceProperties2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pNumPasses-parameter", "pNumPasses must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-pPerformanceQueryCreateInfo-parameter", "pPerformanceQueryCreateInfo must be a valid pointer to a valid VkQueryPoolPerformanceCreateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter", "If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter", "pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter", "If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties2 structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyPropertyCount-parameter", "pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceQueueFamilyProperties2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-queueFamilyIndex-04743", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceScreenPresentationSupportQNX-window-parameter", "window must be a valid pointer to a _screen_window value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter", "format must be a valid VkFormat value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-01094", "samples must be a bit value that is set in VkImageFormatProperties::sampleCounts returned by vkGetPhysicalDeviceImageFormatProperties with format, type, tiling, and usage equal to those in this command and flags equal to the value that is set in VkImageCreateInfo::flags when the image is created", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter", "samples must be a valid VkSampleCountFlagBits value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter", "tiling must be a valid VkImageTiling value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter", "type must be a valid VkImageType value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter", "usage must be a valid combination of VkImageUsageFlagBits values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask", "usage must not be 0", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pFormatInfo-parameter", "pFormatInfo must be a valid pointer to a valid VkPhysicalDeviceSparseImageFormatInfo2 structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pProperties-parameter", "If the value referenced by pPropertyCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pPropertyCount VkSparseImageFormatProperties2 structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-pPropertyCount-parameter", "pPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSparseImageFormatProperties2-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-pCombinationCount-parameter", "pCombinationCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-pCombinations-parameter", "If the value referenced by pCombinationCount is not 0, and pCombinations is not NULL, pCombinations must be a valid pointer to an array of pCombinationCount VkFramebufferMixedSamplesCombinationNV structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-commonparent", "Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-pSurfaceCapabilities-parameter", "pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2EXT structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-surface-06211", "surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-surface-06523", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2EXT-surface-parameter", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-02671", "If a VkSurfaceCapabilitiesFullScreenExclusiveEXT structure is included in the pNext chain of pSurfaceCapabilities, a VkSurfaceFullScreenExclusiveWin32InfoEXT structure must be included in the pNext chain of pSurfaceInfo", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceCapabilities-parameter", "pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilities2KHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-06210", "pSurfaceInfo->surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-06520", "pSurfaceInfo->surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-parameter", "pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-commonparent", "Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-pSurfaceCapabilities-parameter", "pSurfaceCapabilities must be a valid pointer to a VkSurfaceCapabilitiesKHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-surface-06211", "surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-surface-06523", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceCapabilitiesKHR-surface-parameter", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormatCount-parameter", "pSurfaceFormatCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceFormats-parameter", "If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormat2KHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-06210", "pSurfaceInfo->surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-khr-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-06520", "pSurfaceInfo->surface must be a valid VkSurfaceKHR handle", "1.3-khr-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-06521", "If the VK_GOOGLE_surfaceless_query extension is not enabled, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-06522", "If pSurfaceInfo->surface is not VK_NULL_HANDLE, it must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-parameter", "pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-commonparent", "Both of physicalDevice, and surface that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormatCount-parameter", "pSurfaceFormatCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-pSurfaceFormats-parameter", "If the value referenced by pSurfaceFormatCount is not 0, and pSurfaceFormats is not NULL, pSurfaceFormats must be a valid pointer to an array of pSurfaceFormatCount VkSurfaceFormatKHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-06211", "surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-khr-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-06523", "surface must be a valid VkSurfaceKHR handle", "1.3-khr-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-06524", "If the VK_GOOGLE_surfaceless_query extension is not enabled, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-06525", "If surface is not VK_NULL_HANDLE, it must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-parameter", "If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModeCount-parameter", "pPresentModeCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pPresentModes-parameter", "If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06210", "pSurfaceInfo->surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "default"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06520", "pSurfaceInfo->surface must be a valid VkSurfaceKHR handle", "default"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06521", "If the VK_GOOGLE_surfaceless_query extension is not enabled, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06522", "If pSurfaceInfo->surface is not VK_NULL_HANDLE, it must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-parameter", "pSurfaceInfo must be a valid pointer to a valid VkPhysicalDeviceSurfaceInfo2KHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-commonparent", "Both of physicalDevice, and surface that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModeCount-parameter", "pPresentModeCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-pPresentModes-parameter", "If the value referenced by pPresentModeCount is not 0, and pPresentModes is not NULL, pPresentModes must be a valid pointer to an array of pPresentModeCount VkPresentModeKHR values", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-06211", "surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-khr-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-06523", "surface must be a valid VkSurfaceKHR handle", "1.3-khr-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-06524", "If the VK_GOOGLE_surfaceless_query extension is not enabled, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-06525", "If surface is not VK_NULL_HANDLE, it must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfacePresentModesKHR-surface-parameter", "If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceSupportKHR-commonparent", "Both of physicalDevice, and surface must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceSupportKHR-pSupported-parameter", "pSupported must be a valid pointer to a VkBool32 value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceSupportKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceSupportKHR-queueFamilyIndex-01269", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceSurfaceSupportKHR-surface-parameter", "surface must be a valid VkSurfaceKHR handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceToolProperties-pToolCount-parameter", "pToolCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceToolProperties-pToolProperties-parameter", "If the value referenced by pToolCount is not 0, and pToolProperties is not NULL, pToolProperties must be a valid pointer to an array of pToolCount VkPhysicalDeviceToolProperties structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceToolProperties-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pCapabilities-parameter", "pCapabilities must be a valid pointer to a VkVideoCapabilitiesKHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-parameter", "pVideoProfile must be a valid pointer to a valid VkVideoProfileInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pNext-06812", "The pNext chain of pVideoFormatInfo must include a valid VkVideoProfileListInfoKHR structure with profileCount greater than 0", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatInfo-parameter", "pVideoFormatInfo must be a valid pointer to a valid VkPhysicalDeviceVideoFormatInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatProperties-parameter", "If the value referenced by pVideoFormatPropertyCount is not 0, and pVideoFormatProperties is not NULL, pVideoFormatProperties must be a valid pointer to an array of pVideoFormatPropertyCount VkVideoFormatPropertiesKHR structures", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-pVideoFormatPropertyCount-parameter", "pVideoFormatPropertyCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceVideoFormatPropertiesKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-display-parameter", "display must be a valid pointer to a wl_display value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceWaylandPresentationSupportKHR-queueFamilyIndex-01306", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceWin32PresentationSupportKHR-queueFamilyIndex-01309", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-connection-parameter", "connection must be a valid pointer to an xcb_connection_t value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceXcbPresentationSupportKHR-queueFamilyIndex-01312", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter", "dpy must be a valid pointer to a Display value", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-queueFamilyIndex-01315", "queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties for the given physicalDevice", "1.3-extensions"},
    {"VUID-vkGetPipelineCacheData-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPipelineCacheData-pData-parameter", "If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes", "1.3-extensions"},
    {"VUID-vkGetPipelineCacheData-pDataSize-parameter", "pDataSize must be a valid pointer to a size_t value", "1.3-extensions"},
    {"VUID-vkGetPipelineCacheData-pipelineCache-parameter", "pipelineCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkGetPipelineCacheData-pipelineCache-parent", "pipelineCache must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pExecutableInfo-parameter", "pExecutableInfo must be a valid pointer to a valid VkPipelineExecutableInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pInternalRepresentationCount-parameter", "pInternalRepresentationCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pInternalRepresentations-parameter", "If the value referenced by pInternalRepresentationCount is not 0, and pInternalRepresentations is not NULL, pInternalRepresentations must be a valid pointer to an array of pInternalRepresentationCount VkPipelineExecutableInternalRepresentationKHR structures", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03277", "The pipeline member of pExecutableInfo must have been created with device", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03278", "The pipeline member of pExecutableInfo must have been created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipelineExecutableInfo-03276", "The pipelineExecutableInfo feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutablePropertiesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutablePropertiesKHR-pExecutableCount-parameter", "pExecutableCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutablePropertiesKHR-pPipelineInfo-parameter", "pPipelineInfo must be a valid pointer to a valid VkPipelineInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutablePropertiesKHR-pProperties-parameter", "If the value referenced by pExecutableCount is not 0, and pProperties is not NULL, pProperties must be a valid pointer to an array of pExecutableCount VkPipelineExecutablePropertiesKHR structures", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutablePropertiesKHR-pipeline-03271", "The pipeline member of pPipelineInfo must have been created with device", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutablePropertiesKHR-pipelineExecutableInfo-03270", "The pipelineExecutableInfo feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-pExecutableInfo-parameter", "pExecutableInfo must be a valid pointer to a valid VkPipelineExecutableInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-pStatisticCount-parameter", "pStatisticCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-pStatistics-parameter", "If the value referenced by pStatisticCount is not 0, and pStatistics is not NULL, pStatistics must be a valid pointer to an array of pStatisticCount VkPipelineExecutableStatisticKHR structures", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03273", "The pipeline member of pExecutableInfo must have been created with device", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03274", "The pipeline member of pExecutableInfo must have been created with VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetPipelineExecutableStatisticsKHR-pipelineExecutableInfo-03272", "The pipelineExecutableInfo feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetPipelinePropertiesEXT-None-06766", "The pipelinePropertiesIdentifier feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetPipelinePropertiesEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPipelinePropertiesEXT-pPipelineInfo-parameter", "pPipelineInfo must be a valid pointer to a valid VkPipelineInfoEXT structure", "1.3-extensions"},
    {"VUID-vkGetPipelinePropertiesEXT-pPipelineProperties-06739", "pPipelineProperties must be a valid pointer to a VkPipelinePropertiesIdentifierEXT structure", "1.3-extensions"},
    {"VUID-vkGetPipelinePropertiesEXT-pipeline-06738", "The pipeline member of pPipelineInfo must have been created with device", "1.3-extensions"},
    {"VUID-vkGetPrivateData-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetPrivateData-objectType-04018", "objectType must be VK_OBJECT_TYPE_DEVICE, or an object type whose parent is VkDevice", "1.3-extensions"},
    {"VUID-vkGetPrivateData-objectType-parameter", "objectType must be a valid VkObjectType value", "1.3-extensions"},
    {"VUID-vkGetPrivateData-pData-parameter", "pData must be a valid pointer to a uint64_t value", "1.3-extensions"},
    {"VUID-vkGetPrivateData-privateDataSlot-parameter", "privateDataSlot must be a valid VkPrivateDataSlot handle", "1.3-extensions"},
    {"VUID-vkGetPrivateData-privateDataSlot-parent", "privateDataSlot must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-dataSize-00817", "dataSize must be large enough to contain the result of each query, as described here", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-firstQuery-00813", "firstQuery must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-firstQuery-00816", "The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-flags-00815", "If VK_QUERY_RESULT_64_BIT is set in flags then pData and stride must be multiples of 8", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-flags-02827", "If VK_QUERY_RESULT_64_BIT is not set in flags, then pData and stride must be multiples of 4", "1.3"},
    {"VUID-vkGetQueryPoolResults-flags-02828", "If VK_QUERY_RESULT_64_BIT is not set in flags and the queryType used to create queryPool was not VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then pData and stride must be multiples of 4", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-flags-04811", "If flags includes VK_QUERY_RESULT_WITH_STATUS_BIT_KHR, it must not include VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-flags-parameter", "flags must be a valid combination of VkQueryResultFlagBits values", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryPool-parent", "queryPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-00818", "If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-03229", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then pData and stride must be multiples of the size of VkPerformanceCounterResultKHR", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-03230", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, flags must not contain VK_QUERY_RESULT_WITH_AVAILABILITY_BIT, VK_QUERY_RESULT_PARTIAL_BIT or VK_QUERY_RESULT_64_BIT", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-03231", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the queryPool must have been recorded once for each pass as retrieved via a call to vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-04519", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then stride must be large enough to contain VkQueryPoolPerformanceCreateInfoKHR::counterIndexCount used to create queryPool times the size of VkPerformanceCounterResultKHR", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-04810", "If the queryType used to create queryPool was VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR, flags must include VK_QUERY_RESULT_WITH_STATUS_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetQueryPoolResults-queryType-06900", "If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, flags must not contain VK_QUERY_RESULT_WITH_STATUS_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointData2NV-pCheckpointData-parameter", "If the value referenced by pCheckpointDataCount is not 0, and pCheckpointData is not NULL, pCheckpointData must be a valid pointer to an array of pCheckpointDataCount VkCheckpointData2NV structures", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointData2NV-pCheckpointDataCount-parameter", "pCheckpointDataCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointData2NV-queue-03892", "The device that queue belongs to must be in the lost state", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointData2NV-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointDataNV-pCheckpointData-parameter", "If the value referenced by pCheckpointDataCount is not 0, and pCheckpointData is not NULL, pCheckpointData must be a valid pointer to an array of pCheckpointDataCount VkCheckpointDataNV structures", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointDataNV-pCheckpointDataCount-parameter", "pCheckpointDataCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointDataNV-queue-02025", "The device that queue belongs to must be in the lost state", "1.3-extensions"},
    {"VUID-vkGetQueueCheckpointDataNV-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkGetRandROutputDisplayEXT-dpy-parameter", "dpy must be a valid pointer to a Display value", "1.3-extensions"},
    {"VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter", "pDisplay must be a valid pointer to a VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkGetRandROutputDisplayEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-03484", "dataSize must be at least VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleCaptureReplaySize {times} groupCount", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-03483", "The sum of firstGroup and groupCount must be less than or equal to the number of shader groups in pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-04051", "firstGroup must be less than the number of shader groups in pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-03607", "pipeline must have been created with a flags that included VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-04620", "pipeline must be a ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-06720", "pipeline must not have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-parent", "pipeline must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-rayTracingPipelineShaderGroupHandleCaptureReplay-03606", "VkPhysicalDeviceRayTracingPipelineFeaturesKHR::rayTracingPipelineShaderGroupHandleCaptureReplay must be enabled to call this function", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-02420", "dataSize must be at least VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleSize {times} groupCount", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-02419", "The sum of firstGroup and groupCount must be less than or equal to the number of shader groups in pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-04050", "firstGroup must be less than the number of shader groups in pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-03482", "pipeline must not have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-04619", "pipeline must be a ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-parent", "pipeline must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-group-03608", "The value of group must be less than the number of shader groups in pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-03609", "The shader identified by groupShader in group must not be VK_SHADER_UNUSED_KHR", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-parameter", "groupShader must be a valid VkShaderGroupShaderKHR value", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-04622", "pipeline must be a ray tracing pipeline", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-parent", "pipeline must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetRefreshCycleDurationGOOGLE-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetRefreshCycleDurationGOOGLE-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetRefreshCycleDurationGOOGLE-pDisplayTimingProperties-parameter", "pDisplayTimingProperties must be a valid pointer to a VkRefreshCycleDurationGOOGLE structure", "1.3-extensions"},
    {"VUID-vkGetRefreshCycleDurationGOOGLE-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkGetRenderAreaGranularity-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetRenderAreaGranularity-pGranularity-parameter", "pGranularity must be a valid pointer to a VkExtent2D structure", "1.3-extensions"},
    {"VUID-vkGetRenderAreaGranularity-renderPass-parameter", "renderPass must be a valid VkRenderPass handle", "1.3-extensions"},
    {"VUID-vkGetRenderAreaGranularity-renderPass-parent", "renderPass must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetSemaphoreCounterValue-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSemaphoreCounterValue-pValue-parameter", "pValue must be a valid pointer to a uint64_t value", "1.3-extensions"},
    {"VUID-vkGetSemaphoreCounterValue-semaphore-03255", "semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE", "1.3-extensions"},
    {"VUID-vkGetSemaphoreCounterValue-semaphore-parameter", "semaphore must be a valid VkSemaphore handle", "1.3-extensions"},
    {"VUID-vkGetSemaphoreCounterValue-semaphore-parent", "semaphore must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetSemaphoreFdKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSemaphoreFdKHR-pFd-parameter", "pFd must be a valid pointer to an int value", "1.3-extensions"},
    {"VUID-vkGetSemaphoreFdKHR-pGetFdInfo-parameter", "pGetFdInfo must be a valid pointer to a valid VkSemaphoreGetFdInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetSemaphoreWin32HandleKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSemaphoreWin32HandleKHR-pGetWin32HandleInfo-parameter", "pGetWin32HandleInfo must be a valid pointer to a valid VkSemaphoreGetWin32HandleInfoKHR structure", "1.3-extensions"},
    {"VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter", "pHandle must be a valid pointer to a HANDLE value", "1.3-extensions"},
    {"VUID-vkGetSemaphoreZirconHandleFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSemaphoreZirconHandleFUCHSIA-pGetZirconHandleInfo-parameter", "pGetZirconHandleInfo must be a valid pointer to a valid VkSemaphoreGetZirconHandleInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkGetSemaphoreZirconHandleFUCHSIA-pZirconHandle-parameter", "pZirconHandle must be a valid pointer to a zx_handle_t value", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-infoType-parameter", "infoType must be a valid VkShaderInfoTypeAMD value", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-pInfo-parameter", "If the value referenced by pInfoSize is not 0, and pInfo is not NULL, pInfo must be a valid pointer to an array of pInfoSize bytes", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-pInfoSize-parameter", "pInfoSize must be a valid pointer to a size_t value", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-pipeline-parameter", "pipeline must be a valid VkPipeline handle", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-pipeline-parent", "pipeline must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetShaderInfoAMD-shaderStage-parameter", "shaderStage must be a valid VkShaderStageFlagBits value", "1.3-extensions"},
    {"VUID-vkGetShaderModuleCreateInfoIdentifierEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pCreateInfo-parameter", "pCreateInfo must be a valid pointer to a valid VkShaderModuleCreateInfo structure", "1.3-extensions"},
    {"VUID-vkGetShaderModuleCreateInfoIdentifierEXT-pIdentifier-parameter", "pIdentifier must be a valid pointer to a VkShaderModuleIdentifierEXT structure", "1.3-extensions"},
    {"VUID-vkGetShaderModuleCreateInfoIdentifierEXT-shaderModuleIdentifier-06885", "shaderModuleIdentifier feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetShaderModuleIdentifierEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetShaderModuleIdentifierEXT-pIdentifier-parameter", "pIdentifier must be a valid pointer to a VkShaderModuleIdentifierEXT structure", "1.3-extensions"},
    {"VUID-vkGetShaderModuleIdentifierEXT-shaderModule-parameter", "shaderModule must be a valid VkShaderModule handle", "1.3-extensions"},
    {"VUID-vkGetShaderModuleIdentifierEXT-shaderModule-parent", "shaderModule must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetShaderModuleIdentifierEXT-shaderModuleIdentifier-06884", "shaderModuleIdentifier feature must be enabled", "1.3-extensions"},
    {"VUID-vkGetSwapchainCounterEXT-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetSwapchainCounterEXT-counter-parameter", "counter must be a valid VkSurfaceCounterFlagBitsEXT value", "1.3-extensions"},
    {"VUID-vkGetSwapchainCounterEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSwapchainCounterEXT-pCounterValue-parameter", "pCounterValue must be a valid pointer to a uint64_t value", "1.3-extensions"},
    {"VUID-vkGetSwapchainCounterEXT-swapchain-01245", "One or more present commands on swapchain must have been processed by the presentation engine", "1.3-extensions"},
    {"VUID-vkGetSwapchainCounterEXT-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkGetSwapchainImagesKHR-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetSwapchainImagesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSwapchainImagesKHR-pSwapchainImageCount-parameter", "pSwapchainImageCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetSwapchainImagesKHR-pSwapchainImages-parameter", "If the value referenced by pSwapchainImageCount is not 0, and pSwapchainImages is not NULL, pSwapchainImages must be a valid pointer to an array of pSwapchainImageCount VkImage handles", "1.3-extensions"},
    {"VUID-vkGetSwapchainImagesKHR-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkGetSwapchainStatusKHR-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkGetSwapchainStatusKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetSwapchainStatusKHR-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkGetValidationCacheDataEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetValidationCacheDataEXT-pData-parameter", "If the value referenced by pDataSize is not 0, and pData is not NULL, pData must be a valid pointer to an array of pDataSize bytes", "1.3-extensions"},
    {"VUID-vkGetValidationCacheDataEXT-pDataSize-parameter", "pDataSize must be a valid pointer to a size_t value", "1.3-extensions"},
    {"VUID-vkGetValidationCacheDataEXT-validationCache-parameter", "validationCache must be a valid VkValidationCacheEXT handle", "1.3-extensions"},
    {"VUID-vkGetValidationCacheDataEXT-validationCache-parent", "validationCache must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetVideoSessionMemoryRequirementsKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkGetVideoSessionMemoryRequirementsKHR-pMemoryRequirements-parameter", "If the value referenced by pMemoryRequirementsCount is not 0, and pMemoryRequirements is not NULL, pMemoryRequirements must be a valid pointer to an array of pMemoryRequirementsCount VkVideoSessionMemoryRequirementsKHR structures", "1.3-extensions"},
    {"VUID-vkGetVideoSessionMemoryRequirementsKHR-pMemoryRequirementsCount-parameter", "pMemoryRequirementsCount must be a valid pointer to a uint32_t value", "1.3-extensions"},
    {"VUID-vkGetVideoSessionMemoryRequirementsKHR-videoSession-parameter", "videoSession must be a valid VkVideoSessionKHR handle", "1.3-extensions"},
    {"VUID-vkGetVideoSessionMemoryRequirementsKHR-videoSession-parent", "videoSession must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkGetWinrtDisplayNV-pDisplay-parameter", "pDisplay must be a valid pointer to a VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkGetWinrtDisplayNV-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkImportFenceFdKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkImportFenceFdKHR-fence-01463", "fence must not be associated with any queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkImportFenceFdKHR-pImportFenceFdInfo-parameter", "pImportFenceFdInfo must be a valid pointer to a valid VkImportFenceFdInfoKHR structure", "1.3-extensions"},
    {"VUID-vkImportFenceWin32HandleKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkImportFenceWin32HandleKHR-fence-04448", "fence must not be associated with any queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkImportFenceWin32HandleKHR-pImportFenceWin32HandleInfo-parameter", "pImportFenceWin32HandleInfo must be a valid pointer to a valid VkImportFenceWin32HandleInfoKHR structure", "1.3-extensions"},
    {"VUID-vkImportSemaphoreFdKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkImportSemaphoreFdKHR-pImportSemaphoreFdInfo-parameter", "pImportSemaphoreFdInfo must be a valid pointer to a valid VkImportSemaphoreFdInfoKHR structure", "1.3-extensions"},
    {"VUID-vkImportSemaphoreFdKHR-semaphore-01142", "semaphore must not be associated with any queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkImportSemaphoreWin32HandleKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkImportSemaphoreWin32HandleKHR-pImportSemaphoreWin32HandleInfo-parameter", "pImportSemaphoreWin32HandleInfo must be a valid pointer to a valid VkImportSemaphoreWin32HandleInfoKHR structure", "1.3-extensions"},
    {"VUID-vkImportSemaphoreZirconHandleFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkImportSemaphoreZirconHandleFUCHSIA-pImportSemaphoreZirconHandleInfo-parameter", "pImportSemaphoreZirconHandleInfo must be a valid pointer to a valid VkImportSemaphoreZirconHandleInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkImportSemaphoreZirconHandleFUCHSIA-semaphore-04764", "semaphore must not be associated with any queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkInitializePerformanceApiINTEL-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkInitializePerformanceApiINTEL-pInitializeInfo-parameter", "pInitializeInfo must be a valid pointer to a valid VkInitializePerformanceApiInfoINTEL structure", "1.3-extensions"},
    {"VUID-vkInvalidateMappedMemoryRanges-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength", "memoryRangeCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter", "pMemoryRanges must be a valid pointer to an array of memoryRangeCount valid VkMappedMemoryRange structures", "1.3-extensions"},
    {"VUID-vkMapMemory-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkMapMemory-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-vkMapMemory-memory-00678", "memory must not be currently host mapped", "1.3-extensions"},
    {"VUID-vkMapMemory-memory-00682", "memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT", "1.3-extensions"},
    {"VUID-vkMapMemory-memory-00683", "memory must not have been allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkMapMemory-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkMapMemory-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkMapMemory-offset-00679", "offset must be less than the size of memory", "1.3-extensions"},
    {"VUID-vkMapMemory-ppData-parameter", "ppData must be a valid pointer to a pointer value", "1.3-extensions"},
    {"VUID-vkMapMemory-size-00680", "If size is not equal to VK_WHOLE_SIZE, size must be greater than 0", "1.3-extensions"},
    {"VUID-vkMapMemory-size-00681", "If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of the memory minus offset", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-dstCache-00770", "dstCache must not appear in the list of source caches", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-dstCache-parameter", "dstCache must be a valid VkPipelineCache handle", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-dstCache-parent", "dstCache must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-pSrcCaches-parameter", "pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkPipelineCache handles", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-pSrcCaches-parent", "Each element of pSrcCaches must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkMergePipelineCaches-srcCacheCount-arraylength", "srcCacheCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-dstCache-01536", "dstCache must not appear in the list of source caches", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-dstCache-parameter", "dstCache must be a valid VkValidationCacheEXT handle", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-dstCache-parent", "dstCache must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-pSrcCaches-parameter", "pSrcCaches must be a valid pointer to an array of srcCacheCount valid VkValidationCacheEXT handles", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-pSrcCaches-parent", "Each element of pSrcCaches must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkMergeValidationCachesEXT-srcCacheCount-arraylength", "srcCacheCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkQueueBeginDebugUtilsLabelEXT-pLabelInfo-parameter", "pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure", "1.3-extensions"},
    {"VUID-vkQueueBeginDebugUtilsLabelEXT-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-commonparent", "Both of fence, and queue that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-fence-01113", "If fence is not VK_NULL_HANDLE, fence must be unsignaled", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-fence-01114", "If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-fence-parameter", "If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-pBindInfo-parameter", "If bindInfoCount is not 0, pBindInfo must be a valid pointer to an array of bindInfoCount valid VkBindSparseInfo structures", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-pSignalSemaphores-01115", "Each element of the pSignalSemaphores member of each element of pBindInfo must be unsignaled when the semaphore signal operation it defines is executed on the device", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-pWaitSemaphores-01116", "When a semaphore wait operation referring to a binary semaphore defined by any element of the pWaitSemaphores member of any element of pBindInfo executes on queue, there must be no other queues waiting on the same semaphore", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-pWaitSemaphores-01117", "All elements of the pWaitSemaphores member of all elements of the pBindInfo parameter referring to a binary semaphore must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-pWaitSemaphores-03245", "All elements of the pWaitSemaphores member of all elements of pBindInfo created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY must reference a semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) must have also been submitted for execution", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueBindSparse-queuetype", "The queue must support sparse binding operations", "1.3-extensions"},
    {"VUID-vkQueueEndDebugUtilsLabelEXT-None-01911", "There must be an outstanding vkQueueBeginDebugUtilsLabelEXT command prior to the vkQueueEndDebugUtilsLabelEXT on the queue", "1.3-extensions"},
    {"VUID-vkQueueEndDebugUtilsLabelEXT-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueInsertDebugUtilsLabelEXT-pLabelInfo-parameter", "pLabelInfo must be a valid pointer to a valid VkDebugUtilsLabelEXT structure", "1.3-extensions"},
    {"VUID-vkQueueInsertDebugUtilsLabelEXT-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pPresentInfo-parameter", "pPresentInfo must be a valid pointer to a valid VkPresentInfoKHR structure", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pSwapchains-01292", "Each element of pSwapchains member of pPresentInfo must be a swapchain that is created for a surface for which presentation is supported from queue as determined using a call to vkGetPhysicalDeviceSurfaceSupportKHR", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pSwapchains-01293", "If more than one member of pSwapchains was created from a display surface, all display surfaces referenced that refer to the same display must use the same display mode", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pWaitSemaphores-01294", "When a semaphore wait operation referring to a binary semaphore defined by the elements of the pWaitSemaphores member of pPresentInfo executes on queue, there must be no other queues waiting on the same semaphore", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pWaitSemaphores-01295", "All elements of the pWaitSemaphores member of pPresentInfo must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pWaitSemaphores-03267", "All elements of the pWaitSemaphores member of pPresentInfo must be created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-pWaitSemaphores-03268", "All elements of the pWaitSemaphores member of pPresentInfo must reference a semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) must have also been submitted for execution", "1.3-extensions"},
    {"VUID-vkQueuePresentKHR-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueSetPerformanceConfigurationINTEL-commonparent", "Both of configuration, and queue must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkQueueSetPerformanceConfigurationINTEL-configuration-parameter", "configuration must be a valid VkPerformanceConfigurationINTEL handle", "1.3-extensions"},
    {"VUID-vkQueueSetPerformanceConfigurationINTEL-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueSubmit-commonparent", "Both of fence, and queue that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkQueueSubmit-fence-00063", "If fence is not VK_NULL_HANDLE, fence must be unsignaled", "1.3-extensions"},
    {"VUID-vkQueueSubmit-fence-00064", "If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkQueueSubmit-fence-parameter", "If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-00065", "Any calls to vkCmdSetEvent, vkCmdResetEvent or vkCmdWaitEvents that have been recorded into any of the command buffer elements of the pCommandBuffers member of any element of pSubmits, must not reference any VkEvent that is referenced by any of those commands in a command buffer that has been submitted to another queue and is still in the pending state", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-00070", "Each element of the pCommandBuffers member of each element of pSubmits must be in the pending or executable state", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-00071", "If any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-00072", "Any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits must be in the pending or executable state", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-00073", "If any secondary command buffers recorded into any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-00074", "Each element of the pCommandBuffers member of each element of pSubmits must have been allocated from a VkCommandPool that was created for the same queue family queue belongs to", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pCommandBuffers-03220", "If a command recorded into any element of pCommandBuffers was a vkCmdBeginQuery whose queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the profiling lock must have been held continuously on the VkDevice that queue was retrieved from, throughout recording of those command buffers", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pSignalSemaphores-00067", "Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pSubmits-02207", "If any element of pSubmits->pCommandBuffers includes a Queue Family Transfer Acquire Operation, there must exist a previously submitted Queue Family Transfer Release Operation on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such acquire operations, and which happens-before the acquire operation", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pSubmits-02808", "Any resource created with VK_SHARING_MODE_EXCLUSIVE that is read by an operation specified by pSubmits must not be owned by any queue family other than the one which queue belongs to, at the time it is executed", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pSubmits-04626", "Any resource created with VK_SHARING_MODE_CONCURRENT that is accessed by an operation specified by pSubmits must have included the queue family of queue at resource creation time", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pSubmits-parameter", "If submitCount is not 0, pSubmits must be a valid pointer to an array of submitCount valid VkSubmitInfo structures", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pWaitDstStageMask-00066", "Any stage flag included in any element of the pWaitDstStageMask member of any element of pSubmits must be a pipeline stage supported by one of the capabilities of queue, as specified in the table of supported pipeline stages", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pWaitSemaphores-00068", "When a semaphore wait operation referring to a binary semaphore defined by any element of the pWaitSemaphores member of any element of pSubmits executes on queue, there must be no other queues waiting on the same semaphore", "1.3-extensions"},
    {"VUID-vkQueueSubmit-pWaitSemaphores-00069", "All elements of the pWaitSemaphores member of all elements of pSubmits must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution", "1.3"},
    {"VUID-vkQueueSubmit-pWaitSemaphores-03238", "All elements of the pWaitSemaphores member of all elements of pSubmits created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY must reference a semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) must have also been submitted for execution", "1.3-extensions"},
    {"VUID-vkQueueSubmit-queue-06448", "If queue was not created with VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, there must be no element of pSubmits that includes an VkProtectedSubmitInfo structure in its pNext chain with protectedSubmit equal to VK_TRUE", "1.3-extensions"},
    {"VUID-vkQueueSubmit-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03867", "If a command recorded into the commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits referenced an VkEvent, that event must not be referenced by a command that has been submitted to another queue and is still in the pending state", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03874", "The commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits must be in the pending or executable state", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03875", "If a command recorded into the commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03876", "Any secondary command buffers recorded into the commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits must be in the pending or executable state", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03877", "If any secondary command buffers recorded into the commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT, it must not be in the pending state", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03878", "The commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits must have been allocated from a VkCommandPool that was created for the same queue family queue belongs to", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03879", "If a command recorded into the commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits includes a Queue Family Transfer Acquire Operation, there must exist a previously submitted Queue Family Transfer Release Operation on a queue in the queue family identified by the acquire operation, with parameters matching the acquire operation as defined in the definition of such acquire operations, and which happens before the acquire operation", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commandBuffer-03880", "If a command recorded into the commandBuffer member of any element of the pCommandBufferInfos member of any element of pSubmits was a vkCmdBeginQuery whose queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the profiling lock must have been held continuously on the VkDevice that queue was retrieved from, throughout recording of those command buffers", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-commonparent", "Both of fence, and queue that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-fence-04894", "If fence is not VK_NULL_HANDLE, fence must be unsignaled", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-fence-04895", "If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-fence-parameter", "If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-pSubmits-parameter", "If submitCount is not 0, pSubmits must be a valid pointer to an array of submitCount valid VkSubmitInfo2 structures", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-queue-06447", "If queue was not created with VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, the flags member of any element of pSubmits must not include VK_SUBMIT_PROTECTED_BIT_KHR", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-semaphore-03868", "The semaphore member of any binary semaphore element of the pSignalSemaphoreInfos member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-semaphore-03871", "When a semaphore wait operation for a binary semaphore is executed, as defined by the semaphore member of any element of the pWaitSemaphoreInfos member of any element of pSubmits, there must be no other queues waiting on the same semaphore", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-semaphore-03872", "The semaphore member of any element of the pWaitSemaphoreInfos member of any element of pSubmits must be semaphores that are signaled, or have semaphore signal operations previously submitted for execution", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-semaphore-03873", "Any semaphore member of any element of the pWaitSemaphoreInfos member of any element of pSubmits that was created with a VkSemaphoreTypeKHR of VK_SEMAPHORE_TYPE_BINARY_KHR must reference a semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) must have also been submitted for execution", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-stageMask-03869", "The stageMask member of any element of the pSignalSemaphoreInfos member of any element of pSubmits must only include pipeline stages that are supported by the queue family which queue belongs to", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-stageMask-03870", "The stageMask member of any element of the pWaitSemaphoreInfos member of any element of pSubmits must only include pipeline stages that are supported by the queue family which queue belongs to", "1.3-extensions"},
    {"VUID-vkQueueSubmit2-synchronization2-03866", "The synchronization2 feature must be enabled", "1.3-extensions"},
    {"VUID-vkQueueWaitIdle-queue-parameter", "queue must be a valid VkQueue handle", "1.3-extensions"},
    {"VUID-vkRegisterDeviceEventEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkRegisterDeviceEventEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkRegisterDeviceEventEXT-pDeviceEventInfo-parameter", "pDeviceEventInfo must be a valid pointer to a valid VkDeviceEventInfoEXT structure", "1.3-extensions"},
    {"VUID-vkRegisterDeviceEventEXT-pFence-parameter", "pFence must be a valid pointer to a VkFence handle", "1.3-extensions"},
    {"VUID-vkRegisterDisplayEventEXT-commonparent", "Both of device, and display must have been created, allocated, or retrieved from the same VkPhysicalDevice", "1.3-extensions"},
    {"VUID-vkRegisterDisplayEventEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkRegisterDisplayEventEXT-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkRegisterDisplayEventEXT-pAllocator-parameter", "If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure", "1.3-extensions"},
    {"VUID-vkRegisterDisplayEventEXT-pDisplayEventInfo-parameter", "pDisplayEventInfo must be a valid pointer to a valid VkDisplayEventInfoEXT structure", "1.3-extensions"},
    {"VUID-vkRegisterDisplayEventEXT-pFence-parameter", "pFence must be a valid pointer to a VkFence handle", "1.3-extensions"},
    {"VUID-vkReleaseDisplayEXT-display-parameter", "display must be a valid VkDisplayKHR handle", "1.3-extensions"},
    {"VUID-vkReleaseDisplayEXT-display-parent", "display must have been created, allocated, or retrieved from physicalDevice", "1.3-extensions"},
    {"VUID-vkReleaseDisplayEXT-physicalDevice-parameter", "physicalDevice must be a valid VkPhysicalDevice handle", "1.3-extensions"},
    {"VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02677", "swapchain must not be in the retired state", "1.3-extensions"},
    {"VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02678", "swapchain must be a swapchain created with a VkSurfaceFullScreenExclusiveInfoEXT structure, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT", "1.3-extensions"},
    {"VUID-vkReleasePerformanceConfigurationINTEL-configuration-02737", "configuration must not be released before all command buffers submitted while the configuration was set are in pending state", "1.3-extensions"},
    {"VUID-vkReleasePerformanceConfigurationINTEL-configuration-parameter", "If configuration is not VK_NULL_HANDLE, configuration must be a valid VkPerformanceConfigurationINTEL handle", "1.3-extensions"},
    {"VUID-vkReleasePerformanceConfigurationINTEL-configuration-parent", "If configuration is a valid handle, it must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkReleasePerformanceConfigurationINTEL-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkReleaseProfilingLockKHR-device-03235", "The profiling lock of device must have been held via a previous successful call to vkAcquireProfilingLockKHR", "1.3-extensions"},
    {"VUID-vkReleaseProfilingLockKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkResetCommandBuffer-commandBuffer-00045", "commandBuffer must not be in the pending state", "1.3-extensions"},
    {"VUID-vkResetCommandBuffer-commandBuffer-00046", "commandBuffer must have been allocated from a pool that was created with the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT", "1.3-extensions"},
    {"VUID-vkResetCommandBuffer-commandBuffer-parameter", "commandBuffer must be a valid VkCommandBuffer handle", "1.3-extensions"},
    {"VUID-vkResetCommandBuffer-flags-parameter", "flags must be a valid combination of VkCommandBufferResetFlagBits values", "1.3-extensions"},
    {"VUID-vkResetCommandPool-commandPool-00040", "All VkCommandBuffer objects allocated from commandPool must not be in the pending state", "1.3-extensions"},
    {"VUID-vkResetCommandPool-commandPool-parameter", "commandPool must be a valid VkCommandPool handle", "1.3-extensions"},
    {"VUID-vkResetCommandPool-commandPool-parent", "commandPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkResetCommandPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkResetCommandPool-flags-parameter", "flags must be a valid combination of VkCommandPoolResetFlagBits values", "1.3-extensions"},
    {"VUID-vkResetDescriptorPool-descriptorPool-00313", "All uses of descriptorPool (via any allocated descriptor sets) must have completed execution", "1.3-extensions"},
    {"VUID-vkResetDescriptorPool-descriptorPool-parameter", "descriptorPool must be a valid VkDescriptorPool handle", "1.3-extensions"},
    {"VUID-vkResetDescriptorPool-descriptorPool-parent", "descriptorPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkResetDescriptorPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkResetDescriptorPool-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-vkResetEvent-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkResetEvent-event-03821", "There must be an execution dependency between vkResetEvent and the execution of any vkCmdWaitEvents that includes event in its pEvents parameter", "1.3-extensions"},
    {"VUID-vkResetEvent-event-03822", "There must be an execution dependency between vkResetEvent and the execution of any vkCmdWaitEvents2 that includes event in its pEvents parameter", "1.3-extensions"},
    {"VUID-vkResetEvent-event-03823", "event must not have been created with VK_EVENT_CREATE_DEVICE_ONLY_BIT", "1.3-extensions"},
    {"VUID-vkResetEvent-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkResetEvent-event-parent", "event must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkResetFences-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkResetFences-fenceCount-arraylength", "fenceCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkResetFences-pFences-01123", "Each element of pFences must not be currently associated with any queue command that has not yet completed execution on that queue", "1.3-extensions"},
    {"VUID-vkResetFences-pFences-parameter", "pFences must be a valid pointer to an array of fenceCount valid VkFence handles", "1.3-extensions"},
    {"VUID-vkResetFences-pFences-parent", "Each element of pFences must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkResetQueryPool-None-02665", "The hostQueryReset feature must be enabled", "1.3-extensions"},
    {"VUID-vkResetQueryPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkResetQueryPool-firstQuery-02666", "firstQuery must be less than the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkResetQueryPool-firstQuery-02667", "The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool", "1.3-extensions"},
    {"VUID-vkResetQueryPool-firstQuery-02741", "Submitted commands that refer to the range specified by firstQuery and queryCount in queryPool must have completed execution", "1.3-extensions"},
    {"VUID-vkResetQueryPool-firstQuery-02742", "The range of queries specified by firstQuery and queryCount in queryPool must not be in use by calls to vkGetQueryPoolResults or vkResetQueryPool in other threads", "1.3-extensions"},
    {"VUID-vkResetQueryPool-queryPool-parameter", "queryPool must be a valid VkQueryPool handle", "1.3-extensions"},
    {"VUID-vkResetQueryPool-queryPool-parent", "queryPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-collection-06403", "vkSetBufferCollectionImageConstraintsFUCHSIA or vkSetBufferCollectionBufferConstraintsFUCHSIA must not have already been called on collection", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-collection-parent", "collection must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionBufferConstraintsFUCHSIA-pBufferConstraintsInfo-parameter", "pBufferConstraintsInfo must be a valid pointer to a valid VkBufferConstraintsInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-collection-06394", "vkSetBufferCollectionImageConstraintsFUCHSIA or vkSetBufferCollectionBufferConstraintsFUCHSIA must not have already been called on collection", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-collection-parameter", "collection must be a valid VkBufferCollectionFUCHSIA handle", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-collection-parent", "collection must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetBufferCollectionImageConstraintsFUCHSIA-pImageConstraintsInfo-parameter", "pImageConstraintsInfo must be a valid pointer to a valid VkImageConstraintsInfoFUCHSIA structure", "1.3-extensions"},
    {"VUID-vkSetDebugUtilsObjectNameEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02587", "pNameInfo->objectType must not be VK_OBJECT_TYPE_UNKNOWN", "1.3-extensions"},
    {"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02588", "pNameInfo->objectHandle must not be VK_NULL_HANDLE", "1.3-extensions"},
    {"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-parameter", "pNameInfo must be a valid pointer to a valid VkDebugUtilsObjectNameInfoEXT structure", "1.3-extensions"},
    {"VUID-vkSetDebugUtilsObjectTagEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetDebugUtilsObjectTagEXT-pTagInfo-parameter", "pTagInfo must be a valid pointer to a valid VkDebugUtilsObjectTagInfoEXT structure", "1.3-extensions"},
    {"VUID-vkSetDeviceMemoryPriorityEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetDeviceMemoryPriorityEXT-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkSetDeviceMemoryPriorityEXT-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkSetDeviceMemoryPriorityEXT-priority-06258", "priority must be between 0 and 1, inclusive", "1.3-extensions"},
    {"VUID-vkSetEvent-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetEvent-event-03941", "event must not have been created with VK_EVENT_CREATE_DEVICE_ONLY_BIT", "1.3-extensions"},
    {"VUID-vkSetEvent-event-parameter", "event must be a valid VkEvent handle", "1.3-extensions"},
    {"VUID-vkSetEvent-event-parent", "event must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkSetHdrMetadataEXT-commonparent", "Both of device, and the elements of pSwapchains must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkSetHdrMetadataEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetHdrMetadataEXT-pMetadata-parameter", "pMetadata must be a valid pointer to an array of swapchainCount valid VkHdrMetadataEXT structures", "1.3-extensions"},
    {"VUID-vkSetHdrMetadataEXT-pSwapchains-parameter", "pSwapchains must be a valid pointer to an array of swapchainCount valid VkSwapchainKHR handles", "1.3-extensions"},
    {"VUID-vkSetHdrMetadataEXT-swapchainCount-arraylength", "swapchainCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkSetLocalDimmingAMD-commonparent", "Both of device, and swapChain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkSetLocalDimmingAMD-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetLocalDimmingAMD-localDimmingSupport-04618", "VkDisplayNativeHdrSurfaceCapabilitiesAMD::localDimmingSupport must be supported", "1.3-extensions"},
    {"VUID-vkSetLocalDimmingAMD-swapChain-parameter", "swapChain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkSetPrivateData-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSetPrivateData-objectHandle-04016", "objectHandle must be device or a child of device", "1.3-extensions"},
    {"VUID-vkSetPrivateData-objectHandle-04017", "objectHandle must be a valid handle to an object of type objectType", "1.3-extensions"},
    {"VUID-vkSetPrivateData-objectType-parameter", "objectType must be a valid VkObjectType value", "1.3-extensions"},
    {"VUID-vkSetPrivateData-privateDataSlot-parameter", "privateDataSlot must be a valid VkPrivateDataSlot handle", "1.3-extensions"},
    {"VUID-vkSetPrivateData-privateDataSlot-parent", "privateDataSlot must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkSignalSemaphore-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkSignalSemaphore-pSignalInfo-parameter", "pSignalInfo must be a valid pointer to a valid VkSemaphoreSignalInfo structure", "1.3-extensions"},
    {"VUID-vkSubmitDebugUtilsMessageEXT-instance-parameter", "instance must be a valid VkInstance handle", "1.3-extensions"},
    {"VUID-vkSubmitDebugUtilsMessageEXT-messageSeverity-parameter", "messageSeverity must be a valid VkDebugUtilsMessageSeverityFlagBitsEXT value", "1.3-extensions"},
    {"VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-parameter", "messageTypes must be a valid combination of VkDebugUtilsMessageTypeFlagBitsEXT values", "1.3-extensions"},
    {"VUID-vkSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask", "messageTypes must not be 0", "1.3-extensions"},
    {"VUID-vkSubmitDebugUtilsMessageEXT-objectType-02591", "The objectType member of each element of pCallbackData->pObjects must not be VK_OBJECT_TYPE_UNKNOWN", "1.3-extensions"},
    {"VUID-vkSubmitDebugUtilsMessageEXT-pCallbackData-parameter", "pCallbackData must be a valid pointer to a valid VkDebugUtilsMessengerCallbackDataEXT structure", "1.3-extensions"},
    {"VUID-vkTrimCommandPool-commandPool-parameter", "commandPool must be a valid VkCommandPool handle", "1.3-extensions"},
    {"VUID-vkTrimCommandPool-commandPool-parent", "commandPool must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkTrimCommandPool-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkTrimCommandPool-flags-zerobitmask", "flags must be 0", "1.3-extensions"},
    {"VUID-vkUninitializePerformanceApiINTEL-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkUnmapMemory-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkUnmapMemory-memory-00689", "memory must be currently host mapped", "1.3-extensions"},
    {"VUID-vkUnmapMemory-memory-parameter", "memory must be a valid VkDeviceMemory handle", "1.3-extensions"},
    {"VUID-vkUnmapMemory-memory-parent", "memory must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-06994", "Host access to descriptorSet must be externally synchronized", "1.1-khr-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-06995", "Host access to descriptorSet must be externally synchronized unless explicitly denoted otherwise for specific flags", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-descriptorSet-parameter", "descriptorSet must be a valid VkDescriptorSet handle", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parameter", "descriptorUpdateTemplate must be a valid VkDescriptorUpdateTemplate handle", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-descriptorUpdateTemplate-parent", "descriptorUpdateTemplate must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSetWithTemplate-pData-01685", "pData must be a valid pointer to a memory containing one or more valid instances of VkDescriptorImageInfo, VkDescriptorBufferInfo, or VkBufferView in a layout defined by descriptorUpdateTemplate when it was created with vkCreateDescriptorUpdateTemplate", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-None-03047", "Descriptor bindings updated by this command which were created without the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT or VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT bits set must not be used by any command that was recorded to a command buffer which is in the pending state", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-dstSet-00314", "The dstSet member of each element of pDescriptorWrites or pDescriptorCopies must not be used by any command that was recorded to a command buffer which is in the pending state", "1.1-khr-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter", "If descriptorCopyCount is not 0, pDescriptorCopies must be a valid pointer to an array of descriptorCopyCount valid VkCopyDescriptorSet structures", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06236", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, elements of the pTexelBufferView member of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06237", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer member of any element of the pBufferInfo member of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06238", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of any element of the pImageInfo member of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06239", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER the imageView member of any element of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06240", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, elements of the pAccelerationStructures member of a VkWriteDescriptorSetAccelerationStructureKHR structure in the pNext chain of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06241", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, elements of the pAccelerationStructures member of a VkWriteDescriptorSetAccelerationStructureNV structure in the pNext chain of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06493", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, pDescriptorWrites[i].pImageInfo must be a valid pointer to an array of pDescriptorWrites[i].descriptorCount valid VkDescriptorImageInfo structures", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06940", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM or VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, the imageView member of any element of pDescriptorWrites[i] must have been created on device", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06941", "For each element i where pDescriptorWrites[i].descriptorType is VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM or VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, pDescriptorWrites[i].pImageInfo must be a valid pointer to an array of pDescriptorWrites[i].descriptorCount valid VkDescriptorImageInfo structures", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06992", "Host access to pDescriptorWrites[i].dstSet and pDescriptorCopies[i].dstSet must be externally synchronized", "1.1-khr-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-06993", "Host access to pDescriptorWrites[i].dstSet and pDescriptorCopies[i].dstSet must be externally synchronized unless explicitly denoted otherwise for specific flags", "1.3-extensions"},
    {"VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter", "If descriptorWriteCount is not 0, pDescriptorWrites must be a valid pointer to an array of descriptorWriteCount valid VkWriteDescriptorSet structures", "1.3-extensions"},
    {"VUID-vkUpdateVideoSessionParametersKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkUpdateVideoSessionParametersKHR-pUpdateInfo-parameter", "pUpdateInfo must be a valid pointer to a valid VkVideoSessionParametersUpdateInfoKHR structure", "1.3-extensions"},
    {"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-parameter", "videoSessionParameters must be a valid VkVideoSessionParametersKHR handle", "1.3-extensions"},
    {"VUID-vkWaitForFences-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkWaitForFences-fenceCount-arraylength", "fenceCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkWaitForFences-pFences-parameter", "pFences must be a valid pointer to an array of fenceCount valid VkFence handles", "1.3-extensions"},
    {"VUID-vkWaitForFences-pFences-parent", "Each element of pFences must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkWaitForPresentKHR-commonparent", "Both of device, and swapchain must have been created, allocated, or retrieved from the same VkInstance", "1.3-extensions"},
    {"VUID-vkWaitForPresentKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkWaitForPresentKHR-presentWait-06234", "The presentWait feature must be enabled", "1.3-extensions"},
    {"VUID-vkWaitForPresentKHR-swapchain-04997", "swapchain must not be in the retired state", "1.3-extensions"},
    {"VUID-vkWaitForPresentKHR-swapchain-parameter", "swapchain must be a valid VkSwapchainKHR handle", "1.3-extensions"},
    {"VUID-vkWaitSemaphores-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkWaitSemaphores-pWaitInfo-parameter", "pWaitInfo must be a valid pointer to a valid VkSemaphoreWaitInfo structure", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureCount-arraylength", "accelerationStructureCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureHostCommands-03585", "The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructures-03431", "All acceleration structures in pAccelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-buffer-03733", "The buffer used to create each acceleration structure in pAccelerationStructures must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-buffer-03784", "The buffer used to create each acceleration structure in pAccelerationStructures must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-03452", "dataSize must be greater than or equal to accelerationStructureCount*stride", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-04964", "All acceleration structures in pAccelerationStructures must have been built prior to the execution of this command", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-parameter", "pAccelerationStructures must be a valid pointer to an array of accelerationStructureCount valid VkAccelerationStructureKHR handles", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-parent", "Each element of pAccelerationStructures must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03432", "queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "default"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03448", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then stride must be a multiple of the size of VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03449", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then pData must point to a VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03450", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then stride must be a multiple of the size of VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03451", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then pData must point to a VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06731", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, then stride must be a multiple of the size of VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06732", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, then pData must point to a VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06733", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, then stride must be a multiple of the size of VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06734", "If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, then pData must point to a VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06742", "queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR", "1.3-extensions"},
    {"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-parameter", "queryType must be a valid VkQueryType value", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-buffer-07577", "The buffer used to create each micromap in pMicromaps must be bound to host-visible device memory", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-buffer-07579", "The buffer used to create each micromap in pMicromaps must be bound to memory that was not allocated with multiple instances", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-dataSize-07576", "dataSize must be greater than or equal to micromapCount*stride", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-dataSize-arraylength", "dataSize must be greater than 0", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-device-parameter", "device must be a valid VkDevice handle", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-micromapCount-arraylength", "micromapCount must be greater than 0", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-micromapHostCommands-07578", "The VkPhysicalDeviceOpacityMicromapFeaturesEXT::micromapHostCommands feature must be enabled", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-pData-parameter", "pData must be a valid pointer to an array of dataSize bytes", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-pMicromaps-07501", "All micromaps in pMicromaps must have been constructed prior to the execution of this command", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-pMicromaps-07502", "All micromaps in pMicromaps must have been constructed with VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT if queryType is VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-pMicromaps-parameter", "pMicromaps must be a valid pointer to an array of micromapCount valid VkMicromapEXT handles", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-pMicromaps-parent", "Each element of pMicromaps must have been created, allocated, or retrieved from device", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-queryType-07503", "queryType must be VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT or VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-queryType-07573", "If queryType is VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT, then stride must be a multiple of the size of VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-queryType-07574", "If queryType is VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT, then pData must point to a VkDeviceSize", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-queryType-07575", "If queryType is", "1.3-extensions"},
    {"VUID-vkWriteMicromapsPropertiesEXT-queryType-parameter", "queryType must be a valid VkQueryType value", "1.3-extensions"},
};
