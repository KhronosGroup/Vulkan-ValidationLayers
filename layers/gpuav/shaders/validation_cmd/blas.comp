// Copyright (c) 2022-2026 The Khronos Group Inc.
// Copyright (c) 2022-2026 Valve Corporation
// Copyright (c) 2022-2026 LunarG, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

#include "common.h"
#include "build_acceleration_structures.h"

layout(push_constant, scalar)
uniform PushConstants {
    BLASValidationShaderPushData pc;
};

// CPU will try to dispatch `primitive_count` threads
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(buffer_reference, scalar) buffer ArrayU8 { uint8_t array[]; };
layout(buffer_reference, scalar) buffer ArrayU16 { uint16_t array[]; };
layout(buffer_reference, scalar) buffer ArrayU32 { uint array[]; };

// From VkIndexType
const uint VK_INDEX_TYPE_UINT16 = 0;
const uint VK_INDEX_TYPE_UINT32 = 1;
const uint VK_INDEX_TYPE_UINT8 = 1000265000;
const uint VK_INDEX_TYPE_NONE_KHR = 1000165000;

uint LoadIndex(uint i) {
    if (pc.index_type == VK_INDEX_TYPE_UINT16) {
        ArrayU16 array_u16 = ArrayU16(pc.address + pc.address_byte_offset);
        return uint(array_u16.array[i]);
    } else if (pc.index_type == VK_INDEX_TYPE_UINT32) {
        ArrayU32 array_u32 = ArrayU32(pc.address + pc.address_byte_offset);
        return array_u32.array[i];
    } else if (pc.index_type == VK_INDEX_TYPE_UINT8) {
        ArrayU8 array_u8 = ArrayU8(pc.address + pc.address_byte_offset);
        return uint(array_u8.array[i]);
    } else {
        return 0;
    }
}

void StoreIndex(uint i, uint value) {
    if (pc.index_type == VK_INDEX_TYPE_UINT16) {
        ArrayU16 array_u16 = ArrayU16(pc.address + pc.address_byte_offset);
        array_u16.array[i] = uint16_t(value);
    } else if (pc.index_type == VK_INDEX_TYPE_UINT32) {
        ArrayU32 array_u32 = ArrayU32(pc.address + pc.address_byte_offset);
        array_u32.array[i] = value;
    } else if (pc.index_type == VK_INDEX_TYPE_UINT8) {
        ArrayU8 array_u8 = ArrayU8(pc.address + pc.address_byte_offset);
        array_u8.array[i] = uint8_t(value);
    }
}

struct VkAabbPositionsKHR {
    float minX;
    float minY;
    float minZ;
    float maxX;
    float maxY;
    float maxZ;
};
layout(buffer_reference, scalar) buffer AabbsPtr { VkAabbPositionsKHR coords; };

layout(buffer_reference, scalar) buffer TransformPtr { mat3x4 mat; };

void main() {
    const uint gid = gl_GlobalInvocationID.x;

    if (pc.validation_mode == kBLASValidationMode_triangles_indices) {
        if (gid >= (3 * pc.primitive_count)) {
            return;
        }

        const uint fetched_index = LoadIndex(gid);
        if (pc.max_vertex < (pc.first_vertex + fetched_index)) {
            // In practice an invalid index does not cause a device loss, so don't bother changing its value.
            // Should someone add this back, a write barrier needs to be added on the CPU side.
            // StoreIndex(gid, 0);
            GpuavLogError4(kErrorGroup_GpuPreBuildAccelerationStructures, kErrorSubCode_PreBuildAccelerationStructures_MaxFetchedIndex, pc.error_info_i, gid, fetched_index, 0);
        }
    } else if (pc.validation_mode == kBLASValidationMode_aabbs) {
        if (gid >= pc.primitive_count) {
            return;
        }


        const uint64_t aabb_i = gid;
        AabbsPtr aabb = AabbsPtr(pc.address + uint64_t(pc.address_byte_offset) + aabb_i * pc.stride);
        if (aabb.coords.minX > aabb.coords.maxX) {
            GpuavLogError4(kErrorGroup_GpuPreBuildAccelerationStructures, kErrorSubCode_PreBuildAccelerationStructures_MinMaxAabb_X, pc.error_info_i, gid, floatBitsToUint(aabb.coords.minX), floatBitsToUint(aabb.coords.maxX));
        }

        if (aabb.coords.minY > aabb.coords.maxY) {
            GpuavLogError4(kErrorGroup_GpuPreBuildAccelerationStructures, kErrorSubCode_PreBuildAccelerationStructures_MinMaxAabb_Y, pc.error_info_i, gid, floatBitsToUint(aabb.coords.minY), floatBitsToUint(aabb.coords.maxY));
        }
        if (aabb.coords.minZ > aabb.coords.maxZ) {
            GpuavLogError4(kErrorGroup_GpuPreBuildAccelerationStructures, kErrorSubCode_PreBuildAccelerationStructures_MinMaxAabb_Z, pc.error_info_i, gid, floatBitsToUint(aabb.coords.minZ), floatBitsToUint(aabb.coords.maxZ));
        }
    } else if (pc.validation_mode == kBLASValidationMode_transform_matrix) {
        if (gid > 0) {
            return;
        }

        TransformPtr transform = TransformPtr(pc.address + uint64_t(pc.address_byte_offset));
        const mat3 transform3x3 = mat3(
            transform.mat[0].xyz,
            transform.mat[1].xyz,
            transform.mat[2].xyz
        );
        const float det = determinant(transform3x3);
        if (abs(det) < 1e-6) {
            GpuavLogError4(kErrorGroup_GpuPreBuildAccelerationStructures, kErrorSubCode_PreBuildAccelerationStructures_Transform, pc.error_info_i, gid, 0, 0);
        }
    }
}
