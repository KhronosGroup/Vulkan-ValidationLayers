// Copyright (c) 2022-2025 The Khronos Group Inc.
// Copyright (c) 2022-2025 Valve Corporation
// Copyright (c) 2022-2025 LunarG, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#version 460
#extension GL_GOOGLE_include_directive : enable

#include "common.h"
#include "push_data.h"

// Same as VkCopyMemoryIndirectCommandKHR
// (Use camelCase to match Vulkan API)
layout(buffer_reference, scalar) buffer CopyMemoryIndirectCommand {
    uint64_t srcAddress;
    uint64_t dstAddress;
    uint64_t size;
};

// Same as VkCopyMemoryToImageIndirectCommandKHR
// (Use camelCase to match Vulkan API)
layout(buffer_reference, scalar) buffer CopyMemoryToImageIndirectCommand {
    uint64_t srcAddress;
    uint bufferRowLength;
    uint bufferImageHeight;
    // VkImageSubresourceLayers
    uint aspectMmask;
    uint mipLevel;
    uint baseArrayLayer;
    uint layerCount;
    // VkOffset3D
    int imageOffset_x;
    int imageOffset_y;
    int imageOffset_z;
    // VkExtent3D
    uint imageExtent_width;
    uint imageExtent_height;
    uint imageExtent_depth;
};

struct CopyMemoryIndirectApiData {
    // VkStridedDeviceAddressRangeKHR
    uint64_t range_address;
    uint range_size;
    uint range_stride;
    // VkCopyMemoryIndirectInfoKHR::copyCount
    uint copy_count;
    // vkCmdCopyMemoryIndirectKHR vs vkCmdCopyMemoryToImageIndirectKHR
    uint is_image_copy;
    uint safe_mode;
};

layout(set = kValPipeDescSet, binding = kPreCopyMemoryIndirectBinding, scalar) buffer SrcBuffer {
    CopyMemoryIndirectApiData api;
};

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// TODO - For now only checking null, but we need a way (not just here) to easily verify a valid VkDeviceAddress value on the GPU
bool ValidDeviceAddress(uint64_t address) {
    return address != 0ul;
}

// We attempt to make the address safe as there is no way to stop the copy that is about to happen
void MakeSafeBuffer(uint64_t command_address) {
    if (api.safe_mode != 0) {
        CopyMemoryIndirectCommand command = CopyMemoryIndirectCommand(command_address);
        // range_address is a "safe" address as we know it is valid
        command.srcAddress = api.range_address;
        command.dstAddress = api.range_address;
        command.size = 0;
    }
}
void MakeSafeImage(uint64_t command_address) {
    if (api.safe_mode != 0) {
        CopyMemoryToImageIndirectCommand command = CopyMemoryToImageIndirectCommand(command_address);
        // range_address is a "safe" address as we know it is valid
        command.srcAddress = api.range_address;
        command.bufferRowLength = 0;
        command.bufferImageHeight = 0;
        command.imageOffset_x = 0;
        command.imageOffset_y = 0;
        command.imageOffset_z = 0;
        command.imageExtent_width = 0;
        command.imageExtent_height = 0;
        command.imageExtent_depth = 0;
    }
}

void main() {
    // We dispatch multiple threads to work on all the copies
    const uint tid = gl_GlobalInvocationID.x;
    if (tid >= api.copy_count) {
        return;
    }

    uint64_t command_address = api.range_address + (api.range_stride * tid);

    if (api.is_image_copy != 0) {
        CopyMemoryToImageIndirectCommand command = CopyMemoryToImageIndirectCommand(command_address);
        if (!ValidDeviceAddress(command.srcAddress)) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryToImageIndirectSrcAddressInvalid,
                            uint(command.srcAddress), uint(command.srcAddress >> 32), tid, 0);
            MakeSafeImage(command_address);
        } else if ((command.srcAddress & 3ul) != 0) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryToImageIndirectSrcAddressAligned,
                            uint(command.srcAddress), uint(command.srcAddress >> 32), tid, 0);
            MakeSafeImage(command_address);
        } else if (command.bufferRowLength != 0 && command.bufferRowLength < command.imageExtent_width) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryToImageIndirectBufferRowLength,
                            command.bufferRowLength, command.imageExtent_width, tid, 0);
            MakeSafeImage(command_address);
        } else if (command.bufferImageHeight != 0 && command.bufferImageHeight < command.imageExtent_height) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryToImageIndirectBufferImageHeight,
                            command.bufferImageHeight, command.imageExtent_height, tid, 0);
            MakeSafeImage(command_address);
        }
    } else {
        CopyMemoryIndirectCommand command = CopyMemoryIndirectCommand(command_address);
        if (!ValidDeviceAddress(command.srcAddress)) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryIndirectSrcAddressInvalid,
                            uint(command.srcAddress), uint(command.srcAddress >> 32), tid, 0);
            MakeSafeBuffer(command_address);
        } else if (!ValidDeviceAddress(command.dstAddress)) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryIndirectDstAddressInvalid,
                            uint(command.dstAddress), uint(command.dstAddress >> 32), tid, 0);
            MakeSafeBuffer(command_address);
        } else if ((command.srcAddress & 3ul) != 0) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryIndirectSrcAddressAligned,
                            uint(command.srcAddress), uint(command.srcAddress >> 32), tid, 0);
            MakeSafeBuffer(command_address);
        } else if ((command.dstAddress & 3ul) != 0) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryIndirectDstAddressAligned,
                            uint(command.dstAddress), uint(command.dstAddress >> 32), tid, 0);
            MakeSafeBuffer(command_address);
        } else if ((command.size & 3ul) != 0) {
            GpuavLogError4(kErrorGroupInstCopyMemoryIndirect, kErrorSubCodePreCopyMemoryIndirectSizeAligned,
                            uint(command.size), uint(command.size >> 32), tid, 0);
            MakeSafeBuffer(command_address);
        }
    }
}
